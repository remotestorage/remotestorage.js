!function(Q,B){"object"==typeof exports&&"object"==typeof module?module.exports=B():"function"==typeof define&&define.amd?define("RemoteStorage",[],B):"object"==typeof exports?exports.RemoteStorage=B():Q.RemoteStorage=B()}(this,function(){return function(Q){function B(F){if(I[F])return I[F].exports;var g=I[F]={exports:{},id:F,loaded:!1};return Q[F].call(g.exports,g,g.exports,B),g.loaded=!0,g.exports}var I={};return B.m=Q,B.c=I,B.p="",B(0)}([function(Q,B,I){Q.exports=I(16)},function(module,exports,__webpack_require__){eval("'use strict';\n\nvar config = __webpack_require__(5);\n\n/**\n * Method: log\n *\n * Log using console.log, when remoteStorage logging is enabled.\n *\n * You can enable logging with <enableLog>.\n *\n * (In node.js you can also enable logging during remoteStorage object\n * creation. See: <RemoteStorage>).\n */\nfunction log() {\n  if (config.logging) {\n    console.log.apply(console, arguments);\n  }\n}\n\nmodule.exports = log;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvbG9nLmpzPzkzMjAiXSwibmFtZXMiOlsiY29uZmlnIiwicmVxdWlyZSIsImxvZyIsImxvZ2dpbmciLCJjb25zb2xlIiwiYXBwbHkiLCJhcmd1bWVudHMiLCJtb2R1bGUiLCJleHBvcnRzIl0sIm1hcHBpbmdzIjoiOztBQUFBLElBQUlBLFNBQVMsbUJBQUFDLENBQVEsQ0FBUixDQUFiOztBQUVBOzs7Ozs7Ozs7O0FBVUEsU0FBU0MsR0FBVCxHQUFlO0FBQ2IsTUFBSUYsT0FBT0csT0FBWCxFQUFvQjtBQUNsQkMsWUFBUUYsR0FBUixDQUFZRyxLQUFaLENBQWtCRCxPQUFsQixFQUEyQkUsU0FBM0I7QUFDRDtBQUNGOztBQUVEQyxPQUFPQyxPQUFQLEdBQWlCTixHQUFqQiIsImZpbGUiOiIxLmpzIiwic291cmNlc0NvbnRlbnQiOlsidmFyIGNvbmZpZyA9IHJlcXVpcmUoJy4vY29uZmlnJyk7XG5cbi8qKlxuICogTWV0aG9kOiBsb2dcbiAqXG4gKiBMb2cgdXNpbmcgY29uc29sZS5sb2csIHdoZW4gcmVtb3RlU3RvcmFnZSBsb2dnaW5nIGlzIGVuYWJsZWQuXG4gKlxuICogWW91IGNhbiBlbmFibGUgbG9nZ2luZyB3aXRoIDxlbmFibGVMb2c+LlxuICpcbiAqIChJbiBub2RlLmpzIHlvdSBjYW4gYWxzbyBlbmFibGUgbG9nZ2luZyBkdXJpbmcgcmVtb3RlU3RvcmFnZSBvYmplY3RcbiAqIGNyZWF0aW9uLiBTZWU6IDxSZW1vdGVTdG9yYWdlPikuXG4gKi9cbmZ1bmN0aW9uIGxvZygpIHtcbiAgaWYgKGNvbmZpZy5sb2dnaW5nKSB7XG4gICAgY29uc29sZS5sb2cuYXBwbHkoY29uc29sZSwgYXJndW1lbnRzKTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGxvZztcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvbG9nLmpzIl0sInNvdXJjZVJvb3QiOiIifQ==")},function(module,exports){eval("/* WEBPACK VAR INJECTION */(function(global) {'use strict';\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\n// Reusable utility functions\n\n\n/**\n * Function: fixArrayBuffers\n *\n * Takes an object and its copy as produced by the _deepClone function\n * below, and finds and fixes any ArrayBuffers that were cast to `{}` instead\n * of being cloned to new ArrayBuffers with the same content.\n *\n * It recurses into sub-objects, but skips arrays if they occur.\n */\nfunction fixArrayBuffers(srcObj, dstObj) {\n  var field, srcArr, dstArr;\n  if ((typeof srcObj === 'undefined' ? 'undefined' : _typeof(srcObj)) !== 'object' || Array.isArray(srcObj) || srcObj === null) {\n    return;\n  }\n  for (field in srcObj) {\n    if (_typeof(srcObj[field]) === 'object' && srcObj[field] !== null) {\n      if (srcObj[field].toString() === '[object ArrayBuffer]') {\n        dstObj[field] = new ArrayBuffer(srcObj[field].byteLength);\n        srcArr = new Int8Array(srcObj[field]);\n        dstArr = new Int8Array(dstObj[field]);\n        dstArr.set(srcArr);\n      } else {\n        fixArrayBuffers(srcObj[field], dstObj[field]);\n      }\n    }\n  }\n}\n\nvar util = {\n  logError: function logError(error) {\n    if (typeof error === 'string') {\n      console.error(error);\n    } else {\n      console.error(error.message, error.stack);\n    }\n  },\n\n\n  globalContext: typeof window !== 'undefined' ? window : global,\n\n  getGlobalContext: function getGlobalContext() {\n    return typeof window !== 'undefined' ? window : global;\n  },\n  extend: function extend(target) {\n    var sources = Array.prototype.slice.call(arguments, 1);\n    sources.forEach(function (source) {\n      for (var key in source) {\n        target[key] = source[key];\n      }\n    });\n    return target;\n  },\n  asyncEach: function asyncEach(array, callback) {\n    return this.asyncMap(array, callback).then(function () {\n      return array;\n    });\n  },\n  asyncMap: function asyncMap(array, callback) {\n    var pending = Promise.defer();\n    var n = array.length,\n        i = 0;\n    var results = [],\n        errors = [];\n\n    function oneDone() {\n      i++;\n      if (i === n) {\n        pending.resolve(results, errors);\n      }\n    }\n\n    array.forEach(function (item, index) {\n      var result;\n      try {\n        result = callback(item);\n      } catch (exc) {\n        oneDone();\n        errors[index] = exc;\n      }\n      if ((typeof result === 'undefined' ? 'undefined' : _typeof(result)) === 'object' && typeof result.then === 'function') {\n        result.then(function (res) {\n          results[index] = res;oneDone();\n        }, function (error) {\n          errors[index] = error;oneDone();\n        });\n      } else {\n        oneDone();\n        results[index] = result;\n      }\n    });\n\n    return pending.promise;\n  },\n  containingFolder: function containingFolder(path) {\n    if (path === '') {\n      return '/';\n    }\n    if (!path) {\n      throw \"Path not given!\";\n    }\n\n    return path.replace(/\\/+/g, '/').replace(/[^\\/]+\\/?$/, '');\n  },\n  isFolder: function isFolder(path) {\n    return path.substr(-1) === '/';\n  },\n  isDocument: function isDocument(path) {\n    return !util.isFolder(path);\n  },\n  baseName: function baseName(path) {\n    var parts = path.split('/');\n    if (util.isFolder(path)) {\n      return parts[parts.length - 2] + '/';\n    } else {\n      return parts[parts.length - 1];\n    }\n  },\n  cleanPath: function cleanPath(path) {\n    return path.replace(/\\/+/g, '/').split('/').map(encodeURIComponent).join('/').replace(/'/g, '%27');\n  },\n  bindAll: function bindAll(object) {\n    for (var key in this) {\n      if (typeof object[key] === 'function') {\n        object[key] = object[key].bind(object);\n      }\n    }\n  },\n  equal: function equal(a, b, seen) {\n    var key;\n    seen = seen || [];\n\n    if ((typeof a === 'undefined' ? 'undefined' : _typeof(a)) !== (typeof b === 'undefined' ? 'undefined' : _typeof(b))) {\n      return false;\n    }\n\n    if (typeof a === 'number' || typeof a === 'boolean' || typeof a === 'string') {\n      return a === b;\n    }\n\n    if (typeof a === 'function') {\n      return a.toString() === b.toString();\n    }\n\n    if (a instanceof ArrayBuffer && b instanceof ArrayBuffer) {\n      // Without the following conversion the browsers wouldn't be able to\n      // tell the ArrayBuffer instances apart.\n      a = new Uint8Array(a);\n      b = new Uint8Array(b);\n    }\n\n    // If this point has been reached, a and b are either arrays or objects.\n\n    if (a instanceof Array) {\n      if (a.length !== b.length) {\n        return false;\n      }\n\n      for (var i = 0, c = a.length; i < c; i++) {\n        if (!util.equal(a[i], b[i], seen)) {\n          return false;\n        }\n      }\n    } else {\n      // Check that keys from a exist in b\n      for (key in a) {\n        if (a.hasOwnProperty(key) && !(key in b)) {\n          return false;\n        }\n      }\n\n      // Check that keys from b exist in a, and compare the values\n      for (key in b) {\n        if (!b.hasOwnProperty(key)) {\n          continue;\n        }\n\n        if (!(key in a)) {\n          return false;\n        }\n\n        var seenArg;\n\n        if (_typeof(b[key]) === 'object') {\n          if (seen.indexOf(b[key]) >= 0) {\n            // Circular reference, don't attempt to compare this object.\n            // If nothing else returns false, the objects match.\n            continue;\n          }\n\n          seenArg = seen.slice();\n          seenArg.push(b[key]);\n        }\n\n        if (!util.equal(a[key], b[key], seenArg)) {\n          return false;\n        }\n      }\n    }\n\n    return true;\n  },\n  equalObj: function equalObj(obj1, obj2) {\n    console.warn('DEPRECATION WARNING: util.equalObj has been replaced by util.equal.');\n    return util.equal(obj1, obj2);\n  },\n  deepClone: function deepClone(obj) {\n    var clone;\n    if (obj === undefined) {\n      return undefined;\n    } else {\n      clone = JSON.parse(JSON.stringify(obj));\n      fixArrayBuffers(obj, clone);\n      return clone;\n    }\n  },\n  pathsFromRoot: function pathsFromRoot(path) {\n    var paths = [path];\n    var parts = path.replace(/\\/$/, '').split('/');\n\n    while (parts.length > 1) {\n      parts.pop();\n      paths.push(parts.join('/') + '/');\n    }\n    return paths;\n  },\n\n\n  /* jshint ignore:start */\n  md5sum: function md5sum(str) {\n    //\n    // http://www.myersdaily.org/joseph/javascript/md5.js\n    //\n    function md5cycle(x, k) {\n      var a = x[0],\n          b = x[1],\n          c = x[2],\n          d = x[3];\n\n      a = ff(a, b, c, d, k[0], 7, -680876936);\n      d = ff(d, a, b, c, k[1], 12, -389564586);\n      c = ff(c, d, a, b, k[2], 17, 606105819);\n      b = ff(b, c, d, a, k[3], 22, -1044525330);\n      a = ff(a, b, c, d, k[4], 7, -176418897);\n      d = ff(d, a, b, c, k[5], 12, 1200080426);\n      c = ff(c, d, a, b, k[6], 17, -1473231341);\n      b = ff(b, c, d, a, k[7], 22, -45705983);\n      a = ff(a, b, c, d, k[8], 7, 1770035416);\n      d = ff(d, a, b, c, k[9], 12, -1958414417);\n      c = ff(c, d, a, b, k[10], 17, -42063);\n      b = ff(b, c, d, a, k[11], 22, -1990404162);\n      a = ff(a, b, c, d, k[12], 7, 1804603682);\n      d = ff(d, a, b, c, k[13], 12, -40341101);\n      c = ff(c, d, a, b, k[14], 17, -1502002290);\n      b = ff(b, c, d, a, k[15], 22, 1236535329);\n\n      a = gg(a, b, c, d, k[1], 5, -165796510);\n      d = gg(d, a, b, c, k[6], 9, -1069501632);\n      c = gg(c, d, a, b, k[11], 14, 643717713);\n      b = gg(b, c, d, a, k[0], 20, -373897302);\n      a = gg(a, b, c, d, k[5], 5, -701558691);\n      d = gg(d, a, b, c, k[10], 9, 38016083);\n      c = gg(c, d, a, b, k[15], 14, -660478335);\n      b = gg(b, c, d, a, k[4], 20, -405537848);\n      a = gg(a, b, c, d, k[9], 5, 568446438);\n      d = gg(d, a, b, c, k[14], 9, -1019803690);\n      c = gg(c, d, a, b, k[3], 14, -187363961);\n      b = gg(b, c, d, a, k[8], 20, 1163531501);\n      a = gg(a, b, c, d, k[13], 5, -1444681467);\n      d = gg(d, a, b, c, k[2], 9, -51403784);\n      c = gg(c, d, a, b, k[7], 14, 1735328473);\n      b = gg(b, c, d, a, k[12], 20, -1926607734);\n\n      a = hh(a, b, c, d, k[5], 4, -378558);\n      d = hh(d, a, b, c, k[8], 11, -2022574463);\n      c = hh(c, d, a, b, k[11], 16, 1839030562);\n      b = hh(b, c, d, a, k[14], 23, -35309556);\n      a = hh(a, b, c, d, k[1], 4, -1530992060);\n      d = hh(d, a, b, c, k[4], 11, 1272893353);\n      c = hh(c, d, a, b, k[7], 16, -155497632);\n      b = hh(b, c, d, a, k[10], 23, -1094730640);\n      a = hh(a, b, c, d, k[13], 4, 681279174);\n      d = hh(d, a, b, c, k[0], 11, -358537222);\n      c = hh(c, d, a, b, k[3], 16, -722521979);\n      b = hh(b, c, d, a, k[6], 23, 76029189);\n      a = hh(a, b, c, d, k[9], 4, -640364487);\n      d = hh(d, a, b, c, k[12], 11, -421815835);\n      c = hh(c, d, a, b, k[15], 16, 530742520);\n      b = hh(b, c, d, a, k[2], 23, -995338651);\n\n      a = ii(a, b, c, d, k[0], 6, -198630844);\n      d = ii(d, a, b, c, k[7], 10, 1126891415);\n      c = ii(c, d, a, b, k[14], 15, -1416354905);\n      b = ii(b, c, d, a, k[5], 21, -57434055);\n      a = ii(a, b, c, d, k[12], 6, 1700485571);\n      d = ii(d, a, b, c, k[3], 10, -1894986606);\n      c = ii(c, d, a, b, k[10], 15, -1051523);\n      b = ii(b, c, d, a, k[1], 21, -2054922799);\n      a = ii(a, b, c, d, k[8], 6, 1873313359);\n      d = ii(d, a, b, c, k[15], 10, -30611744);\n      c = ii(c, d, a, b, k[6], 15, -1560198380);\n      b = ii(b, c, d, a, k[13], 21, 1309151649);\n      a = ii(a, b, c, d, k[4], 6, -145523070);\n      d = ii(d, a, b, c, k[11], 10, -1120210379);\n      c = ii(c, d, a, b, k[2], 15, 718787259);\n      b = ii(b, c, d, a, k[9], 21, -343485551);\n\n      x[0] = add32(a, x[0]);\n      x[1] = add32(b, x[1]);\n      x[2] = add32(c, x[2]);\n      x[3] = add32(d, x[3]);\n    }\n\n    function cmn(q, a, b, x, s, t) {\n      a = add32(add32(a, q), add32(x, t));\n      return add32(a << s | a >>> 32 - s, b);\n    }\n\n    function ff(a, b, c, d, x, s, t) {\n      return cmn(b & c | ~b & d, a, b, x, s, t);\n    }\n\n    function gg(a, b, c, d, x, s, t) {\n      return cmn(b & d | c & ~d, a, b, x, s, t);\n    }\n\n    function hh(a, b, c, d, x, s, t) {\n      return cmn(b ^ c ^ d, a, b, x, s, t);\n    }\n\n    function ii(a, b, c, d, x, s, t) {\n      return cmn(c ^ (b | ~d), a, b, x, s, t);\n    }\n\n    function md51(s) {\n      txt = '';\n      var n = s.length,\n          state = [1732584193, -271733879, -1732584194, 271733878],\n          i;\n      for (i = 64; i <= s.length; i += 64) {\n        md5cycle(state, md5blk(s.substring(i - 64, i)));\n      }\n      s = s.substring(i - 64);\n      var tail = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];\n      for (i = 0; i < s.length; i++) {\n        tail[i >> 2] |= s.charCodeAt(i) << (i % 4 << 3);\n      }tail[i >> 2] |= 0x80 << (i % 4 << 3);\n      if (i > 55) {\n        md5cycle(state, tail);\n        for (i = 0; i < 16; i++) {\n          tail[i] = 0;\n        }\n      }\n      tail[14] = n * 8;\n      md5cycle(state, tail);\n      return state;\n    }\n\n    function md5blk(s) {\n      var md5blks = [],\n          i;\n      for (i = 0; i < 64; i += 4) {\n        md5blks[i >> 2] = s.charCodeAt(i) + (s.charCodeAt(i + 1) << 8) + (s.charCodeAt(i + 2) << 16) + (s.charCodeAt(i + 3) << 24);\n      }\n      return md5blks;\n    }\n\n    var hex_chr = '0123456789abcdef'.split('');\n\n    function rhex(n) {\n      var s = '',\n          j = 0;\n      for (; j < 4; j++) {\n        s += hex_chr[n >> j * 8 + 4 & 0x0F] + hex_chr[n >> j * 8 & 0x0F];\n      }return s;\n    }\n\n    function hex(x) {\n      for (var i = 0; i < x.length; i++) {\n        x[i] = rhex(x[i]);\n      }return x.join('');\n    }\n\n    function md5(s) {\n      return hex(md51(s));\n    }\n\n    var add32 = function add32(a, b) {\n      return a + b & 0xFFFFFFFF;\n    };\n\n    if (md5('hello') !== '5d41402abc4b2a76b9719d911017c592') {\n      add32 = function add32(x, y) {\n        var lsw = (x & 0xFFFF) + (y & 0xFFFF),\n            msw = (x >> 16) + (y >> 16) + (lsw >> 16);\n        return msw << 16 | lsw & 0xFFFF;\n      };\n    }\n\n    return md5(str);\n  },\n\n  /* jshint ignore:end */\n\n  localStorageAvailable: function localStorageAvailable() {\n    var context = util.getGlobalContext();\n\n    if (!('localStorage' in context)) {\n      return false;\n    }\n\n    try {\n      context.localStorage.setItem('rs-check', 1);\n      context.localStorage.removeItem('rs-check');\n      return true;\n    } catch (error) {\n      return false;\n    }\n  }\n};\n\nmodule.exports = util;\n/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvdXRpbC5qcz9hZDAwIl0sIm5hbWVzIjpbImZpeEFycmF5QnVmZmVycyIsInNyY09iaiIsImRzdE9iaiIsImZpZWxkIiwic3JjQXJyIiwiZHN0QXJyIiwiQXJyYXkiLCJpc0FycmF5IiwidG9TdHJpbmciLCJBcnJheUJ1ZmZlciIsImJ5dGVMZW5ndGgiLCJJbnQ4QXJyYXkiLCJzZXQiLCJ1dGlsIiwibG9nRXJyb3IiLCJlcnJvciIsImNvbnNvbGUiLCJtZXNzYWdlIiwic3RhY2siLCJnbG9iYWxDb250ZXh0Iiwid2luZG93IiwiZ2xvYmFsIiwiZ2V0R2xvYmFsQ29udGV4dCIsImV4dGVuZCIsInRhcmdldCIsInNvdXJjZXMiLCJwcm90b3R5cGUiLCJzbGljZSIsImNhbGwiLCJhcmd1bWVudHMiLCJmb3JFYWNoIiwic291cmNlIiwia2V5IiwiYXN5bmNFYWNoIiwiYXJyYXkiLCJjYWxsYmFjayIsImFzeW5jTWFwIiwidGhlbiIsInBlbmRpbmciLCJQcm9taXNlIiwiZGVmZXIiLCJuIiwibGVuZ3RoIiwiaSIsInJlc3VsdHMiLCJlcnJvcnMiLCJvbmVEb25lIiwicmVzb2x2ZSIsIml0ZW0iLCJpbmRleCIsInJlc3VsdCIsImV4YyIsInJlcyIsInByb21pc2UiLCJjb250YWluaW5nRm9sZGVyIiwicGF0aCIsInJlcGxhY2UiLCJpc0ZvbGRlciIsInN1YnN0ciIsImlzRG9jdW1lbnQiLCJiYXNlTmFtZSIsInBhcnRzIiwic3BsaXQiLCJjbGVhblBhdGgiLCJtYXAiLCJlbmNvZGVVUklDb21wb25lbnQiLCJqb2luIiwiYmluZEFsbCIsIm9iamVjdCIsImJpbmQiLCJlcXVhbCIsImEiLCJiIiwic2VlbiIsIlVpbnQ4QXJyYXkiLCJjIiwiaGFzT3duUHJvcGVydHkiLCJzZWVuQXJnIiwiaW5kZXhPZiIsInB1c2giLCJlcXVhbE9iaiIsIm9iajEiLCJvYmoyIiwid2FybiIsImRlZXBDbG9uZSIsIm9iaiIsImNsb25lIiwidW5kZWZpbmVkIiwiSlNPTiIsInBhcnNlIiwic3RyaW5naWZ5IiwicGF0aHNGcm9tUm9vdCIsInBhdGhzIiwicG9wIiwibWQ1c3VtIiwic3RyIiwibWQ1Y3ljbGUiLCJ4IiwiayIsImQiLCJmZiIsImdnIiwiaGgiLCJpaSIsImFkZDMyIiwiY21uIiwicSIsInMiLCJ0IiwibWQ1MSIsInR4dCIsInN0YXRlIiwibWQ1YmxrIiwic3Vic3RyaW5nIiwidGFpbCIsImNoYXJDb2RlQXQiLCJtZDVibGtzIiwiaGV4X2NociIsInJoZXgiLCJqIiwiaGV4IiwibWQ1IiwieSIsImxzdyIsIm1zdyIsImxvY2FsU3RvcmFnZUF2YWlsYWJsZSIsImNvbnRleHQiLCJsb2NhbFN0b3JhZ2UiLCJzZXRJdGVtIiwicmVtb3ZlSXRlbSIsIm1vZHVsZSIsImV4cG9ydHMiXSwibWFwcGluZ3MiOiI7Ozs7QUFBQTs7O0FBR0U7Ozs7Ozs7OztBQVNBLFNBQVNBLGVBQVQsQ0FBeUJDLE1BQXpCLEVBQWlDQyxNQUFqQyxFQUF5QztBQUN2QyxNQUFJQyxLQUFKLEVBQVdDLE1BQVgsRUFBbUJDLE1BQW5CO0FBQ0EsTUFBSSxRQUFPSixNQUFQLHlDQUFPQSxNQUFQLE9BQW1CLFFBQW5CLElBQStCSyxNQUFNQyxPQUFOLENBQWNOLE1BQWQsQ0FBL0IsSUFBd0RBLFdBQVcsSUFBdkUsRUFBNkU7QUFDM0U7QUFDRDtBQUNELE9BQUtFLEtBQUwsSUFBY0YsTUFBZCxFQUFzQjtBQUNwQixRQUFJLFFBQU9BLE9BQU9FLEtBQVAsQ0FBUCxNQUEwQixRQUExQixJQUFzQ0YsT0FBT0UsS0FBUCxNQUFrQixJQUE1RCxFQUFrRTtBQUNoRSxVQUFJRixPQUFPRSxLQUFQLEVBQWNLLFFBQWQsT0FBNkIsc0JBQWpDLEVBQXlEO0FBQ3ZETixlQUFPQyxLQUFQLElBQWdCLElBQUlNLFdBQUosQ0FBZ0JSLE9BQU9FLEtBQVAsRUFBY08sVUFBOUIsQ0FBaEI7QUFDQU4saUJBQVMsSUFBSU8sU0FBSixDQUFjVixPQUFPRSxLQUFQLENBQWQsQ0FBVDtBQUNBRSxpQkFBUyxJQUFJ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QUlBLFFBQUlpRCxJQUFJLE9BQUosTUFBaUIsa0NBQXJCLEVBQXlEO0FBQ3ZEakIsY0FBUSxlQUFVUCxDQUFWLEVBQWF5QixDQUFiLEVBQWdCO0FBQ3RCLFlBQUlDLE1BQU0sQ0FBQzFCLElBQUksTUFBTCxLQUFnQnlCLElBQUksTUFBcEIsQ0FBVjtBQUFBLFlBQ0lFLE1BQU0sQ0FBQzNCLEtBQUssRUFBTixLQUFheUIsS0FBSyxFQUFsQixLQUF5QkMsT0FBTyxFQUFoQyxDQURWO0FBRUEsZUFBUUMsT0FBTyxFQUFSLEdBQWVELE1BQU0sTUFBNUI7QUFDRCxPQUpEO0FBS0Q7O0FBRUQsV0FBT0YsSUFBSTFCLEdBQUosQ0FBUDtBQUNELEdBcFhROztBQXFYVDs7QUFHQThCLHVCQXhYUyxtQ0F3WGdCO0FBQ3ZCLFFBQU1DLFVBQVVqSCxLQUFLUyxnQkFBTCxFQUFoQjs7QUFFQSxRQUFJLEVBQUUsa0JBQWtCd0csT0FBcEIsQ0FBSixFQUFrQztBQUFFLGFBQU8sS0FBUDtBQUFlOztBQUVuRCxRQUFJO0FBQ0ZBLGNBQVFDLFlBQVIsQ0FBcUJDLE9BQXJCLENBQTZCLFVBQTdCLEVBQXlDLENBQXpDO0FBQ0FGLGNBQVFDLFlBQVIsQ0FBcUJFLFVBQXJCLENBQWdDLFVBQWhDO0FBQ0EsYUFBTyxJQUFQO0FBQ0QsS0FKRCxDQUlFLE9BQU1sSCxLQUFOLEVBQWE7QUFDYixhQUFPLEtBQVA7QUFDRDtBQUNGO0FBcFlRLENBQVg7O0FBd1lBbUgsT0FBT0MsT0FBUCxHQUFpQnRILElBQWpCLEMiLCJmaWxlIjoiMi5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIFJldXNhYmxlIHV0aWxpdHkgZnVuY3Rpb25zXG5cblxuICAvKipcbiAgICogRnVuY3Rpb246IGZpeEFycmF5QnVmZmVyc1xuICAgKlxuICAgKiBUYWtlcyBhbiBvYmplY3QgYW5kIGl0cyBjb3B5IGFzIHByb2R1Y2VkIGJ5IHRoZSBfZGVlcENsb25lIGZ1bmN0aW9uXG4gICAqIGJlbG93LCBhbmQgZmluZHMgYW5kIGZpeGVzIGFueSBBcnJheUJ1ZmZlcnMgdGhhdCB3ZXJlIGNhc3QgdG8gYHt9YCBpbnN0ZWFkXG4gICAqIG9mIGJlaW5nIGNsb25lZCB0byBuZXcgQXJyYXlCdWZmZXJzIHdpdGggdGhlIHNhbWUgY29udGVudC5cbiAgICpcbiAgICogSXQgcmVjdXJzZXMgaW50byBzdWItb2JqZWN0cywgYnV0IHNraXBzIGFycmF5cyBpZiB0aGV5IG9jY3VyLlxuICAgKi9cbiAgZnVuY3Rpb24gZml4QXJyYXlCdWZmZXJzKHNyY09iaiwgZHN0T2JqKSB7XG4gICAgdmFyIGZpZWxkLCBzcmNBcnIsIGRzdEFycjtcbiAgICBpZiAodHlwZW9mKHNyY09iaikgIT09ICdvYmplY3QnIHx8IEFycmF5LmlzQXJyYXkoc3JjT2JqKSB8fCBzcmNPYmogPT09IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZm9yIChmaWVsZCBpbiBzcmNPYmopIHtcbiAgICAgIGlmICh0eXBlb2Yoc3JjT2JqW2ZpZWxkXSkgPT09ICdvYmplY3QnICYmIHNyY09ialtmaWVsZF0gIT09IG51bGwpIHtcbiAgICAgICAgaWYgKHNyY09ialtmaWVsZF0udG9TdHJpbmcoKSA9PT0gJ1tvYmplY3QgQXJyYXlCdWZmZXJdJykge1xuICAgICAgICAgIGRzdE9ialtmaWVsZF0gPSBuZXcgQXJyYXlCdWZmZXIoc3JjT2JqW2ZpZWxkXS5ieXRlTGVuZ3RoKTtcbiAgICAgICAgICBzcmNBcnIgPSBuZXcgSW50OEFycmF5KHNyY09ialtmaWVsZF0pO1xuICAgICAgICAgIGRzdEFyciA9IG5ldyBJbnQ4QXJyYXkoZHN0T2JqW2ZpZWxkXSk7XG4gICAgICAgICAgZHN0QXJyLnNldChzcmNBcnIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGZpeEFycmF5QnVmZmVycyhzcmNPYmpbZmllbGRdLCBkc3RPYmpbZmllbGRdKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHZhciB1dGlsID0ge1xuICAgIGxvZ0Vycm9yKGVycm9yKSB7XG4gICAgICBpZiAodHlwZW9mKGVycm9yKSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihlcnJvcik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLmVycm9yKGVycm9yLm1lc3NhZ2UsIGVycm9yLnN0YWNrKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgZ2xvYmFsQ29udGV4dDogKHR5cGVvZih3aW5kb3cpICE9PSAndW5kZWZpbmVkJyA/IHdpbmRvdyA6IGdsb2JhbCksXG5cbiAgICBnZXRHbG9iYWxDb250ZXh0ICgpIHtcbiAgICAgIHJldHVybiAodHlwZW9mKHdpbmRvdykgIT09ICd1bmRlZmluZWQnID8gd2luZG93IDogZ2xvYmFsKTtcbiAgICB9LFxuXG4gICAgZXh0ZW5kICh0YXJnZXQpIHtcbiAgICAgIHZhciBzb3VyY2VzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcbiAgICAgIHNvdXJjZXMuZm9yRWFjaChmdW5jdGlvbiAoc291cmNlKSB7XG4gICAgICAgIGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHtcbiAgICAgICAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgfSxcblxuICAgIGFzeW5jRWFjaCAoYXJyYXksIGNhbGxiYWNrKSB7XG4gICAgICByZXR1cm4gdGhpcy5hc3luY01hcChhcnJheSwgY2FsbGJhY2spLlxuICAgICAgICB0aGVuKGZ1bmN0aW9uICgpIHsgcmV0dXJuIGFycmF5OyB9KTtcbiAgICB9LFxuXG4gICAgYXN5bmNNYXAgKGFycmF5LCBjYWxsYmFjaykge1xuICAgICAgdmFyIHBlbmRpbmcgPSBQcm9taXNlLmRlZmVyKCk7XG4gICAgICB2YXIgbiA9IGFycmF5Lmxlbmd0aCwgaSA9IDA7XG4gICAgICB2YXIgcmVzdWx0cyA9IFtdLCBlcnJvcnMgPSBbXTtcblxuICAgICAgZnVuY3Rpb24gb25lRG9uZSgpIHtcbiAgICAgICAgaSsrO1xuICAgICAgICBpZiAoaSA9PT0gbikge1xuICAgICAgICAgIHBlbmRpbmcucmVzb2x2ZShyZXN1bHRzLCBlcnJvcnMpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGFycmF5LmZvckVhY2goZnVuY3Rpb24gKGl0ZW0sIGluZGV4KSB7XG4gICAgICAgIHZhciByZXN1bHQ7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmVzdWx0ID0gY2FsbGJhY2soaXRlbSk7XG4gICAgICAgIH0gY2F0Y2goZXhjKSB7XG4gICAgICAgICAgb25lRG9uZSgpO1xuICAgICAgICAgIGVycm9yc1tpbmRleF0gPSBleGM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZihyZXN1bHQpID09PSAnb2JqZWN0JyAmJiB0eXBlb2YocmVzdWx0LnRoZW4pID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgcmVzdWx0LnRoZW4oZnVuY3Rpb24gKHJlcykgeyByZXN1bHRzW2luZGV4XSA9IHJlczsgb25lRG9uZSgpOyB9LFxuICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIChlcnJvcikgeyBlcnJvcnNbaW5kZXhdID0gZXJyb3I7IG9uZURvbmUoKTsgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb25lRG9uZSgpO1xuICAgICAgICAgIHJlc3VsdHNbaW5kZXhdID0gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgcmV0dXJuIHBlbmRpbmcucHJvbWlzZTtcbiAgICB9LFxuXG4gICAgY29udGFpbmluZ0ZvbGRlciAocGF0aCkge1xuICAgICAgaWYgKHBhdGggPT09ICcnKSB7XG4gICAgICAgIHJldHVybiAnLyc7XG4gICAgICB9XG4gICAgICBpZiAoISBwYXRoKSB7XG4gICAgICAgIHRocm93IFwiUGF0aCBub3QgZ2l2ZW4hXCI7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBwYXRoLnJlcGxhY2UoL1xcLysvZywgJy8nKS5yZXBsYWNlKC9bXlxcL10rXFwvPyQvLCAnJyk7XG4gICAgfSxcblxuICAgIGlzRm9sZGVyIChwYXRoKSB7XG4gICAgICByZXR1cm4gcGF0aC5zdWJzdHIoLTEpID09PSAnLyc7XG4gICAgfSxcblxuICAgIGlzRG9jdW1lbnQgKHBhdGgpIHtcbiAgICAgIHJldHVybiAhdXRpbC5pc0ZvbGRlcihwYXRoKTtcbiAgICB9LFxuXG4gICAgYmFzZU5hbWUgKHBhdGgpIHtcbiAgICAgIHZhciBwYXJ0cyA9IHBhdGguc3BsaXQoJy8nKTtcbiAgICAgIGlmICh1dGlsLmlzRm9sZGVyKHBhdGgpKSB7XG4gICAgICAgIHJldHVybiBwYXJ0c1twYXJ0cy5sZW5ndGgtMl0rJy8nO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHBhcnRzW3BhcnRzLmxlbmd0aC0xXTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgY2xlYW5QYXRoIChwYXRoKSB7XG4gICAgICByZXR1cm4gcGF0aC5yZXBsYWNlKC9cXC8rL2csICcvJylcbiAgICAgICAgICAgICAgICAgLnNwbGl0KCcvJykubWFwKGVuY29kZVVSSUNvbXBvbmVudCkuam9pbignLycpXG4gICAgICAgICAgICAgICAgIC5yZXBsYWNlKC8nL2csICclMjcnKTtcbiAgICB9LFxuXG4gICAgYmluZEFsbCAob2JqZWN0KSB7XG4gICAgICBmb3IgKHZhciBrZXkgaW4gdGhpcykge1xuICAgICAgICBpZiAodHlwZW9mKG9iamVjdFtrZXldKSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIG9iamVjdFtrZXldID0gb2JqZWN0W2tleV0uYmluZChvYmplY3QpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIGVxdWFsIChhLCBiLCBzZWVuKSB7XG4gICAgICB2YXIga2V5O1xuICAgICAgc2VlbiA9IHNlZW4gfHwgW107XG5cbiAgICAgIGlmICh0eXBlb2YoYSkgIT09IHR5cGVvZihiKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2YoYSkgPT09ICdudW1iZXInIHx8IHR5cGVvZihhKSA9PT0gJ2Jvb2xlYW4nIHx8IHR5cGVvZihhKSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIGEgPT09IGI7XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2YoYSkgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIGEudG9TdHJpbmcoKSA9PT0gYi50b1N0cmluZygpO1xuICAgICAgfVxuXG4gICAgICBpZiAoYSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyICYmIGIgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgICAgICAvLyBXaXRob3V0IHRoZSBmb2xsb3dpbmcgY29udmVyc2lvbiB0aGUgYnJvd3NlcnMgd291bGRuJ3QgYmUgYWJsZSB0b1xuICAgICAgICAvLyB0ZWxsIHRoZSBBcnJheUJ1ZmZlciBpbnN0YW5jZXMgYXBhcnQuXG4gICAgICAgIGEgPSBuZXcgVWludDhBcnJheShhKTtcbiAgICAgICAgYiA9IG5ldyBVaW50OEFycmF5KGIpO1xuICAgICAgfVxuXG4gICAgICAvLyBJZiB0aGlzIHBvaW50IGhhcyBiZWVuIHJlYWNoZWQsIGEgYW5kIGIgYXJlIGVpdGhlciBhcnJheXMgb3Igb2JqZWN0cy5cblxuICAgICAgaWYgKGEgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgICBpZiAoYS5sZW5ndGggIT09IGIubGVuZ3RoKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGMgPSBhLmxlbmd0aDsgaSA8IGM7IGkrKykge1xuICAgICAgICAgIGlmICghdXRpbC5lcXVhbChhW2ldLCBiW2ldLCBzZWVuKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gQ2hlY2sgdGhhdCBrZXlzIGZyb20gYSBleGlzdCBpbiBiXG4gICAgICAgIGZvciAoa2V5IGluIGEpIHtcbiAgICAgICAgICBpZiAoYS5oYXNPd25Qcm9wZXJ0eShrZXkpICYmICEoa2V5IGluIGIpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ2hlY2sgdGhhdCBrZXlzIGZyb20gYiBleGlzdCBpbiBhLCBhbmQgY29tcGFyZSB0aGUgdmFsdWVzXG4gICAgICAgIGZvciAoa2V5IGluIGIpIHtcbiAgICAgICAgICBpZiAoIWIuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKCEoa2V5IGluIGEpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIHNlZW5Bcmc7XG5cbiAgICAgICAgICBpZiAodHlwZW9mKGJba2V5XSkgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICBpZiAoc2Vlbi5pbmRleE9mKGJba2V5XSkgPj0gMCkge1xuICAgICAgICAgICAgICAvLyBDaXJjdWxhciByZWZlcmVuY2UsIGRvbid0IGF0dGVtcHQgdG8gY29tcGFyZSB0aGlzIG9iamVjdC5cbiAgICAgICAgICAgICAgLy8gSWYgbm90aGluZyBlbHNlIHJldHVybnMgZmFsc2UsIHRoZSBvYmplY3RzIG1hdGNoLlxuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgc2VlbkFyZyA9IHNlZW4uc2xpY2UoKTtcbiAgICAgICAgICAgIHNlZW5BcmcucHVzaChiW2tleV0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICghdXRpbC5lcXVhbChhW2tleV0sIGJba2V5XSwgc2VlbkFyZykpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSxcblxuICAgIGVxdWFsT2JqIChvYmoxLCBvYmoyKSB7XG4gICAgICBjb25zb2xlLndhcm4oJ0RFUFJFQ0FUSU9OIFdBUk5JTkc6IHV0aWwuZXF1YWxPYmogaGFzIGJlZW4gcmVwbGFjZWQgYnkgdXRpbC5lcXVhbC4nKTtcbiAgICAgIHJldHVybiB1dGlsLmVxdWFsKG9iajEsIG9iajIpO1xuICAgIH0sXG5cbiAgICBkZWVwQ2xvbmUgKG9iaikge1xuICAgICAgdmFyIGNsb25lO1xuICAgICAgaWYgKG9iaiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjbG9uZSA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkob2JqKSk7XG4gICAgICAgIGZpeEFycmF5QnVmZmVycyhvYmosIGNsb25lKTtcbiAgICAgICAgcmV0dXJuIGNsb25lO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBwYXRoc0Zyb21Sb290IChwYXRoKSB7XG4gICAgICB2YXIgcGF0aHMgPSBbcGF0aF07XG4gICAgICB2YXIgcGFydHMgPSBwYXRoLnJlcGxhY2UoL1xcLyQvLCAnJykuc3BsaXQoJy8nKTtcblxuICAgICAgd2hpbGUgKHBhcnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgcGFydHMucG9wKCk7XG4gICAgICAgIHBhdGhzLnB1c2gocGFydHMuam9pbignLycpKycvJyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcGF0aHM7XG4gICAgfSxcblxuICAgIC8qIGpzaGludCBpZ25vcmU6c3RhcnQgKi9cbiAgICBtZDVzdW0gKHN0cikge1xuICAgICAgLy9cbiAgICAgIC8vIGh0dHA6Ly93d3cubXllcnNkYWlseS5vcmcvam9zZXBoL2phdmFzY3JpcHQvbWQ1LmpzXG4gICAgICAvL1xuICAgICAgZnVuY3Rpb24gbWQ1Y3ljbGUoeCwgaykge1xuICAgICAgICB2YXIgYSA9IHhbMF0sIGIgPSB4WzFdLCBjID0geFsyXSwgZCA9IHhbM107XG5cbiAgICAgICAgYSA9IGZmKGEsIGIsIGMsIGQsIGtbMF0sIDcsIC02ODA4NzY5MzYpO1xuICAgICAgICBkID0gZmYoZCwgYSwgYiwgYywga1sxXSwgMTIsIC0zODk1NjQ1ODYpO1xuICAgICAgICBjID0gZmYoYywgZCwgYSwgYiwga1syXSwgMTcsICA2MDYxMDU4MTkpO1xuICAgICAgICBiID0gZmYoYiwgYywgZCwgYSwga1szXSwgMjIsIC0xMDQ0NTI1MzMwKTtcbiAgICAgICAgYSA9IGZmKGEsIGIsIGMsIGQsIGtbNF0sIDcsIC0xNzY0MTg4OTcpO1xuICAgICAgICBkID0gZmYoZCwgYSwgYiwgYywga1s1XSwgMTIsICAxMjAwMDgwNDI2KTtcbiAgICAgICAgYyA9IGZmKGMsIGQsIGEsIGIsIGtbNl0sIDE3LCAtMTQ3MzIzMTM0MSk7XG4gICAgICAgIGIgPSBmZihiLCBjLCBkLCBhLCBrWzddLCAyMiwgLTQ1NzA1OTgzKTtcbiAgICAgICAgYSA9IGZmKGEsIGIsIGMsIGQsIGtbOF0sIDcsICAxNzcwMDM1NDE2KTtcbiAgICAgICAgZCA9IGZmKGQsIGEsIGIsIGMsIGtbOV0sIDEyLCAtMTk1ODQxNDQxNyk7XG4gICAgICAgIGMgPSBmZihjLCBkLCBhLCBiLCBrWzEwXSwgMTcsIC00MjA2Myk7XG4gICAgICAgIGIgPSBmZihiLCBjLCBkLCBhLCBrWzExXSwgMjIsIC0xOTkwNDA0MTYyKTtcbiAgICAgICAgYSA9IGZmKGEsIGIsIGMsIGQsIGtbMTJdLCA3LCAgMTgwNDYwMzY4Mik7XG4gICAgICAgIGQgPSBmZihkLCBhLCBiLCBjLCBrWzEzXSwgMTIsIC00MDM0MTEwMSk7XG4gICAgICAgIGMgPSBmZihjLCBkLCBhLCBiLCBrWzE0XSwgMTcsIC0xNTAyMDAyMjkwKTtcbiAgICAgICAgYiA9IGZmKGIsIGMsIGQsIGEsIGtbMTVdLCAyMiwgIDEyMzY1MzUzMjkpO1xuXG4gICAgICAgIGEgPSBnZyhhLCBiLCBjLCBkLCBrWzFdLCA1LCAtMTY1Nzk2NTEwKTtcbiAgICAgICAgZCA9IGdnKGQsIGEsIGIsIGMsIGtbNl0sIDksIC0xMDY5NTAxNjMyKTtcbiAgICAgICAgYyA9IGdnKGMsIGQsIGEsIGIsIGtbMTFdLCAxNCwgIDY0MzcxNzcxMyk7XG4gICAgICAgIGIgPSBnZyhiLCBjLCBkLCBhLCBrWzBdLCAyMCwgLTM3Mzg5NzMwMik7XG4gICAgICAgIGEgPSBnZyhhLCBiLCBjLCBkLCBrWzVdLCA1LCAtNzAxNTU4NjkxKTtcbiAgICAgICAgZCA9IGdnKGQsIGEsIGIsIGMsIGtbMTBdLCA5LCAgMzgwMTYwODMpO1xuICAgICAgICBjID0gZ2coYywgZCwgYSwgYiwga1sxNV0sIDE0LCAtNjYwNDc4MzM1KTtcbiAgICAgICAgYiA9IGdnKGIsIGMsIGQsIGEsIGtbNF0sIDIwLCAtNDA1NTM3ODQ4KTtcbiAgICAgICAgYSA9IGdnKGEsIGIsIGMsIGQsIGtbOV0sIDUsICA1Njg0NDY0MzgpO1xuICAgICAgICBkID0gZ2coZCwgYSwgYiwgYywga1sxNF0sIDksIC0xMDE5ODAzNjkwKTtcbiAgICAgICAgYyA9IGdnKGMsIGQsIGEsIGIsIGtbM10sIDE0LCAtMTg3MzYzOTYxKTtcbiAgICAgICAgYiA9IGdnKGIsIGMsIGQsIGEsIGtbOF0sIDIwLCAgMTE2MzUzMTUwMSk7XG4gICAgICAgIGEgPSBnZyhhLCBiLCBjLCBkLCBrWzEzXSwgNSwgLTE0NDQ2ODE0NjcpO1xuICAgICAgICBkID0gZ2coZCwgYSwgYiwgYywga1syXSwgOSwgLTUxNDAzNzg0KTtcbiAgICAgICAgYyA9IGdnKGMsIGQsIGEsIGIsIGtbN10sIDE0LCAgMTczNTMyODQ3Myk7XG4gICAgICAgIGIgPSBnZyhiLCBjLCBkLCBhLCBrWzEyXSwgMjAsIC0xOTI2NjA3NzM0KTtcblxuICAgICAgICBhID0gaGgoYSwgYiwgYywgZCwga1s1XSwgNCwgLTM3ODU1OCk7XG4gICAgICAgIGQgPSBoaChkLCBhLCBiLCBjLCBrWzhdLCAxMSwgLTIwMjI1NzQ0NjMpO1xuICAgICAgICBjID0gaGgoYywgZCwgYSwgYiwga1sxMV0sIDE2LCAgMTgzOTAzMDU2Mik7XG4gICAgICAgIGIgPSBoaChiLCBjLCBkLCBhLCBrWzE0XSwgMjMsIC0zNTMwOTU1Nik7XG4gICAgICAgIGEgPSBoaChhLCBiLCBjLCBkLCBrWzFdLCA0LCAtMTUzMDk5MjA2MCk7XG4gICAgICAgIGQgPSBoaChkLCBhLCBiLCBjLCBrWzRdLCAxMSwgIDEyNzI4OTMzNTMpO1xuICAgICAgICBjID0gaGgoYywgZCwgYSwgYiwga1s3XSwgMTYsIC0xNTU0OTc2MzIpO1xuICAgICAgICBiID0gaGgoYiwgYywgZCwgYSwga1sxMF0sIDIzLCAtMTA5NDczMDY0MCk7XG4gICAgICAgIGEgPSBoaChhLCBiLCBjLCBkLCBrWzEzXSwgNCwgIDY4MTI3OTE3NCk7XG4gICAgICAgIGQgPSBoaChkLCBhLCBiLCBjLCBrWzBdLCAxMSwgLTM1ODUzNzIyMik7XG4gICAgICAgIGMgPSBoaChjLCBkLCBhLCBiLCBrWzNdLCAxNiwgLTcyMjUyMTk3OSk7XG4gICAgICAgIGIgPSBoaChiLCBjLCBkLCBhLCBrWzZdLCAyMywgIDc2MDI5MTg5KTtcbiAgICAgICAgYSA9IGhoKGEsIGIsIGMsIGQsIGtbOV0sIDQsIC02NDAzNjQ0ODcpO1xuICAgICAgICBkID0gaGgoZCwgYSwgYiwgYywga1sxMl0sIDExLCAtNDIxODE1ODM1KTtcbiAgICAgICAgYyA9IGhoKGMsIGQsIGEsIGIsIGtbMTVdLCAxNiwgIDUzMDc0MjUyMCk7XG4gICAgICAgIGIgPSBoaChiLCBjLCBkLCBhLCBrWzJdLCAyMywgLTk5NTMzODY1MSk7XG5cbiAgICAgICAgYSA9IGlpKGEsIGIsIGMsIGQsIGtbMF0sIDYsIC0xOTg2MzA4NDQpO1xuICAgICAgICBkID0gaWkoZCwgYSwgYiwgYywga1s3XSwgMTAsICAxMTI2ODkxNDE1KTtcbiAgICAgICAgYyA9IGlpKGMsIGQsIGEsIGIsIGtbMTRdLCAxNSwgLTE0MTYzNTQ5MDUpO1xuICAgICAgICBiID0gaWkoYiwgYywgZCwgYSwga1s1XSwgMjEsIC01NzQzNDA1NSk7XG4gICAgICAgIGEgPSBpaShhLCBiLCBjLCBkLCBrWzEyXSwgNiwgIDE3MDA0ODU1NzEpO1xuICAgICAgICBkID0gaWkoZCwgYSwgYiwgYywga1szXSwgMTAsIC0xODk0OTg2NjA2KTtcbiAgICAgICAgYyA9IGlpKGMsIGQsIGEsIGIsIGtbMTBdLCAxNSwgLTEwNTE1MjMpO1xuICAgICAgICBiID0gaWkoYiwgYywgZCwgYSwga1sxXSwgMjEsIC0yMDU0OTIyNzk5KTtcbiAgICAgICAgYSA9IGlpKGEsIGIsIGMsIGQsIGtbOF0sIDYsICAxODczMzEzMzU5KTtcbiAgICAgICAgZCA9IGlpKGQsIGEsIGIsIGMsIGtbMTVdLCAxMCwgLTMwNjExNzQ0KTtcbiAgICAgICAgYyA9IGlpKGMsIGQsIGEsIGIsIGtbNl0sIDE1LCAtMTU2MDE5ODM4MCk7XG4gICAgICAgIGIgPSBpaShiLCBjLCBkLCBhLCBrWzEzXSwgMjEsICAxMzA5MTUxNjQ5KTtcbiAgICAgICAgYSA9IGlpKGEsIGIsIGMsIGQsIGtbNF0sIDYsIC0xNDU1MjMwNzApO1xuICAgICAgICBkID0gaWkoZCwgYSwgYiwgYywga1sxMV0sIDEwLCAtMTEyMDIxMDM3OSk7XG4gICAgICAgIGMgPSBpaShjLCBkLCBhLCBiLCBrWzJdLCAxNSwgIDcxODc4NzI1OSk7XG4gICAgICAgIGIgPSBpaShiLCBjLCBkLCBhLCBrWzldLCAyMSwgLTM0MzQ4NTU1MSk7XG5cbiAgICAgICAgeFswXSA9IGFkZDMyKGEsIHhbMF0pO1xuICAgICAgICB4WzFdID0gYWRkMzIoYiwgeFsxXSk7XG4gICAgICAgIHhbMl0gPSBhZGQzMihjLCB4WzJdKTtcbiAgICAgICAgeFszXSA9IGFkZDMyKGQsIHhbM10pO1xuXG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGNtbihxLCBhLCBiLCB4LCBzLCB0KSB7XG4gICAgICAgIGEgPSBhZGQzMihhZGQzMihhLCBxKSwgYWRkMzIoeCwgdCkpO1xuICAgICAgICByZXR1cm4gYWRkMzIoKGEgPDwgcykgfCAoYSA+Pj4gKDMyIC0gcykpLCBiKTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gZmYoYSwgYiwgYywgZCwgeCwgcywgdCkge1xuICAgICAgICByZXR1cm4gY21uKChiICYgYykgfCAoKH5iKSAmIGQpLCBhLCBiLCB4LCBzLCB0KTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gZ2coYSwgYiwgYywgZCwgeCwgcywgdCkge1xuICAgICAgICByZXR1cm4gY21uKChiICYgZCkgfCAoYyAmICh+ZCkpLCBhLCBiLCB4LCBzLCB0KTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gaGgoYSwgYiwgYywgZCwgeCwgcywgdCkge1xuICAgICAgICByZXR1cm4gY21uKGIgXiBjIF4gZCwgYSwgYiwgeCwgcywgdCk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGlpKGEsIGIsIGMsIGQsIHgsIHMsIHQpIHtcbiAgICAgICAgcmV0dXJuIGNtbihjIF4gKGIgfCAofmQpKSwgYSwgYiwgeCwgcywgdCk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIG1kNTEocykge1xuICAgICAgICB0eHQgPSAnJztcbiAgICAgICAgdmFyIG4gPSBzLmxlbmd0aCxcbiAgICAgICAgICAgIHN0YXRlID0gWzE3MzI1ODQxOTMsIC0yNzE3MzM4NzksIC0xNzMyNTg0MTk0LCAyNzE3MzM4NzhdLCBpO1xuICAgICAgICBmb3IgKGk9NjQ7IGk8PXMubGVuZ3RoOyBpKz02NCkge1xuICAgICAgICAgIG1kNWN5Y2xlKHN0YXRlLCBtZDVibGsocy5zdWJzdHJpbmcoaS02NCwgaSkpKTtcbiAgICAgICAgfVxuICAgICAgICBzID0gcy5zdWJzdHJpbmcoaS02NCk7XG4gICAgICAgIHZhciB0YWlsID0gWzAsMCwwLDAsIDAsMCwwLDAsIDAsMCwwLDAsIDAsMCwwLDBdO1xuICAgICAgICBmb3IgKGk9MDsgaTxzLmxlbmd0aDsgaSsrKVxuICAgICAgICAgIHRhaWxbaT4+Ml0gfD0gcy5jaGFyQ29kZUF0KGkpIDw8ICgoaSU0KSA8PCAzKTtcbiAgICAgICAgdGFpbFtpPj4yXSB8PSAweDgwIDw8ICgoaSU0KSA8PCAzKTtcbiAgICAgICAgaWYgKGkgPiA1NSkge1xuICAgICAgICAgIG1kNWN5Y2xlKHN0YXRlLCB0YWlsKTtcbiAgICAgICAgICBmb3IgKGk9MDsgaTwxNjsgaSsrKSB0YWlsW2ldID0gMDtcbiAgICAgICAgfVxuICAgICAgICB0YWlsWzE0XSA9IG4qODtcbiAgICAgICAgbWQ1Y3ljbGUoc3RhdGUsIHRhaWwpO1xuICAgICAgICByZXR1cm4gc3RhdGU7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIG1kNWJsayhzKSB7XG4gICAgICAgIHZhciBtZDVibGtzID0gW10sIGk7XG4gICAgICAgIGZvciAoaT0wOyBpPDY0OyBpKz00KSB7XG4gICAgICAgICAgbWQ1Ymxrc1tpPj4yXSA9IHMuY2hhckNvZGVBdChpKSArIChzLmNoYXJDb2RlQXQoaSsxKSA8PCA4KSArIChzLmNoYXJDb2RlQXQoaSsyKSA8PCAxNikgKyAocy5jaGFyQ29kZUF0KGkrMykgPDwgMjQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZDVibGtzO1xuICAgICAgfVxuXG4gICAgICB2YXIgaGV4X2NociA9ICcwMTIzNDU2Nzg5YWJjZGVmJy5zcGxpdCgnJyk7XG5cbiAgICAgIGZ1bmN0aW9uIHJoZXgobilcbiAgICAgIHtcbiAgICAgICAgdmFyIHM9JycsIGo9MDtcbiAgICAgICAgZm9yKDsgajw0OyBqKyspXG4gICAgICAgICAgcyArPSBoZXhfY2hyWyhuID4+IChqICogOCArIDQpKSAmIDB4MEZdICsgaGV4X2NoclsobiA+PiAoaiAqIDgpKSAmIDB4MEZdO1xuICAgICAgICByZXR1cm4gcztcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gaGV4KHgpIHtcbiAgICAgICAgZm9yICh2YXIgaT0wOyBpPHgubGVuZ3RoOyBpKyspXG4gICAgICAgICAgeFtpXSA9IHJoZXgoeFtpXSk7XG4gICAgICAgIHJldHVybiB4LmpvaW4oJycpO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBtZDUocykge1xuICAgICAgICByZXR1cm4gaGV4KG1kNTEocykpO1xuICAgICAgfVxuXG4gICAgICB2YXIgYWRkMzIgPSBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICByZXR1cm4gKGEgKyBiKSAmIDB4RkZGRkZGRkY7XG4gICAgICB9O1xuXG4gICAgICBpZiAobWQ1KCdoZWxsbycpICE9PSAnNWQ0MTQwMmFiYzRiMmE3NmI5NzE5ZDkxMTAxN2M1OTInKSB7XG4gICAgICAgIGFkZDMyID0gZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgICAgICB2YXIgbHN3ID0gKHggJiAweEZGRkYpICsgKHkgJiAweEZGRkYpLFxuICAgICAgICAgICAgICBtc3cgPSAoeCA+PiAxNikgKyAoeSA+PiAxNikgKyAobHN3ID4+IDE2KTtcbiAgICAgICAgICByZXR1cm4gKG1zdyA8PCAxNikgfCAobHN3ICYgMHhGRkZGKTtcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG1kNShzdHIpO1xuICAgIH0sXG4gICAgLyoganNoaW50IGlnbm9yZTplbmQgKi9cblxuXG4gICAgbG9jYWxTdG9yYWdlQXZhaWxhYmxlICgpIHtcbiAgICAgIGNvbnN0IGNvbnRleHQgPSB1dGlsLmdldEdsb2JhbENvbnRleHQoKTtcblxuICAgICAgaWYgKCEoJ2xvY2FsU3RvcmFnZScgaW4gY29udGV4dCkpIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnRleHQubG9jYWxTdG9yYWdlLnNldEl0ZW0oJ3JzLWNoZWNrJywgMSk7XG4gICAgICAgIGNvbnRleHQubG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0oJ3JzLWNoZWNrJyk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfSBjYXRjaChlcnJvcikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuXG4gIH07XG5cbiAgbW9kdWxlLmV4cG9ydHMgPSB1dGlsO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL3V0aWwuanMiXSwic291cmNlUm9vdCI6IiJ9");
},function(module,exports,__webpack_require__){eval("'use strict';\n\nvar log = __webpack_require__(1);\n\n/**\n * Interface: eventhandling\n */\nvar methods = {\n  /**\n   * Method: addEventListener\n   *\n   * Install an event handler for the given event name\n   */\n  addEventListener: function addEventListener(eventName, handler) {\n    if (typeof eventName !== 'string') {\n      throw new Error('Argument eventName should be a string');\n    }\n    if (typeof handler !== 'function') {\n      throw new Error('Argument handler should be a function');\n    }\n    log('[Eventhandling] Adding event listener', eventName);\n    this._validateEvent(eventName);\n    this._handlers[eventName].push(handler);\n  },\n\n  /**\n   * Method: removeEventListener\n   *\n   * Remove a previously installed event handler\n   */\n  removeEventListener: function removeEventListener(eventName, handler) {\n    this._validateEvent(eventName);\n    var hl = this._handlers[eventName].length;\n    for (var i = 0; i < hl; i++) {\n      if (this._handlers[eventName][i] === handler) {\n        this._handlers[eventName].splice(i, 1);\n        return;\n      }\n    }\n  },\n\n  _emit: function _emit(eventName) {\n    this._validateEvent(eventName);\n    var args = Array.prototype.slice.call(arguments, 1);\n    this._handlers[eventName].slice().forEach(function (handler) {\n      handler.apply(this, args);\n    });\n  },\n\n  _validateEvent: function _validateEvent(eventName) {\n    if (!(eventName in this._handlers)) {\n      throw new Error(\"Unknown event: \" + eventName);\n    }\n  },\n\n  _delegateEvent: function _delegateEvent(eventName, target) {\n    target.on(eventName, function (event) {\n      this._emit(eventName, event);\n    }.bind(this));\n  },\n\n  _addEvent: function _addEvent(eventName) {\n    this._handlers[eventName] = [];\n  }\n};\n\n/**\n * Method: eventhandling.on\n *\n * Alias for <addEventListener>\n **/\nmethods.on = methods.addEventListener;\n\n/**\n * Method: eventhandling.off\n *\n * Alias for <removeEventListener>\n **/\nmethods.off = methods.removeEventListener;\n\n/**\n * Function: eventHandling\n *\n * Mixes event handling functionality into an object.\n *\n * The first parameter is always the object to be extended.\n * All remaining parameter are expected to be strings, interpreted as valid event\n * names.\n *\n * Example:\n *   (start code)\n *   var MyConstructor = function () {\n *     eventHandling(this, 'connected', 'disconnected');\n *\n *     this._emit('connected');\n *     this._emit('disconnected');\n *     // This would throw an exception:\n *     // this._emit('something-else');\n *   };\n *\n *   var myObject = new MyConstructor();\n *   myObject.on('connected', function () { console.log('connected'); });\n *   myObject.on('disconnected', function () { console.log('disconnected'); });\n *   // This would throw an exception as well:\n *   // myObject.on('something-else', function () {});\n *   (end code)\n */\nmodule.exports = function (object) {\n  var eventNames = Array.prototype.slice.call(arguments, 1);\n  for (var key in methods) {\n    object[key] = methods[key];\n  }\n  object._handlers = {};\n  eventNames.forEach(function (eventName) {\n    object._addEvent(eventName);\n  });\n};\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvZXZlbnRoYW5kbGluZy5qcz83NjIzIl0sIm5hbWVzIjpbImxvZyIsInJlcXVpcmUiLCJtZXRob2RzIiwiYWRkRXZlbnRMaXN0ZW5lciIsImV2ZW50TmFtZSIsImhhbmRsZXIiLCJFcnJvciIsIl92YWxpZGF0ZUV2ZW50IiwiX2hhbmRsZXJzIiwicHVzaCIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJobCIsImxlbmd0aCIsImkiLCJzcGxpY2UiLCJfZW1pdCIsImFyZ3MiLCJBcnJheSIsInByb3RvdHlwZSIsInNsaWNlIiwiY2FsbCIsImFyZ3VtZW50cyIsImZvckVhY2giLCJhcHBseSIsIl9kZWxlZ2F0ZUV2ZW50IiwidGFyZ2V0Iiwib24iLCJldmVudCIsImJpbmQiLCJfYWRkRXZlbnQiLCJvZmYiLCJtb2R1bGUiLCJleHBvcnRzIiwib2JqZWN0IiwiZXZlbnROYW1lcyIsImtleSJdLCJtYXBwaW5ncyI6Ijs7QUFBRSxJQUFJQSxNQUFNLG1CQUFBQyxDQUFRLENBQVIsQ0FBVjs7QUFFQTs7O0FBR0EsSUFBSUMsVUFBVTtBQUNaOzs7OztBQUtBQyxvQkFBa0IsMEJBQVVDLFNBQVYsRUFBcUJDLE9BQXJCLEVBQThCO0FBQzlDLFFBQUksT0FBT0QsU0FBUCxLQUFzQixRQUExQixFQUFvQztBQUNsQyxZQUFNLElBQUlFLEtBQUosQ0FBVSx1Q0FBVixDQUFOO0FBQ0Q7QUFDRCxRQUFJLE9BQU9ELE9BQVAsS0FBb0IsVUFBeEIsRUFBb0M7QUFDbEMsWUFBTSxJQUFJQyxLQUFKLENBQVUsdUNBQVYsQ0FBTjtBQUNEO0FBQ0ROLFFBQUksdUNBQUosRUFBNkNJLFNBQTdDO0FBQ0EsU0FBS0csY0FBTCxDQUFvQkgsU0FBcEI7QUFDQSxTQUFLSSxTQUFMLENBQWVKLFNBQWYsRUFBMEJLLElBQTFCLENBQStCSixPQUEvQjtBQUNELEdBaEJXOztBQWtCWjs7Ozs7QUFLQUssdUJBQXFCLDZCQUFVTixTQUFWLEVBQXFCQyxPQUFyQixFQUE4QjtBQUNqRCxTQUFLRSxjQUFMLENBQW9CSCxTQUFwQjtBQUNBLFFBQUlPLEtBQUssS0FBS0gsU0FBTCxDQUFlSixTQUFmLEVBQTBCUSxNQUFuQztBQUNBLFNBQUssSUFBSUMsSUFBRSxDQUFYLEVBQWFBLElBQUVGLEVBQWYsRUFBa0JFLEdBQWxCLEVBQXVCO0FBQ3JCLFVBQUksS0FBS0wsU0FBTCxDQUFlSixTQUFmLEVBQTBCUyxDQUExQixNQUFpQ1IsT0FBckMsRUFBOEM7QUFDNUMsYUFBS0csU0FBTCxDQUFlSixTQUFmLEVBQTBCVSxNQUExQixDQUFpQ0QsQ0FBakMsRUFBb0MsQ0FBcEM7QUFDQTtBQUNEO0FBQ0Y7QUFDRixHQWhDVzs7QUFrQ1pFLFNBQU8sZUFBVVgsU0FBVixFQUFxQjtBQUMxQixTQUFLRyxjQUFMLENBQW9CSCxTQUFwQjtBQUNBLFFBQUlZLE9BQU9DLE1BQU1DLFNBQU4sQ0FBZ0JDLEtBQWhCLENBQXNCQyxJQUF0QixDQUEyQkMsU0FBM0IsRUFBc0MsQ0FBdEMsQ0FBWDtBQUNBLFNBQUtiLFNBQUwsQ0FBZUosU0FBZixFQUEwQmUsS0FBMUIsR0FBa0NHLE9BQWxDLENBQTBDLFVBQVVqQixPQUFWLEVBQW1CO0FBQzNEQSxjQUFRa0IsS0FBUixDQUFjLElBQWQsRUFBb0JQLElBQXBCO0FBQ0QsS0FGRDtBQUdELEdBeENXOztBQTBDWlQsa0JBQWdCLHdCQUFVSCxTQUFWLEVBQXFCO0FBQ25DLFFBQUksRUFBR0EsYUFBYSxLQUFLSSxTQUFyQixDQUFKLEVBQXFDO0FBQ25DLFlBQU0sSUFBSUYsS0FBSixDQUFVLG9CQUFvQkYsU0FBOUIsQ0FBTjtBQUNEO0FBQ0YsR0E5Q1c7O0FBZ0Rab0Isa0JBQWdCLHdCQUFVcEIsU0FBVixFQUFxQnFCLE1BQXJCLEVBQTZCO0FBQzNDQSxXQUFPQyxFQUFQLENBQVV0QixTQUFWLEVBQXFCLFVBQVV1QixLQUFWLEVBQWlCO0FBQ3BDLFdBQUtaLEtBQUwsQ0FBV1gsU0FBWCxFQUFzQnVCLEtBQXRCO0FBQ0QsS0FGb0IsQ0FFbkJDLElBRm1CLENBRWQsSUFGYyxDQUFyQjtBQUdELEdBcERXOztBQXNEWkMsYUFBVyxtQkFBVXpCLFNBQVYsRUFBcUI7QUFDOUIsU0FBS0ksU0FBTCxDQUFlSixTQUFmLElBQTRCLEVBQTVCO0FBQ0Q7QUF4RFcsQ0FBZDs7QUEyREE7Ozs7O0FBS0FGLFFBQVF3QixFQUFSLEdBQWF4QixRQUFRQyxnQkFBckI7O0FBRUE7Ozs7O0FBS0FELFFBQVE0QixHQUFSLEdBQWM1QixRQUFRUSxtQkFBdEI7O0FBR0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQTJCRHFCLE9BQU9DLE9BQVAsR0FBaUIsVUFBVUMsTUFBVixFQUFrQjtBQUNoQyxNQUFJQyxhQUFhakIsTUFBTUMsU0FBTixDQUFnQkMsS0FBaEIsQ0FBc0JDLElBQXRCLENBQTJCQyxTQUEzQixFQUFzQyxDQUF0QyxDQUFqQjtBQUNBLE9BQUssSUFBSWMsR0FBVCxJQUFnQmpDLE9BQWhCLEVBQXlCO0FBQ3ZCK0IsV0FBT0UsR0FBUCxJQUFjakMsUUFBUWlDLEdBQVIsQ0FBZDtBQUNEO0FBQ0RGLFNBQU96QixTQUFQLEdBQW1CLEVBQW5CO0FBQ0EwQixhQUFXWixPQUFYLENBQW1CLFVBQVVsQixTQUFWLEVBQXFCO0FBQ3RDNkIsV0FBT0osU0FBUCxDQUFpQnpCLFNBQWpCO0FBQ0QsR0FGRDtBQUdELENBVEYiLCJmaWxlIjoiMy5qcyIsInNvdXJjZXNDb250ZW50IjpbIiAgdmFyIGxvZyA9IHJlcXVpcmUoJy4vbG9nJyk7XG4gIFxuICAvKipcbiAgICogSW50ZXJmYWNlOiBldmVudGhhbmRsaW5nXG4gICAqL1xuICB2YXIgbWV0aG9kcyA9IHtcbiAgICAvKipcbiAgICAgKiBNZXRob2Q6IGFkZEV2ZW50TGlzdGVuZXJcbiAgICAgKlxuICAgICAqIEluc3RhbGwgYW4gZXZlbnQgaGFuZGxlciBmb3IgdGhlIGdpdmVuIGV2ZW50IG5hbWVcbiAgICAgKi9cbiAgICBhZGRFdmVudExpc3RlbmVyOiBmdW5jdGlvbiAoZXZlbnROYW1lLCBoYW5kbGVyKSB7XG4gICAgICBpZiAodHlwZW9mKGV2ZW50TmFtZSkgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQXJndW1lbnQgZXZlbnROYW1lIHNob3VsZCBiZSBhIHN0cmluZycpO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZihoYW5kbGVyKSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0FyZ3VtZW50IGhhbmRsZXIgc2hvdWxkIGJlIGEgZnVuY3Rpb24nKTtcbiAgICAgIH1cbiAgICAgIGxvZygnW0V2ZW50aGFuZGxpbmddIEFkZGluZyBldmVudCBsaXN0ZW5lcicsIGV2ZW50TmFtZSk7XG4gICAgICB0aGlzLl92YWxpZGF0ZUV2ZW50KGV2ZW50TmFtZSk7XG4gICAgICB0aGlzLl9oYW5kbGVyc1tldmVudE5hbWVdLnB1c2goaGFuZGxlcik7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1ldGhvZDogcmVtb3ZlRXZlbnRMaXN0ZW5lclxuICAgICAqXG4gICAgICogUmVtb3ZlIGEgcHJldmlvdXNseSBpbnN0YWxsZWQgZXZlbnQgaGFuZGxlclxuICAgICAqL1xuICAgIHJlbW92ZUV2ZW50TGlzdGVuZXI6IGZ1bmN0aW9uIChldmVudE5hbWUsIGhhbmRsZXIpIHtcbiAgICAgIHRoaXMuX3ZhbGlkYXRlRXZlbnQoZXZlbnROYW1lKTtcbiAgICAgIHZhciBobCA9IHRoaXMuX2hhbmRsZXJzW2V2ZW50TmFtZV0ubGVuZ3RoO1xuICAgICAgZm9yICh2YXIgaT0wO2k8aGw7aSsrKSB7XG4gICAgICAgIGlmICh0aGlzLl9oYW5kbGVyc1tldmVudE5hbWVdW2ldID09PSBoYW5kbGVyKSB7XG4gICAgICAgICAgdGhpcy5faGFuZGxlcnNbZXZlbnROYW1lXS5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIF9lbWl0OiBmdW5jdGlvbiAoZXZlbnROYW1lKSB7XG4gICAgICB0aGlzLl92YWxpZGF0ZUV2ZW50KGV2ZW50TmFtZSk7XG4gICAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gICAgICB0aGlzLl9oYW5kbGVyc1tldmVudE5hbWVdLnNsaWNlKCkuZm9yRWFjaChmdW5jdGlvbiAoaGFuZGxlcikge1xuICAgICAgICBoYW5kbGVyLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgICAgfSk7XG4gICAgfSxcblxuICAgIF92YWxpZGF0ZUV2ZW50OiBmdW5jdGlvbiAoZXZlbnROYW1lKSB7XG4gICAgICBpZiAoISAoZXZlbnROYW1lIGluIHRoaXMuX2hhbmRsZXJzKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIGV2ZW50OiBcIiArIGV2ZW50TmFtZSk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIF9kZWxlZ2F0ZUV2ZW50OiBmdW5jdGlvbiAoZXZlbnROYW1lLCB0YXJnZXQpIHtcbiAgICAgIHRhcmdldC5vbihldmVudE5hbWUsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICB0aGlzLl9lbWl0KGV2ZW50TmFtZSwgZXZlbnQpO1xuICAgICAgfS5iaW5kKHRoaXMpKTtcbiAgICB9LFxuXG4gICAgX2FkZEV2ZW50OiBmdW5jdGlvbiAoZXZlbnROYW1lKSB7XG4gICAgICB0aGlzLl9oYW5kbGVyc1tldmVudE5hbWVdID0gW107XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBNZXRob2Q6IGV2ZW50aGFuZGxpbmcub25cbiAgICpcbiAgICogQWxpYXMgZm9yIDxhZGRFdmVudExpc3RlbmVyPlxuICAgKiovXG4gIG1ldGhvZHMub24gPSBtZXRob2RzLmFkZEV2ZW50TGlzdGVuZXI7XG5cbiAgLyoqXG4gICAqIE1ldGhvZDogZXZlbnRoYW5kbGluZy5vZmZcbiAgICpcbiAgICogQWxpYXMgZm9yIDxyZW1vdmVFdmVudExpc3RlbmVyPlxuICAgKiovXG4gIG1ldGhvZHMub2ZmID0gbWV0aG9kcy5yZW1vdmVFdmVudExpc3RlbmVyO1xuXG5cbiAgLyoqXG4gICAqIEZ1bmN0aW9uOiBldmVudEhhbmRsaW5nXG4gICAqXG4gICAqIE1peGVzIGV2ZW50IGhhbmRsaW5nIGZ1bmN0aW9uYWxpdHkgaW50byBhbiBvYmplY3QuXG4gICAqXG4gICAqIFRoZSBmaXJzdCBwYXJhbWV0ZXIgaXMgYWx3YXlzIHRoZSBvYmplY3QgdG8gYmUgZXh0ZW5kZWQuXG4gICAqIEFsbCByZW1haW5pbmcgcGFyYW1ldGVyIGFyZSBleHBlY3RlZCB0byBiZSBzdHJpbmdzLCBpbnRlcnByZXRlZCBhcyB2YWxpZCBldmVudFxuICAgKiBuYW1lcy5cbiAgICpcbiAgICogRXhhbXBsZTpcbiAgICogICAoc3RhcnQgY29kZSlcbiAgICogICB2YXIgTXlDb25zdHJ1Y3RvciA9IGZ1bmN0aW9uICgpIHtcbiAgICogICAgIGV2ZW50SGFuZGxpbmcodGhpcywgJ2Nvbm5lY3RlZCcsICdkaXNjb25uZWN0ZWQnKTtcbiAgICpcbiAgICogICAgIHRoaXMuX2VtaXQoJ2Nvbm5lY3RlZCcpO1xuICAgKiAgICAgdGhpcy5fZW1pdCgnZGlzY29ubmVjdGVkJyk7XG4gICAqICAgICAvLyBUaGlzIHdvdWxkIHRocm93IGFuIGV4Y2VwdGlvbjpcbiAgICogICAgIC8vIHRoaXMuX2VtaXQoJ3NvbWV0aGluZy1lbHNlJyk7XG4gICAqICAgfTtcbiAgICpcbiAgICogICB2YXIgbXlPYmplY3QgPSBuZXcgTXlDb25zdHJ1Y3RvcigpO1xuICAgKiAgIG15T2JqZWN0Lm9uKCdjb25uZWN0ZWQnLCBmdW5jdGlvbiAoKSB7IGNvbnNvbGUubG9nKCdjb25uZWN0ZWQnKTsgfSk7XG4gICAqICAgbXlPYmplY3Qub24oJ2Rpc2Nvbm5lY3RlZCcsIGZ1bmN0aW9uICgpIHsgY29uc29sZS5sb2coJ2Rpc2Nvbm5lY3RlZCcpOyB9KTtcbiAgICogICAvLyBUaGlzIHdvdWxkIHRocm93IGFuIGV4Y2VwdGlvbiBhcyB3ZWxsOlxuICAgKiAgIC8vIG15T2JqZWN0Lm9uKCdzb21ldGhpbmctZWxzZScsIGZ1bmN0aW9uICgpIHt9KTtcbiAgICogICAoZW5kIGNvZGUpXG4gICAqL1xuIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG9iamVjdCkge1xuICAgIHZhciBldmVudE5hbWVzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcbiAgICBmb3IgKHZhciBrZXkgaW4gbWV0aG9kcykge1xuICAgICAgb2JqZWN0W2tleV0gPSBtZXRob2RzW2tleV07XG4gICAgfVxuICAgIG9iamVjdC5faGFuZGxlcnMgPSB7fTtcbiAgICBldmVudE5hbWVzLmZvckVhY2goZnVuY3Rpb24gKGV2ZW50TmFtZSkge1xuICAgICAgb2JqZWN0Ll9hZGRFdmVudChldmVudE5hbWUpO1xuICAgIH0pO1xuICB9O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2V2ZW50aGFuZGxpbmcuanMiXSwic291cmNlUm9vdCI6IiJ9")},function(module,exports,__webpack_require__){eval("'use strict';\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar log = __webpack_require__(1);\nvar util = __webpack_require__(2);\n\nfunction extractParams(url) {\n  //FF already decodes the URL fragment in document.location.hash, so use this instead:\n  var location = url || Authorize.getLocation().href,\n      hashPos = location.indexOf('#'),\n      hash;\n  if (hashPos === -1) {\n    return;\n  }\n  hash = location.substring(hashPos + 1);\n  // if hash is not of the form #key=val&key=val, it's probably not for us\n  if (hash.indexOf('=') === -1) {\n    return;\n  }\n  return hash.split('&').reduce(function (params, kvs) {\n    var kv = kvs.split('=');\n\n    if (kv[0] === 'state' && kv[1].match(/rsDiscovery/)) {\n      // extract rsDiscovery data from the state param\n      var stateValue = decodeURIComponent(kv[1]);\n      var encodedData = stateValue.substr(stateValue.indexOf('rsDiscovery=')).split('&')[0].split('=')[1];\n\n      params['rsDiscovery'] = JSON.parse(atob(encodedData));\n\n      // remove rsDiscovery param\n      stateValue = stateValue.replace(new RegExp('\\&?rsDiscovery=' + encodedData), '');\n\n      if (stateValue.length > 0) {\n        params['state'] = stateValue;\n      }\n    } else {\n      params[decodeURIComponent(kv[0])] = decodeURIComponent(kv[1]);\n    }\n\n    return params;\n  }, {});\n}\n\nvar Authorize = function Authorize(remoteStorage, authURL, scope, redirectUri, clientId) {\n  log('[Authorize] authURL = ', authURL, 'scope = ', scope, 'redirectUri = ', redirectUri, 'clientId = ', clientId);\n\n  // keep track of the discovery data during redirect if we can't save it in localStorage\n  if (!util.localStorageAvailable() && remoteStorage.backend === 'remotestorage') {\n    redirectUri += redirectUri.indexOf('#') > 0 ? '&' : '#';\n\n    var discoveryData = {\n      userAddress: remoteStorage.remote.userAddress,\n      href: remoteStorage.remote.href,\n      storageApi: remoteStorage.remote.storageApi,\n      properties: remoteStorage.remote.properties\n    };\n\n    redirectUri += 'rsDiscovery=' + btoa(JSON.stringify(discoveryData));\n  }\n\n  var url = authURL,\n      hashPos = redirectUri.indexOf('#');\n  url += authURL.indexOf('?') > 0 ? '&' : '?';\n  url += 'redirect_uri=' + encodeURIComponent(redirectUri.replace(/#.*$/, ''));\n  url += '&scope=' + encodeURIComponent(scope);\n  url += '&client_id=' + encodeURIComponent(clientId);\n  if (hashPos !== -1 && hashPos + 1 !== redirectUri.length) {\n    url += '&state=' + encodeURIComponent(redirectUri.substring(hashPos + 1));\n  }\n  url += '&response_type=token';\n\n  if (util.globalContext.cordova) {\n    return Authorize.openWindow(url, redirectUri, 'location=yes,clearsessioncache=yes,clearcache=yes').then(function (authResult) {\n      remoteStorage.remote.configure({\n        token: authResult.access_token\n      });\n    });\n  }\n\n  Authorize.setLocation(url);\n};\n\nAuthorize.IMPLIED_FAKE_TOKEN = false;\n\nAuthorize.Unauthorized = function () {\n  Error.apply(this, arguments);\n};\nAuthorize.Unauthorized.prototype = Object.create(Error.prototype);\n\n/**\n * Get current document location\n *\n * Override this method if access to document.location is forbidden\n */\nAuthorize.getLocation = function () {\n  return document.location;\n};\n\n/**\n * Set current document location\n *\n * Override this method if access to document.location is forbidden\n */\nAuthorize.setLocation = function (location) {\n  if (typeof location === 'string') {\n    document.location.href = location;\n  } else if ((typeof location === 'undefined' ? 'undefined' : _typeof(location)) === 'object') {\n    document.location = location;\n  } else {\n    throw \"Invalid location \" + location;\n  }\n};\n\n/**\n * Open new InAppBrowser window for OAuth in Cordova\n */\nAuthorize.openWindow = function (url, redirectUri, options) {\n  return new Promise(function (resolve, reject) {\n\n    var newWindow = open(url, '_blank', options);\n\n    if (!newWindow || newWindow.closed) {\n      return reject('Authorization popup was blocked');\n    }\n\n    var handleExit = function handleExit() {\n      return reject('Authorization was canceled');\n    };\n\n    var handleLoadstart = function handleLoadstart(event) {\n      if (event.url.indexOf(redirectUri) !== 0) {\n        return;\n      }\n\n      newWindow.removeEventListener('exit', handleExit);\n      newWindow.close();\n\n      var authResult = extractParams(event.url);\n\n      if (!authResult) {\n        return reject('Authorization error');\n      }\n\n      return resolve(authResult);\n    };\n\n    newWindow.addEventListener('loadstart', handleLoadstart);\n    newWindow.addEventListener('exit', handleExit);\n  });\n};\n\nAuthorize._rs_supported = function () {\n  return typeof document !== 'undefined';\n};\n\nvar onFeaturesLoaded;\nAuthorize._rs_init = function (remoteStorage) {\n\n  onFeaturesLoaded = function onFeaturesLoaded() {\n    var authParamsUsed = false;\n    if (params) {\n      if (params.error) {\n        throw \"Authorization server errored: \" + params.error;\n      }\n\n      // rsDiscovery came with the redirect, because it couldn't be\n      // saved in localStorage\n      if (params.rsDiscovery) {\n        remoteStorage.remote.configure(params.rsDiscovery);\n      }\n\n      if (params.access_token) {\n        remoteStorage.remote.configure({\n          token: params.access_token\n        });\n        authParamsUsed = true;\n      }\n      if (params.remotestorage) {\n        remoteStorage.connect(params.remotestorage);\n        authParamsUsed = true;\n      }\n      if (params.state) {\n        location = Authorize.getLocation();\n        Authorize.setLocation(location.href.split('#')[0] + '#' + params.state);\n      }\n    }\n    if (!authParamsUsed) {\n      remoteStorage.remote.stopWaitingForToken();\n    }\n  };\n  var params = extractParams(),\n      location;\n  if (params) {\n    location = Authorize.getLocation();\n    location.hash = '';\n  }\n  remoteStorage.on('features-loaded', onFeaturesLoaded);\n};\n\nAuthorize._rs_cleanup = function (remoteStorage) {\n  remoteStorage.removeEventListener('features-loaded', onFeaturesLoaded);\n};\n\nmodule.exports = Authorize;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvYXV0aG9yaXplLmpzPzI4NTEiXSwibmFtZXMiOlsibG9nIiwicmVxdWlyZSIsInV0aWwiLCJleHRyYWN0UGFyYW1zIiwidXJsIiwibG9jYXRpb24iLCJBdXRob3JpemUiLCJnZXRMb2NhdGlvbiIsImhyZWYiLCJoYXNoUG9zIiwiaW5kZXhPZiIsImhhc2giLCJzdWJzdHJpbmciLCJzcGxpdCIsInJlZHVjZSIsInBhcmFtcyIsImt2cyIsImt2IiwibWF0Y2giLCJzdGF0ZVZhbHVlIiwiZGVjb2RlVVJJQ29tcG9uZW50IiwiZW5jb2RlZERhdGEiLCJzdWJzdHIiLCJKU09OIiwicGFyc2UiLCJhdG9iIiwicmVwbGFjZSIsIlJlZ0V4cCIsImxlbmd0aCIsInJlbW90ZVN0b3JhZ2UiLCJhdXRoVVJMIiwic2NvcGUiLCJyZWRpcmVjdFVyaSIsImNsaWVudElkIiwibG9jYWxTdG9yYWdlQXZhaWxhYmxlIiwiYmFja2VuZCIsImRpc2NvdmVyeURhdGEiLCJ1c2VyQWRkcmVzcyIsInJlbW90ZSIsInN0b3JhZ2VBcGkiLCJwcm9wZXJ0aWVzIiwiYnRvYSIsInN0cmluZ2lmeSIsImVuY29kZVVSSUNvbXBvbmVudCIsImdsb2JhbENvbnRleHQiLCJjb3Jkb3ZhIiwib3BlbldpbmRvdyIsInRoZW4iLCJhdXRoUmVzdWx0IiwiY29uZmlndXJlIiwidG9rZW4iLCJhY2Nlc3NfdG9rZW4iLCJzZXRMb2NhdGlvbiIsIklNUExJRURfRkFLRV9UT0tFTiIsIlVuYXV0aG9yaXplZCIsIkVycm9yIiwiYXBwbHkiLCJhcmd1bWVudHMiLCJwcm90b3R5cGUiLCJPYmplY3QiLCJjcmVhdGUiLCJkb2N1bWVudCIsIm9wdGlvbnMiLCJQcm9taXNlIiwicmVzb2x2ZSIsInJlamVjdCIsIm5ld1dpbmRvdyIsIm9wZW4iLCJjbG9zZWQiLCJoYW5kbGVFeGl0IiwiaGFuZGxlTG9hZHN0YXJ0IiwiZXZlbnQiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwiY2xvc2UiLCJhZGRFdmVudExpc3RlbmVyIiwiX3JzX3N1cHBvcnRlZCIsIm9uRmVhdHVyZXNMb2FkZWQiLCJfcnNfaW5pdCIsImF1dGhQYXJhbXNVc2VkIiwiZXJyb3IiLCJyc0Rpc2NvdmVyeSIsInJlbW90ZXN0b3JhZ2UiLCJjb25uZWN0Iiwic3RhdGUiLCJzdG9wV2FpdGluZ0ZvclRva2VuIiwib24iLCJfcnNfY2xlYW51cCIsIm1vZHVsZSIsImV4cG9ydHMiXSwibWFwcGluZ3MiOiI7Ozs7QUFBQSxJQUFJQSxNQUFNLG1CQUFBQyxDQUFRLENBQVIsQ0FBVjtBQUNBLElBQUlDLE9BQU8sbUJBQUFELENBQVEsQ0FBUixDQUFYOztBQUVFLFNBQVNFLGFBQVQsQ0FBdUJDLEdBQXZCLEVBQTRCO0FBQzFCO0FBQ0EsTUFBSUMsV0FBV0QsT0FBT0UsVUFBVUMsV0FBVixHQUF3QkMsSUFBOUM7QUFBQSxNQUNJQyxVQUFXSixTQUFTSyxPQUFULENBQWlCLEdBQWpCLENBRGY7QUFBQSxNQUVJQyxJQUZKO0FBR0EsTUFBSUYsWUFBWSxDQUFDLENBQWpCLEVBQW9CO0FBQUU7QUFBUztBQUMvQkUsU0FBT04sU0FBU08sU0FBVCxDQUFtQkgsVUFBUSxDQUEzQixDQUFQO0FBQ0E7QUFDQSxNQUFJRSxLQUFLRCxPQUFMLENBQWEsR0FBYixNQUFzQixDQUFDLENBQTNCLEVBQThCO0FBQUU7QUFBUztBQUN6QyxTQUFPQyxLQUFLRSxLQUFMLENBQVcsR0FBWCxFQUFnQkMsTUFBaEIsQ0FBdUIsVUFBVUMsTUFBVixFQUFrQkMsR0FBbEIsRUFBdUI7QUFDbkQsUUFBSUMsS0FBS0QsSUFBSUgsS0FBSixDQUFVLEdBQVYsQ0FBVDs7QUFFQSxRQUFJSSxHQUFHLENBQUgsTUFBVSxPQUFWLElBQXFCQSxHQUFHLENBQUgsRUFBTUMsS0FBTixDQUFZLGFBQVosQ0FBekIsRUFBcUQ7QUFDbkQ7QUFDQSxVQUFJQyxhQUFhQyxtQkFBbUJILEdBQUcsQ0FBSCxDQUFuQixDQUFqQjtBQUNBLFVBQUlJLGNBQWNGLFdBQVdHLE1BQVgsQ0FBa0JILFdBQVdU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QStCO0FBQzdCQyxpQkFBT25DLE9BQU9vQztBQURlLFNBQS9CO0FBR0EyQix5QkFBaUIsSUFBakI7QUFDRDtBQUNELFVBQUkvRCxPQUFPa0UsYUFBWCxFQUEwQjtBQUN4QnBELHNCQUFjcUQsT0FBZCxDQUFzQm5FLE9BQU9rRSxhQUE3QjtBQUNBSCx5QkFBaUIsSUFBakI7QUFDRDtBQUNELFVBQUkvRCxPQUFPb0UsS0FBWCxFQUFrQjtBQUNoQjlFLG1CQUFXQyxVQUFVQyxXQUFWLEVBQVg7QUFDQUQsa0JBQVU4QyxXQUFWLENBQXNCL0MsU0FBU0csSUFBVCxDQUFjSyxLQUFkLENBQW9CLEdBQXBCLEVBQXlCLENBQXpCLElBQTRCLEdBQTVCLEdBQWdDRSxPQUFPb0UsS0FBN0Q7QUFDRDtBQUNGO0FBQ0QsUUFBSSxDQUFDTCxjQUFMLEVBQXFCO0FBQ25CakQsb0JBQWNTLE1BQWQsQ0FBcUI4QyxtQkFBckI7QUFDRDtBQUNGLEdBL0JEO0FBZ0NBLE1BQUlyRSxTQUFTWixlQUFiO0FBQUEsTUFDSUUsUUFESjtBQUVBLE1BQUlVLE1BQUosRUFBWTtBQUNWVixlQUFXQyxVQUFVQyxXQUFWLEVBQVg7QUFDQUYsYUFBU00sSUFBVCxHQUFnQixFQUFoQjtBQUNEO0FBQ0RrQixnQkFBY3dELEVBQWQsQ0FBaUIsaUJBQWpCLEVBQW9DVCxnQkFBcEM7QUFDRCxDQXpDRDs7QUEyQ0F0RSxVQUFVZ0YsV0FBVixHQUF3QixVQUFVekQsYUFBVixFQUF5QjtBQUMvQ0EsZ0JBQWMyQyxtQkFBZCxDQUFrQyxpQkFBbEMsRUFBcURJLGdCQUFyRDtBQUNELENBRkQ7O0FBSUFXLE9BQU9DLE9BQVAsR0FBaUJsRixTQUFqQiIsImZpbGUiOiI0LmpzIiwic291cmNlc0NvbnRlbnQiOlsidmFyIGxvZyA9IHJlcXVpcmUoJy4vbG9nJyk7XG52YXIgdXRpbCA9IHJlcXVpcmUoJy4vdXRpbCcpO1xuICBcbiAgZnVuY3Rpb24gZXh0cmFjdFBhcmFtcyh1cmwpIHtcbiAgICAvL0ZGIGFscmVhZHkgZGVjb2RlcyB0aGUgVVJMIGZyYWdtZW50IGluIGRvY3VtZW50LmxvY2F0aW9uLmhhc2gsIHNvIHVzZSB0aGlzIGluc3RlYWQ6XG4gICAgdmFyIGxvY2F0aW9uID0gdXJsIHx8IEF1dGhvcml6ZS5nZXRMb2NhdGlvbigpLmhyZWYsXG4gICAgICAgIGhhc2hQb3MgID0gbG9jYXRpb24uaW5kZXhPZignIycpLFxuICAgICAgICBoYXNoO1xuICAgIGlmIChoYXNoUG9zID09PSAtMSkgeyByZXR1cm47IH1cbiAgICBoYXNoID0gbG9jYXRpb24uc3Vic3RyaW5nKGhhc2hQb3MrMSk7XG4gICAgLy8gaWYgaGFzaCBpcyBub3Qgb2YgdGhlIGZvcm0gI2tleT12YWwma2V5PXZhbCwgaXQncyBwcm9iYWJseSBub3QgZm9yIHVzXG4gICAgaWYgKGhhc2guaW5kZXhPZignPScpID09PSAtMSkgeyByZXR1cm47IH1cbiAgICByZXR1cm4gaGFzaC5zcGxpdCgnJicpLnJlZHVjZShmdW5jdGlvbiAocGFyYW1zLCBrdnMpIHtcbiAgICAgIHZhciBrdiA9IGt2cy5zcGxpdCgnPScpO1xuXG4gICAgICBpZiAoa3ZbMF0gPT09ICdzdGF0ZScgJiYga3ZbMV0ubWF0Y2goL3JzRGlzY292ZXJ5LykpIHtcbiAgICAgICAgLy8gZXh0cmFjdCByc0Rpc2NvdmVyeSBkYXRhIGZyb20gdGhlIHN0YXRlIHBhcmFtXG4gICAgICAgIHZhciBzdGF0ZVZhbHVlID0gZGVjb2RlVVJJQ29tcG9uZW50KGt2WzFdKTtcbiAgICAgICAgdmFyIGVuY29kZWREYXRhID0gc3RhdGVWYWx1ZS5zdWJzdHIoc3RhdGVWYWx1ZS5pbmRleE9mKCdyc0Rpc2NvdmVyeT0nKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5zcGxpdCgnJicpWzBdXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuc3BsaXQoJz0nKVsxXTtcblxuICAgICAgICBwYXJhbXNbJ3JzRGlzY292ZXJ5J10gPSBKU09OLnBhcnNlKGF0b2IoZW5jb2RlZERhdGEpKTtcblxuICAgICAgICAvLyByZW1vdmUgcnNEaXNjb3ZlcnkgcGFyYW1cbiAgICAgICAgc3RhdGVWYWx1ZSA9IHN0YXRlVmFsdWUucmVwbGFjZShuZXcgUmVnRXhwKCdcXCY/cnNEaXNjb3Zlcnk9JyArIGVuY29kZWREYXRhKSwgJycpO1xuXG4gICAgICAgIGlmIChzdGF0ZVZhbHVlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBwYXJhbXNbJ3N0YXRlJ10gPSBzdGF0ZVZhbHVlO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwYXJhbXNbZGVjb2RlVVJJQ29tcG9uZW50KGt2WzBdKV0gPSBkZWNvZGVVUklDb21wb25lbnQoa3ZbMV0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcGFyYW1zO1xuICAgIH0sIHt9KTtcbiAgfVxuXG5cbiAgdmFyIEF1dGhvcml6ZSA9IGZ1bmN0aW9uIChyZW1vdGVTdG9yYWdlLCBhdXRoVVJMLCBzY29wZSwgcmVkaXJlY3RVcmksIGNsaWVudElkKSB7XG4gICAgbG9nKCdbQXV0aG9yaXplXSBhdXRoVVJMID0gJywgYXV0aFVSTCwgJ3Njb3BlID0gJywgc2NvcGUsICdyZWRpcmVjdFVyaSA9ICcsIHJlZGlyZWN0VXJpLCAnY2xpZW50SWQgPSAnLCBjbGllbnRJZCk7XG5cbiAgICAvLyBrZWVwIHRyYWNrIG9mIHRoZSBkaXNjb3ZlcnkgZGF0YSBkdXJpbmcgcmVkaXJlY3QgaWYgd2UgY2FuJ3Qgc2F2ZSBpdCBpbiBsb2NhbFN0b3JhZ2VcbiAgICBpZiAoIXV0aWwubG9jYWxTdG9yYWdlQXZhaWxhYmxlKCkgJiZcbiAgICAgICAgcmVtb3RlU3RvcmFnZS5iYWNrZW5kID09PSAncmVtb3Rlc3RvcmFnZScpIHtcbiAgICAgIHJlZGlyZWN0VXJpICs9IHJlZGlyZWN0VXJpLmluZGV4T2YoJyMnKSA+IDAgPyAnJicgOiAnIyc7XG5cbiAgICAgIHZhciBkaXNjb3ZlcnlEYXRhID0ge1xuICAgICAgICB1c2VyQWRkcmVzczogcmVtb3RlU3RvcmFnZS5yZW1vdGUudXNlckFkZHJlc3MsXG4gICAgICAgIGhyZWY6IHJlbW90ZVN0b3JhZ2UucmVtb3RlLmhyZWYsXG4gICAgICAgIHN0b3JhZ2VBcGk6IHJlbW90ZVN0b3JhZ2UucmVtb3RlLnN0b3JhZ2VBcGksXG4gICAgICAgIHByb3BlcnRpZXM6IHJlbW90ZVN0b3JhZ2UucmVtb3RlLnByb3BlcnRpZXNcbiAgICAgIH07XG5cbiAgICAgIHJlZGlyZWN0VXJpICs9ICdyc0Rpc2NvdmVyeT0nICsgYnRvYShKU09OLnN0cmluZ2lmeShkaXNjb3ZlcnlEYXRhKSk7XG4gICAgfVxuXG4gICAgdmFyIHVybCA9IGF1dGhVUkwsIGhhc2hQb3MgPSByZWRpcmVjdFVyaS5pbmRleE9mKCcjJyk7XG4gICAgdXJsICs9IGF1dGhVUkwuaW5kZXhPZignPycpID4gMCA/ICcmJyA6ICc/JztcbiAgICB1cmwgKz0gJ3JlZGlyZWN0X3VyaT0nICsgZW5jb2RlVVJJQ29tcG9uZW50KHJlZGlyZWN0VXJpLnJlcGxhY2UoLyMuKiQvLCAnJykpO1xuICAgIHVybCArPSAnJnNjb3BlPScgKyBlbmNvZGVVUklDb21wb25lbnQoc2NvcGUpO1xuICAgIHVybCArPSAnJmNsaWVudF9pZD0nICsgZW5jb2RlVVJJQ29tcG9uZW50KGNsaWVudElkKTtcbiAgICBpZiAoaGFzaFBvcyAhPT0gLSAxICYmIGhhc2hQb3MrMSAhPT0gcmVkaXJlY3RVcmkubGVuZ3RoKSB7XG4gICAgICB1cmwgKz0gJyZzdGF0ZT0nICsgZW5jb2RlVVJJQ29tcG9uZW50KHJlZGlyZWN0VXJpLnN1YnN0cmluZyhoYXNoUG9zKzEpKTtcbiAgICB9XG4gICAgdXJsICs9ICcmcmVzcG9uc2VfdHlwZT10b2tlbic7XG5cbiAgICBpZiAodXRpbC5nbG9iYWxDb250ZXh0LmNvcmRvdmEpIHtcbiAgICAgIHJldHVybiBBdXRob3JpemUub3BlbldpbmRvdyhcbiAgICAgICAgICB1cmwsXG4gICAgICAgICAgcmVkaXJlY3RVcmksXG4gICAgICAgICAgJ2xvY2F0aW9uPXllcyxjbGVhcnNlc3Npb25jYWNoZT15ZXMsY2xlYXJjYWNoZT15ZXMnXG4gICAgICAgIClcbiAgICAgICAgLnRoZW4oZnVuY3Rpb24oYXV0aFJlc3VsdCkge1xuICAgICAgICAgIHJlbW90ZVN0b3JhZ2UucmVtb3RlLmNvbmZpZ3VyZSh7XG4gICAgICAgICAgICB0b2tlbjogYXV0aFJlc3VsdC5hY2Nlc3NfdG9rZW5cbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgQXV0aG9yaXplLnNldExvY2F0aW9uKHVybCk7XG4gIH07XG5cbiAgQXV0aG9yaXplLklNUExJRURfRkFLRV9UT0tFTiA9IGZhbHNlO1xuICBcbiAgQXV0aG9yaXplLlVuYXV0aG9yaXplZCA9IGZ1bmN0aW9uICgpIHsgRXJyb3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfTtcbiAgQXV0aG9yaXplLlVuYXV0aG9yaXplZC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEVycm9yLnByb3RvdHlwZSk7XG5cblxuICAvKipcbiAgICogR2V0IGN1cnJlbnQgZG9jdW1lbnQgbG9jYXRpb25cbiAgICpcbiAgICogT3ZlcnJpZGUgdGhpcyBtZXRob2QgaWYgYWNjZXNzIHRvIGRvY3VtZW50LmxvY2F0aW9uIGlzIGZvcmJpZGRlblxuICAgKi9cbiAgQXV0aG9yaXplLmdldExvY2F0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBkb2N1bWVudC5sb2NhdGlvbjtcbiAgfTtcblxuICAvKipcbiAgICogU2V0IGN1cnJlbnQgZG9jdW1lbnQgbG9jYXRpb25cbiAgICpcbiAgICogT3ZlcnJpZGUgdGhpcyBtZXRob2QgaWYgYWNjZXNzIHRvIGRvY3VtZW50LmxvY2F0aW9uIGlzIGZvcmJpZGRlblxuICAgKi9cbiAgQXV0aG9yaXplLnNldExvY2F0aW9uID0gZnVuY3Rpb24gKGxvY2F0aW9uKSB7XG4gICAgaWYgKHR5cGVvZiBsb2NhdGlvbiA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGRvY3VtZW50LmxvY2F0aW9uLmhyZWYgPSBsb2NhdGlvbjtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBsb2NhdGlvbiA9PT0gJ29iamVjdCcpIHtcbiAgICAgIGRvY3VtZW50LmxvY2F0aW9uID0gbG9jYXRpb247XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IFwiSW52YWxpZCBsb2NhdGlvbiBcIiArIGxvY2F0aW9uO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogT3BlbiBuZXcgSW5BcHBCcm93c2VyIHdpbmRvdyBmb3IgT0F1dGggaW4gQ29yZG92YVxuICAgKi9cbiAgQXV0aG9yaXplLm9wZW5XaW5kb3cgPSBmdW5jdGlvbiAodXJsLCByZWRpcmVjdFVyaSwgb3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSggKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuXG4gICAgICB2YXIgbmV3V2luZG93ID0gb3Blbih1cmwsICdfYmxhbmsnLCBvcHRpb25zKTtcblxuICAgICAgaWYgKCFuZXdXaW5kb3cgfHwgbmV3V2luZG93LmNsb3NlZCkge1xuICAgICAgICByZXR1cm4gcmVqZWN0KCdBdXRob3JpemF0aW9uIHBvcHVwIHdhcyBibG9ja2VkJyk7XG4gICAgICB9XG5cbiAgICAgIHZhciBoYW5kbGVFeGl0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gcmVqZWN0KCdBdXRob3JpemF0aW9uIHdhcyBjYW5jZWxlZCcpO1xuICAgICAgfTtcblxuICAgICAgdmFyIGhhbmRsZUxvYWRzdGFydCA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICBpZiAoZXZlbnQudXJsLmluZGV4T2YocmVkaXJlY3RVcmkpICE9PSAwKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgbmV3V2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2V4aXQnLCBoYW5kbGVFeGl0KTtcbiAgICAgICAgbmV3V2luZG93LmNsb3NlKCk7XG5cbiAgICAgICAgdmFyIGF1dGhSZXN1bHQgPSBleHRyYWN0UGFyYW1zKGV2ZW50LnVybCk7XG5cbiAgICAgICAgaWYgKCFhdXRoUmVzdWx0KSB7XG4gICAgICAgICAgcmV0dXJuIHJlamVjdCgnQXV0aG9yaXphdGlvbiBlcnJvcicpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc29sdmUoYXV0aFJlc3VsdCk7XG4gICAgICB9O1xuXG4gICAgICBuZXdXaW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignbG9hZHN0YXJ0JywgaGFuZGxlTG9hZHN0YXJ0KTtcbiAgICAgIG5ld1dpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdleGl0JywgaGFuZGxlRXhpdCk7XG5cbiAgICB9KTtcbiAgfTtcblxuXG4gIEF1dGhvcml6ZS5fcnNfc3VwcG9ydGVkID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0eXBlb2YoZG9jdW1lbnQpICE9PSAndW5kZWZpbmVkJztcbiAgfTtcblxuICB2YXIgb25GZWF0dXJlc0xvYWRlZDtcbiAgQXV0aG9yaXplLl9yc19pbml0ID0gZnVuY3Rpb24gKHJlbW90ZVN0b3JhZ2UpIHtcblxuICAgIG9uRmVhdHVyZXNMb2FkZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgYXV0aFBhcmFtc1VzZWQgPSBmYWxzZTtcbiAgICAgIGlmIChwYXJhbXMpIHtcbiAgICAgICAgaWYgKHBhcmFtcy5lcnJvcikge1xuICAgICAgICAgIHRocm93IFwiQXV0aG9yaXphdGlvbiBzZXJ2ZXIgZXJyb3JlZDogXCIgKyBwYXJhbXMuZXJyb3I7XG4gICAgICAgIH1cblxuICAgICAgICAvLyByc0Rpc2NvdmVyeSBjYW1lIHdpdGggdGhlIHJlZGlyZWN0LCBiZWNhdXNlIGl0IGNvdWxkbid0IGJlXG4gICAgICAgIC8vIHNhdmVkIGluIGxvY2FsU3RvcmFnZVxuICAgICAgICBpZiAocGFyYW1zLnJzRGlzY292ZXJ5KSB7XG4gICAgICAgICAgcmVtb3RlU3RvcmFnZS5yZW1vdGUuY29uZmlndXJlKHBhcmFtcy5yc0Rpc2NvdmVyeSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocGFyYW1zLmFjY2Vzc190b2tlbikge1xuICAgICAgICAgIHJlbW90ZVN0b3JhZ2UucmVtb3RlLmNvbmZpZ3VyZSh7XG4gICAgICAgICAgICB0b2tlbjogcGFyYW1zLmFjY2Vzc190b2tlblxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGF1dGhQYXJhbXNVc2VkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGFyYW1zLnJlbW90ZXN0b3JhZ2UpIHtcbiAgICAgICAgICByZW1vdGVTdG9yYWdlLmNvbm5lY3QocGFyYW1zLnJlbW90ZXN0b3JhZ2UpO1xuICAgICAgICAgIGF1dGhQYXJhbXNVc2VkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGFyYW1zLnN0YXRlKSB7XG4gICAgICAgICAgbG9jYXRpb24gPSBBdXRob3JpemUuZ2V0TG9jYXRpb24oKTtcbiAgICAgICAgICBBdXRob3JpemUuc2V0TG9jYXRpb24obG9jYXRpb24uaHJlZi5zcGxpdCgnIycpWzBdKycjJytwYXJhbXMuc3RhdGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoIWF1dGhQYXJhbXNVc2VkKSB7XG4gICAgICAgIHJlbW90ZVN0b3JhZ2UucmVtb3RlLnN0b3BXYWl0aW5nRm9yVG9rZW4oKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHZhciBwYXJhbXMgPSBleHRyYWN0UGFyYW1zKCksXG4gICAgICAgIGxvY2F0aW9uO1xuICAgIGlmIChwYXJhbXMpIHtcbiAgICAgIGxvY2F0aW9uID0gQXV0aG9yaXplLmdldExvY2F0aW9uKCk7XG4gICAgICBsb2NhdGlvbi5oYXNoID0gJyc7XG4gICAgfVxuICAgIHJlbW90ZVN0b3JhZ2Uub24oJ2ZlYXR1cmVzLWxvYWRlZCcsIG9uRmVhdHVyZXNMb2FkZWQpO1xuICB9O1xuXG4gIEF1dGhvcml6ZS5fcnNfY2xlYW51cCA9IGZ1bmN0aW9uIChyZW1vdGVTdG9yYWdlKSB7XG4gICAgcmVtb3RlU3RvcmFnZS5yZW1vdmVFdmVudExpc3RlbmVyKCdmZWF0dXJlcy1sb2FkZWQnLCBvbkZlYXR1cmVzTG9hZGVkKTtcbiAgfTtcblxuICBtb2R1bGUuZXhwb3J0cyA9IEF1dGhvcml6ZTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9hdXRob3JpemUuanMiXSwic291cmNlUm9vdCI6IiJ9");
},function(module,exports){eval('"use strict";\n\nvar config = {\n     logging: false,\n     changeEvents: {\n          local: true,\n          window: false,\n          remote: true,\n          conflict: true\n     },\n     cache: true,\n     disableFeatures: [],\n     discoveryTimeout: 10000,\n     syncInterval: 10000,\n     backgroundSyncInterval: 60000,\n     isBackground: false,\n     cordovaRedirectUri: undefined\n};\n\nmodule.exports = config;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvY29uZmlnLmpzPzQyNjQiXSwibmFtZXMiOlsiY29uZmlnIiwibG9nZ2luZyIsImNoYW5nZUV2ZW50cyIsImxvY2FsIiwid2luZG93IiwicmVtb3RlIiwiY29uZmxpY3QiLCJjYWNoZSIsImRpc2FibGVGZWF0dXJlcyIsImRpc2NvdmVyeVRpbWVvdXQiLCJzeW5jSW50ZXJ2YWwiLCJiYWNrZ3JvdW5kU3luY0ludGVydmFsIiwiaXNCYWNrZ3JvdW5kIiwiY29yZG92YVJlZGlyZWN0VXJpIiwidW5kZWZpbmVkIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJtYXBwaW5ncyI6Ijs7QUFBQSxJQUFJQSxTQUFTO0FBQ1pDLGNBQVMsS0FERztBQUVaQyxtQkFBYztBQUNUQyxpQkFBVSxJQUREO0FBRVRDLGtCQUFVLEtBRkQ7QUFHVEMsa0JBQVUsSUFIRDtBQUlUQyxvQkFBVTtBQUpELE1BRkY7QUFRWEMsWUFBTyxJQVJJO0FBU1hDLHNCQUFpQixFQVROO0FBVVhDLHVCQUFrQixLQVZQO0FBV1hDLG1CQUFjLEtBWEg7QUFZWEMsNkJBQXdCLEtBWmI7QUFhWEMsbUJBQWMsS0FiSDtBQWNYQyx5QkFBb0JDO0FBZFQsQ0FBYjs7QUFpQkFDLE9BQU9DLE9BQVAsR0FBaUJoQixNQUFqQiIsImZpbGUiOiI1LmpzIiwic291cmNlc0NvbnRlbnQiOlsidmFyIGNvbmZpZyA9IHtcblx0bG9nZ2luZzogZmFsc2UsXG5cdGNoYW5nZUV2ZW50czoge1xuICAgICAgbG9jYWw6ICAgIHRydWUsXG4gICAgICB3aW5kb3c6ICAgZmFsc2UsXG4gICAgICByZW1vdGU6ICAgdHJ1ZSxcbiAgICAgIGNvbmZsaWN0OiB0cnVlXG4gIH0sXG4gIGNhY2hlOiB0cnVlLFxuICBkaXNhYmxlRmVhdHVyZXM6IFtdLFxuICBkaXNjb3ZlcnlUaW1lb3V0OiAxMDAwMCxcbiAgc3luY0ludGVydmFsOiAxMDAwMCxcbiAgYmFja2dyb3VuZFN5bmNJbnRlcnZhbDogNjAwMDAsXG4gIGlzQmFja2dyb3VuZDogZmFsc2UsXG4gIGNvcmRvdmFSZWRpcmVjdFVyaTogdW5kZWZpbmVkXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGNvbmZpZztcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvY29uZmlnLmpzIl0sInNvdXJjZVJvb3QiOiIifQ==')},function(module,exports,__webpack_require__){eval("'use strict';\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nfunction deprecate(thing, replacement) {\n  console.log('WARNING: ' + thing + ' is deprecated. Use ' + replacement + ' instead.');\n}\n\nvar eventHandling = __webpack_require__(3);\nvar util = __webpack_require__(2);\nvar config = __webpack_require__(5);\nvar _uuid = __webpack_require__(31);\n\n/**\n * Class: BaseClient\n *\n * Provides a high-level interface to access data below a given root path.\n *\n * A BaseClient deals with three types of data: folders, objects and files.\n *\n * <getListing> returns a mapping of all items within a folder. Items that\n * end with a forward slash (\"/\") are child folders. For instance:\n * {\n *   'folder/': true,\n *   'document.txt': true\n * }\n *\n * <getObject> / <storeObject> operate on JSON objects. Each object has a type.\n *\n * <getFile> / <storeFile> operates on files. Each file has a MIME type.\n *\n * <remove> operates on either objects or files (but not folders, folders are\n * created and removed implictly).\n */\nvar BaseClient = function BaseClient(storage, base) {\n  if (base[base.length - 1] !== '/') {\n    throw \"Not a folder: \" + base;\n  }\n\n  if (base === '/') {\n    // allow absolute and relative paths for the root scope.\n    this.makePath = function (path) {\n      return (path[0] === '/' ? '' : '/') + path;\n    };\n  }\n\n  /**\n   * Property: storage\n   *\n   * The <RemoteStorage> instance this <BaseClient> operates on.\n   */\n  this.storage = storage;\n\n  /**\n   * Property: base\n   *\n   * Base path this <BaseClient> operates on.\n   *\n   * For the module's privateClient this would be /<moduleName>/, for the\n   * corresponding publicClient /public/<moduleName>/.\n   */\n  this.base = base;\n\n  var parts = this.base.split('/');\n  if (parts.length > 2) {\n    this.moduleName = parts[1];\n  } else {\n    this.moduleName = 'root';\n  }\n\n  // Defined in baseclient/types.js\n  /**\n   * Property: schemas\n   *\n   * Contains schema objects of all types known to the BaseClient instance\n   **/\n\n  /**\n   * Event: change\n   *\n   * Emitted when a node changes\n   *\n   * Arguments:\n   *   event - Event object containing information about the changed node\n   *\n   * (start code)\n   * {\n   *    path: path, // Absolute path of the changed node, from the storage root\n   *    relativePath: relativePath, // Path of the changed node, relative to this baseclient's scope root\n   *    origin: 'window', 'local', 'remote', or 'conflict' // emitted by user action within the app, local data store, remote sync, or versioning conflicts\n   *    oldValue: oldBody, // Old body of the changed node (local version in conflicts; undefined if creation)\n   *    newValue: newBody, // New body of the changed node (remote version in conflicts; undefined if deletion)\n   *    lastCommonValue: lastCommonValue, //most recent known common ancestor body of 'yours' and 'theirs' in case of conflict\n   *    oldContentType: oldContentType, // Old contentType of the changed node ('yours' for conflicts; undefined if creation)\n   *    newContentType: newContentType, // New contentType of the changed node ('theirs' for conflicts; undefined if deletion)\n   *    lastCommonContentType: lastCommonContentType // Most recent known common ancestor contentType of 'yours' and 'theirs' in case of conflict\n   *  }\n   * (end code)\n   *\n   * Example of an event with origin 'local' (fired on page load):\n   *\n   * (start code)\n   * {\n   *    path: '/public/design/color.txt',\n   *    relativePath: 'color.txt',\n   *    origin: 'local',\n   *    oldValue: undefined,\n   *    newValue: 'white',\n   *    oldContentType: undefined,\n   *    newContentType: 'text/plain'\n   *  }\n   * (end code)\n   *\n   * Example of a conflict:\n   * Say you changed 'color.txt' from 'white' to 'blue'; if you have set `config.changeEvents.window` to `true`,\n   * then you will receive:\n   *\n   * (start code)\n   * {\n   *    path: '/public/design/color.txt',\n   *    relativePath: 'color.txt',\n   *    origin: 'window',\n   *    oldValue: 'white',\n   *    newValue: 'blue',\n   *    oldContentType: 'text/plain',\n   *    newContentType: 'text/plain'\n   *  }\n   * (end code)\n   *\n   * But when this change is pushed out by asynchronous synchronization, this change may rejected by the\n   * server, if the remote version has in the meantime changed from 'white' to  for instance 'red'; this will then lead to a change\n   * event with origin 'conflict' (usually a few seconds after the event with origin 'window', if you had that activated). Note\n   * that since you already changed it from 'white' to 'blue' in the local version a few seconds ago, `oldValue` is now your local\n   * value of 'blue':\n   *\n   * (start code)\n   * {\n   *    path: '/public/design/color.txt',\n   *    relativePath: 'color.txt',\n   *    origin: 'conflict',\n   *    oldValue: 'blue',\n   *    newValue: 'red',\n   *    lastCommonValue: 'white',\n   *    oldContentType: 'text/plain,\n   *    newContentType: 'text/plain'\n   *    lastCommonContentType: 'text/plain'\n   *  }\n   * (end code)\n   *\n   * In practice, you should always redraw your views to display the content of the `newValue` field when a change event is received,\n   * regardless of its origin. Events with origin 'local' are fired conveniently during the page load, so that you can fill your views\n   * when the page loads. Events with origin 'window' are fired whenever you change a value by calling a method on the baseClient;\n   * these are disabled by default. Events with origin 'remote' are fired when remote changes are discovered during sync (only for caching\n   * startegies 'SEEN' and 'ALL'). Events with origin 'conflict' are fired when a conflict occurs while pushing out your local changes to\n   * the remote store in asynchronous synchronization (see example above).\n   **/\n\n  eventHandling(this, 'change');\n  this.on = this.on.bind(this);\n  storage.onChange(this.base, this._fireChange.bind(this));\n};\n\nBaseClient.prototype = {\n\n  extend: function extend(object) {\n    for (var key in object) {\n      this[key] = object[key];\n    }\n    return this;\n  },\n\n  /**\n   * Method: scope\n   *\n   * Returns a new <BaseClient> operating on a subpath of the current <base> path.\n   */\n  scope: function scope(path) {\n    return new BaseClient(this.storage, this.makePath(path));\n  },\n\n  // folder operations\n\n  /**\n   * Method: getListing\n   *\n   * Get a list of child nodes below a given path.\n   *\n   * The callback semantics of getListing are identical to those of getObject.\n   *\n   * Parameters:\n   *   path   - The path to query. It MUST end with a forward slash.\n   *   maxAge - Either false or the maximum age of cached listing in\n   *            milliseconds. Defaults to false in anonymous mode and to\n   *            2*syncInterval in connected mode.\n   *\n   * Returns:\n   *\n   *   A promise for an object, representing child nodes. If the maxAge\n   *   requirement cannot be met because of network problems, this promise\n   *   will be rejected. If the maxAge requirement is set to false or the\n   *   library is in offline state, the promise will always be fulfilled with\n   *   data from the local store.\n   *\n   *   Keys ending in a forward slash represent *folder nodes*, while all\n   *   other keys represent *data nodes*.\n   *\n   *   For spec versions <= 01, the data node information will contain only\n   *   the item's ETag. For later spec versions, it will also contain the\n   *   content type and -length of the item.\n   *\n   * Example:\n   *   (start code)\n   *   client.getListing('', false).then(function (listing) {\n   *     // listing is for instance:\n   *     // {\n   *     //   'folder/': true,\n   *     //   'document.txt': true\n   *     // }\n   *   });\n   *   (end code)\n   */\n  getListing: function getListing(path, maxAge) {\n    if (typeof path !== 'string') {\n      path = '';\n    } else if (path.length > 0 && path[path.length - 1] !== '/') {\n      return Promise.reject(\"Not a folder: \" + path);\n    }\n    return this.storage.get(this.makePath(path), maxAge).then(function (r) {\n      return r.statusCode === 404 ? {} : r.body;\n    });\n  },\n\n  /**\n   * Method: getAll\n   *\n   * Get all objects directly below a given path.\n   *\n   * Parameters:\n   *   path   - Path to the folder.\n   *   maxAge - Either false or the maximum age of cached objects in\n   *            milliseconds. Defaults to false in anonymous mode and to\n   *            2*syncInterval in connected mode.\n   *\n   * Returns:\n   *   A promise for an object in the form { path : object, ... }. If the\n   *   maxAge requirement cannot be met because of network problems, this\n   *   promise will be rejected. If the maxAge requirement is set to false,\n   *   the promise will always be fulfilled with data from the local store.\n   *\n   *   For items that are not JSON-stringified objects (e.g. stored using\n   *   `storeFile` instead of `storeObject`), the object's value is filled in\n   *   with `true`.\n   *\n   * Example:\n   *   (start code)\n   *   client.getAll('', false).then(function (objects) {\n   *     for (var key in objects) {\n   *       console.log('- ' + key + ': ', objects[key]);\n   *     }\n   *   });\n   *   (end code)\n   */\n  getAll: function getAll(path, maxAge) {\n    if (typeof path !== 'string') {\n      path = '';\n    } else if (path.length > 0 && path[path.length - 1] !== '/') {\n      return Promise.reject(\"Not a folder: \" + path);\n    }\n\n    return this.storage.get(this.makePath(path), maxAge).then(function (r) {\n      if (r.statusCode === 404) {\n        return {};\n      }\n      if (_typeof(r.body) === 'object') {\n        var keys = Object.keys(r.body);\n        if (keys.length === 0) {\n          // treat this like 404. it probably means a folder listing that\n          // has changes that haven't been pushed out yet.\n          return {};\n        }\n\n        var calls = keys.map(function (key) {\n          return this.storage.get(this.makePath(path + key), maxAge).then(function (o) {\n            if (typeof o.body === 'string') {\n              try {\n                o.body = JSON.parse(o.body);\n              } catch (e) {}\n            }\n            if (_typeof(o.body) === 'object') {\n              r.body[key] = o.body;\n            }\n          });\n        }.bind(this));\n        return Promise.all(calls).then(function () {\n          return r.body;\n        });\n      }\n    }.bind(this));\n  },\n\n  // file operations\n\n  /**\n   * Method: getFile\n   *\n   * Get the file at the given path. A file is raw data, as opposed to\n   * a JSON object (use <getObject> for that).\n   *\n   * Except for the return value structure, getFile works exactly like\n   * getObject.\n   *\n   * Parameters:\n   *   path   - See getObject.\n   *   maxAge - Either false or the maximum age of cached file in\n   *            milliseconds. Defaults to false in anonymous mode and to\n   *            2*syncInterval in connected mode.\n   *\n   * Returns:\n   *   A promise for an object:\n   *\n   *   mimeType - String representing the MIME Type of the document.\n   *   data     - Raw data of the document (either a string or an ArrayBuffer)\n   *\n   *   If the maxAge requirement cannot be met because of network problems, this\n   *   promise will be rejected. If the maxAge requirement is set to false, the\n   *   promise will always be fulfilled with data from the local store.\n   *\n   * Example:\n   *   (start code)\n   *   // Display an image:\n   *   client.getFile('path/to/some/image', false).then(function (file) {\n   *     var blob = new Blob([file.data], { type: file.mimeType });\n   *     var targetElement = document.findElementById('my-image-element');\n   *     targetElement.src = window.URL.createObjectURL(blob);\n   *   });\n   *   (end code)\n   */\n  getFile: function getFile(path, maxAge) {\n    if (typeof path !== 'string') {\n      return Promise.reject('Argument \\'path\\' of baseClient.getFile must be a string');\n    }\n    return this.storage.get(this.makePath(path), maxAge).then(function (r) {\n      return {\n        data: r.body,\n        contentType: r.contentType,\n        revision: r.revision // (this is new)\n      };\n    });\n  },\n\n  /**\n   * Method: storeFile\n   *\n   * Store raw data at a given path.\n   *\n   * Parameters:\n   *   mimeType - MIME media type of the data being stored\n   *   path     - path relative to the module root. MAY NOT end in a forward slash.\n   *   data     - string, ArrayBuffer or ArrayBufferView of raw data to store\n   *\n   * The given mimeType will later be returned, when retrieving the data\n   * using <getFile>.\n   *\n   * Example (UTF-8 data):\n   *   (start code)\n   *   client.storeFile('text/html', 'index.html', '<h1>Hello World!</h1>');\n   *   (end code)\n   *\n   * Example (Binary data):\n   *   (start code)\n   *   // MARKUP:\n   *   <input type=\"file\" id=\"file-input\">\n   *   // CODE:\n   *   var input = document.getElementById('file-input');\n   *   var file = input.files[0];\n   *   var fileReader = new FileReader();\n   *\n   *   fileReader.onload = function () {\n   *     client.storeFile(file.type, file.name, fileReader.result);\n   *   };\n   *\n   *   fileReader.readAsArrayBuffer(file);\n   *   (end code)\n   *\n   */\n  storeFile: function storeFile(mimeType, path, body) {\n    if (typeof mimeType !== 'string') {\n      return Promise.reject('Argument \\'mimeType\\' of baseClient.storeFile must be a string');\n    }\n    if (typeof path !== 'string') {\n      return Promise.reject('Argument \\'path\\' of baseClient.storeFile must be a string');\n    }\n    if (typeof body !== 'string' && (typeof body === 'undefined' ? 'undefined' : _typeof(body)) !== 'object') {\n      return Promise.reject('Argument \\'body\\' of baseClient.storeFile must be a string, ArrayBuffer, or ArrayBufferView');\n    }\n    if (!this.storage.access.checkPathPermission(this.makePath(path), 'rw')) {\n      console.warn('WARNING: Editing a document to which only read access (\\'r\\') was claimed');\n    }\n\n    return this.storage.put(this.makePath(path), body, mimeType).then(function (r) {\n      if (r.statusCode === 200 || r.statusCode === 201) {\n        return r.revision;\n      } else {\n        return Promise.reject(\"Request (PUT \" + this.makePath(path) + \") failed with status: \" + r.statusCode);\n      }\n    }.bind(this));\n  },\n\n  // object operations\n\n  /**\n   * Method: getObject\n   *\n   * Get a JSON object from given path.\n   *\n   * Parameters:\n   *   path   - Relative path from the module root (without leading slash).\n   *   maxAge - Either false or the maximum age of cached object in\n   *            milliseconds. Defaults to false in anonymous mode and to\n   *            2*syncInterval in connected mode.\n   *\n   * Returns:\n   *   A promise for the object. If the maxAge requirement cannot be met\n   *   because of network problems, this promise will be rejected. If the\n   *   maxAge requirement is set to false, the promise will always be\n   *   fulfilled with data from the local store.\n   *\n   * Example:\n   *   (start code)\n   *   client.getObject('/path/to/object', false).\n   *     then(function (object) {\n   *       // object is either an object or null\n   *     });\n   *   (end code)\n   */\n  getObject: function getObject(path, maxAge) {\n    if (typeof path !== 'string') {\n      return Promise.reject('Argument \\'path\\' of baseClient.getObject must be a string');\n    }\n    return this.storage.get(this.makePath(path), maxAge).then(function (r) {\n      if (_typeof(r.body) === 'object') {\n        // will be the case for documents stored with rs.js <= 0.10.0-beta2\n        return r.body;\n      } else if (typeof r.body === 'string') {\n        try {\n          return JSON.parse(r.body);\n        } catch (e) {\n          throw \"Not valid JSON: \" + this.makePath(path);\n        }\n      } else if (typeof r.body !== 'undefined' && r.statusCode === 200) {\n        return Promise.reject(\"Not an object: \" + this.makePath(path));\n      }\n    }.bind(this));\n  },\n\n  /**\n   * Method: storeObject\n   *\n   * Store object at given path. Triggers synchronization.\n   *\n   * Parameters:\n   *\n   *   type     - unique type of this object within this module. See description below.\n   *   path     - path relative to the module root.\n   *   object   - an object to be saved to the given node. It must be serializable as JSON.\n   *\n   * Returns:\n   *   A promise to store the object. The promise fails with a ValidationError, when validations fail.\n   *\n   *\n   * What about the type?:\n   *\n   *   A great thing about having data on the web, is to be able to link to\n   *   it and rearrange it to fit the current circumstances. To facilitate\n   *   that, eventually you need to know how the data at hand is structured.\n   *   For documents on the web, this is usually done via a MIME type. The\n   *   MIME type of JSON objects however, is always application/json.\n   *   To add that extra layer of \"knowing what this object is\", remoteStorage\n   *   aims to use <JSON-LD at http://json-ld.org/>.\n   *   A first step in that direction, is to add a *@context attribute* to all\n   *   JSON data put into remoteStorage.\n   *   Now that is what the *type* is for.\n   *\n   *   Within remoteStorage.js, @context values are built using three components:\n   *     http://remotestorage.io/spec/modules/ - A prefix to guarantee uniqueness\n   *     the module name     - module names should be unique as well\n   *     the type given here - naming this particular kind of object within this module\n   *\n   *   In retrospect that means, that whenever you introduce a new \"type\" in calls to\n   *   storeObject, you should make sure that once your code is in the wild, future\n   *   versions of the code are compatible with the same JSON structure.\n   *\n   * How to define types?:\n   *\n   *   See <declareType> for examples.\n   */\n  storeObject: function storeObject(typeAlias, path, object) {\n    if (typeof typeAlias !== 'string') {\n      return Promise.reject('Argument \\'typeAlias\\' of baseClient.storeObject must be a string');\n    }\n    if (typeof path !== 'string') {\n      return Promise.reject('Argument \\'path\\' of baseClient.storeObject must be a string');\n    }\n    if ((typeof object === 'undefined' ? 'undefined' : _typeof(object)) !== 'object') {\n      return Promise.reject('Argument \\'object\\' of baseClient.storeObject must be an object');\n    }\n\n    this._attachType(object, typeAlias);\n\n    try {\n      var validationResult = this.validate(object);\n      if (!validationResult.valid) {\n        return Promise.reject(validationResult);\n      }\n    } catch (exc) {\n      return Promise.reject(exc);\n    }\n\n    return this.storage.put(this.makePath(path), JSON.stringify(object), 'application/json; charset=UTF-8').then(function (r) {\n      if (r.statusCode === 200 || r.statusCode === 201) {\n        return r.revision;\n      } else {\n        return Promise.reject(\"Request (PUT \" + this.makePath(path) + \") failed with status: \" + r.statusCode);\n      }\n    }.bind(this));\n  },\n\n  // generic operations\n\n  /**\n   * Method: remove\n   *\n   * Remove node at given path from storage. Triggers synchronization.\n   *\n   * Parameters:\n   *   path     - Path relative to the module root.\n   */\n  remove: function remove(path) {\n    if (typeof path !== 'string') {\n      return Promise.reject('Argument \\'path\\' of baseClient.remove must be a string');\n    }\n    if (!this.storage.access.checkPathPermission(this.makePath(path), 'rw')) {\n      console.warn('WARNING: Removing a document to which only read access (\\'r\\') was claimed');\n    }\n\n    return this.storage.delete(this.makePath(path));\n  },\n\n  cache: function cache(path, strategy) {\n    if (typeof path !== 'string') {\n      throw 'Argument \\'path\\' of baseClient.cache must be a string';\n    }\n    if (strategy === false) {\n      deprecate('caching strategy <false>', '<\"FLUSH\">');\n      strategy = 'FLUSH';\n    } else if (strategy === undefined) {\n      strategy = 'ALL';\n    } else if (typeof strategy !== 'string') {\n      deprecate('that caching strategy', '<\"ALL\">');\n      strategy = 'ALL';\n    }\n    if (strategy !== 'FLUSH' && strategy !== 'SEEN' && strategy !== 'ALL') {\n      throw 'Argument \\'strategy\\' of baseclient.cache must be one of ' + '[\"FLUSH\", \"SEEN\", \"ALL\"]';\n    }\n    this.storage.caching.set(this.makePath(path), strategy);\n    return this;\n  },\n\n  flush: function flush(path) {\n    return this.storage.local.flush(path);\n  },\n\n  makePath: function makePath(path) {\n    return this.base + (path || '');\n  },\n\n  _fireChange: function _fireChange(event) {\n    if (config.changeEvents[event.origin]) {\n      ['new', 'old', 'lastCommon'].forEach(function (fieldNamePrefix) {\n        if (!event[fieldNamePrefix + 'ContentType'] || /^application\\/(.*)json(.*)/.exec(event[fieldNamePrefix + 'ContentType'])) {\n          if (typeof event[fieldNamePrefix + 'Value'] === 'string') {\n            try {\n              event[fieldNamePrefix + 'Value'] = JSON.parse(event[fieldNamePrefix + 'Value']);\n            } catch (e) {}\n          }\n        }\n      });\n      this._emit('change', event);\n    }\n  },\n\n  _cleanPath: util.cleanPath,\n\n  /**\n   * Method: getItemURL\n   *\n   * Retrieve full URL of item\n   *\n   * Parameters:\n   *   path     - Path relative to the module root.\n   */\n  getItemURL: function getItemURL(path) {\n    if (typeof path !== 'string') {\n      throw 'Argument \\'path\\' of baseClient.getItemURL must be a string';\n    }\n    if (this.storage.connected) {\n      path = this._cleanPath(this.makePath(path));\n      return this.storage.remote.href + path;\n    } else {\n      return undefined;\n    }\n  },\n\n  uuid: function uuid() {\n    return _uuid();\n  }\n\n};\n\n/**\n * Method: RS#scope\n *\n * Returns a new <RS.BaseClient> scoped to the given path.\n *\n * Parameters:\n *   path - Root path of new BaseClient.\n *\n *\n * Example:\n *   (start code)\n *\n *   var foo = remoteStorage.scope('/foo/');\n *\n *   // PUTs data \"baz\" to path /foo/bar\n *   foo.storeFile('text/plain', 'bar', 'baz');\n *\n *   var something = foo.scope('something/');\n *\n *   // GETs listing from path /foo/something/bla/\n *   something.getListing('bla/');\n *\n *   (end code)\n *\n */\nBaseClient._rs_init = function () {};\n\n/* e.g.:\nremoteStorage.defineModule('locations', function (priv, pub) {\n  return {\n    exports: {\n      features: priv.scope('features/').defaultType('feature'),\n      collections: priv.scope('collections/').defaultType('feature-collection');\n    }\n  };\n});\n*/\n\n// Defined in baseclient/types.js\n/**\n * Method: declareType\n *\n * Declare a remoteStorage object type using a JSON schema. See\n * <BaseClient.Types>\n **/\n\nmodule.exports = BaseClient;\n\n// needs to be after the export to change prototype\n// this should be different (we need to import `types` functionality, not modifing BaseClient.prototype from there)\n__webpack_require__(23);\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvYmFzZWNsaWVudC5qcz9jMDk1Il0sIm5hbWVzIjpbImRlcHJlY2F0ZSIsInRoaW5nIiwicmVwbGFjZW1lbnQiLCJjb25zb2xlIiwibG9nIiwiZXZlbnRIYW5kbGluZyIsInJlcXVpcmUiLCJ1dGlsIiwiY29uZmlnIiwidXVpZCIsIkJhc2VDbGllbnQiLCJzdG9yYWdlIiwiYmFzZSIsImxlbmd0aCIsIm1ha2VQYXRoIiwicGF0aCIsInBhcnRzIiwic3BsaXQiLCJtb2R1bGVOYW1lIiwib24iLCJiaW5kIiwib25DaGFuZ2UiLCJfZmlyZUNoYW5nZSIsInByb3RvdHlwZSIsImV4dGVuZCIsIm9iamVjdCIsImtleSIsInNjb3BlIiwiZ2V0TGlzdGluZyIsIm1heEFnZSIsIlByb21pc2UiLCJyZWplY3QiLCJnZXQiLCJ0aGVuIiwiciIsInN0YXR1c0NvZGUiLCJib2R5IiwiZ2V0QWxsIiwia2V5cyIsIk9iamVjdCIsImNhbGxzIiwibWFwIiwibyIsIkpTT04iLCJwYXJzZSIsImUiLCJhbGwiLCJnZXRGaWxlIiwiZGF0YSIsImNvbnRlbnRUeXBlIiwicmV2aXNpb24iLCJzdG9yZUZpbGUiLCJtaW1lVHlwZSIsImFjY2VzcyIsImNoZWNrUGF0aFBlcm1pc3Npb24iLCJ3YXJuIiwicHV0IiwiZ2V0T2JqZWN0Iiwic3RvcmVPYmplY3QiLCJ0eXBlQWxpYXMiLCJfYXR0YWNoVHlwZSIsInZhbGlkYXRpb25SZXN1bHQiLCJ2YWxpZGF0ZSIsInZhbGlkIiwiZXhjIiwic3RyaW5naWZ5IiwicmVtb3ZlIiwiZGVsZXRlIiwiY2FjaGUiLCJzdHJhdGVneSIsInVuZGVmaW5lZCIsImNhY2hpbmciLCJzZXQiLCJmbHVzaCIsImxvY2FsIiwiZXZlbnQiLCJjaGFuZ2VFdmVudHMiLCJvcmlnaW4iLCJmb3JFYWNoIiwiZmllbGROYW1lUHJlZml4IiwiZXhlYyIsIl9lbWl0IiwiX2NsZWFuUGF0aCIsImNsZWFuUGF0aCIsImdldEl0ZW1VUkwiLCJjb25u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UyxDQUNWO0FBQ0Y7QUFDRjtBQUNGLE9BVkQ7QUFXQSxXQUFLb0MsS0FBTCxDQUFXLFFBQVgsRUFBcUJOLEtBQXJCO0FBQ0Q7QUFDRixHQWxib0I7O0FBb2JyQk8sY0FBWTNFLEtBQUs0RSxTQXBiSTs7QUFzYnJCOzs7Ozs7OztBQVFBQyxjQUFZLG9CQUFVckUsSUFBVixFQUFnQjtBQUMxQixRQUFJLE9BQU9BLElBQVAsS0FBaUIsUUFBckIsRUFBK0I7QUFDN0IsWUFBTSw2REFBTjtBQUNEO0FBQ0QsUUFBSSxLQUFLSixPQUFMLENBQWEwRSxTQUFqQixFQUE0QjtBQUMxQnRFLGFBQU8sS0FBS21FLFVBQUwsQ0FBaUIsS0FBS3BFLFFBQUwsQ0FBY0MsSUFBZCxDQUFqQixDQUFQO0FBQ0EsYUFBTyxLQUFLSixPQUFMLENBQWEyRSxNQUFiLENBQW9CQyxJQUFwQixHQUEyQnhFLElBQWxDO0FBQ0QsS0FIRCxNQUdPO0FBQ0wsYUFBT3VELFNBQVA7QUFDRDtBQUNGLEdBeGNvQjs7QUEwY3JCN0QsUUFBTSxnQkFBWTtBQUNoQixXQUFPQSxPQUFQO0FBQ0Q7O0FBNWNvQixDQUF2Qjs7QUFnZEE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUF5QkFDLFdBQVc4RSxRQUFYLEdBQXNCLFlBQVksQ0FFakMsQ0FGRDs7QUFJQTs7Ozs7Ozs7Ozs7QUFXQTtBQUNBOzs7Ozs7O0FBT0ZDLE9BQU9DLE9BQVAsR0FBaUJoRixVQUFqQjs7QUFFQTtBQUNBO0FBQ0EsbUJBQUFKLENBQVEsRUFBUiIsImZpbGUiOiI2LmpzIiwic291cmNlc0NvbnRlbnQiOlsiXG4gIGZ1bmN0aW9uIGRlcHJlY2F0ZSh0aGluZywgcmVwbGFjZW1lbnQpIHtcbiAgICBjb25zb2xlLmxvZygnV0FSTklORzogJyArIHRoaW5nICsgJyBpcyBkZXByZWNhdGVkLiBVc2UgJyArXG4gICAgICAgICAgICAgICAgcmVwbGFjZW1lbnQgKyAnIGluc3RlYWQuJyk7XG4gIH1cblxuICB2YXIgZXZlbnRIYW5kbGluZyA9IHJlcXVpcmUoJy4vZXZlbnRoYW5kbGluZycpO1xuICB2YXIgdXRpbCA9IHJlcXVpcmUoJy4vdXRpbCcpO1xuICB2YXIgY29uZmlnID0gcmVxdWlyZSgnLi9jb25maWcnKTtcbiAgdmFyIHV1aWQgPSByZXF1aXJlKCd1dWlkL3Y0Jyk7XG5cblxuICAvKipcbiAgICogQ2xhc3M6IEJhc2VDbGllbnRcbiAgICpcbiAgICogUHJvdmlkZXMgYSBoaWdoLWxldmVsIGludGVyZmFjZSB0byBhY2Nlc3MgZGF0YSBiZWxvdyBhIGdpdmVuIHJvb3QgcGF0aC5cbiAgICpcbiAgICogQSBCYXNlQ2xpZW50IGRlYWxzIHdpdGggdGhyZWUgdHlwZXMgb2YgZGF0YTogZm9sZGVycywgb2JqZWN0cyBhbmQgZmlsZXMuXG4gICAqXG4gICAqIDxnZXRMaXN0aW5nPiByZXR1cm5zIGEgbWFwcGluZyBvZiBhbGwgaXRlbXMgd2l0aGluIGEgZm9sZGVyLiBJdGVtcyB0aGF0XG4gICAqIGVuZCB3aXRoIGEgZm9yd2FyZCBzbGFzaCAoXCIvXCIpIGFyZSBjaGlsZCBmb2xkZXJzLiBGb3IgaW5zdGFuY2U6XG4gICAqIHtcbiAgICogICAnZm9sZGVyLyc6IHRydWUsXG4gICAqICAgJ2RvY3VtZW50LnR4dCc6IHRydWVcbiAgICogfVxuICAgKlxuICAgKiA8Z2V0T2JqZWN0PiAvIDxzdG9yZU9iamVjdD4gb3BlcmF0ZSBvbiBKU09OIG9iamVjdHMuIEVhY2ggb2JqZWN0IGhhcyBhIHR5cGUuXG4gICAqXG4gICAqIDxnZXRGaWxlPiAvIDxzdG9yZUZpbGU+IG9wZXJhdGVzIG9uIGZpbGVzLiBFYWNoIGZpbGUgaGFzIGEgTUlNRSB0eXBlLlxuICAgKlxuICAgKiA8cmVtb3ZlPiBvcGVyYXRlcyBvbiBlaXRoZXIgb2JqZWN0cyBvciBmaWxlcyAoYnV0IG5vdCBmb2xkZXJzLCBmb2xkZXJzIGFyZVxuICAgKiBjcmVhdGVkIGFuZCByZW1vdmVkIGltcGxpY3RseSkuXG4gICAqL1xuICB2YXIgQmFzZUNsaWVudCA9IGZ1bmN0aW9uIChzdG9yYWdlLCBiYXNlKSB7XG4gICAgaWYgKGJhc2VbYmFzZS5sZW5ndGggLSAxXSAhPT0gJy8nKSB7XG4gICAgICB0aHJvdyBcIk5vdCBhIGZvbGRlcjogXCIgKyBiYXNlO1xuICAgIH1cblxuICAgIGlmIChiYXNlID09PSAnLycpIHtcbiAgICAgIC8vIGFsbG93IGFic29sdXRlIGFuZCByZWxhdGl2ZSBwYXRocyBmb3IgdGhlIHJvb3Qgc2NvcGUuXG4gICAgICB0aGlzLm1ha2VQYXRoID0gZnVuY3Rpb24gKHBhdGgpIHtcbiAgICAgICAgcmV0dXJuIChwYXRoWzBdID09PSAnLycgPyAnJyA6ICcvJykgKyBwYXRoO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQcm9wZXJ0eTogc3RvcmFnZVxuICAgICAqXG4gICAgICogVGhlIDxSZW1vdGVTdG9yYWdlPiBpbnN0YW5jZSB0aGlzIDxCYXNlQ2xpZW50PiBvcGVyYXRlcyBvbi5cbiAgICAgKi9cbiAgICB0aGlzLnN0b3JhZ2UgPSBzdG9yYWdlO1xuXG4gICAgLyoqXG4gICAgICogUHJvcGVydHk6IGJhc2VcbiAgICAgKlxuICAgICAqIEJhc2UgcGF0aCB0aGlzIDxCYXNlQ2xpZW50PiBvcGVyYXRlcyBvbi5cbiAgICAgKlxuICAgICAqIEZvciB0aGUgbW9kdWxlJ3MgcHJpdmF0ZUNsaWVudCB0aGlzIHdvdWxkIGJlIC88bW9kdWxlTmFtZT4vLCBmb3IgdGhlXG4gICAgICogY29ycmVzcG9uZGluZyBwdWJsaWNDbGllbnQgL3B1YmxpYy88bW9kdWxlTmFtZT4vLlxuICAgICAqL1xuICAgIHRoaXMuYmFzZSA9IGJhc2U7XG5cbiAgICB2YXIgcGFydHMgPSB0aGlzLmJhc2Uuc3BsaXQoJy8nKTtcbiAgICBpZiAocGFydHMubGVuZ3RoID4gMikge1xuICAgICAgdGhpcy5tb2R1bGVOYW1lID0gcGFydHNbMV07XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMubW9kdWxlTmFtZSA9ICdyb290JztcbiAgICB9XG5cbiAgICAvLyBEZWZpbmVkIGluIGJhc2VjbGllbnQvdHlwZXMuanNcbiAgICAvKipcbiAgICAgKiBQcm9wZXJ0eTogc2NoZW1hc1xuICAgICAqXG4gICAgICogQ29udGFpbnMgc2NoZW1hIG9iamVjdHMgb2YgYWxsIHR5cGVzIGtub3duIHRvIHRoZSBCYXNlQ2xpZW50IGluc3RhbmNlXG4gICAgICoqL1xuXG4gICAgLyoqXG4gICAgICogRXZlbnQ6IGNoYW5nZVxuICAgICAqXG4gICAgICogRW1pdHRlZCB3aGVuIGEgbm9kZSBjaGFuZ2VzXG4gICAgICpcbiAgICAgKiBBcmd1bWVudHM6XG4gICAgICogICBldmVudCAtIEV2ZW50IG9iamVjdCBjb250YWluaW5nIGluZm9ybWF0aW9uIGFib3V0IHRoZSBjaGFuZ2VkIG5vZGVcbiAgICAgKlxuICAgICAqIChzdGFydCBjb2RlKVxuICAgICAqIHtcbiAgICAgKiAgICBwYXRoOiBwYXRoLCAvLyBBYnNvbHV0ZSBwYXRoIG9mIHRoZSBjaGFuZ2VkIG5vZGUsIGZyb20gdGhlIHN0b3JhZ2Ugcm9vdFxuICAgICAqICAgIHJlbGF0aXZlUGF0aDogcmVsYXRpdmVQYXRoLCAvLyBQYXRoIG9mIHRoZSBjaGFuZ2VkIG5vZGUsIHJlbGF0aXZlIHRvIHRoaXMgYmFzZWNsaWVudCdzIHNjb3BlIHJvb3RcbiAgICAgKiAgICBvcmlnaW46ICd3aW5kb3cnLCAnbG9jYWwnLCAncmVtb3RlJywgb3IgJ2NvbmZsaWN0JyAvLyBlbWl0dGVkIGJ5IHVzZXIgYWN0aW9uIHdpdGhpbiB0aGUgYXBwLCBsb2NhbCBkYXRhIHN0b3JlLCByZW1vdGUgc3luYywgb3IgdmVyc2lvbmluZyBjb25mbGljdHNcbiAgICAgKiAgICBvbGRWYWx1ZTogb2xkQm9keSwgLy8gT2xkIGJvZHkgb2YgdGhlIGNoYW5nZWQgbm9kZSAobG9jYWwgdmVyc2lvbiBpbiBjb25mbGljdHM7IHVuZGVmaW5lZCBpZiBjcmVhdGlvbilcbiAgICAgKiAgICBuZXdWYWx1ZTogbmV3Qm9keSwgLy8gTmV3IGJvZHkgb2YgdGhlIGNoYW5nZWQgbm9kZSAocmVtb3RlIHZlcnNpb24gaW4gY29uZmxpY3RzOyB1bmRlZmluZWQgaWYgZGVsZXRpb24pXG4gICAgICogICAgbGFzdENvbW1vblZhbHVlOiBsYXN0Q29tbW9uVmFsdWUsIC8vbW9zdCByZWNlbnQga25vd24gY29tbW9uIGFuY2VzdG9yIGJvZHkgb2YgJ3lvdXJzJyBhbmQgJ3RoZWlycycgaW4gY2FzZSBvZiBjb25mbGljdFxuICAgICAqICAgIG9sZENvbnRlbnRUeXBlOiBvbGRDb250ZW50VHlwZSwgLy8gT2xkIGNvbnRlbnRUeXBlIG9mIHRoZSBjaGFuZ2VkIG5vZGUgKCd5b3VycycgZm9yIGNvbmZsaWN0czsgdW5kZWZpbmVkIGlmIGNyZWF0aW9uKVxuICAgICAqICAgIG5ld0NvbnRlbnRUeXBlOiBuZXdDb250ZW50VHlwZSwgLy8gTmV3IGNvbnRlbnRUeXBlIG9mIHRoZSBjaGFuZ2VkIG5vZGUgKCd0aGVpcnMnIGZvciBjb25mbGljdHM7IHVuZGVmaW5lZCBpZiBkZWxldGlvbilcbiAgICAgKiAgICBsYXN0Q29tbW9uQ29udGVudFR5cGU6IGxhc3RDb21tb25Db250ZW50VHlwZSAvLyBNb3N0IHJlY2VudCBrbm93biBjb21tb24gYW5jZXN0b3IgY29udGVudFR5cGUgb2YgJ3lvdXJzJyBhbmQgJ3RoZWlycycgaW4gY2FzZSBvZiBjb25mbGljdFxuICAgICAqICB9XG4gICAgICogKGVuZCBjb2RlKVxuICAgICAqXG4gICAgICogRXhhbXBsZSBvZiBhbiBldmVudCB3aXRoIG9yaWdpbiAnbG9jYWwnIChmaXJlZCBvbiBwYWdlIGxvYWQpOlxuICAgICAqXG4gICAgICogKHN0YXJ0IGNvZGUpXG4gICAgICoge1xuICAgICAqICAgIHBhdGg6ICcvcHVibGljL2Rlc2lnbi9jb2xvci50eHQnLFxuICAgICAqICAgIHJlbGF0aXZlUGF0aDogJ2NvbG9yLnR4dCcsXG4gICAgICogICAgb3JpZ2luOiAnbG9jYWwnLFxuICAgICAqICAgIG9sZFZhbHVlOiB1bmRlZmluZWQsXG4gICAgICogICAgbmV3VmFsdWU6ICd3aGl0ZScsXG4gICAgICogICAgb2xkQ29udGVudFR5cGU6IHVuZGVmaW5lZCxcbiAgICAgKiAgICBuZXdDb250ZW50VHlwZTogJ3RleHQvcGxhaW4nXG4gICAgICogIH1cbiAgICAgKiAoZW5kIGNvZGUpXG4gICAgICpcbiAgICAgKiBFeGFtcGxlIG9mIGEgY29uZmxpY3Q6XG4gICAgICogU2F5IHlvdSBjaGFuZ2VkICdjb2xvci50eHQnIGZyb20gJ3doaXRlJyB0byAnYmx1ZSc7IGlmIHlvdSBoYXZlIHNldCBgY29uZmlnLmNoYW5nZUV2ZW50cy53aW5kb3dgIHRvIGB0cnVlYCxcbiAgICAgKiB0aGVuIHlvdSB3aWxsIHJlY2VpdmU6XG4gICAgICpcbiAgICAgKiAoc3RhcnQgY29kZSlcbiAgICAgKiB7XG4gICAgICogICAgcGF0aDogJy9wdWJsaWMvZGVzaWduL2NvbG9yLnR4dCcsXG4gICAgICogICAgcmVsYXRpdmVQYXRoOiAnY29sb3IudHh0JyxcbiAgICAgKiAgICBvcmlnaW46ICd3aW5kb3cnLFxuICAgICAqICAgIG9sZFZhbHVlOiAnd2hpdGUnLFxuICAgICAqICAgIG5ld1ZhbHVlOiAnYmx1ZScsXG4gICAgICogICAgb2xkQ29udGVudFR5cGU6ICd0ZXh0L3BsYWluJyxcbiAgICAgKiAgICBuZXdDb250ZW50VHlwZTogJ3RleHQvcGxhaW4nXG4gICAgICogIH1cbiAgICAgKiAoZW5kIGNvZGUpXG4gICAgICpcbiAgICAgKiBCdXQgd2hlbiB0aGlzIGNoYW5nZSBpcyBwdXNoZWQgb3V0IGJ5IGFzeW5jaHJvbm91cyBzeW5jaHJvbml6YXRpb24sIHRoaXMgY2hhbmdlIG1heSByZWplY3RlZCBieSB0aGVcbiAgICAgKiBzZXJ2ZXIsIGlmIHRoZSByZW1vdGUgdmVyc2lvbiBoYXMgaW4gdGhlIG1lYW50aW1lIGNoYW5nZWQgZnJvbSAnd2hpdGUnIHRvICBmb3IgaW5zdGFuY2UgJ3JlZCc7IHRoaXMgd2lsbCB0aGVuIGxlYWQgdG8gYSBjaGFuZ2VcbiAgICAgKiBldmVudCB3aXRoIG9yaWdpbiAnY29uZmxpY3QnICh1c3VhbGx5IGEgZmV3IHNlY29uZHMgYWZ0ZXIgdGhlIGV2ZW50IHdpdGggb3JpZ2luICd3aW5kb3cnLCBpZiB5b3UgaGFkIHRoYXQgYWN0aXZhdGVkKS4gTm90ZVxuICAgICAqIHRoYXQgc2luY2UgeW91IGFscmVhZHkgY2hhbmdlZCBpdCBmcm9tICd3aGl0ZScgdG8gJ2JsdWUnIGluIHRoZSBsb2NhbCB2ZXJzaW9uIGEgZmV3IHNlY29uZHMgYWdvLCBgb2xkVmFsdWVgIGlzIG5vdyB5b3VyIGxvY2FsXG4gICAgICogdmFsdWUgb2YgJ2JsdWUnOlxuICAgICAqXG4gICAgICogKHN0YXJ0IGNvZGUpXG4gICAgICoge1xuICAgICAqICAgIHBhdGg6ICcvcHVibGljL2Rlc2lnbi9jb2xvci50eHQnLFxuICAgICAqICAgIHJlbGF0aXZlUGF0aDogJ2NvbG9yLnR4dCcsXG4gICAgICogICAgb3JpZ2luOiAnY29uZmxpY3QnLFxuICAgICAqICAgIG9sZFZhbHVlOiAnYmx1ZScsXG4gICAgICogICAgbmV3VmFsdWU6ICdyZWQnLFxuICAgICAqICAgIGxhc3RDb21tb25WYWx1ZTogJ3doaXRlJyxcbiAgICAgKiAgICBvbGRDb250ZW50VHlwZTogJ3RleHQvcGxhaW4sXG4gICAgICogICAgbmV3Q29udGVudFR5cGU6ICd0ZXh0L3BsYWluJ1xuICAgICAqICAgIGxhc3RDb21tb25Db250ZW50VHlwZTogJ3RleHQvcGxhaW4nXG4gICAgICogIH1cbiAgICAgKiAoZW5kIGNvZGUpXG4gICAgICpcbiAgICAgKiBJbiBwcmFjdGljZSwgeW91IHNob3VsZCBhbHdheXMgcmVkcmF3IHlvdXIgdmlld3MgdG8gZGlzcGxheSB0aGUgY29udGVudCBvZiB0aGUgYG5ld1ZhbHVlYCBmaWVsZCB3aGVuIGEgY2hhbmdlIGV2ZW50IGlzIHJlY2VpdmVkLFxuICAgICAqIHJlZ2FyZGxlc3Mgb2YgaXRzIG9yaWdpbi4gRXZlbnRzIHdpdGggb3JpZ2luICdsb2NhbCcgYXJlIGZpcmVkIGNvbnZlbmllbnRseSBkdXJpbmcgdGhlIHBhZ2UgbG9hZCwgc28gdGhhdCB5b3UgY2FuIGZpbGwgeW91ciB2aWV3c1xuICAgICAqIHdoZW4gdGhlIHBhZ2UgbG9hZHMuIEV2ZW50cyB3aXRoIG9yaWdpbiAnd2luZG93JyBhcmUgZmlyZWQgd2hlbmV2ZXIgeW91IGNoYW5nZSBhIHZhbHVlIGJ5IGNhbGxpbmcgYSBtZXRob2Qgb24gdGhlIGJhc2VDbGllbnQ7XG4gICAgICogdGhlc2UgYXJlIGRpc2FibGVkIGJ5IGRlZmF1bHQuIEV2ZW50cyB3aXRoIG9yaWdpbiAncmVtb3RlJyBhcmUgZmlyZWQgd2hlbiByZW1vdGUgY2hhbmdlcyBhcmUgZGlzY292ZXJlZCBkdXJpbmcgc3luYyAob25seSBmb3IgY2FjaGluZ1xuICAgICAqIHN0YXJ0ZWdpZXMgJ1NFRU4nIGFuZCAnQUxMJykuIEV2ZW50cyB3aXRoIG9yaWdpbiAnY29uZmxpY3QnIGFyZSBmaXJlZCB3aGVuIGEgY29uZmxpY3Qgb2NjdXJzIHdoaWxlIHB1c2hpbmcgb3V0IHlvdXIgbG9jYWwgY2hhbmdlcyB0b1xuICAgICAqIHRoZSByZW1vdGUgc3RvcmUgaW4gYXN5bmNocm9ub3VzIHN5bmNocm9uaXphdGlvbiAoc2VlIGV4YW1wbGUgYWJvdmUpLlxuICAgICAqKi9cblxuICAgIGV2ZW50SGFuZGxpbmcodGhpcywgJ2NoYW5nZScpO1xuICAgIHRoaXMub24gPSB0aGlzLm9uLmJpbmQodGhpcyk7XG4gICAgc3RvcmFnZS5vbkNoYW5nZSh0aGlzLmJhc2UsIHRoaXMuX2ZpcmVDaGFuZ2UuYmluZCh0aGlzKSk7XG4gIH07XG5cbiAgQmFzZUNsaWVudC5wcm90b3R5cGUgPSB7XG5cbiAgICBleHRlbmQ6IGZ1bmN0aW9uIChvYmplY3QpIHtcbiAgICAgIGZvciAodmFyIGtleSBpbiBvYmplY3QpIHtcbiAgICAgICAgdGhpc1trZXldID0gb2JqZWN0W2tleV07XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTWV0aG9kOiBzY29wZVxuICAgICAqXG4gICAgICogUmV0dXJucyBhIG5ldyA8QmFzZUNsaWVudD4gb3BlcmF0aW5nIG9uIGEgc3VicGF0aCBvZiB0aGUgY3VycmVudCA8YmFzZT4gcGF0aC5cbiAgICAgKi9cbiAgICBzY29wZTogZnVuY3Rpb24gKHBhdGgpIHtcbiAgICAgIHJldHVybiBuZXcgQmFzZUNsaWVudCh0aGlzLnN0b3JhZ2UsIHRoaXMubWFrZVBhdGgocGF0aCkpO1xuICAgIH0sXG5cbiAgICAvLyBmb2xkZXIgb3BlcmF0aW9uc1xuXG4gICAgLyoqXG4gICAgICogTWV0aG9kOiBnZXRMaXN0aW5nXG4gICAgICpcbiAgICAgKiBHZXQgYSBsaXN0IG9mIGNoaWxkIG5vZGVzIGJlbG93IGEgZ2l2ZW4gcGF0aC5cbiAgICAgKlxuICAgICAqIFRoZSBjYWxsYmFjayBzZW1hbnRpY3Mgb2YgZ2V0TGlzdGluZyBhcmUgaWRlbnRpY2FsIHRvIHRob3NlIG9mIGdldE9iamVjdC5cbiAgICAgKlxuICAgICAqIFBhcmFtZXRlcnM6XG4gICAgICogICBwYXRoICAgLSBUaGUgcGF0aCB0byBxdWVyeS4gSXQgTVVTVCBlbmQgd2l0aCBhIGZvcndhcmQgc2xhc2guXG4gICAgICogICBtYXhBZ2UgLSBFaXRoZXIgZmFsc2Ugb3IgdGhlIG1heGltdW0gYWdlIG9mIGNhY2hlZCBsaXN0aW5nIGluXG4gICAgICogICAgICAgICAgICBtaWxsaXNlY29uZHMuIERlZmF1bHRzIHRvIGZhbHNlIGluIGFub255bW91cyBtb2RlIGFuZCB0b1xuICAgICAqICAgICAgICAgICAgMipzeW5jSW50ZXJ2YWwgaW4gY29ubmVjdGVkIG1vZGUuXG4gICAgICpcbiAgICAgKiBSZXR1cm5zOlxuICAgICAqXG4gICAgICogICBBIHByb21pc2UgZm9yIGFuIG9iamVjdCwgcmVwcmVzZW50aW5nIGNoaWxkIG5vZGVzLiBJZiB0aGUgbWF4QWdlXG4gICAgICogICByZXF1aXJlbWVudCBjYW5ub3QgYmUgbWV0IGJlY2F1c2Ugb2YgbmV0d29yayBwcm9ibGVtcywgdGhpcyBwcm9taXNlXG4gICAgICogICB3aWxsIGJlIHJlamVjdGVkLiBJZiB0aGUgbWF4QWdlIHJlcXVpcmVtZW50IGlzIHNldCB0byBmYWxzZSBvciB0aGVcbiAgICAgKiAgIGxpYnJhcnkgaXMgaW4gb2ZmbGluZSBzdGF0ZSwgdGhlIHByb21pc2Ugd2lsbCBhbHdheXMgYmUgZnVsZmlsbGVkIHdpdGhcbiAgICAgKiAgIGRhdGEgZnJvbSB0aGUgbG9jYWwgc3RvcmUuXG4gICAgICpcbiAgICAgKiAgIEtleXMgZW5kaW5nIGluIGEgZm9yd2FyZCBzbGFzaCByZXByZXNlbnQgKmZvbGRlciBub2RlcyosIHdoaWxlIGFsbFxuICAgICAqICAgb3RoZXIga2V5cyByZXByZXNlbnQgKmRhdGEgbm9kZXMqLlxuICAgICAqXG4gICAgICogICBGb3Igc3BlYyB2ZXJzaW9ucyA8PSAwMSwgdGhlIGRhdGEgbm9kZSBpbmZvcm1hdGlvbiB3aWxsIGNvbnRhaW4gb25seVxuICAgICAqICAgdGhlIGl0ZW0ncyBFVGFnLiBGb3IgbGF0ZXIgc3BlYyB2ZXJzaW9ucywgaXQgd2lsbCBhbHNvIGNvbnRhaW4gdGhlXG4gICAgICogICBjb250ZW50IHR5cGUgYW5kIC1sZW5ndGggb2YgdGhlIGl0ZW0uXG4gICAgICpcbiAgICAgKiBFeGFtcGxlOlxuICAgICAqICAgKHN0YXJ0IGNvZGUpXG4gICAgICogICBjbGllbnQuZ2V0TGlzdGluZygnJywgZmFsc2UpLnRoZW4oZnVuY3Rpb24gKGxpc3RpbmcpIHtcbiAgICAgKiAgICAgLy8gbGlzdGluZyBpcyBmb3IgaW5zdGFuY2U6XG4gICAgICogICAgIC8vIHtcbiAgICAgKiAgICAgLy8gICAnZm9sZGVyLyc6IHRydWUsXG4gICAgICogICAgIC8vICAgJ2RvY3VtZW50LnR4dCc6IHRydWVcbiAgICAgKiAgICAgLy8gfVxuICAgICAqICAgfSk7XG4gICAgICogICAoZW5kIGNvZGUpXG4gICAgICovXG4gICAgZ2V0TGlzdGluZzogZnVuY3Rpb24gKHBhdGgsIG1heEFnZSkge1xuICAgICAgaWYgKHR5cGVvZihwYXRoKSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgcGF0aCA9ICcnO1xuICAgICAgfSBlbHNlIGlmIChwYXRoLmxlbmd0aCA+IDAgJiYgcGF0aFtwYXRoLmxlbmd0aCAtIDFdICE9PSAnLycpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KFwiTm90IGEgZm9sZGVyOiBcIiArIHBhdGgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuc3RvcmFnZS5nZXQodGhpcy5tYWtlUGF0aChwYXRoKSwgbWF4QWdlKS50aGVuKFxuICAgICAgICBmdW5jdGlvbiAocikge1xuICAgICAgICAgIHJldHVybiAoci5zdGF0dXNDb2RlID09PSA0MDQpID8ge30gOiByLmJvZHk7XG4gICAgICAgIH1cbiAgICAgICk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1ldGhvZDogZ2V0QWxsXG4gICAgICpcbiAgICAgKiBHZXQgYWxsIG9iamVjdHMgZGlyZWN0bHkgYmVsb3cgYSBnaXZlbiBwYXRoLlxuICAgICAqXG4gICAgICogUGFyYW1ldGVyczpcbiAgICAgKiAgIHBhdGggICAtIFBhdGggdG8gdGhlIGZvbGRlci5cbiAgICAgKiAgIG1heEFnZSAtIEVpdGhlciBmYWxzZSBvciB0aGUgbWF4aW11bSBhZ2Ugb2YgY2FjaGVkIG9iamVjdHMgaW5cbiAgICAgKiAgICAgICAgICAgIG1pbGxpc2Vjb25kcy4gRGVmYXVsdHMgdG8gZmFsc2UgaW4gYW5vbnltb3VzIG1vZGUgYW5kIHRvXG4gICAgICogICAgICAgICAgICAyKnN5bmNJbnRlcnZhbCBpbiBjb25uZWN0ZWQgbW9kZS5cbiAgICAgKlxuICAgICAqIFJldHVybnM6XG4gICAgICogICBBIHByb21pc2UgZm9yIGFuIG9iamVjdCBpbiB0aGUgZm9ybSB7IHBhdGggOiBvYmplY3QsIC4uLiB9LiBJZiB0aGVcbiAgICAgKiAgIG1heEFnZSByZXF1aXJlbWVudCBjYW5ub3QgYmUgbWV0IGJlY2F1c2Ugb2YgbmV0d29yayBwcm9ibGVtcywgdGhpc1xuICAgICAqICAgcHJvbWlzZSB3aWxsIGJlIHJlamVjdGVkLiBJZiB0aGUgbWF4QWdlIHJlcXVpcmVtZW50IGlzIHNldCB0byBmYWxzZSxcbiAgICAgKiAgIHRoZSBwcm9taXNlIHdpbGwgYWx3YXlzIGJlIGZ1bGZpbGxlZCB3aXRoIGRhdGEgZnJvbSB0aGUgbG9jYWwgc3RvcmUuXG4gICAgICpcbiAgICAgKiAgIEZvciBpdGVtcyB0aGF0IGFyZSBub3QgSlNPTi1zdHJpbmdpZmllZCBvYmplY3RzIChlLmcuIHN0b3JlZCB1c2luZ1xuICAgICAqICAgYHN0b3JlRmlsZWAgaW5zdGVhZCBvZiBgc3RvcmVPYmplY3RgKSwgdGhlIG9iamVjdCdzIHZhbHVlIGlzIGZpbGxlZCBpblxuICAgICAqICAgd2l0aCBgdHJ1ZWAuXG4gICAgICpcbiAgICAgKiBFeGFtcGxlOlxuICAgICAqICAgKHN0YXJ0IGNvZGUpXG4gICAgICogICBjbGllbnQuZ2V0QWxsKCcnLCBmYWxzZSkudGhlbihmdW5jdGlvbiAob2JqZWN0cykge1xuICAgICAqICAgICBmb3IgKHZhciBrZXkgaW4gb2JqZWN0cykge1xuICAgICAqICAgICAgIGNvbnNvbGUubG9nKCctICcgKyBrZXkgKyAnOiAnLCBvYmplY3RzW2tleV0pO1xuICAgICAqICAgICB9XG4gICAgICogICB9KTtcbiAgICAgKiAgIChlbmQgY29kZSlcbiAgICAgKi9cbiAgICBnZXRBbGw6IGZ1bmN0aW9uIChwYXRoLCBtYXhBZ2UpIHtcbiAgICAgIGlmICh0eXBlb2YocGF0aCkgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHBhdGggPSAnJztcbiAgICAgIH0gZWxzZSBpZiAocGF0aC5sZW5ndGggPiAwICYmIHBhdGhbcGF0aC5sZW5ndGggLSAxXSAhPT0gJy8nKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChcIk5vdCBhIGZvbGRlcjogXCIgKyBwYXRoKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMuc3RvcmFnZS5nZXQodGhpcy5tYWtlUGF0aChwYXRoKSwgbWF4QWdlKS50aGVuKGZ1bmN0aW9uIChyKSB7XG4gICAgICAgIGlmIChyLnN0YXR1c0NvZGUgPT09IDQwNCkgeyByZXR1cm4ge307IH1cbiAgICAgICAgaWYgKHR5cGVvZihyLmJvZHkpID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMoci5ib2R5KTtcbiAgICAgICAgICBpZiAoa2V5cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIC8vIHRyZWF0IHRoaXMgbGlrZSA0MDQuIGl0IHByb2JhYmx5IG1lYW5zIGEgZm9sZGVyIGxpc3RpbmcgdGhhdFxuICAgICAgICAgICAgLy8gaGFzIGNoYW5nZXMgdGhhdCBoYXZlbid0IGJlZW4gcHVzaGVkIG91dCB5ZXQuXG4gICAgICAgICAgICByZXR1cm4ge307XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIGNhbGxzID0ga2V5cy5tYXAoZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3RvcmFnZS5nZXQodGhpcy5tYWtlUGF0aChwYXRoICsga2V5KSwgbWF4QWdlKVxuICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbiAobykge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2Yoby5ib2R5KSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIG8uYm9keSA9IEpTT04ucGFyc2Uoby5ib2R5KTtcbiAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZihvLmJvZHkpID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgICAgci5ib2R5W2tleV0gPSBvLmJvZHk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICB9LmJpbmQodGhpcykpO1xuICAgICAgICAgIHJldHVybiBQcm9taXNlLmFsbChjYWxscykudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gci5ib2R5O1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9LmJpbmQodGhpcykpO1xuICAgIH0sXG5cbiAgICAvLyBmaWxlIG9wZXJhdGlvbnNcblxuICAgIC8qKlxuICAgICAqIE1ldGhvZDogZ2V0RmlsZVxuICAgICAqXG4gICAgICogR2V0IHRoZSBmaWxlIGF0IHRoZSBnaXZlbiBwYXRoLiBBIGZpbGUgaXMgcmF3IGRhdGEsIGFzIG9wcG9zZWQgdG9cbiAgICAgKiBhIEpTT04gb2JqZWN0ICh1c2UgPGdldE9iamVjdD4gZm9yIHRoYXQpLlxuICAgICAqXG4gICAgICogRXhjZXB0IGZvciB0aGUgcmV0dXJuIHZhbHVlIHN0cnVjdHVyZSwgZ2V0RmlsZSB3b3JrcyBleGFjdGx5IGxpa2VcbiAgICAgKiBnZXRPYmplY3QuXG4gICAgICpcbiAgICAgKiBQYXJhbWV0ZXJzOlxuICAgICAqICAgcGF0aCAgIC0gU2VlIGdldE9iamVjdC5cbiAgICAgKiAgIG1heEFnZSAtIEVpdGhlciBmYWxzZSBvciB0aGUgbWF4aW11bSBhZ2Ugb2YgY2FjaGVkIGZpbGUgaW5cbiAgICAgKiAgICAgICAgICAgIG1pbGxpc2Vjb25kcy4gRGVmYXVsdHMgdG8gZmFsc2UgaW4gYW5vbnltb3VzIG1vZGUgYW5kIHRvXG4gICAgICogICAgICAgICAgICAyKnN5bmNJbnRlcnZhbCBpbiBjb25uZWN0ZWQgbW9kZS5cbiAgICAgKlxuICAgICAqIFJldHVybnM6XG4gICAgICogICBBIHByb21pc2UgZm9yIGFuIG9iamVjdDpcbiAgICAgKlxuICAgICAqICAgbWltZVR5cGUgLSBTdHJpbmcgcmVwcmVzZW50aW5nIHRoZSBNSU1FIFR5cGUgb2YgdGhlIGRvY3VtZW50LlxuICAgICAqICAgZGF0YSAgICAgLSBSYXcgZGF0YSBvZiB0aGUgZG9jdW1lbnQgKGVpdGhlciBhIHN0cmluZyBvciBhbiBBcnJheUJ1ZmZlcilcbiAgICAgKlxuICAgICAqICAgSWYgdGhlIG1heEFnZSByZXF1aXJlbWVudCBjYW5ub3QgYmUgbWV0IGJlY2F1c2Ugb2YgbmV0d29yayBwcm9ibGVtcywgdGhpc1xuICAgICAqICAgcHJvbWlzZSB3aWxsIGJlIHJlamVjdGVkLiBJZiB0aGUgbWF4QWdlIHJlcXVpcmVtZW50IGlzIHNldCB0byBmYWxzZSwgdGhlXG4gICAgICogICBwcm9taXNlIHdpbGwgYWx3YXlzIGJlIGZ1bGZpbGxlZCB3aXRoIGRhdGEgZnJvbSB0aGUgbG9jYWwgc3RvcmUuXG4gICAgICpcbiAgICAgKiBFeGFtcGxlOlxuICAgICAqICAgKHN0YXJ0IGNvZGUpXG4gICAgICogICAvLyBEaXNwbGF5IGFuIGltYWdlOlxuICAgICAqICAgY2xpZW50LmdldEZpbGUoJ3BhdGgvdG8vc29tZS9pbWFnZScsIGZhbHNlKS50aGVuKGZ1bmN0aW9uIChmaWxlKSB7XG4gICAgICogICAgIHZhciBibG9iID0gbmV3IEJsb2IoW2ZpbGUuZGF0YV0sIHsgdHlwZTogZmlsZS5taW1lVHlwZSB9KTtcbiAgICAgKiAgICAgdmFyIHRhcmdldEVsZW1lbnQgPSBkb2N1bWVudC5maW5kRWxlbWVudEJ5SWQoJ215LWltYWdlLWVsZW1lbnQnKTtcbiAgICAgKiAgICAgdGFyZ2V0RWxlbWVudC5zcmMgPSB3aW5kb3cuVVJMLmNyZWF0ZU9iamVjdFVSTChibG9iKTtcbiAgICAgKiAgIH0pO1xuICAgICAqICAgKGVuZCBjb2RlKVxuICAgICAqL1xuICAgIGdldEZpbGU6IGZ1bmN0aW9uIChwYXRoLCBtYXhBZ2UpIHtcbiAgICAgIGlmICh0eXBlb2YocGF0aCkgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdCgnQXJndW1lbnQgXFwncGF0aFxcJyBvZiBiYXNlQ2xpZW50LmdldEZpbGUgbXVzdCBiZSBhIHN0cmluZycpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuc3RvcmFnZS5nZXQodGhpcy5tYWtlUGF0aChwYXRoKSwgbWF4QWdlKS50aGVuKGZ1bmN0aW9uIChyKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgZGF0YTogci5ib2R5LFxuICAgICAgICAgIGNvbnRlbnRUeXBlOiByLmNvbnRlbnRUeXBlLFxuICAgICAgICAgIHJldmlzaW9uOiByLnJldmlzaW9uIC8vICh0aGlzIGlzIG5ldylcbiAgICAgICAgfTtcbiAgICAgIH0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNZXRob2Q6IHN0b3JlRmlsZVxuICAgICAqXG4gICAgICogU3RvcmUgcmF3IGRhdGEgYXQgYSBnaXZlbiBwYXRoLlxuICAgICAqXG4gICAgICogUGFyYW1ldGVyczpcbiAgICAgKiAgIG1pbWVUeXBlIC0gTUlNRSBtZWRpYSB0eXBlIG9mIHRoZSBkYXRhIGJlaW5nIHN0b3JlZFxuICAgICAqICAgcGF0aCAgICAgLSBwYXRoIHJlbGF0aXZlIHRvIHRoZSBtb2R1bGUgcm9vdC4gTUFZIE5PVCBlbmQgaW4gYSBmb3J3YXJkIHNsYXNoLlxuICAgICAqICAgZGF0YSAgICAgLSBzdHJpbmcsIEFycmF5QnVmZmVyIG9yIEFycmF5QnVmZmVyVmlldyBvZiByYXcgZGF0YSB0byBzdG9yZVxuICAgICAqXG4gICAgICogVGhlIGdpdmVuIG1pbWVUeXBlIHdpbGwgbGF0ZXIgYmUgcmV0dXJuZWQsIHdoZW4gcmV0cmlldmluZyB0aGUgZGF0YVxuICAgICAqIHVzaW5nIDxnZXRGaWxlPi5cbiAgICAgKlxuICAgICAqIEV4YW1wbGUgKFVURi04IGRhdGEpOlxuICAgICAqICAgKHN0YXJ0IGNvZGUpXG4gICAgICogICBjbGllbnQuc3RvcmVGaWxlKCd0ZXh0L2h0bWwnLCAnaW5kZXguaHRtbCcsICc8aDE+SGVsbG8gV29ybGQhPC9oMT4nKTtcbiAgICAgKiAgIChlbmQgY29kZSlcbiAgICAgKlxuICAgICAqIEV4YW1wbGUgKEJpbmFyeSBkYXRhKTpcbiAgICAgKiAgIChzdGFydCBjb2RlKVxuICAgICAqICAgLy8gTUFSS1VQOlxuICAgICAqICAgPGlucHV0IHR5cGU9XCJmaWxlXCIgaWQ9XCJmaWxlLWlucHV0XCI+XG4gICAgICogICAvLyBDT0RFOlxuICAgICAqICAgdmFyIGlucHV0ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2ZpbGUtaW5wdXQnKTtcbiAgICAgKiAgIHZhciBmaWxlID0gaW5wdXQuZmlsZXNbMF07XG4gICAgICogICB2YXIgZmlsZVJlYWRlciA9IG5ldyBGaWxlUmVhZGVyKCk7XG4gICAgICpcbiAgICAgKiAgIGZpbGVSZWFkZXIub25sb2FkID0gZnVuY3Rpb24gKCkge1xuICAgICAqICAgICBjbGllbnQuc3RvcmVGaWxlKGZpbGUudHlwZSwgZmlsZS5uYW1lLCBmaWxlUmVhZGVyLnJlc3VsdCk7XG4gICAgICogICB9O1xuICAgICAqXG4gICAgICogICBmaWxlUmVhZGVyLnJlYWRBc0FycmF5QnVmZmVyKGZpbGUpO1xuICAgICAqICAgKGVuZCBjb2RlKVxuICAgICAqXG4gICAgICovXG4gICAgc3RvcmVGaWxlOiBmdW5jdGlvbiAobWltZVR5cGUsIHBhdGgsIGJvZHkpIHtcbiAgICAgIGlmICh0eXBlb2YobWltZVR5cGUpICE9PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoJ0FyZ3VtZW50IFxcJ21pbWVUeXBlXFwnIG9mIGJhc2VDbGllbnQuc3RvcmVGaWxlIG11c3QgYmUgYSBzdHJpbmcnKTtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YocGF0aCkgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdCgnQXJndW1lbnQgXFwncGF0aFxcJyBvZiBiYXNlQ2xpZW50LnN0b3JlRmlsZSBtdXN0IGJlIGEgc3RyaW5nJyk7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mKGJvZHkpICE9PSAnc3RyaW5nJyAmJiB0eXBlb2YoYm9keSkgIT09ICdvYmplY3QnKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdCgnQXJndW1lbnQgXFwnYm9keVxcJyBvZiBiYXNlQ2xpZW50LnN0b3JlRmlsZSBtdXN0IGJlIGEgc3RyaW5nLCBBcnJheUJ1ZmZlciwgb3IgQXJyYXlCdWZmZXJWaWV3Jyk7XG4gICAgICB9XG4gICAgICBpZiAoIXRoaXMuc3RvcmFnZS5hY2Nlc3MuY2hlY2tQYXRoUGVybWlzc2lvbih0aGlzLm1ha2VQYXRoKHBhdGgpLCAncncnKSkge1xuICAgICAgICBjb25zb2xlLndhcm4oJ1dBUk5JTkc6IEVkaXRpbmcgYSBkb2N1bWVudCB0byB3aGljaCBvbmx5IHJlYWQgYWNjZXNzIChcXCdyXFwnKSB3YXMgY2xhaW1lZCcpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5zdG9yYWdlLnB1dCh0aGlzLm1ha2VQYXRoKHBhdGgpLCBib2R5LCBtaW1lVHlwZSkudGhlbihmdW5jdGlvbiAocikge1xuICAgICAgICBpZiAoci5zdGF0dXNDb2RlID09PSAyMDAgfHwgci5zdGF0dXNDb2RlID09PSAyMDEpIHtcbiAgICAgICAgICByZXR1cm4gci5yZXZpc2lvbjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoXCJSZXF1ZXN0IChQVVQgXCIgKyB0aGlzLm1ha2VQYXRoKHBhdGgpICsgXCIpIGZhaWxlZCB3aXRoIHN0YXR1czogXCIgKyByLnN0YXR1c0NvZGUpO1xuICAgICAgICB9XG4gICAgICB9LmJpbmQodGhpcykpO1xuICAgIH0sXG5cbiAgICAvLyBvYmplY3Qgb3BlcmF0aW9uc1xuXG4gICAgLyoqXG4gICAgICogTWV0aG9kOiBnZXRPYmplY3RcbiAgICAgKlxuICAgICAqIEdldCBhIEpTT04gb2JqZWN0IGZyb20gZ2l2ZW4gcGF0aC5cbiAgICAgKlxuICAgICAqIFBhcmFtZXRlcnM6XG4gICAgICogICBwYXRoICAgLSBSZWxhdGl2ZSBwYXRoIGZyb20gdGhlIG1vZHVsZSByb290ICh3aXRob3V0IGxlYWRpbmcgc2xhc2gpLlxuICAgICAqICAgbWF4QWdlIC0gRWl0aGVyIGZhbHNlIG9yIHRoZSBtYXhpbXVtIGFnZSBvZiBjYWNoZWQgb2JqZWN0IGluXG4gICAgICogICAgICAgICAgICBtaWxsaXNlY29uZHMuIERlZmF1bHRzIHRvIGZhbHNlIGluIGFub255bW91cyBtb2RlIGFuZCB0b1xuICAgICAqICAgICAgICAgICAgMipzeW5jSW50ZXJ2YWwgaW4gY29ubmVjdGVkIG1vZGUuXG4gICAgICpcbiAgICAgKiBSZXR1cm5zOlxuICAgICAqICAgQSBwcm9taXNlIGZvciB0aGUgb2JqZWN0LiBJZiB0aGUgbWF4QWdlIHJlcXVpcmVtZW50IGNhbm5vdCBiZSBtZXRcbiAgICAgKiAgIGJlY2F1c2Ugb2YgbmV0d29yayBwcm9ibGVtcywgdGhpcyBwcm9taXNlIHdpbGwgYmUgcmVqZWN0ZWQuIElmIHRoZVxuICAgICAqICAgbWF4QWdlIHJlcXVpcmVtZW50IGlzIHNldCB0byBmYWxzZSwgdGhlIHByb21pc2Ugd2lsbCBhbHdheXMgYmVcbiAgICAgKiAgIGZ1bGZpbGxlZCB3aXRoIGRhdGEgZnJvbSB0aGUgbG9jYWwgc3RvcmUuXG4gICAgICpcbiAgICAgKiBFeGFtcGxlOlxuICAgICAqICAgKHN0YXJ0IGNvZGUpXG4gICAgICogICBjbGllbnQuZ2V0T2JqZWN0KCcvcGF0aC90by9vYmplY3QnLCBmYWxzZSkuXG4gICAgICogICAgIHRoZW4oZnVuY3Rpb24gKG9iamVjdCkge1xuICAgICAqICAgICAgIC8vIG9iamVjdCBpcyBlaXRoZXIgYW4gb2JqZWN0IG9yIG51bGxcbiAgICAgKiAgICAgfSk7XG4gICAgICogICAoZW5kIGNvZGUpXG4gICAgICovXG4gICAgZ2V0T2JqZWN0OiBmdW5jdGlvbiAocGF0aCwgbWF4QWdlKSB7XG4gICAgICBpZiAodHlwZW9mKHBhdGgpICE9PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoJ0FyZ3VtZW50IFxcJ3BhdGhcXCcgb2YgYmFzZUNsaWVudC5nZXRPYmplY3QgbXVzdCBiZSBhIHN0cmluZycpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuc3RvcmFnZS5nZXQodGhpcy5tYWtlUGF0aChwYXRoKSwgbWF4QWdlKS50aGVuKGZ1bmN0aW9uIChyKSB7XG4gICAgICAgIGlmICh0eXBlb2Yoci5ib2R5KSA9PT0gJ29iamVjdCcpIHsgLy8gd2lsbCBiZSB0aGUgY2FzZSBmb3IgZG9jdW1lbnRzIHN0b3JlZCB3aXRoIHJzLmpzIDw9IDAuMTAuMC1iZXRhMlxuICAgICAgICAgIHJldHVybiByLmJvZHk7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mKHIuYm9keSkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBKU09OLnBhcnNlKHIuYm9keSk7XG4gICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgdGhyb3cgXCJOb3QgdmFsaWQgSlNPTjogXCIgKyB0aGlzLm1ha2VQYXRoKHBhdGgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2Yoci5ib2R5KSAhPT0gJ3VuZGVmaW5lZCcgJiYgci5zdGF0dXNDb2RlID09PSAyMDApIHtcbiAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoXCJOb3QgYW4gb2JqZWN0OiBcIiArIHRoaXMubWFrZVBhdGgocGF0aCkpO1xuICAgICAgICB9XG4gICAgICB9LmJpbmQodGhpcykpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNZXRob2Q6IHN0b3JlT2JqZWN0XG4gICAgICpcbiAgICAgKiBTdG9yZSBvYmplY3QgYXQgZ2l2ZW4gcGF0aC4gVHJpZ2dlcnMgc3luY2hyb25pemF0aW9uLlxuICAgICAqXG4gICAgICogUGFyYW1ldGVyczpcbiAgICAgKlxuICAgICAqICAgdHlwZSAgICAgLSB1bmlxdWUgdHlwZSBvZiB0aGlzIG9iamVjdCB3aXRoaW4gdGhpcyBtb2R1bGUuIFNlZSBkZXNjcmlwdGlvbiBiZWxvdy5cbiAgICAgKiAgIHBhdGggICAgIC0gcGF0aCByZWxhdGl2ZSB0byB0aGUgbW9kdWxlIHJvb3QuXG4gICAgICogICBvYmplY3QgICAtIGFuIG9iamVjdCB0byBiZSBzYXZlZCB0byB0aGUgZ2l2ZW4gbm9kZS4gSXQgbXVzdCBiZSBzZXJpYWxpemFibGUgYXMgSlNPTi5cbiAgICAgKlxuICAgICAqIFJldHVybnM6XG4gICAgICogICBBIHByb21pc2UgdG8gc3RvcmUgdGhlIG9iamVjdC4gVGhlIHByb21pc2UgZmFpbHMgd2l0aCBhIFZhbGlkYXRpb25FcnJvciwgd2hlbiB2YWxpZGF0aW9ucyBmYWlsLlxuICAgICAqXG4gICAgICpcbiAgICAgKiBXaGF0IGFib3V0IHRoZSB0eXBlPzpcbiAgICAgKlxuICAgICAqICAgQSBncmVhdCB0aGluZyBhYm91dCBoYXZpbmcgZGF0YSBvbiB0aGUgd2ViLCBpcyB0byBiZSBhYmxlIHRvIGxpbmsgdG9cbiAgICAgKiAgIGl0IGFuZCByZWFycmFuZ2UgaXQgdG8gZml0IHRoZSBjdXJyZW50IGNpcmN1bXN0YW5jZXMuIFRvIGZhY2lsaXRhdGVcbiAgICAgKiAgIHRoYXQsIGV2ZW50dWFsbHkgeW91IG5lZWQgdG8ga25vdyBob3cgdGhlIGRhdGEgYXQgaGFuZCBpcyBzdHJ1Y3R1cmVkLlxuICAgICAqICAgRm9yIGRvY3VtZW50cyBvbiB0aGUgd2ViLCB0aGlzIGlzIHVzdWFsbHkgZG9uZSB2aWEgYSBNSU1FIHR5cGUuIFRoZVxuICAgICAqICAgTUlNRSB0eXBlIG9mIEpTT04gb2JqZWN0cyBob3dldmVyLCBpcyBhbHdheXMgYXBwbGljYXRpb24vanNvbi5cbiAgICAgKiAgIFRvIGFkZCB0aGF0IGV4dHJhIGxheWVyIG9mIFwia25vd2luZyB3aGF0IHRoaXMgb2JqZWN0IGlzXCIsIHJlbW90ZVN0b3JhZ2VcbiAgICAgKiAgIGFpbXMgdG8gdXNlIDxKU09OLUxEIGF0IGh0dHA6Ly9qc29uLWxkLm9yZy8+LlxuICAgICAqICAgQSBmaXJzdCBzdGVwIGluIHRoYXQgZGlyZWN0aW9uLCBpcyB0byBhZGQgYSAqQGNvbnRleHQgYXR0cmlidXRlKiB0byBhbGxcbiAgICAgKiAgIEpTT04gZGF0YSBwdXQgaW50byByZW1vdGVTdG9yYWdlLlxuICAgICAqICAgTm93IHRoYXQgaXMgd2hhdCB0aGUgKnR5cGUqIGlzIGZvci5cbiAgICAgKlxuICAgICAqICAgV2l0aGluIHJlbW90ZVN0b3JhZ2UuanMsIEBjb250ZXh0IHZhbHVlcyBhcmUgYnVpbHQgdXNpbmcgdGhyZWUgY29tcG9uZW50czpcbiAgICAgKiAgICAgaHR0cDovL3JlbW90ZXN0b3JhZ2UuaW8vc3BlYy9tb2R1bGVzLyAtIEEgcHJlZml4IHRvIGd1YXJhbnRlZSB1bmlxdWVuZXNzXG4gICAgICogICAgIHRoZSBtb2R1bGUgbmFtZSAgICAgLSBtb2R1bGUgbmFtZXMgc2hvdWxkIGJlIHVuaXF1ZSBhcyB3ZWxsXG4gICAgICogICAgIHRoZSB0eXBlIGdpdmVuIGhlcmUgLSBuYW1pbmcgdGhpcyBwYXJ0aWN1bGFyIGtpbmQgb2Ygb2JqZWN0IHdpdGhpbiB0aGlzIG1vZHVsZVxuICAgICAqXG4gICAgICogICBJbiByZXRyb3NwZWN0IHRoYXQgbWVhbnMsIHRoYXQgd2hlbmV2ZXIgeW91IGludHJvZHVjZSBhIG5ldyBcInR5cGVcIiBpbiBjYWxscyB0b1xuICAgICAqICAgc3RvcmVPYmplY3QsIHlvdSBzaG91bGQgbWFrZSBzdXJlIHRoYXQgb25jZSB5b3VyIGNvZGUgaXMgaW4gdGhlIHdpbGQsIGZ1dHVyZVxuICAgICAqICAgdmVyc2lvbnMgb2YgdGhlIGNvZGUgYXJlIGNvbXBhdGlibGUgd2l0aCB0aGUgc2FtZSBKU09OIHN0cnVjdHVyZS5cbiAgICAgKlxuICAgICAqIEhvdyB0byBkZWZpbmUgdHlwZXM/OlxuICAgICAqXG4gICAgICogICBTZWUgPGRlY2xhcmVUeXBlPiBmb3IgZXhhbXBsZXMuXG4gICAgICovXG4gICAgc3RvcmVPYmplY3Q6IGZ1bmN0aW9uICh0eXBlQWxpYXMsIHBhdGgsIG9iamVjdCkge1xuICAgICAgaWYgKHR5cGVvZih0eXBlQWxpYXMpICE9PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoJ0FyZ3VtZW50IFxcJ3R5cGVBbGlhc1xcJyBvZiBiYXNlQ2xpZW50LnN0b3JlT2JqZWN0IG11c3QgYmUgYSBzdHJpbmcnKTtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YocGF0aCkgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdCgnQXJndW1lbnQgXFwncGF0aFxcJyBvZiBiYXNlQ2xpZW50LnN0b3JlT2JqZWN0IG11c3QgYmUgYSBzdHJpbmcnKTtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2Yob2JqZWN0KSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KCdBcmd1bWVudCBcXCdvYmplY3RcXCcgb2YgYmFzZUNsaWVudC5zdG9yZU9iamVjdCBtdXN0IGJlIGFuIG9iamVjdCcpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9hdHRhY2hUeXBlKG9iamVjdCwgdHlwZUFsaWFzKTtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgdmFyIHZhbGlkYXRpb25SZXN1bHQgPSB0aGlzLnZhbGlkYXRlKG9iamVjdCk7XG4gICAgICAgIGlmICghIHZhbGlkYXRpb25SZXN1bHQudmFsaWQpIHtcbiAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QodmFsaWRhdGlvblJlc3VsdCk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2goZXhjKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChleGMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5zdG9yYWdlLnB1dCh0aGlzLm1ha2VQYXRoKHBhdGgpLCBKU09OLnN0cmluZ2lmeShvYmplY3QpLCAnYXBwbGljYXRpb24vanNvbjsgY2hhcnNldD1VVEYtOCcpLnRoZW4oZnVuY3Rpb24gKHIpIHtcbiAgICAgICAgaWYgKHIuc3RhdHVzQ29kZSA9PT0gMjAwIHx8IHIuc3RhdHVzQ29kZSA9PT0gMjAxKSB7XG4gICAgICAgICAgcmV0dXJuIHIucmV2aXNpb247XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KFwiUmVxdWVzdCAoUFVUIFwiICsgdGhpcy5tYWtlUGF0aChwYXRoKSArIFwiKSBmYWlsZWQgd2l0aCBzdGF0dXM6IFwiICsgci5zdGF0dXNDb2RlKTtcbiAgICAgICAgfVxuICAgICAgfS5iaW5kKHRoaXMpKTtcbiAgICB9LFxuXG4gICAgLy8gZ2VuZXJpYyBvcGVyYXRpb25zXG5cbiAgICAvKipcbiAgICAgKiBNZXRob2Q6IHJlbW92ZVxuICAgICAqXG4gICAgICogUmVtb3ZlIG5vZGUgYXQgZ2l2ZW4gcGF0aCBmcm9tIHN0b3JhZ2UuIFRyaWdnZXJzIHN5bmNocm9uaXphdGlvbi5cbiAgICAgKlxuICAgICAqIFBhcmFtZXRlcnM6XG4gICAgICogICBwYXRoICAgICAtIFBhdGggcmVsYXRpdmUgdG8gdGhlIG1vZHVsZSByb290LlxuICAgICAqL1xuICAgIHJlbW92ZTogZnVuY3Rpb24gKHBhdGgpIHtcbiAgICAgIGlmICh0eXBlb2YocGF0aCkgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdCgnQXJndW1lbnQgXFwncGF0aFxcJyBvZiBiYXNlQ2xpZW50LnJlbW92ZSBtdXN0IGJlIGEgc3RyaW5nJyk7XG4gICAgICB9XG4gICAgICBpZiAoIXRoaXMuc3RvcmFnZS5hY2Nlc3MuY2hlY2tQYXRoUGVybWlzc2lvbih0aGlzLm1ha2VQYXRoKHBhdGgpLCAncncnKSkge1xuICAgICAgICBjb25zb2xlLndhcm4oJ1dBUk5JTkc6IFJlbW92aW5nIGEgZG9jdW1lbnQgdG8gd2hpY2ggb25seSByZWFkIGFjY2VzcyAoXFwnclxcJykgd2FzIGNsYWltZWQnKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMuc3RvcmFnZS5kZWxldGUodGhpcy5tYWtlUGF0aChwYXRoKSk7XG4gICAgfSxcblxuXG4gICAgY2FjaGU6IGZ1bmN0aW9uIChwYXRoLCBzdHJhdGVneSkge1xuICAgICAgaWYgKHR5cGVvZihwYXRoKSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgdGhyb3cgJ0FyZ3VtZW50IFxcJ3BhdGhcXCcgb2YgYmFzZUNsaWVudC5jYWNoZSBtdXN0IGJlIGEgc3RyaW5nJztcbiAgICAgIH1cbiAgICAgIGlmIChzdHJhdGVneSA9PT0gZmFsc2UpIHtcbiAgICAgICAgZGVwcmVjYXRlKCdjYWNoaW5nIHN0cmF0ZWd5IDxmYWxzZT4nLCAnPFwiRkxVU0hcIj4nKTtcbiAgICAgICAgc3RyYXRlZ3kgPSAnRkxVU0gnO1xuICAgICAgfSBlbHNlIGlmIChzdHJhdGVneSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHN0cmF0ZWd5ID0gJ0FMTCc7XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZihzdHJhdGVneSkgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGRlcHJlY2F0ZSgndGhhdCBjYWNoaW5nIHN0cmF0ZWd5JywgJzxcIkFMTFwiPicpO1xuICAgICAgICBzdHJhdGVneSA9ICdBTEwnO1xuICAgICAgfVxuICAgICAgaWYgKHN0cmF0ZWd5ICE9PSAnRkxVU0gnICYmXG4gICAgICAgICAgc3RyYXRlZ3kgIT09ICdTRUVOJyAmJlxuICAgICAgICAgIHN0cmF0ZWd5ICE9PSAnQUxMJykge1xuICAgICAgICB0aHJvdyAnQXJndW1lbnQgXFwnc3RyYXRlZ3lcXCcgb2YgYmFzZWNsaWVudC5jYWNoZSBtdXN0IGJlIG9uZSBvZiAnXG4gICAgICAgICAgICArICdbXCJGTFVTSFwiLCBcIlNFRU5cIiwgXCJBTExcIl0nO1xuICAgICAgfVxuICAgICAgdGhpcy5zdG9yYWdlLmNhY2hpbmcuc2V0KHRoaXMubWFrZVBhdGgocGF0aCksIHN0cmF0ZWd5KTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBmbHVzaDogZnVuY3Rpb24gKHBhdGgpIHtcbiAgICAgIHJldHVybiB0aGlzLnN0b3JhZ2UubG9jYWwuZmx1c2gocGF0aCk7XG4gICAgfSxcblxuICAgIG1ha2VQYXRoOiBmdW5jdGlvbiAocGF0aCkge1xuICAgICAgcmV0dXJuIHRoaXMuYmFzZSArIChwYXRoIHx8ICcnKTtcbiAgICB9LFxuXG4gICAgX2ZpcmVDaGFuZ2U6IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgaWYgKGNvbmZpZy5jaGFuZ2VFdmVudHNbZXZlbnQub3JpZ2luXSkge1xuICAgICAgICBbJ25ldycsICdvbGQnLCAnbGFzdENvbW1vbiddLmZvckVhY2goZnVuY3Rpb24gKGZpZWxkTmFtZVByZWZpeCkge1xuICAgICAgICAgIGlmICgoIWV2ZW50W2ZpZWxkTmFtZVByZWZpeCsnQ29udGVudFR5cGUnXSlcbiAgICAgICAgICAgICAgfHwgKC9eYXBwbGljYXRpb25cXC8oLiopanNvbiguKikvLmV4ZWMoZXZlbnRbZmllbGROYW1lUHJlZml4KydDb250ZW50VHlwZSddKSkpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YoZXZlbnRbZmllbGROYW1lUHJlZml4KydWYWx1ZSddKSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBldmVudFtmaWVsZE5hbWVQcmVmaXgrJ1ZhbHVlJ10gPSBKU09OLnBhcnNlKGV2ZW50W2ZpZWxkTmFtZVByZWZpeCsnVmFsdWUnXSk7XG4gICAgICAgICAgICAgIH0gY2F0Y2goZSkge1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5fZW1pdCgnY2hhbmdlJywgZXZlbnQpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBfY2xlYW5QYXRoOiB1dGlsLmNsZWFuUGF0aCxcblxuICAgIC8qKlxuICAgICAqIE1ldGhvZDogZ2V0SXRlbVVSTFxuICAgICAqXG4gICAgICogUmV0cmlldmUgZnVsbCBVUkwgb2YgaXRlbVxuICAgICAqXG4gICAgICogUGFyYW1ldGVyczpcbiAgICAgKiAgIHBhdGggICAgIC0gUGF0aCByZWxhdGl2ZSB0byB0aGUgbW9kdWxlIHJvb3QuXG4gICAgICovXG4gICAgZ2V0SXRlbVVSTDogZnVuY3Rpb24gKHBhdGgpIHtcbiAgICAgIGlmICh0eXBlb2YocGF0aCkgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRocm93ICdBcmd1bWVudCBcXCdwYXRoXFwnIG9mIGJhc2VDbGllbnQuZ2V0SXRlbVVSTCBtdXN0IGJlIGEgc3RyaW5nJztcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLnN0b3JhZ2UuY29ubmVjdGVkKSB7XG4gICAgICAgIHBhdGggPSB0aGlzLl9jbGVhblBhdGgoIHRoaXMubWFrZVBhdGgocGF0aCkgKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RvcmFnZS5yZW1vdGUuaHJlZiArIHBhdGg7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICB1dWlkOiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdXVpZCgpO1xuICAgIH1cblxuICB9O1xuXG4gIC8qKlxuICAgKiBNZXRob2Q6IFJTI3Njb3BlXG4gICAqXG4gICAqIFJldHVybnMgYSBuZXcgPFJTLkJhc2VDbGllbnQ+IHNjb3BlZCB0byB0aGUgZ2l2ZW4gcGF0aC5cbiAgICpcbiAgICogUGFyYW1ldGVyczpcbiAgICogICBwYXRoIC0gUm9vdCBwYXRoIG9mIG5ldyBCYXNlQ2xpZW50LlxuICAgKlxuICAgKlxuICAgKiBFeGFtcGxlOlxuICAgKiAgIChzdGFydCBjb2RlKVxuICAgKlxuICAgKiAgIHZhciBmb28gPSByZW1vdGVTdG9yYWdlLnNjb3BlKCcvZm9vLycpO1xuICAgKlxuICAgKiAgIC8vIFBVVHMgZGF0YSBcImJhelwiIHRvIHBhdGggL2Zvby9iYXJcbiAgICogICBmb28uc3RvcmVGaWxlKCd0ZXh0L3BsYWluJywgJ2JhcicsICdiYXonKTtcbiAgICpcbiAgICogICB2YXIgc29tZXRoaW5nID0gZm9vLnNjb3BlKCdzb21ldGhpbmcvJyk7XG4gICAqXG4gICAqICAgLy8gR0VUcyBsaXN0aW5nIGZyb20gcGF0aCAvZm9vL3NvbWV0aGluZy9ibGEvXG4gICAqICAgc29tZXRoaW5nLmdldExpc3RpbmcoJ2JsYS8nKTtcbiAgICpcbiAgICogICAoZW5kIGNvZGUpXG4gICAqXG4gICAqL1xuICBCYXNlQ2xpZW50Ll9yc19pbml0ID0gZnVuY3Rpb24gKCkge1xuICAgIFxuICB9O1xuXG4gIC8qIGUuZy46XG4gIHJlbW90ZVN0b3JhZ2UuZGVmaW5lTW9kdWxlKCdsb2NhdGlvbnMnLCBmdW5jdGlvbiAocHJpdiwgcHViKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGV4cG9ydHM6IHtcbiAgICAgICAgZmVhdHVyZXM6IHByaXYuc2NvcGUoJ2ZlYXR1cmVzLycpLmRlZmF1bHRUeXBlKCdmZWF0dXJlJyksXG4gICAgICAgIGNvbGxlY3Rpb25zOiBwcml2LnNjb3BlKCdjb2xsZWN0aW9ucy8nKS5kZWZhdWx0VHlwZSgnZmVhdHVyZS1jb2xsZWN0aW9uJyk7XG4gICAgICB9XG4gICAgfTtcbiAgfSk7XG4gICovXG5cbiAgLy8gRGVmaW5lZCBpbiBiYXNlY2xpZW50L3R5cGVzLmpzXG4gIC8qKlxuICAgKiBNZXRob2Q6IGRlY2xhcmVUeXBlXG4gICAqXG4gICAqIERlY2xhcmUgYSByZW1vdGVTdG9yYWdlIG9iamVjdCB0eXBlIHVzaW5nIGEgSlNPTiBzY2hlbWEuIFNlZVxuICAgKiA8QmFzZUNsaWVudC5UeXBlcz5cbiAgICoqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IEJhc2VDbGllbnQ7XG5cbi8vIG5lZWRzIHRvIGJlIGFmdGVyIHRoZSBleHBvcnQgdG8gY2hhbmdlIHByb3RvdHlwZVxuLy8gdGhpcyBzaG91bGQgYmUgZGlmZmVyZW50ICh3ZSBuZWVkIHRvIGltcG9ydCBgdHlwZXNgIGZ1bmN0aW9uYWxpdHksIG5vdCBtb2RpZmluZyBCYXNlQ2xpZW50LnByb3RvdHlwZSBmcm9tIHRoZXJlKVxucmVxdWlyZSgnLi90eXBlcycpO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9iYXNlY2xpZW50LmpzIl0sInNvdXJjZVJvb3QiOiIifQ==");
},function(module,exports,__webpack_require__){eval("'use strict';\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar util = __webpack_require__(2);\nvar config = __webpack_require__(5);\nvar log = __webpack_require__(1);\n\n/**\n * Interface: cachinglayer\n *\n * This module defines functions that are mixed into remoteStorage.local when\n * it is instantiated (currently one of indexeddb.js, localstorage.js, or\n * inmemorystorage.js).\n *\n * All remoteStorage.local implementations should therefore implement\n * this.getNodes, this.setNodes, and this.forAllNodes. The rest is blended in\n * here to create a GPD (get/put/delete) interface which the BaseClient can\n * talk to.\n */\n\nvar isFolder = util.isFolder;\nvar isDocument = util.isDocument;\nvar deepClone = util.deepClone;\n\nfunction getLatest(node) {\n  if ((typeof node === 'undefined' ? 'undefined' : _typeof(node)) !== 'object' || typeof node.path !== 'string') {\n    return;\n  }\n  if (isFolder(node.path)) {\n    if (node.local && node.local.itemsMap) {\n      return node.local;\n    }\n    if (node.common && node.common.itemsMap) {\n      return node.common;\n    }\n  } else {\n    if (node.local && node.local.body && node.local.contentType) {\n      return node.local;\n    }\n    if (node.common && node.common.body && node.common.contentType) {\n      return node.common;\n    }\n    // Migration code! Once all apps use at least this version of the lib, we\n    // can publish clean-up code that migrates over any old-format data, and\n    // stop supporting it. For now, new apps will support data in both\n    // formats, thanks to this:\n    if (node.body && node.contentType) {\n      return {\n        body: node.body,\n        contentType: node.contentType\n      };\n    }\n  }\n}\n\nfunction isOutdated(nodes, maxAge) {\n  var path;\n  for (path in nodes) {\n    if (nodes[path] && nodes[path].remote) {\n      return true;\n    }\n    var nodeVersion = getLatest(nodes[path]);\n    if (nodeVersion && nodeVersion.timestamp && new Date().getTime() - nodeVersion.timestamp <= maxAge) {\n      return false;\n    } else if (!nodeVersion) {\n      return true;\n    }\n  }\n  return true;\n}\n\nvar pathsFromRoot = util.pathsFromRoot;\n\nfunction makeNode(path) {\n  var node = { path: path, common: {} };\n\n  if (isFolder(path)) {\n    node.common.itemsMap = {};\n  }\n  return node;\n}\n\nfunction updateFolderNodeWithItemName(node, itemName) {\n  if (!node.common) {\n    node.common = {\n      itemsMap: {}\n    };\n  }\n  if (!node.common.itemsMap) {\n    node.common.itemsMap = {};\n  }\n  if (!node.local) {\n    node.local = deepClone(node.common);\n  }\n  if (!node.local.itemsMap) {\n    node.local.itemsMap = node.common.itemsMap;\n  }\n  node.local.itemsMap[itemName] = true;\n\n  return node;\n}\n\nvar methods = {\n\n  // TODO: improve our code structure so that this function\n  // could call sync.queueGetRequest directly instead of needing\n  // this hacky third parameter as a callback\n  get: function get(path, maxAge, queueGetRequest) {\n    var self = this;\n    if (typeof maxAge === 'number') {\n      return self.getNodes(pathsFromRoot(path)).then(function (objs) {\n        var node = getLatest(objs[path]);\n        if (isOutdated(objs, maxAge)) {\n          return queueGetRequest(path);\n        } else if (node) {\n          return { statusCode: 200, body: node.body || node.itemsMap, contentType: node.contentType };\n        } else {\n          return { statusCode: 404 };\n        }\n      });\n    } else {\n      return self.getNodes([path]).then(function (objs) {\n        var node = getLatest(objs[path]);\n        if (node) {\n          if (isFolder(path)) {\n            for (var i in node.itemsMap) {\n              // the hasOwnProperty check here is only because our jshint settings require it:\n              if (node.itemsMap.hasOwnProperty(i) && node.itemsMap[i] === false) {\n                delete node.itemsMap[i];\n              }\n            }\n          }\n          return { statusCode: 200, body: node.body || node.itemsMap, contentType: node.contentType };\n        } else {\n          return { statusCode: 404 };\n        }\n      });\n    }\n  },\n\n  put: function put(path, body, contentType) {\n    var paths = pathsFromRoot(path);\n\n    function _processNodes(paths, nodes) {\n      try {\n        for (var i = 0, len = paths.length; i < len; i++) {\n          var path = paths[i];\n          var node = nodes[path];\n          var previous;\n\n          if (!node) {\n            nodes[path] = node = makeNode(path);\n          }\n\n          // Document\n          if (i === 0) {\n            previous = getLatest(node);\n            node.local = {\n              body: body,\n              contentType: contentType,\n              previousBody: previous ? previous.body : undefined,\n              previousContentType: previous ? previous.contentType : undefined\n            };\n          }\n          // Folder\n          else {\n              var itemName = paths[i - 1].substring(path.length);\n              node = updateFolderNodeWithItemName(node, itemName);\n            }\n        }\n        return nodes;\n      } catch (e) {\n        log('[Cachinglayer] Error during PUT', nodes, e);\n        throw e;\n      }\n    }\n    return this._updateNodes(paths, _processNodes);\n  },\n\n  delete: function _delete(path) {\n    var paths = pathsFromRoot(path);\n\n    return this._updateNodes(paths, function (paths, nodes) {\n      for (var i = 0, len = paths.length; i < len; i++) {\n        var path = paths[i];\n        var node = nodes[path];\n        var previous;\n\n        if (!node) {\n          throw new Error('Cannot delete non-existing node ' + path);\n        }\n\n        if (i === 0) {\n          // Document\n          previous = getLatest(node);\n          node.local = {\n            body: false,\n            previousBody: previous ? previous.body : undefined,\n            previousContentType: previous ? previous.contentType : undefined\n          };\n        } else {\n          // Folder\n          if (!node.local) {\n            node.local = deepClone(node.common);\n          }\n          var itemName = paths[i - 1].substring(path.length);\n          delete node.local.itemsMap[itemName];\n\n          if (Object.getOwnPropertyNames(node.local.itemsMap).length > 0) {\n            // This folder still contains other items, don't remove any further ancestors\n            break;\n          }\n        }\n      }\n      return nodes;\n    });\n  },\n  flush: function flush(path) {\n    var self = this;\n    return self._getAllDescendentPaths(path).then(function (paths) {\n      return self.getNodes(paths);\n    }).then(function (nodes) {\n      for (var path in nodes) {\n        var node = nodes[path];\n\n        if (node && node.common && node.local) {\n          self._emitChange({\n            path: node.path,\n            origin: 'local',\n            oldValue: node.local.body === false ? undefined : node.local.body,\n            newValue: node.common.body === false ? undefined : node.common.body\n          });\n        }\n        nodes[path] = undefined;\n      }\n      return self.setNodes(nodes);\n    });\n  },\n\n  _emitChange: function _emitChange(obj) {\n    if (config.changeEvents[obj.origin]) {\n      this._emit('change', obj);\n    }\n  },\n\n  fireInitial: function fireInitial() {\n    if (!config.changeEvents.local) {\n      return;\n    }\n    var self = this;\n    self.forAllNodes(function (node) {\n      var latest;\n      if (isDocument(node.path)) {\n        latest = getLatest(node);\n        if (latest) {\n          self._emitChange({\n            path: node.path,\n            origin: 'local',\n            oldValue: undefined,\n            oldContentType: undefined,\n            newValue: latest.body,\n            newContentType: latest.contentType\n          });\n        }\n      }\n    }).then(function () {\n      self._emit('local-events-done');\n    });\n  },\n\n  onDiff: function onDiff(diffHandler) {\n    this.diffHandler = diffHandler;\n  },\n\n  migrate: function migrate(node) {\n    if ((typeof node === 'undefined' ? 'undefined' : _typeof(node)) === 'object' && !node.common) {\n      node.common = {};\n      if (typeof node.path === 'string') {\n        if (node.path.substr(-1) === '/' && _typeof(node.body) === 'object') {\n          node.common.itemsMap = node.body;\n        }\n      } else {\n        //save legacy content of document node as local version\n        if (!node.local) {\n          node.local = {};\n        }\n        node.local.body = node.body;\n        node.local.contentType = node.contentType;\n      }\n    }\n    return node;\n  },\n\n  // FIXME\n  // this process of updating nodes needs to be heavily documented first, then\n  // refactored. Right now it's almost impossible to refactor as there's no\n  // explanation of why things are implemented certain ways or what the goal(s)\n  // of the behavior are. -slvrbckt (+1 -les)\n  _updateNodesRunning: false,\n  _updateNodesQueued: [],\n  _updateNodes: function _updateNodes(paths, _processNodes) {\n    return new Promise(function (resolve, reject) {\n      this._doUpdateNodes(paths, _processNodes, {\n        resolve: resolve,\n        reject: reject\n      });\n    }.bind(this));\n  },\n  _doUpdateNodes: function _doUpdateNodes(paths, _processNodes, promise) {\n    var self = this;\n\n    if (self._updateNodesRunning) {\n      self._updateNodesQueued.push({\n        paths: paths,\n        cb: _processNodes,\n        promise: promise\n      });\n      return;\n    } else {\n      self._updateNodesRunning = true;\n    }\n\n    self.getNodes(paths).then(function (nodes) {\n      var existingNodes = deepClone(nodes);\n      var changeEvents = [];\n      var node;\n      var equal = util.equal;\n\n      nodes = _processNodes(paths, nodes);\n\n      for (var path in nodes) {\n        node = nodes[path];\n        if (equal(node, existingNodes[path])) {\n          delete nodes[path];\n        } else if (isDocument(path)) {\n          if (!equal(node.local.body, node.local.previousBody) || node.local.contentType !== node.local.previousContentType) {\n            changeEvents.push({\n              path: path,\n              origin: 'window',\n              oldValue: node.local.previousBody,\n              newValue: node.local.body === false ? undefined : node.local.body,\n              oldContentType: node.local.previousContentType,\n              newContentType: node.local.contentType\n            });\n          }\n          delete node.local.previousBody;\n          delete node.local.previousContentType;\n        }\n      }\n\n      self.setNodes(nodes).then(function () {\n        self._emitChangeEvents(changeEvents);\n        promise.resolve({ statusCode: 200 });\n      });\n    }).then(function () {\n      return Promise.resolve();\n    }, function (err) {\n      promise.reject(err);\n    }).then(function () {\n      self._updateNodesRunning = false;\n      var nextJob = self._updateNodesQueued.shift();\n      if (nextJob) {\n        self._doUpdateNodes(nextJob.paths, nextJob.cb, nextJob.promise);\n      }\n    });\n  },\n\n  _emitChangeEvents: function _emitChangeEvents(events) {\n    for (var i = 0, len = events.length; i < len; i++) {\n      this._emitChange(events[i]);\n      if (this.diffHandler) {\n        this.diffHandler(events[i].path);\n      }\n    }\n  },\n\n  _getAllDescendentPaths: function _getAllDescendentPaths(path) {\n    var self = this;\n    if (isFolder(path)) {\n      return self.getNodes([path]).then(function (nodes) {\n        var allPaths = [path];\n        var latest = getLatest(nodes[path]);\n\n        var itemNames = Object.keys(latest.itemsMap);\n        var calls = itemNames.map(function (itemName) {\n          return self._getAllDescendentPaths(path + itemName).then(function (paths) {\n            for (var i = 0, len = paths.length; i < len; i++) {\n              allPaths.push(paths[i]);\n            }\n          });\n        });\n        return Promise.all(calls).then(function () {\n          return allPaths;\n        });\n      });\n    } else {\n      return Promise.resolve([path]);\n    }\n  },\n\n  _getInternals: function _getInternals() {\n    return {\n      getLatest: getLatest,\n      makeNode: makeNode,\n      isOutdated: isOutdated\n    };\n  }\n};\n\n/**\n * Function: cachingLayer\n *\n * Mixes common caching layer functionality into an object.\n *\n * The first parameter is always the object to be extended.\n *\n * Example:\n *   (start code)\n *   var MyConstructor = function () {\n *     cachingLayer(this);\n *   };\n *   (end code)\n */\nvar cachingLayer = function cachingLayer(object) {\n  for (var key in methods) {\n    object[key] = methods[key];\n  }\n};\n\nmodule.exports = cachingLayer;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvY2FjaGluZ2xheWVyLmpzPzc5MjgiXSwibmFtZXMiOlsidXRpbCIsInJlcXVpcmUiLCJjb25maWciLCJsb2ciLCJpc0ZvbGRlciIsImlzRG9jdW1lbnQiLCJkZWVwQ2xvbmUiLCJnZXRMYXRlc3QiLCJub2RlIiwicGF0aCIsImxvY2FsIiwiaXRlbXNNYXAiLCJjb21tb24iLCJib2R5IiwiY29udGVudFR5cGUiLCJpc091dGRhdGVkIiwibm9kZXMiLCJtYXhBZ2UiLCJyZW1vdGUiLCJub2RlVmVyc2lvbiIsInRpbWVzdGFtcCIsIkRhdGUiLCJnZXRUaW1lIiwicGF0aHNGcm9tUm9vdCIsIm1ha2VOb2RlIiwidXBkYXRlRm9sZGVyTm9kZVdpdGhJdGVtTmFtZSIsIml0ZW1OYW1lIiwibWV0aG9kcyIsImdldCIsInF1ZXVlR2V0UmVxdWVzdCIsInNlbGYiLCJnZXROb2RlcyIsInRoZW4iLCJvYmpzIiwic3RhdHVzQ29kZSIsImkiLCJoYXNPd25Qcm9wZXJ0eSIsInB1dCIsInBhdGhzIiwiX3Byb2Nlc3NOb2RlcyIsImxlbiIsImxlbmd0aCIsInByZXZpb3VzIiwicHJldmlvdXNCb2R5IiwidW5kZWZpbmVkIiwicHJldmlvdXNDb250ZW50VHlwZSIsInN1YnN0cmluZyIsImUiLCJfdXBkYXRlTm9kZXMiLCJkZWxldGUiLCJFcnJvciIsIk9iamVjdCIsImdldE93blByb3BlcnR5TmFtZXMiLCJmbHVzaCIsIl9nZXRBbGxEZXNjZW5kZW50UGF0aHMiLCJfZW1pdENoYW5nZSIsIm9yaWdpbiIsIm9sZFZhbHVlIiwibmV3VmFsdWUiLCJzZXROb2RlcyIsIm9iaiIsImNoYW5nZUV2ZW50cyIsIl9lbWl0IiwiZmlyZUluaXRpYWwiLCJmb3JBbGxOb2RlcyIsImxhdGVzdCIsIm9sZENvbnRlbnRUeXBlIiwibmV3Q29udGVudFR5cGUiLCJvbkRpZmYiLCJkaWZmSGFuZGxlciIsIm1pZ3JhdGUiLCJzdWJzdHIiLCJfdXBkYXRlTm9kZXNSdW5uaW5nIiwiX3VwZGF0ZU5vZGVzUXVldWVkIiwiUHJvbWlzZSIsInJlc29sdmUiLCJyZWplY3QiLCJfZG9VcGRhdGVOb2RlcyIsImJpbmQiLCJwcm9taXNlIiwicHVzaCIsImNiIiwiZXhpc3RpbmdOb2RlcyIsImVxdWFsIiwiX2VtaXRDaGFuZ2VFdmVudHMiLCJlcnIiLCJuZXh0Sm9iIiwic2hpZnQiLCJldmVudHMiLCJhbGxQYXRocyIsIml0ZW1OYW1lcyIsImtleXMiLCJjYWxscyIsIm1hcCIsImFsbCIsIl9nZXRJbnRlcm5hbHMiLCJjYWNoaW5nTGF5ZXIiLCJvYmplY3QiLCJrZXkiLCJtb2R1bGUiLCJleHBvcnRzIl0sIm1hcHBpbmdzIjoiOzs7O0FBQUUsSUFBTUEsT0FBTyxtQkFBQUMsQ0FBUSxDQUFSLENBQWI7QUFDQSxJQUFNQyxTQUFTLG1CQUFBRCxDQUFRLENBQVIsQ0FBZjtBQUNBLElBQU1FLE1BQU0sbUJBQUFGLENBQVEsQ0FBUixDQUFaOztBQUdBOzs7Ozs7Ozs7Ozs7O0FBYUEsSUFBTUcsV0FBV0osS0FBS0ksUUFBdEI7QUFDQSxJQUFNQyxhQUFhTCxLQUFLSyxVQUF4QjtBQUNBLElBQU1DLFlBQVlOLEtBQUtNLFNBQXZCOztBQUVBLFNBQVNDLFNBQVQsQ0FBbUJDLElBQW5CLEVBQXlCO0FBQ3ZCLE1BQUksUUFBT0EsSUFBUCx5Q0FBT0EsSUFBUCxPQUFpQixRQUFqQixJQUE2QixPQUFPQSxLQUFLQyxJQUFaLEtBQXNCLFFBQXZELEVBQWlFO0FBQy9EO0FBQ0Q7QUFDRCxNQUFJTCxTQUFTSSxLQUFLQyxJQUFkLENBQUosRUFBeUI7QUFDdkIsUUFBSUQsS0FBS0UsS0FBTCxJQUFjRixLQUFLRSxLQUFMLENBQVdDLFFBQTdCLEVBQXVDO0FBQ3JDLGFBQU9ILEtBQUtFLEtBQVo7QUFDRDtBQUNELFFBQUlGLEtBQUtJLE1BQUwsSUFBZUosS0FBS0ksTUFBTCxDQUFZRCxRQUEvQixFQUF5QztBQUN2QyxhQUFPSCxLQUFLSSxNQUFaO0FBQ0Q7QUFDRixHQVBELE1BT087QUFDTCxRQUFJSixL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QUlpRixlQUFlLFNBQWZBLFlBQWUsQ0FBVUMsTUFBVixFQUFrQjtBQUNuQyxPQUFLLElBQUlDLEdBQVQsSUFBZ0J2RSxPQUFoQixFQUF5QjtBQUN2QnNFLFdBQU9DLEdBQVAsSUFBY3ZFLFFBQVF1RSxHQUFSLENBQWQ7QUFDRDtBQUNGLENBSkQ7O0FBTUFDLE9BQU9DLE9BQVAsR0FBaUJKLFlBQWpCIiwiZmlsZSI6IjcuanMiLCJzb3VyY2VzQ29udGVudCI6WyIgIGNvbnN0IHV0aWwgPSByZXF1aXJlKCcuL3V0aWwnKTtcbiAgY29uc3QgY29uZmlnID0gcmVxdWlyZSgnLi9jb25maWcnKTtcbiAgY29uc3QgbG9nID0gcmVxdWlyZSgnLi9sb2cnKTtcblxuXG4gIC8qKlxuICAgKiBJbnRlcmZhY2U6IGNhY2hpbmdsYXllclxuICAgKlxuICAgKiBUaGlzIG1vZHVsZSBkZWZpbmVzIGZ1bmN0aW9ucyB0aGF0IGFyZSBtaXhlZCBpbnRvIHJlbW90ZVN0b3JhZ2UubG9jYWwgd2hlblxuICAgKiBpdCBpcyBpbnN0YW50aWF0ZWQgKGN1cnJlbnRseSBvbmUgb2YgaW5kZXhlZGRiLmpzLCBsb2NhbHN0b3JhZ2UuanMsIG9yXG4gICAqIGlubWVtb3J5c3RvcmFnZS5qcykuXG4gICAqXG4gICAqIEFsbCByZW1vdGVTdG9yYWdlLmxvY2FsIGltcGxlbWVudGF0aW9ucyBzaG91bGQgdGhlcmVmb3JlIGltcGxlbWVudFxuICAgKiB0aGlzLmdldE5vZGVzLCB0aGlzLnNldE5vZGVzLCBhbmQgdGhpcy5mb3JBbGxOb2Rlcy4gVGhlIHJlc3QgaXMgYmxlbmRlZCBpblxuICAgKiBoZXJlIHRvIGNyZWF0ZSBhIEdQRCAoZ2V0L3B1dC9kZWxldGUpIGludGVyZmFjZSB3aGljaCB0aGUgQmFzZUNsaWVudCBjYW5cbiAgICogdGFsayB0by5cbiAgICovXG5cbiAgY29uc3QgaXNGb2xkZXIgPSB1dGlsLmlzRm9sZGVyO1xuICBjb25zdCBpc0RvY3VtZW50ID0gdXRpbC5pc0RvY3VtZW50O1xuICBjb25zdCBkZWVwQ2xvbmUgPSB1dGlsLmRlZXBDbG9uZTtcblxuICBmdW5jdGlvbiBnZXRMYXRlc3Qobm9kZSkge1xuICAgIGlmICh0eXBlb2Yobm9kZSkgIT09ICdvYmplY3QnIHx8IHR5cGVvZihub2RlLnBhdGgpICE9PSAnc3RyaW5nJykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoaXNGb2xkZXIobm9kZS5wYXRoKSkge1xuICAgICAgaWYgKG5vZGUubG9jYWwgJiYgbm9kZS5sb2NhbC5pdGVtc01hcCkge1xuICAgICAgICByZXR1cm4gbm9kZS5sb2NhbDtcbiAgICAgIH1cbiAgICAgIGlmIChub2RlLmNvbW1vbiAmJiBub2RlLmNvbW1vbi5pdGVtc01hcCkge1xuICAgICAgICByZXR1cm4gbm9kZS5jb21tb247XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChub2RlLmxvY2FsICYmIG5vZGUubG9jYWwuYm9keSAmJiBub2RlLmxvY2FsLmNvbnRlbnRUeXBlKSB7XG4gICAgICAgIHJldHVybiBub2RlLmxvY2FsO1xuICAgICAgfVxuICAgICAgaWYgKG5vZGUuY29tbW9uICYmIG5vZGUuY29tbW9uLmJvZHkgJiYgbm9kZS5jb21tb24uY29udGVudFR5cGUpIHtcbiAgICAgICAgcmV0dXJuIG5vZGUuY29tbW9uO1xuICAgICAgfVxuICAgICAgLy8gTWlncmF0aW9uIGNvZGUhIE9uY2UgYWxsIGFwcHMgdXNlIGF0IGxlYXN0IHRoaXMgdmVyc2lvbiBvZiB0aGUgbGliLCB3ZVxuICAgICAgLy8gY2FuIHB1Ymxpc2ggY2xlYW4tdXAgY29kZSB0aGF0IG1pZ3JhdGVzIG92ZXIgYW55IG9sZC1mb3JtYXQgZGF0YSwgYW5kXG4gICAgICAvLyBzdG9wIHN1cHBvcnRpbmcgaXQuIEZvciBub3csIG5ldyBhcHBzIHdpbGwgc3VwcG9ydCBkYXRhIGluIGJvdGhcbiAgICAgIC8vIGZvcm1hdHMsIHRoYW5rcyB0byB0aGlzOlxuICAgICAgaWYgKG5vZGUuYm9keSAmJiBub2RlLmNvbnRlbnRUeXBlKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgYm9keTogbm9kZS5ib2R5LFxuICAgICAgICAgIGNvbnRlbnRUeXBlOiBub2RlLmNvbnRlbnRUeXBlXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaXNPdXRkYXRlZChub2RlcywgbWF4QWdlKSB7XG4gICAgdmFyIHBhdGg7XG4gICAgZm9yIChwYXRoIGluIG5vZGVzKSB7XG4gICAgICBpZiAobm9kZXNbcGF0aF0gJiYgbm9kZXNbcGF0aF0ucmVtb3RlKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgdmFyIG5vZGVWZXJzaW9uID0gZ2V0TGF0ZXN0KG5vZGVzW3BhdGhdKTtcbiAgICAgIGlmIChub2RlVmVyc2lvbiAmJiBub2RlVmVyc2lvbi50aW1lc3RhbXAgJiYgKG5ldyBEYXRlKCkuZ2V0VGltZSgpKSAtIG5vZGVWZXJzaW9uLnRpbWVzdGFtcCA8PSBtYXhBZ2UpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfSBlbHNlIGlmICghbm9kZVZlcnNpb24pIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgdmFyIHBhdGhzRnJvbVJvb3QgPSB1dGlsLnBhdGhzRnJvbVJvb3Q7XG5cbiAgZnVuY3Rpb24gbWFrZU5vZGUocGF0aCkge1xuICAgIHZhciBub2RlID0geyBwYXRoOiBwYXRoLCBjb21tb246IHsgfSB9O1xuXG4gICAgaWYgKGlzRm9sZGVyKHBhdGgpKSB7XG4gICAgICBub2RlLmNvbW1vbi5pdGVtc01hcCA9IHt9O1xuICAgIH1cbiAgICByZXR1cm4gbm9kZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHVwZGF0ZUZvbGRlck5vZGVXaXRoSXRlbU5hbWUobm9kZSwgaXRlbU5hbWUpIHtcbiAgICBpZiAoIW5vZGUuY29tbW9uKSB7XG4gICAgICBub2RlLmNvbW1vbiA9IHtcbiAgICAgICAgaXRlbXNNYXA6IHt9XG4gICAgICB9O1xuICAgIH1cbiAgICBpZiAoIW5vZGUuY29tbW9uLml0ZW1zTWFwKSB7XG4gICAgICBub2RlLmNvbW1vbi5pdGVtc01hcCA9IHt9O1xuICAgIH1cbiAgICBpZiAoIW5vZGUubG9jYWwpIHtcbiAgICAgIG5vZGUubG9jYWwgPSBkZWVwQ2xvbmUobm9kZS5jb21tb24pO1xuICAgIH1cbiAgICBpZiAoIW5vZGUubG9jYWwuaXRlbXNNYXApIHtcbiAgICAgIG5vZGUubG9jYWwuaXRlbXNNYXAgPSBub2RlLmNvbW1vbi5pdGVtc01hcDtcbiAgICB9XG4gICAgbm9kZS5sb2NhbC5pdGVtc01hcFtpdGVtTmFtZV0gPSB0cnVlO1xuXG4gICAgcmV0dXJuIG5vZGU7XG4gIH1cblxuICB2YXIgbWV0aG9kcyA9IHtcblxuICAgIC8vIFRPRE86IGltcHJvdmUgb3VyIGNvZGUgc3RydWN0dXJlIHNvIHRoYXQgdGhpcyBmdW5jdGlvblxuICAgIC8vIGNvdWxkIGNhbGwgc3luYy5xdWV1ZUdldFJlcXVlc3QgZGlyZWN0bHkgaW5zdGVhZCBvZiBuZWVkaW5nXG4gICAgLy8gdGhpcyBoYWNreSB0aGlyZCBwYXJhbWV0ZXIgYXMgYSBjYWxsYmFja1xuICAgIGdldDogZnVuY3Rpb24gKHBhdGgsIG1heEFnZSwgcXVldWVHZXRSZXF1ZXN0KSB7XG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICBpZiAodHlwZW9mKG1heEFnZSkgPT09ICdudW1iZXInKSB7XG4gICAgICAgIHJldHVybiBzZWxmLmdldE5vZGVzKHBhdGhzRnJvbVJvb3QocGF0aCkpXG4gICAgICAgIC50aGVuKGZ1bmN0aW9uIChvYmpzKSB7XG4gICAgICAgICAgdmFyIG5vZGUgPSBnZXRMYXRlc3Qob2Jqc1twYXRoXSk7XG4gICAgICAgICAgaWYgKGlzT3V0ZGF0ZWQob2JqcywgbWF4QWdlKSkge1xuICAgICAgICAgICAgcmV0dXJuIHF1ZXVlR2V0UmVxdWVzdChwYXRoKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKG5vZGUpIHtcbiAgICAgICAgICAgIHJldHVybiB7c3RhdHVzQ29kZTogMjAwLCBib2R5OiBub2RlLmJvZHkgfHwgbm9kZS5pdGVtc01hcCwgY29udGVudFR5cGU6IG5vZGUuY29udGVudFR5cGV9O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4ge3N0YXR1c0NvZGU6IDQwNH07XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBzZWxmLmdldE5vZGVzKFtwYXRoXSlcbiAgICAgICAgLnRoZW4oZnVuY3Rpb24gKG9ianMpIHtcbiAgICAgICAgICB2YXIgbm9kZSA9IGdldExhdGVzdChvYmpzW3BhdGhdKTtcbiAgICAgICAgICBpZiAobm9kZSkge1xuICAgICAgICAgICAgaWYgKGlzRm9sZGVyKHBhdGgpKSB7XG4gICAgICAgICAgICAgIGZvciAodmFyIGkgaW4gbm9kZS5pdGVtc01hcCkge1xuICAgICAgICAgICAgICAgIC8vIHRoZSBoYXNPd25Qcm9wZXJ0eSBjaGVjayBoZXJlIGlzIG9ubHkgYmVjYXVzZSBvdXIganNoaW50IHNldHRpbmdzIHJlcXVpcmUgaXQ6XG4gICAgICAgICAgICAgICAgaWYgKG5vZGUuaXRlbXNNYXAuaGFzT3duUHJvcGVydHkoaSkgJiYgbm9kZS5pdGVtc01hcFtpXSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgIGRlbGV0ZSBub2RlLml0ZW1zTWFwW2ldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHtzdGF0dXNDb2RlOiAyMDAsIGJvZHk6IG5vZGUuYm9keSB8fCBub2RlLml0ZW1zTWFwLCBjb250ZW50VHlwZTogbm9kZS5jb250ZW50VHlwZX07XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB7c3RhdHVzQ29kZTogNDA0fTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBwdXQ6IGZ1bmN0aW9uIChwYXRoLCBib2R5LCBjb250ZW50VHlwZSkge1xuICAgICAgdmFyIHBhdGhzID0gcGF0aHNGcm9tUm9vdChwYXRoKTtcblxuICAgICAgZnVuY3Rpb24gX3Byb2Nlc3NOb2RlcyhwYXRocywgbm9kZXMpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gcGF0aHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBwYXRoID0gcGF0aHNbaV07XG4gICAgICAgICAgICB2YXIgbm9kZSA9IG5vZGVzW3BhdGhdO1xuICAgICAgICAgICAgdmFyIHByZXZpb3VzO1xuXG4gICAgICAgICAgICBpZiAoIW5vZGUpIHtcbiAgICAgICAgICAgICAgbm9kZXNbcGF0aF0gPSBub2RlID0gbWFrZU5vZGUocGF0aCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIERvY3VtZW50XG4gICAgICAgICAgICBpZiAoaSA9PT0gMCkge1xuICAgICAgICAgICAgICBwcmV2aW91cyA9IGdldExhdGVzdChub2RlKTtcbiAgICAgICAgICAgICAgbm9kZS5sb2NhbCA9IHtcbiAgICAgICAgICAgICAgICBib2R5OiAgICAgICAgICAgICAgICBib2R5LFxuICAgICAgICAgICAgICAgIGNvbnRlbnRUeXBlOiAgICAgICAgIGNvbnRlbnRUeXBlLFxuICAgICAgICAgICAgICAgIHByZXZpb3VzQm9keTogICAgICAgIChwcmV2aW91cyA/IHByZXZpb3VzLmJvZHkgOiB1bmRlZmluZWQpLFxuICAgICAgICAgICAgICAgIHByZXZpb3VzQ29udGVudFR5cGU6IChwcmV2aW91cyA/IHByZXZpb3VzLmNvbnRlbnRUeXBlIDogdW5kZWZpbmVkKSxcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEZvbGRlclxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgIHZhciBpdGVtTmFtZSA9IHBhdGhzW2ktMV0uc3Vic3RyaW5nKHBhdGgubGVuZ3RoKTtcbiAgICAgICAgICAgICAgbm9kZSA9IHVwZGF0ZUZvbGRlck5vZGVXaXRoSXRlbU5hbWUobm9kZSwgaXRlbU5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbm9kZXM7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICBsb2coJ1tDYWNoaW5nbGF5ZXJdIEVycm9yIGR1cmluZyBQVVQnLCBub2RlcywgZSk7XG4gICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuX3VwZGF0ZU5vZGVzKHBhdGhzLCBfcHJvY2Vzc05vZGVzKTtcbiAgICB9LFxuXG4gICAgZGVsZXRlOiBmdW5jdGlvbiAocGF0aCkge1xuICAgICAgdmFyIHBhdGhzID0gcGF0aHNGcm9tUm9vdChwYXRoKTtcblxuICAgICAgcmV0dXJuIHRoaXMuX3VwZGF0ZU5vZGVzKHBhdGhzLCBmdW5jdGlvbiAocGF0aHMsIG5vZGVzKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBwYXRocy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgIHZhciBwYXRoID0gcGF0aHNbaV07XG4gICAgICAgICAgdmFyIG5vZGUgPSBub2Rlc1twYXRoXTtcbiAgICAgICAgICB2YXIgcHJldmlvdXM7XG4gICAgICAgICAgXG4gICAgICAgICAgaWYgKCFub2RlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBkZWxldGUgbm9uLWV4aXN0aW5nIG5vZGUgJytwYXRoKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoaSA9PT0gMCkge1xuICAgICAgICAgIC8vIERvY3VtZW50XG4gICAgICAgICAgICBwcmV2aW91cyA9IGdldExhdGVzdChub2RlKTtcbiAgICAgICAgICAgIG5vZGUubG9jYWwgPSB7XG4gICAgICAgICAgICAgIGJvZHk6ICAgICAgICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgICAgICBwcmV2aW91c0JvZHk6ICAgICAgICAocHJldmlvdXMgPyBwcmV2aW91cy5ib2R5IDogdW5kZWZpbmVkKSxcbiAgICAgICAgICAgICAgcHJldmlvdXNDb250ZW50VHlwZTogKHByZXZpb3VzID8gcHJldmlvdXMuY29udGVudFR5cGUgOiB1bmRlZmluZWQpLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIEZvbGRlclxuICAgICAgICAgICAgaWYgKCFub2RlLmxvY2FsKSB7XG4gICAgICAgICAgICAgIG5vZGUubG9jYWwgPSBkZWVwQ2xvbmUobm9kZS5jb21tb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGl0ZW1OYW1lID0gcGF0aHNbaS0xXS5zdWJzdHJpbmcocGF0aC5sZW5ndGgpO1xuICAgICAgICAgICAgZGVsZXRlIG5vZGUubG9jYWwuaXRlbXNNYXBbaXRlbU5hbWVdO1xuXG4gICAgICAgICAgICBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMobm9kZS5sb2NhbC5pdGVtc01hcCkubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAvLyBUaGlzIGZvbGRlciBzdGlsbCBjb250YWlucyBvdGhlciBpdGVtcywgZG9uJ3QgcmVtb3ZlIGFueSBmdXJ0aGVyIGFuY2VzdG9yc1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5vZGVzO1xuICAgICAgfSk7XG4gICAgfSxcbiAgICBmbHVzaDogZnVuY3Rpb24gKHBhdGgpIHtcbiAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgIHJldHVybiBzZWxmLl9nZXRBbGxEZXNjZW5kZW50UGF0aHMocGF0aCkudGhlbihmdW5jdGlvbiAocGF0aHMpIHtcbiAgICAgICAgcmV0dXJuIHNlbGYuZ2V0Tm9kZXMocGF0aHMpO1xuICAgICAgfSkudGhlbihmdW5jdGlvbiAobm9kZXMpIHtcbiAgICAgICAgZm9yICh2YXIgcGF0aCBpbiBub2Rlcykge1xuICAgICAgICAgIHZhciBub2RlID0gbm9kZXNbcGF0aF07XG5cbiAgICAgICAgICBpZiAobm9kZSAmJiBub2RlLmNvbW1vbiAmJiBub2RlLmxvY2FsKSB7XG4gICAgICAgICAgICBzZWxmLl9lbWl0Q2hhbmdlKHtcbiAgICAgICAgICAgICAgcGF0aDogICAgIG5vZGUucGF0aCxcbiAgICAgICAgICAgICAgb3JpZ2luOiAgICdsb2NhbCcsXG4gICAgICAgICAgICAgIG9sZFZhbHVlOiAobm9kZS5sb2NhbC5ib2R5ID09PSBmYWxzZSA/IHVuZGVmaW5lZCA6IG5vZGUubG9jYWwuYm9keSksXG4gICAgICAgICAgICAgIG5ld1ZhbHVlOiAobm9kZS5jb21tb24uYm9keSA9PT0gZmFsc2UgPyB1bmRlZmluZWQgOiBub2RlLmNvbW1vbi5ib2R5KVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIG5vZGVzW3BhdGhdID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzZWxmLnNldE5vZGVzKG5vZGVzKTtcbiAgICAgIH0pO1xuICAgIH0sXG5cbiAgICBfZW1pdENoYW5nZTogZnVuY3Rpb24gKG9iaikge1xuICAgICAgaWYgKGNvbmZpZy5jaGFuZ2VFdmVudHNbb2JqLm9yaWdpbl0pIHtcbiAgICAgICAgdGhpcy5fZW1pdCgnY2hhbmdlJywgb2JqKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgZmlyZUluaXRpYWw6IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICghY29uZmlnLmNoYW5nZUV2ZW50cy5sb2NhbCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICBzZWxmLmZvckFsbE5vZGVzKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgIHZhciBsYXRlc3Q7XG4gICAgICAgIGlmIChpc0RvY3VtZW50KG5vZGUucGF0aCkpIHtcbiAgICAgICAgICBsYXRlc3QgPSBnZXRMYXRlc3Qobm9kZSk7XG4gICAgICAgICAgaWYgKGxhdGVzdCkge1xuICAgICAgICAgICAgc2VsZi5fZW1pdENoYW5nZSh7XG4gICAgICAgICAgICAgIHBhdGg6ICAgICAgICAgICBub2RlLnBhdGgsXG4gICAgICAgICAgICAgIG9yaWdpbjogICAgICAgICAnbG9jYWwnLFxuICAgICAgICAgICAgICBvbGRWYWx1ZTogICAgICAgdW5kZWZpbmVkLFxuICAgICAgICAgICAgICBvbGRDb250ZW50VHlwZTogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICBuZXdWYWx1ZTogICAgICAgbGF0ZXN0LmJvZHksXG4gICAgICAgICAgICAgIG5ld0NvbnRlbnRUeXBlOiBsYXRlc3QuY29udGVudFR5cGVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgIHNlbGYuX2VtaXQoJ2xvY2FsLWV2ZW50cy1kb25lJyk7XG4gICAgICB9KTtcbiAgICB9LFxuXG4gICAgb25EaWZmOiBmdW5jdGlvbiAoZGlmZkhhbmRsZXIpIHtcbiAgICAgIHRoaXMuZGlmZkhhbmRsZXIgPSBkaWZmSGFuZGxlcjtcbiAgICB9LFxuXG4gICAgbWlncmF0ZTogZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgIGlmICh0eXBlb2Yobm9kZSkgPT09ICdvYmplY3QnICYmICFub2RlLmNvbW1vbikge1xuICAgICAgICBub2RlLmNvbW1vbiA9IHt9O1xuICAgICAgICBpZiAodHlwZW9mKG5vZGUucGF0aCkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgaWYgKG5vZGUucGF0aC5zdWJzdHIoLTEpID09PSAnLycgJiYgdHlwZW9mKG5vZGUuYm9keSkgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICBub2RlLmNvbW1vbi5pdGVtc01hcCA9IG5vZGUuYm9keTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy9zYXZlIGxlZ2FjeSBjb250ZW50IG9mIGRvY3VtZW50IG5vZGUgYXMgbG9jYWwgdmVyc2lvblxuICAgICAgICAgIGlmICghbm9kZS5sb2NhbCkge1xuICAgICAgICAgICAgbm9kZS5sb2NhbCA9IHt9O1xuICAgICAgICAgIH1cbiAgICAgICAgICBub2RlLmxvY2FsLmJvZHkgPSBub2RlLmJvZHk7XG4gICAgICAgICAgbm9kZS5sb2NhbC5jb250ZW50VHlwZSA9IG5vZGUuY29udGVudFR5cGU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBub2RlO1xuICAgIH0sXG5cbiAgICAvLyBGSVhNRVxuICAgIC8vIHRoaXMgcHJvY2VzcyBvZiB1cGRhdGluZyBub2RlcyBuZWVkcyB0byBiZSBoZWF2aWx5IGRvY3VtZW50ZWQgZmlyc3QsIHRoZW5cbiAgICAvLyByZWZhY3RvcmVkLiBSaWdodCBub3cgaXQncyBhbG1vc3QgaW1wb3NzaWJsZSB0byByZWZhY3RvciBhcyB0aGVyZSdzIG5vXG4gICAgLy8gZXhwbGFuYXRpb24gb2Ygd2h5IHRoaW5ncyBhcmUgaW1wbGVtZW50ZWQgY2VydGFpbiB3YXlzIG9yIHdoYXQgdGhlIGdvYWwocylcbiAgICAvLyBvZiB0aGUgYmVoYXZpb3IgYXJlLiAtc2x2cmJja3QgKCsxIC1sZXMpXG4gICAgX3VwZGF0ZU5vZGVzUnVubmluZzogZmFsc2UsXG4gICAgX3VwZGF0ZU5vZGVzUXVldWVkOiBbXSxcbiAgICBfdXBkYXRlTm9kZXM6IGZ1bmN0aW9uIChwYXRocywgX3Byb2Nlc3NOb2Rlcykge1xuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICB0aGlzLl9kb1VwZGF0ZU5vZGVzKHBhdGhzLCBfcHJvY2Vzc05vZGVzLCB7XG4gICAgICAgICAgcmVzb2x2ZTogcmVzb2x2ZSxcbiAgICAgICAgICByZWplY3Q6IHJlamVjdFxuICAgICAgICB9KTtcbiAgICAgIH0uYmluZCh0aGlzKSk7XG4gICAgfSxcbiAgICBfZG9VcGRhdGVOb2RlczogZnVuY3Rpb24gKHBhdGhzLCBfcHJvY2Vzc05vZGVzLCBwcm9taXNlKSB7XG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAgIGlmIChzZWxmLl91cGRhdGVOb2Rlc1J1bm5pbmcpIHtcbiAgICAgICAgc2VsZi5fdXBkYXRlTm9kZXNRdWV1ZWQucHVzaCh7XG4gICAgICAgICAgcGF0aHM6IHBhdGhzLFxuICAgICAgICAgIGNiOiBfcHJvY2Vzc05vZGVzLFxuICAgICAgICAgIHByb21pc2U6IHByb21pc2VcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNlbGYuX3VwZGF0ZU5vZGVzUnVubmluZyA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIHNlbGYuZ2V0Tm9kZXMocGF0aHMpLnRoZW4oZnVuY3Rpb24gKG5vZGVzKSB7XG4gICAgICAgIHZhciBleGlzdGluZ05vZGVzID0gZGVlcENsb25lKG5vZGVzKTtcbiAgICAgICAgdmFyIGNoYW5nZUV2ZW50cyA9IFtdO1xuICAgICAgICB2YXIgbm9kZTtcbiAgICAgICAgdmFyIGVxdWFsID0gdXRpbC5lcXVhbDtcblxuICAgICAgICBub2RlcyA9IF9wcm9jZXNzTm9kZXMocGF0aHMsIG5vZGVzKTtcblxuICAgICAgICBmb3IgKHZhciBwYXRoIGluIG5vZGVzKSB7XG4gICAgICAgICAgbm9kZSA9IG5vZGVzW3BhdGhdO1xuICAgICAgICAgIGlmIChlcXVhbChub2RlLCBleGlzdGluZ05vZGVzW3BhdGhdKSkge1xuICAgICAgICAgICAgZGVsZXRlIG5vZGVzW3BhdGhdO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIGlmIChpc0RvY3VtZW50KHBhdGgpKSB7XG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICFlcXVhbChub2RlLmxvY2FsLmJvZHksIG5vZGUubG9jYWwucHJldmlvdXNCb2R5KSB8fFxuICAgICAgICAgICAgICBub2RlLmxvY2FsLmNvbnRlbnRUeXBlICE9PSBub2RlLmxvY2FsLnByZXZpb3VzQ29udGVudFR5cGVcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICBjaGFuZ2VFdmVudHMucHVzaCh7XG4gICAgICAgICAgICAgICAgcGF0aDogICAgICAgICAgIHBhdGgsXG4gICAgICAgICAgICAgICAgb3JpZ2luOiAgICAgICAgICd3aW5kb3cnLFxuICAgICAgICAgICAgICAgIG9sZFZhbHVlOiAgICAgICBub2RlLmxvY2FsLnByZXZpb3VzQm9keSxcbiAgICAgICAgICAgICAgICBuZXdWYWx1ZTogICAgICAgbm9kZS5sb2NhbC5ib2R5ID09PSBmYWxzZSA/IHVuZGVmaW5lZCA6IG5vZGUubG9jYWwuYm9keSxcbiAgICAgICAgICAgICAgICBvbGRDb250ZW50VHlwZTogbm9kZS5sb2NhbC5wcmV2aW91c0NvbnRlbnRUeXBlLFxuICAgICAgICAgICAgICAgIG5ld0NvbnRlbnRUeXBlOiBub2RlLmxvY2FsLmNvbnRlbnRUeXBlXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGVsZXRlIG5vZGUubG9jYWwucHJldmlvdXNCb2R5O1xuICAgICAgICAgICAgZGVsZXRlIG5vZGUubG9jYWwucHJldmlvdXNDb250ZW50VHlwZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBzZWxmLnNldE5vZGVzKG5vZGVzKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBzZWxmLl9lbWl0Q2hhbmdlRXZlbnRzKGNoYW5nZUV2ZW50cyk7XG4gICAgICAgICAgcHJvbWlzZS5yZXNvbHZlKHtzdGF0dXNDb2RlOiAyMDB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9KS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgICAgfSwgZnVuY3Rpb24gKGVycikge1xuICAgICAgICBwcm9taXNlLnJlamVjdChlcnIpO1xuICAgICAgfSkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgIHNlbGYuX3VwZGF0ZU5vZGVzUnVubmluZyA9IGZhbHNlO1xuICAgICAgICB2YXIgbmV4dEpvYiA9IHNlbGYuX3VwZGF0ZU5vZGVzUXVldWVkLnNoaWZ0KCk7XG4gICAgICAgIGlmIChuZXh0Sm9iKSB7XG4gICAgICAgICAgc2VsZi5fZG9VcGRhdGVOb2RlcyhuZXh0Sm9iLnBhdGhzLCBuZXh0Sm9iLmNiLCBuZXh0Sm9iLnByb21pc2UpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9LFxuXG4gICAgX2VtaXRDaGFuZ2VFdmVudHM6IGZ1bmN0aW9uIChldmVudHMpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBldmVudHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgdGhpcy5fZW1pdENoYW5nZShldmVudHNbaV0pO1xuICAgICAgICBpZiAodGhpcy5kaWZmSGFuZGxlcikge1xuICAgICAgICAgIHRoaXMuZGlmZkhhbmRsZXIoZXZlbnRzW2ldLnBhdGgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIF9nZXRBbGxEZXNjZW5kZW50UGF0aHM6IGZ1bmN0aW9uIChwYXRoKSB7XG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICBpZiAoaXNGb2xkZXIocGF0aCkpIHtcbiAgICAgICAgcmV0dXJuIHNlbGYuZ2V0Tm9kZXMoW3BhdGhdKS50aGVuKGZ1bmN0aW9uIChub2Rlcykge1xuICAgICAgICAgIHZhciBhbGxQYXRocyA9IFtwYXRoXTtcbiAgICAgICAgICB2YXIgbGF0ZXN0ID0gZ2V0TGF0ZXN0KG5vZGVzW3BhdGhdKTtcblxuICAgICAgICAgIHZhciBpdGVtTmFtZXMgPSBPYmplY3Qua2V5cyhsYXRlc3QuaXRlbXNNYXApO1xuICAgICAgICAgIHZhciBjYWxscyA9IGl0ZW1OYW1lcy5tYXAoZnVuY3Rpb24gKGl0ZW1OYW1lKSB7XG4gICAgICAgICAgICByZXR1cm4gc2VsZi5fZ2V0QWxsRGVzY2VuZGVudFBhdGhzKHBhdGgraXRlbU5hbWUpLnRoZW4oZnVuY3Rpb24gKHBhdGhzKSB7XG4gICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBwYXRocy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgIGFsbFBhdGhzLnB1c2gocGF0aHNbaV0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwoY2FsbHMpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIGFsbFBhdGhzO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoW3BhdGhdKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgX2dldEludGVybmFsczogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZ2V0TGF0ZXN0OiBnZXRMYXRlc3QsXG4gICAgICAgIG1ha2VOb2RlOiBtYWtlTm9kZSxcbiAgICAgICAgaXNPdXRkYXRlZDogaXNPdXRkYXRlZFxuICAgICAgfTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEZ1bmN0aW9uOiBjYWNoaW5nTGF5ZXJcbiAgICpcbiAgICogTWl4ZXMgY29tbW9uIGNhY2hpbmcgbGF5ZXIgZnVuY3Rpb25hbGl0eSBpbnRvIGFuIG9iamVjdC5cbiAgICpcbiAgICogVGhlIGZpcnN0IHBhcmFtZXRlciBpcyBhbHdheXMgdGhlIG9iamVjdCB0byBiZSBleHRlbmRlZC5cbiAgICpcbiAgICogRXhhbXBsZTpcbiAgICogICAoc3RhcnQgY29kZSlcbiAgICogICB2YXIgTXlDb25zdHJ1Y3RvciA9IGZ1bmN0aW9uICgpIHtcbiAgICogICAgIGNhY2hpbmdMYXllcih0aGlzKTtcbiAgICogICB9O1xuICAgKiAgIChlbmQgY29kZSlcbiAgICovXG4gIHZhciBjYWNoaW5nTGF5ZXIgPSBmdW5jdGlvbiAob2JqZWN0KSB7XG4gICAgZm9yICh2YXIga2V5IGluIG1ldGhvZHMpIHtcbiAgICAgIG9iamVjdFtrZXldID0gbWV0aG9kc1trZXldO1xuICAgIH1cbiAgfTtcblxuICBtb2R1bGUuZXhwb3J0cyA9IGNhY2hpbmdMYXllcjtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9jYWNoaW5nbGF5ZXIuanMiXSwic291cmNlUm9vdCI6IiJ9");
},function(module,exports,__webpack_require__){eval("'use strict';\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar util = __webpack_require__(2);\nvar Env = __webpack_require__(14);\nvar eventHandling = __webpack_require__(3);\nvar log = __webpack_require__(1);\nvar Authorize = __webpack_require__(4);\nvar config = __webpack_require__(5);\n\nvar isFolder = util.isFolder;\nvar isDocument = util.isDocument;\nvar equal = util.equal;\nvar deepClone = util.deepClone;\nvar pathsFromRoot = util.pathsFromRoot;\n\nfunction taskFor(action, path, promise) {\n  return {\n    action: action,\n    path: path,\n    promise: promise\n  };\n}\n\nfunction isStaleChild(node) {\n  return node.remote && node.remote.revision && !node.remote.itemsMap && !node.remote.body;\n}\n\nfunction hasCommonRevision(node) {\n  return node.common && node.common.revision;\n}\n\nfunction handleVisibility() {\n  var rs = this;\n\n  function handleVisibilityChange(fg) {\n    var oldValue, newValue;\n    oldValue = rs.getCurrentSyncInterval();\n    config.isBackground = !fg;\n    newValue = rs.getCurrentSyncInterval();\n    rs._emit('sync-interval-change', { oldValue: oldValue, newValue: newValue });\n  }\n\n  Env.on(\"background\", function () {\n    handleVisibilityChange(false);\n  });\n\n  Env.on(\"foreground\", function () {\n    handleVisibilityChange(true);\n  });\n}\n\n/**\n * Class: RemoteStorage.Sync\n *\n * What this class does is basically six things:\n * - retrieving the remote version of relevant documents and folders\n * - add all local and remote documents together into one tree\n * - push local documents out if they don't exist remotely\n * - push local changes out to remote documents (conditionally, to\n *      avoid race conditions where both have changed)\n * - adopt the local version of a document to its remote version if\n *      both exist and they differ\n * - delete the local version of a document if it was deleted remotely\n * - if any get requests were waiting for remote data, resolve them once\n *      this data comes in.\n *\n * It does this using requests to documents, and to folders. Whenever a\n * folder GET comes in, it gives information about all the documents it\n * contains (this is the `markChildren` function).\n **/\nvar Sync = function Sync(remoteStorage, setLocal, setRemote, setAccess, setCaching) {\n  this.remoteStorage = remoteStorage;\n  this.local = setLocal;\n  this.local.onDiff(function (path) {\n    this.addTask(path);\n    this.doTasks();\n  }.bind(this));\n  this.remote = setRemote;\n  this.access = setAccess;\n  this.caching = setCaching;\n  this._tasks = {};\n  this._running = {};\n  this._timeStarted = {};\n  eventHandling(this, 'done', 'req-done');\n  this.caching.onActivate(function (path) {\n    this.addTask(path);\n    this.doTasks();\n  }.bind(this));\n};\n\nSync.prototype = {\n\n  now: function now() {\n    return new Date().getTime();\n  },\n\n  queueGetRequest: function queueGetRequest(path) {\n    var _this = this;\n\n    return new Promise(function (resolve, reject) {\n      if (!_this.remote.connected) {\n        reject('cannot fulfill maxAge requirement - remote is not connected');\n      } else if (!_this.remote.online) {\n        reject('cannot fulfill maxAge requirement - remote is not online');\n      } else {\n        _this.addTask(path, function () {\n          this.local.get(path).then(function (r) {\n            return resolve(r);\n          });\n        }.bind(_this));\n\n        _this.doTasks();\n      }\n    });\n  },\n\n  corruptServerItemsMap: function corruptServerItemsMap(itemsMap, force02) {\n    if ((typeof itemsMap === 'undefined' ? 'undefined' : _typeof(itemsMap)) !== 'object' || Array.isArray(itemsMap)) {\n      return true;\n    }\n\n    for (var itemName in itemsMap) {\n      var item = itemsMap[itemName];\n\n      if ((typeof item === 'undefined' ? 'undefined' : _typeof(item)) !== 'object') {\n        return true;\n      }\n      if (typeof item.ETag !== 'string') {\n        return true;\n      }\n      if (isFolder(itemName)) {\n        if (itemName.substring(0, itemName.length - 1).indexOf('/') !== -1) {\n          return true;\n        }\n      } else {\n        if (itemName.indexOf('/') !== -1) {\n          return true;\n        }\n        if (force02) {\n          if (typeof item['Content-Type'] !== 'string') {\n            return true;\n          }\n          if (typeof item['Content-Length'] !== 'number') {\n            return true;\n          }\n        }\n      }\n    }\n\n    return false;\n  },\n\n  corruptItemsMap: function corruptItemsMap(itemsMap) {\n    if ((typeof itemsMap === 'undefined' ? 'undefined' : _typeof(itemsMap)) !== 'object' || Array.isArray(itemsMap)) {\n      return true;\n    }\n\n    for (var itemName in itemsMap) {\n      if (typeof itemsMap[itemName] !== 'boolean') {\n        return true;\n      }\n    }\n\n    return false;\n  },\n\n  corruptRevision: function corruptRevision(rev) {\n    return (typeof rev === 'undefined' ? 'undefined' : _typeof(rev)) !== 'object' || Array.isArray(rev) || rev.revision && typeof rev.revision !== 'string' || rev.body && typeof rev.body !== 'string' && _typeof(rev.body) !== 'object' || rev.contentType && typeof rev.contentType !== 'string' || rev.contentLength && typeof rev.contentLength !== 'number' || rev.timestamp && typeof rev.timestamp !== 'number' || rev.itemsMap && this.corruptItemsMap(rev.itemsMap);\n  },\n\n  isCorrupt: function isCorrupt(node) {\n    return (typeof node === 'undefined' ? 'undefined' : _typeof(node)) !== 'object' || Array.isArray(node) || typeof node.path !== 'string' || this.corruptRevision(node.common) || node.local && this.corruptRevision(node.local) || node.remote && this.corruptRevision(node.remote) || node.push && this.corruptRevision(node.push);\n  },\n\n  hasTasks: function hasTasks() {\n    return Object.getOwnPropertyNames(this._tasks).length > 0;\n  },\n\n  collectDiffTasks: function collectDiffTasks() {\n    var num = 0;\n\n    return this.local.forAllNodes(function (node) {\n\n      if (num > 100) {\n        return;\n      }\n\n      if (this.isCorrupt(node)) {\n        log('[Sync] WARNING: corrupt node in local cache', node);\n        if ((typeof node === 'undefined' ? 'undefined' : _typeof(node)) === 'object' && node.path) {\n          this.addTask(node.path);\n          num++;\n        }\n      } else if (this.needsFetch(node) && this.access.checkPathPermission(node.path, 'r')) {\n        this.addTask(node.path);\n        num++;\n      } else if (isDocument(node.path) && this.needsPush(node) && this.access.checkPathPermission(node.path, 'rw')) {\n        this.addTask(node.path);\n        num++;\n      }\n    }.bind(this)).then(function () {\n      return num;\n    }, function (err) {\n      throw err;\n    });\n  },\n\n  inConflict: function inConflict(node) {\n    return node.local && node.remote && (node.remote.body !== undefined || node.remote.itemsMap);\n  },\n\n  needsRefresh: function needsRefresh(node) {\n    if (node.common) {\n      if (!node.common.timestamp) {\n        return true;\n      }\n      return this.now() - node.common.timestamp > config.syncInterval;\n    }\n    return false;\n  },\n\n  needsFetch: function needsFetch(node) {\n    if (this.inConflict(node)) {\n      return true;\n    }\n    if (node.common && node.common.itemsMap === undefined && node.common.body === undefined) {\n      return true;\n    }\n    if (node.remote && node.remote.itemsMap === undefined && node.remote.body === undefined) {\n      return true;\n    }\n    return false;\n  },\n\n  needsPush: function needsPush(node) {\n    if (this.inConflict(node)) {\n      return false;\n    }\n    if (node.local && !node.push) {\n      return true;\n    }\n  },\n\n  needsRemotePut: function needsRemotePut(node) {\n    return node.local && node.local.body;\n  },\n\n  needsRemoteDelete: function needsRemoteDelete(node) {\n    return node.local && node.local.body === false;\n  },\n\n  getParentPath: function getParentPath(path) {\n    var parts = path.match(/^(.*\\/)([^\\/]+\\/?)$/);\n\n    if (parts) {\n      return parts[1];\n    } else {\n      throw new Error('Not a valid path: \"' + path + '\"');\n    }\n  },\n\n  deleteChildPathsFromTasks: function deleteChildPathsFromTasks() {\n    for (var path in this._tasks) {\n      var paths = pathsFromRoot(path);\n\n      for (var i = 1; i < paths.length; i++) {\n        if (this._tasks[paths[i]]) {\n          // move pending promises to parent task\n          if (Array.isArray(this._tasks[path]) && this._tasks[path].length) {\n            Array.prototype.push.apply(this._tasks[paths[i]], this._tasks[path]);\n          }\n          delete this._tasks[path];\n        }\n      }\n    }\n  },\n\n  collectRefreshTasks: function collectRefreshTasks() {\n    return this.local.forAllNodes(function (node) {\n      var parentPath;\n      if (this.needsRefresh(node)) {\n        try {\n          parentPath = this.getParentPath(node.path);\n        } catch (e) {\n          // node.path is already '/', can't take parentPath\n        }\n        if (parentPath && this.access.checkPathPermission(parentPath, 'r')) {\n          this.addTask(parentPath);\n        } else if (this.access.checkPathPermission(node.path, 'r')) {\n          this.addTask(node.path);\n        }\n      }\n    }.bind(this)).then(function () {\n      this.deleteChildPathsFromTasks();\n    }.bind(this), function (err) {\n      throw err;\n    });\n  },\n\n  flush: function flush(nodes) {\n    for (var path in nodes) {\n      // Strategy is 'FLUSH' and no local changes exist\n      if (this.caching.checkPath(path) === 'FLUSH' && nodes[path] && !nodes[path].local) {\n        log('[Sync] Flushing', path);\n        nodes[path] = undefined; // Cause node to be flushed from cache\n      }\n    }\n    return nodes;\n  },\n\n  doTask: function doTask(path) {\n    return this.local.getNodes([path]).then(function (nodes) {\n      var node = nodes[path];\n      // First fetch:\n      if (typeof node === 'undefined') {\n        return taskFor('get', path, this.remote.get(path));\n      }\n      // Fetch known-stale child:\n      else if (isStaleChild(node)) {\n          return taskFor('get', path, this.remote.get(path));\n        }\n        // Push PUT:\n        else if (this.needsRemotePut(node)) {\n            node.push = deepClone(node.local);\n            node.push.timestamp = this.now();\n\n            return this.local.setNodes(this.flush(nodes)).then(function () {\n              var options;\n              if (hasCommonRevision(node)) {\n                options = { ifMatch: node.common.revision };\n              } else {\n                // Initial PUT (fail if something is already there)\n                options = { ifNoneMatch: '*' };\n              }\n\n              return taskFor('put', path, this.remote.put(path, node.push.body, node.push.contentType, options));\n            }.bind(this));\n          }\n          // Push DELETE:\n          else if (this.needsRemoteDelete(node)) {\n              node.push = { body: false, timestamp: this.now() };\n\n              return this.local.setNodes(this.flush(nodes)).then(function () {\n                if (hasCommonRevision(node)) {\n                  return taskFor('delete', path, this.remote.delete(path, { ifMatch: node.common.revision }));\n                } else {\n                  // Ascertain current common or remote revision first\n                  return taskFor('get', path, this.remote.get(path));\n                }\n              }.bind(this));\n            }\n            // Conditional refresh:\n            else if (hasCommonRevision(node)) {\n                return taskFor('get', path, this.remote.get(path, { ifNoneMatch: node.common.revision }));\n              } else {\n                return taskFor('get', path, this.remote.get(path));\n              }\n    }.bind(this));\n  },\n\n  autoMergeFolder: function autoMergeFolder(node) {\n    if (node.remote.itemsMap) {\n      node.common = node.remote;\n      delete node.remote;\n\n      if (node.common.itemsMap) {\n        for (var itemName in node.common.itemsMap) {\n          if (!node.local.itemsMap[itemName]) {\n            // Indicates the node is either newly being fetched\n            // has been deleted locally (whether or not leading to conflict);\n            // before listing it in local listings, check if a local deletion\n            // exists.\n            node.local.itemsMap[itemName] = false;\n          }\n        }\n\n        if (equal(node.local.itemsMap, node.common.itemsMap)) {\n          delete node.local;\n        }\n      }\n    }\n    return node;\n  },\n\n  autoMergeDocument: function autoMergeDocument(node) {\n    hasNoRemoteChanges = function hasNoRemoteChanges(node) {\n      if (node.remote && node.remote.revision && node.remote.revision !== node.common.revision) {\n        return false;\n      }\n      return node.common.body === undefined && node.remote.body === false || node.remote.body === node.common.body && node.remote.contentType === node.common.contentType;\n    };\n    mergeMutualDeletion = function mergeMutualDeletion(node) {\n      if (node.remote && node.remote.body === false && node.local && node.local.body === false) {\n        delete node.local;\n      }\n      return node;\n    };\n\n    if (hasNoRemoteChanges(node)) {\n      node = mergeMutualDeletion(node);\n      delete node.remote;\n    } else if (node.remote.body !== undefined) {\n      // keep/revert:\n      log('[Sync] Emitting keep/revert');\n\n      this.local._emitChange({\n        origin: 'conflict',\n        path: node.path,\n        oldValue: node.local.body,\n        newValue: node.remote.body,\n        lastCommonValue: node.common.body,\n        oldContentType: node.local.contentType,\n        newContentType: node.remote.contentType,\n        lastCommonContentType: node.common.contentType\n      });\n\n      if (node.remote.body) {\n        node.common = node.remote;\n      } else {\n        node.common = {};\n      }\n      delete node.remote;\n      delete node.local;\n    }\n    return node;\n  },\n\n  autoMerge: function autoMerge(node) {\n    if (node.remote) {\n      if (node.local) {\n        if (isFolder(node.path)) {\n          return this.autoMergeFolder(node);\n        } else {\n          return this.autoMergeDocument(node);\n        }\n      } else {\n        // no local changes\n        if (isFolder(node.path)) {\n          if (node.remote.itemsMap !== undefined) {\n            node.common = node.remote;\n            delete node.remote;\n          }\n        } else {\n          if (node.remote.body !== undefined) {\n            var change = {\n              origin: 'remote',\n              path: node.path,\n              oldValue: node.common.body === false ? undefined : node.common.body,\n              newValue: node.remote.body === false ? undefined : node.remote.body,\n              oldContentType: node.common.contentType,\n              newContentType: node.remote.contentType\n            };\n            if (change.oldValue || change.newValue) {\n              this.local._emitChange(change);\n            }\n\n            if (!node.remote.body) {\n              // no remote, so delete/don't create\n              return;\n            }\n\n            node.common = node.remote;\n            delete node.remote;\n          }\n        }\n      }\n    } else {\n      if (node.common.body) {\n        this.local._emitChange({\n          origin: 'remote',\n          path: node.path,\n          oldValue: node.common.body,\n          newValue: undefined,\n          oldContentType: node.common.contentType,\n          newContentType: undefined\n        });\n      }\n\n      return undefined;\n    }\n    return node;\n  },\n\n  updateCommonTimestamp: function updateCommonTimestamp(path, revision) {\n    return this.local.getNodes([path]).then(function (nodes) {\n      if (nodes[path] && nodes[path].common && nodes[path].common.revision === revision) {\n        nodes[path].common.timestamp = this.now();\n      }\n      return this.local.setNodes(this.flush(nodes));\n    }.bind(this));\n  },\n\n  markChildren: function markChildren(path, itemsMap, changedNodes, missingChildren) {\n    var paths = [];\n    var meta = {};\n    var recurse = {};\n\n    for (var item in itemsMap) {\n      paths.push(path + item);\n      meta[path + item] = itemsMap[item];\n    }\n    for (var childName in missingChildren) {\n      paths.push(path + childName);\n    }\n\n    return this.local.getNodes(paths).then(function (nodes) {\n      var cachingStrategy;\n      var node;\n\n      var nodeChanged = function nodeChanged(node, etag) {\n        return node.common.revision !== etag && (!node.remote || node.remote.revision !== etag);\n      };\n\n      for (var nodePath in nodes) {\n        node = nodes[nodePath];\n\n        if (meta[nodePath]) {\n          if (node && node.common) {\n            if (nodeChanged(node, meta[nodePath].ETag)) {\n              changedNodes[nodePath] = deepClone(node);\n              changedNodes[nodePath].remote = {\n                revision: meta[nodePath].ETag,\n                timestamp: this.now()\n              };\n              changedNodes[nodePath] = this.autoMerge(changedNodes[nodePath]);\n            }\n          } else {\n            cachingStrategy = this.caching.checkPath(nodePath);\n            if (cachingStrategy === 'ALL') {\n              changedNodes[nodePath] = {\n                path: nodePath,\n                common: {\n                  timestamp: this.now()\n                },\n                remote: {\n                  revision: meta[nodePath].ETag,\n                  timestamp: this.now()\n                }\n              };\n            }\n          }\n\n          if (changedNodes[nodePath] && meta[nodePath]['Content-Type']) {\n            changedNodes[nodePath].remote.contentType = meta[nodePath]['Content-Type'];\n          }\n\n          if (changedNodes[nodePath] && meta[nodePath]['Content-Length']) {\n            changedNodes[nodePath].remote.contentLength = meta[nodePath]['Content-Length'];\n          }\n        } else if (missingChildren[nodePath.substring(path.length)] && node && node.common) {\n          if (node.common.itemsMap) {\n            for (var commonItem in node.common.itemsMap) {\n              recurse[nodePath + commonItem] = true;\n            }\n          }\n\n          if (node.local && node.local.itemsMap) {\n            for (var localItem in node.local.itemsMap) {\n              recurse[nodePath + localItem] = true;\n            }\n          }\n\n          if (node.remote || isFolder(nodePath)) {\n            changedNodes[nodePath] = undefined;\n          } else {\n            changedNodes[nodePath] = this.autoMerge(node);\n\n            if (typeof changedNodes[nodePath] === 'undefined') {\n              var parentPath = this.getParentPath(nodePath);\n              var parentNode = changedNodes[parentPath];\n              var itemName = nodePath.substring(path.length);\n              if (parentNode && parentNode.local) {\n                delete parentNode.local.itemsMap[itemName];\n\n                if (equal(parentNode.local.itemsMap, parentNode.common.itemsMap)) {\n                  delete parentNode.local;\n                }\n              }\n            }\n          }\n        }\n      }\n\n      return this.deleteRemoteTrees(Object.keys(recurse), changedNodes).then(function (changedObjs2) {\n        return this.local.setNodes(this.flush(changedObjs2));\n      }.bind(this));\n    }.bind(this));\n  },\n\n  deleteRemoteTrees: function deleteRemoteTrees(paths, changedNodes) {\n    if (paths.length === 0) {\n      return Promise.resolve(changedNodes);\n    }\n\n    return this.local.getNodes(paths).then(function (nodes) {\n      var subPaths = {};\n\n      collectSubPaths = function collectSubPaths(folder, path) {\n        if (folder && folder.itemsMap) {\n          for (var itemName in folder.itemsMap) {\n            subPaths[path + itemName] = true;\n          }\n        }\n      };\n\n      for (var path in nodes) {\n        var node = nodes[path];\n\n        // TODO Why check for the node here? I don't think this check ever applies\n        if (!node) {\n          continue;\n        }\n\n        if (isFolder(path)) {\n          collectSubPaths(node.common, path);\n          collectSubPaths(node.local, path);\n        } else {\n          if (node.common && _typeof(node.common.body) !== undefined) {\n            changedNodes[path] = deepClone(node);\n            changedNodes[path].remote = {\n              body: false,\n              timestamp: this.now()\n            };\n            changedNodes[path] = this.autoMerge(changedNodes[path]);\n          }\n        }\n      }\n\n      // Recurse whole tree depth levels at once:\n      return this.deleteRemoteTrees(Object.keys(subPaths), changedNodes).then(function (changedNodes2) {\n        return this.local.setNodes(this.flush(changedNodes2));\n      }.bind(this));\n    }.bind(this));\n  },\n\n  completeFetch: function completeFetch(path, bodyOrItemsMap, contentType, revision) {\n    var paths;\n    var parentPath;\n    var pathsFromRootArr = pathsFromRoot(path);\n\n    if (isFolder(path)) {\n      paths = [path];\n    } else {\n      parentPath = pathsFromRootArr[1];\n      paths = [path, parentPath];\n    }\n\n    return this.local.getNodes(paths).then(function (nodes) {\n      var itemName;\n      var missingChildren = {};\n      var node = nodes[path];\n      var parentNode;\n\n      var collectMissingChildren = function collectMissingChildren(folder) {\n        if (folder && folder.itemsMap) {\n          for (var itemName in folder.itemsMap) {\n            if (!bodyOrItemsMap[itemName]) {\n              missingChildren[itemName] = true;\n            }\n          }\n        }\n      };\n\n      if ((typeof node === 'undefined' ? 'undefined' : _typeof(node)) !== 'object' || node.path !== path || _typeof(node.common) !== 'object') {\n        node = {\n          path: path,\n          common: {}\n        };\n        nodes[path] = node;\n      }\n\n      node.remote = {\n        revision: revision,\n        timestamp: this.now()\n      };\n\n      if (isFolder(path)) {\n        collectMissingChildren(node.common);\n        collectMissingChildren(node.remote);\n\n        node.remote.itemsMap = {};\n        for (itemName in bodyOrItemsMap) {\n          node.remote.itemsMap[itemName] = true;\n        }\n      } else {\n        node.remote.body = bodyOrItemsMap;\n        node.remote.contentType = contentType;\n\n        parentNode = nodes[parentPath];\n        if (parentNode && parentNode.local && parentNode.local.itemsMap) {\n          itemName = path.substring(parentPath.length);\n          parentNode.local.itemsMap[itemName] = true;\n          if (equal(parentNode.local.itemsMap, parentNode.common.itemsMap)) {\n            delete parentNode.local;\n          }\n        }\n      }\n\n      nodes[path] = this.autoMerge(node);\n      return {\n        toBeSaved: nodes,\n        missingChildren: missingChildren\n      };\n    }.bind(this));\n  },\n\n  completePush: function completePush(path, action, conflict, revision) {\n    return this.local.getNodes([path]).then(function (nodes) {\n      var node = nodes[path];\n\n      if (!node.push) {\n        this.stopped = true;\n        throw new Error('completePush called but no push version!');\n      }\n\n      if (conflict) {\n        log('[Sync] We have a conflict');\n\n        if (!node.remote || node.remote.revision !== revision) {\n          node.remote = {\n            revision: revision || 'conflict',\n            timestamp: this.now()\n          };\n          delete node.push;\n        }\n\n        nodes[path] = this.autoMerge(node);\n      } else {\n        node.common = {\n          revision: revision,\n          timestamp: this.now()\n        };\n\n        if (action === 'put') {\n          node.common.body = node.push.body;\n          node.common.contentType = node.push.contentType;\n\n          if (equal(node.local.body, node.push.body) && node.local.contentType === node.push.contentType) {\n            delete node.local;\n          }\n\n          delete node.push;\n        } else if (action === 'delete') {\n          if (node.local.body === false) {\n            // No new local changes since push; flush it.\n            nodes[path] = undefined;\n          } else {\n            delete node.push;\n          }\n        }\n      }\n\n      return this.local.setNodes(this.flush(nodes));\n    }.bind(this));\n  },\n\n  dealWithFailure: function dealWithFailure(path, action, statusMeaning) {\n\n    return this.local.getNodes([path]).then(function (nodes) {\n      if (nodes[path]) {\n        delete nodes[path].push;\n        return this.local.setNodes(this.flush(nodes));\n      }\n    }.bind(this));\n  },\n\n  interpretStatus: function interpretStatus(statusCode) {\n    if (statusCode === 'offline' || statusCode === 'timeout') {\n      return {\n        successful: false,\n        networkProblems: true,\n        statusCode: statusCode\n      };\n    }\n\n    var series = Math.floor(statusCode / 100);\n\n    return {\n      successful: series === 2 || statusCode === 304 || statusCode === 412 || statusCode === 404,\n      conflict: statusCode === 412,\n      unAuth: statusCode === 401 && this.remote.token !== Authorize.IMPLIED_FAKE_TOKEN || statusCode === 402 || statusCode === 403,\n      notFound: statusCode === 404,\n      changed: statusCode !== 304,\n      statusCode: statusCode\n    };\n  },\n\n  handleGetResponse: function handleGetResponse(path, status, bodyOrItemsMap, contentType, revision) {\n    if (status.notFound) {\n      if (isFolder(path)) {\n        bodyOrItemsMap = {};\n      } else {\n        bodyOrItemsMap = false;\n      }\n    }\n\n    if (status.changed) {\n      return this.completeFetch(path, bodyOrItemsMap, contentType, revision).then(function (dataFromFetch) {\n        if (isFolder(path)) {\n          if (this.corruptServerItemsMap(bodyOrItemsMap)) {\n            log('[Sync] WARNING: Discarding corrupt folder description from server for ' + path);\n            return false;\n          } else {\n            return this.markChildren(path, bodyOrItemsMap, dataFromFetch.toBeSaved, dataFromFetch.missingChildren).then(function () {\n              return true;\n            });\n          }\n        } else {\n          return this.local.setNodes(this.flush(dataFromFetch.toBeSaved)).then(function () {\n            return true;\n          });\n        }\n      }.bind(this));\n    } else {\n      return this.updateCommonTimestamp(path, revision).then(function () {\n        return true;\n      });\n    }\n  },\n\n  handleResponse: function handleResponse(path, action, r) {\n    var status = this.interpretStatus(r.statusCode);\n    if (status.successful) {\n      if (action === 'get') {\n        return this.handleGetResponse(path, status, r.body, r.contentType, r.revision);\n      } else if (action === 'put' || action === 'delete') {\n        return this.completePush(path, action, status.conflict, r.revision).then(function () {\n          return true;\n        });\n      } else {\n        throw new Error('cannot handle response for unknown action', action);\n      }\n    } else {\n      // Unsuccessful\n      var error;\n      if (status.unAuth) {\n        error = new Authorize.Unauthorized();\n      } else if (status.networkProblems) {\n        error = new Sync.SyncError('Network request failed.');\n      } else {\n        error = new Error('HTTP response code ' + status.statusCode + ' received.');\n      }\n\n      return this.dealWithFailure(path, action, status).then(function () {\n        this.remoteStorage._emit('error', error);\n        throw error;\n      });\n    }\n  },\n\n  numThreads: 10,\n\n  finishTask: function finishTask(task) {\n    if (task.action === undefined) {\n      delete this._running[task.path];\n      return;\n    }\n    var self = this;\n\n    return task.promise.then(function (r) {\n      return self.handleResponse(task.path, task.action, r);\n    }, function (err) {\n      log('[Sync] wireclient rejects its promise!', task.path, task.action, err);\n      return self.handleResponse(task.path, task.action, { statusCode: 'offline' });\n    }).then(function (completed) {\n      delete self._timeStarted[task.path];\n      delete self._running[task.path];\n\n      if (completed) {\n        if (self._tasks[task.path]) {\n          for (var i = 0; i < self._tasks[task.path].length; i++) {\n            self._tasks[task.path][i]();\n          }\n          delete self._tasks[task.path];\n        }\n      }\n\n      self._emit('req-done');\n\n      self.collectTasks(false).then(function () {\n        // See if there are any more tasks that are not refresh tasks\n        if (!self.hasTasks() || self.stopped) {\n          log('[Sync] Sync is done! Reschedule?', Object.getOwnPropertyNames(self._tasks).length, self.stopped);\n          if (!self.done) {\n            self.done = true;\n            self._emit('done');\n          }\n        } else {\n          // Use a 10ms timeout to let the JavaScript runtime catch its breath\n          // (and hopefully force an IndexedDB auto-commit?), and also to cause\n          // the threads to get staggered and get a good spread over time:\n          setTimeout(function () {\n            self.doTasks();\n          }, 10);\n        }\n      });\n    }, function (err) {\n      log('[Sync] Error', err);\n      delete self._timeStarted[task.path];\n      delete self._running[task.path];\n      self._emit('req-done');\n      if (!self.done) {\n        self.done = true;\n        self._emit('done');\n      }\n    });\n  },\n\n  doTasks: function doTasks() {\n    var numToHave,\n        numAdded = 0,\n        numToAdd,\n        path;\n    if (this.remote.connected) {\n      if (this.remote.online) {\n        numToHave = this.numThreads;\n      } else {\n        numToHave = 1;\n      }\n    } else {\n      numToHave = 0;\n    }\n    numToAdd = numToHave - Object.getOwnPropertyNames(this._running).length;\n    if (numToAdd <= 0) {\n      return true;\n    }\n    for (path in this._tasks) {\n      if (!this._running[path]) {\n        this._timeStarted[path] = this.now();\n        this._running[path] = this.doTask(path);\n        this._running[path].then(this.finishTask.bind(this));\n        numAdded++;\n        if (numAdded >= numToAdd) {\n          return true;\n        }\n      }\n    }\n    return numAdded >= numToAdd;\n  },\n\n  collectTasks: function collectTasks(alsoCheckRefresh) {\n    if (this.hasTasks() || this.stopped) {\n      return Promise.resolve();\n    }\n\n    return this.collectDiffTasks().then(function (numDiffs) {\n      if (numDiffs || alsoCheckRefresh === false) {\n        return Promise.resolve();\n      } else {\n        return this.collectRefreshTasks();\n      }\n    }.bind(this), function (err) {\n      throw err;\n    });\n  },\n\n  addTask: function addTask(path, cb) {\n    if (!this._tasks[path]) {\n      this._tasks[path] = [];\n    }\n    if (typeof cb === 'function') {\n      this._tasks[path].push(cb);\n    }\n  },\n\n  /**\n   * Method: sync\n   **/\n  sync: function sync() {\n    this.done = false;\n\n    if (!this.doTasks()) {\n      return this.collectTasks().then(function () {\n        try {\n          this.doTasks();\n        } catch (e) {\n          log('[Sync] doTasks error', e);\n        }\n      }.bind(this), function (e) {\n        log('[Sync] Sync error', e);\n        throw new Error('Local cache unavailable');\n      });\n    } else {\n      return Promise.resolve();\n    }\n  }\n};\n\nvar syncCycleCb, _syncOnConnect;\nSync._rs_init = function (remoteStorage) {\n\n  syncCycleCb = function syncCycleCb() {\n    // if (!config.cache) return false\n    log('[Sync] syncCycleCb calling syncCycle');\n    if (Env.isBrowser()) {\n      handleVisibility.bind(remoteStorage)();\n    }\n\n    if (!remoteStorage.sync) {\n      // Call this now that all other modules are also ready:\n      remoteStorage.sync = new Sync(remoteStorage, remoteStorage.local, remoteStorage.remote, remoteStorage.access, remoteStorage.caching);\n\n      if (remoteStorage.syncStopped) {\n        log('[Sync] Instantiating sync stopped');\n        remoteStorage.sync.stopped = true;\n        delete remoteStorage.syncStopped;\n      }\n    }\n\n    log('[Sync] syncCycleCb calling syncCycle');\n    remoteStorage.syncCycle();\n  };\n\n  _syncOnConnect = function syncOnConnect() {\n    remoteStorage.removeEventListener('connected', _syncOnConnect);\n    remoteStorage.startSync();\n  };\n\n  remoteStorage.on('ready', syncCycleCb);\n  remoteStorage.on('connected', _syncOnConnect);\n};\n\nSync._rs_cleanup = function (remoteStorage) {\n  remoteStorage.stopSync();\n  remoteStorage.removeEventListener('ready', syncCycleCb);\n  remoteStorage.removeEventListener('connected', _syncOnConnect);\n\n  remoteStorage.sync = undefined;\n  delete remoteStorage.sync;\n};\n\nvar SyncError = function SyncError(originalError) {\n  var msg = 'Sync failed: ';\n  if ((typeof originalError === 'undefined' ? 'undefined' : _typeof(originalError)) === 'object' && 'message' in originalError) {\n    msg += originalError.message;\n  } else {\n    msg += originalError;\n  }\n  this.originalError = originalError;\n  this.message = msg;\n};\n\nSyncError.prototype = new Error();\nSyncError.prototype.constructor = SyncError;\n\nSync.SyncError = SyncError;\n\nmodule.exports = Sync;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvc3luYy5qcz81ODY0Il0sIm5hbWVzIjpbInV0aWwiLCJyZXF1aXJlIiwiRW52IiwiZXZlbnRIYW5kbGluZyIsImxvZyIsIkF1dGhvcml6ZSIsImNvbmZpZyIsImlzRm9sZGVyIiwiaXNEb2N1bWVudCIsImVxdWFsIiwiZGVlcENsb25lIiwicGF0aHNGcm9tUm9vdCIsInRhc2tGb3IiLCJhY3Rpb24iLCJwYXRoIiwicHJvbWlzZSIsImlzU3RhbGVDaGlsZCIsIm5vZGUiLCJyZW1vdGUiLCJyZXZpc2lvbiIsIml0ZW1zTWFwIiwiYm9keSIsImhhc0NvbW1vblJldmlzaW9uIiwiY29tbW9uIiwiaGFuZGxlVmlzaWJpbGl0eSIsInJzIiwiaGFuZGxlVmlzaWJpbGl0eUNoYW5nZSIsImZnIiwib2xkVmFsdWUiLCJuZXdWYWx1ZSIsImdldEN1cnJlbnRTeW5jSW50ZXJ2YWwiLCJpc0JhY2tncm91bmQiLCJfZW1pdCIsIm9uIiwiU3luYyIsInJlbW90ZVN0b3JhZ2UiLCJzZXRMb2NhbCIsInNldFJlbW90ZSIsInNldEFjY2VzcyIsInNldENhY2hpbmciLCJsb2NhbCIsIm9uRGlmZiIsImFkZFRhc2siLCJkb1Rhc2tzIiwiYmluZCIsImFjY2VzcyIsImNhY2hpbmciLCJfdGFza3MiLCJfcnVubmluZyIsIl90aW1lU3RhcnRlZCIsIm9uQWN0aXZhdGUiLCJwcm90b3R5cGUiLCJub3ciLCJEYXRlIiwiZ2V0VGltZSIsInF1ZXVlR2V0UmVxdWVzdCIsIlByb21pc2UiLCJyZXNvbHZlIiwicmVqZWN0IiwiY29ubmVjdGVkIiwib25saW5lIiwiZ2V0IiwidGhlbiIsInIiLCJjb3JydXB0U2VydmVySXRlbXNNYXAiLCJmb3JjZTAyIiwiQXJyYXkiLCJpc0FycmF5IiwiaXRlbU5hbWUiLCJpdGVtIiwiRVRhZyIsInN1YnN0cmluZyIsImxlbmd0aCIsImluZGV4T2YiLCJjb3JydXB0SXRlbXNNYXAiLCJjb3JydXB0UmV2aXNpb24iLCJyZXYiLCJjb250ZW50VHlwZSIsImNvbnRlbnRMZW5ndGgiLCJ0aW1lc3RhbXAiLCJpc0NvcnJ1cHQiLCJwdXNoIiwiaGFzVGFza3MiLCJPYmplY3QiLCJnZXRPd25Qcm9wZXJ0eU5hbWVzIiwiY29sbGVjdERpZmZUYXNrcyIsIm51bSIsImZvckFsbE5vZGVzIiwibmVlZHNGZXRjaCIsImNoZWNrUGF0aFBlcm1pc3Npb24iLCJuZWVkc1B1c2giLCJlcnIiLCJpbkNvbmZsaWN0IiwidW5kZWZpbmVkIiwibmVlZHNSZWZyZXNoIiwic3luY0ludGVydmFsIiwibmVlZHNSZW1vdGVQdXQiLCJuZWVkc1JlbW90ZURlbGV0ZSIsImdldFBhcmVudFBhdGgiLCJwYXJ0cyIsIm1hdGNoIiwiRXJyb3IiLCJkZWxldGVDaGlsZFBhdGhzRnJvbVRhc2tzIiwicGF0aHMiLCJpIiwiYXBwbHkiLCJjb2xsZWN0UmVmcmVzaFRhc2tzIiwicGFyZW50UGF0aCIsImUiLCJmbHVzaCIsIm5vZGVzIiwiY2hlY2tQYXRoIiwiZG9UYXNrIiwiZ2V0Tm9kZXMiLCJzZXROb2RlcyIsIm9wdGlvbnMiLCJpZk1hdGNoIiwiaWZOb25lTWF0Y2giLCJwdXQiLCJkZWxldGUiLCJhdXRvTWVyZ2VGb2xkZXIiLCJhdXRvTWVyZ2VEb2N1bWVudCIsImhhc05vUmVtb3RlQ2hhbmdlcyIsIm1lcmdlTXV0dWFsRGVsZXRpb24iLCJfZW1pdENoYW5nZSIsIm9yaWdpbiIsImxhc3RDb21tb25WYWx1ZSIsIm9sZENvbnRlbnRUeXBlIiwibmV3Q29udGVudFR5cGUiLCJsYXN0Q29tbW9uQ29udGVudFR5cGUiLCJhdXRvTWVyZ2UiLCJjaGFuZ2UiLCJ1cGRhdGVDb21tb25UaW1lc3RhbXAiLCJtYXJrQ2hpbGRyZW4iLCJjaGFuZ2VkTm9kZXMiLCJtaXNzaW5nQ2hpbGRyZW4iLCJtZXRhIiwicmVjdXJzZSIsImNoaWxkTmFtZSIsImNhY2hpbmdTdHJhdGVneSIsIm5vZGVDaGFuZ2VkIiwiZXRhZyIsIm5vZGVQYXRoIiwiY29tbW9uSXRlbSIsImxvY2FsSXRlbSIsInBhcmVudE5vZGUiLCJkZWxldGVSZW1vdGVUcmVlcyIsImtleXMiLCJjaGFuZ2VkT2JqczIiLCJzdWJQYXRocyIsImNvbGxlY3RTdWJQYXRocyIsImZvbGRlciIsImNoYW5nZWROb2RlczIiLCJjb21wbGV0ZUZldGNoIiwiYm9keU9ySXRlbXNNYXAiLCJwYXRoc0Zyb21Sb290QXJyIiwiY29sbGVjdE1pc3NpbmdDaGlsZHJlbiIsInRvQmVTYXZlZCIsImNvbXBsZXRlUHVzaCIsImNvbmZsaWN0Iiwic3RvcHBlZCIsImRlYWxXaXRoRmFpbHVyZSIsInN0YXR1c01lYW5pbmciLCJpbnRlcnByZXRTdGF0dXMiLCJzdGF0dXNDb2RlIiwic3VjY2Vzc2Z1bCIsIm5ldHdvcmtQcm9ibGVtcyIsInNlcmllcyIsIk1hdGgiLCJmbG9vciIsInVuQXV0aCIsInRva2VuIiwiSU1QTElFRF9GQUtFX1RPS0VOIiwibm90Rm91bmQiLCJjaGFuZ2VkIiwiaGFuZGxlR2V0UmVzcG9uc2UiLCJzdGF0dXMiLCJkYXRhRnJvbUZldGNoIiwiaGFuZGxlUmVzcG9uc2UiLCJlcnJvciIsIlVuYXV0aG9yaXplZCIsIlN5bmNFcnJvciIsIm51bVRocmVhZHMiLCJmaW5pc2hUYXNrIiwidGFzayIsInNlbGYiLCJjb21wbGV0ZWQiLCJjb2xsZWN0VGFza3MiLCJkb25lIiwic2V0VGltZW91dCIsIm51bVRvSGF2ZSIsIm51bUFkZGVkIiwibnVtVG9BZGQiLCJhbHNvQ2hlY2tSZWZyZXNoIiwibnVtRGlmZnMiLCJjYiIsInN5bmMiLCJzeW5jQ3ljbGVDYiIsInN5bmNPbkNvbm5lY3QiLCJfcnNfaW5pdCIsImlzQnJvd3NlciIsInN5bmNTdG9wcGVkIiwic3luY0N5Y2xlIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsInN0YXJ0U3luYyIsIl9yc19jbGVhbnVwIiwic3RvcFN5bmMiLCJvcmlnaW5hbEVycm9yIiwibXNnIiwibWVzc2FnZSIsImNvbnN0cnVjdG9yIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJtYXBwaW5ncyI6Ijs7OztBQUFFLElBQUlB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SUFBakIiLCJmaWxlIjoiOC5qcyIsInNvdXJjZXNDb250ZW50IjpbIiAgdmFyIHV0aWwgPSByZXF1aXJlKCcuL3V0aWwnKTtcbiAgdmFyIEVudiA9IHJlcXVpcmUoJy4vZW52Jyk7XG4gIHZhciBldmVudEhhbmRsaW5nID0gcmVxdWlyZSgnLi9ldmVudGhhbmRsaW5nJyk7XG4gIHZhciBsb2cgPSByZXF1aXJlKCcuL2xvZycpO1xuICB2YXIgQXV0aG9yaXplID0gcmVxdWlyZSgnLi9hdXRob3JpemUnKTtcbiAgdmFyIGNvbmZpZyA9IHJlcXVpcmUoJy4vY29uZmlnJyk7XG4gIFxuICB2YXIgaXNGb2xkZXIgPSB1dGlsLmlzRm9sZGVyO1xuICB2YXIgaXNEb2N1bWVudCA9IHV0aWwuaXNEb2N1bWVudDtcbiAgdmFyIGVxdWFsID0gdXRpbC5lcXVhbDtcbiAgdmFyIGRlZXBDbG9uZSA9IHV0aWwuZGVlcENsb25lO1xuICB2YXIgcGF0aHNGcm9tUm9vdCA9IHV0aWwucGF0aHNGcm9tUm9vdDtcblxuICBmdW5jdGlvbiB0YXNrRm9yKGFjdGlvbiwgcGF0aCwgcHJvbWlzZSkge1xuICAgIHJldHVybiB7XG4gICAgICBhY3Rpb246ICBhY3Rpb24sXG4gICAgICBwYXRoOiAgICBwYXRoLFxuICAgICAgcHJvbWlzZTogcHJvbWlzZVxuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBpc1N0YWxlQ2hpbGQobm9kZSkge1xuICAgIHJldHVybiBub2RlLnJlbW90ZSAmJiBub2RlLnJlbW90ZS5yZXZpc2lvbiAmJiAhbm9kZS5yZW1vdGUuaXRlbXNNYXAgJiYgIW5vZGUucmVtb3RlLmJvZHk7XG4gIH1cblxuICBmdW5jdGlvbiBoYXNDb21tb25SZXZpc2lvbihub2RlKSB7XG4gICAgcmV0dXJuIG5vZGUuY29tbW9uICYmIG5vZGUuY29tbW9uLnJldmlzaW9uO1xuICB9XG5cbiAgZnVuY3Rpb24gaGFuZGxlVmlzaWJpbGl0eSgpIHtcbiAgICB2YXIgcnMgPSB0aGlzO1xuXG4gICAgZnVuY3Rpb24gaGFuZGxlVmlzaWJpbGl0eUNoYW5nZShmZykge1xuICAgICAgdmFyIG9sZFZhbHVlLCBuZXdWYWx1ZTtcbiAgICAgIG9sZFZhbHVlID0gcnMuZ2V0Q3VycmVudFN5bmNJbnRlcnZhbCgpO1xuICAgICAgY29uZmlnLmlzQmFja2dyb3VuZCA9ICFmZztcbiAgICAgIG5ld1ZhbHVlID0gcnMuZ2V0Q3VycmVudFN5bmNJbnRlcnZhbCgpO1xuICAgICAgcnMuX2VtaXQoJ3N5bmMtaW50ZXJ2YWwtY2hhbmdlJywge29sZFZhbHVlOiBvbGRWYWx1ZSwgbmV3VmFsdWU6IG5ld1ZhbHVlfSk7XG4gICAgfVxuXG4gICAgRW52Lm9uKFwiYmFja2dyb3VuZFwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICBoYW5kbGVWaXNpYmlsaXR5Q2hhbmdlKGZhbHNlKTtcbiAgICB9KTtcblxuICAgIEVudi5vbihcImZvcmVncm91bmRcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgaGFuZGxlVmlzaWJpbGl0eUNoYW5nZSh0cnVlKTtcbiAgICB9KTtcbiAgfVxuXG5cbiAgLyoqXG4gICAqIENsYXNzOiBSZW1vdGVTdG9yYWdlLlN5bmNcbiAgICpcbiAgICogV2hhdCB0aGlzIGNsYXNzIGRvZXMgaXMgYmFzaWNhbGx5IHNpeCB0aGluZ3M6XG4gICAqIC0gcmV0cmlldmluZyB0aGUgcmVtb3RlIHZlcnNpb24gb2YgcmVsZXZhbnQgZG9jdW1lbnRzIGFuZCBmb2xkZXJzXG4gICAqIC0gYWRkIGFsbCBsb2NhbCBhbmQgcmVtb3RlIGRvY3VtZW50cyB0b2dldGhlciBpbnRvIG9uZSB0cmVlXG4gICAqIC0gcHVzaCBsb2NhbCBkb2N1bWVudHMgb3V0IGlmIHRoZXkgZG9uJ3QgZXhpc3QgcmVtb3RlbHlcbiAgICogLSBwdXNoIGxvY2FsIGNoYW5nZXMgb3V0IHRvIHJlbW90ZSBkb2N1bWVudHMgKGNvbmRpdGlvbmFsbHksIHRvXG4gICAqICAgICAgYXZvaWQgcmFjZSBjb25kaXRpb25zIHdoZXJlIGJvdGggaGF2ZSBjaGFuZ2VkKVxuICAgKiAtIGFkb3B0IHRoZSBsb2NhbCB2ZXJzaW9uIG9mIGEgZG9jdW1lbnQgdG8gaXRzIHJlbW90ZSB2ZXJzaW9uIGlmXG4gICAqICAgICAgYm90aCBleGlzdCBhbmQgdGhleSBkaWZmZXJcbiAgICogLSBkZWxldGUgdGhlIGxvY2FsIHZlcnNpb24gb2YgYSBkb2N1bWVudCBpZiBpdCB3YXMgZGVsZXRlZCByZW1vdGVseVxuICAgKiAtIGlmIGFueSBnZXQgcmVxdWVzdHMgd2VyZSB3YWl0aW5nIGZvciByZW1vdGUgZGF0YSwgcmVzb2x2ZSB0aGVtIG9uY2VcbiAgICogICAgICB0aGlzIGRhdGEgY29tZXMgaW4uXG4gICAqXG4gICAqIEl0IGRvZXMgdGhpcyB1c2luZyByZXF1ZXN0cyB0byBkb2N1bWVudHMsIGFuZCB0byBmb2xkZXJzLiBXaGVuZXZlciBhXG4gICAqIGZvbGRlciBHRVQgY29tZXMgaW4sIGl0IGdpdmVzIGluZm9ybWF0aW9uIGFib3V0IGFsbCB0aGUgZG9jdW1lbnRzIGl0XG4gICAqIGNvbnRhaW5zICh0aGlzIGlzIHRoZSBgbWFya0NoaWxkcmVuYCBmdW5jdGlvbikuXG4gICAqKi9cbiAgdmFyIFN5bmMgPSBmdW5jdGlvbiAocmVtb3RlU3RvcmFnZSwgc2V0TG9jYWwsIHNldFJlbW90ZSwgc2V0QWNjZXNzLCBzZXRDYWNoaW5nKSB7XG4gICAgdGhpcy5yZW1vdGVTdG9yYWdlID0gcmVtb3RlU3RvcmFnZTtcbiAgICB0aGlzLmxvY2FsID0gc2V0TG9jYWw7XG4gICAgdGhpcy5sb2NhbC5vbkRpZmYoZnVuY3Rpb24gKHBhdGgpIHtcbiAgICAgIHRoaXMuYWRkVGFzayhwYXRoKTtcbiAgICAgIHRoaXMuZG9UYXNrcygpO1xuICAgIH0uYmluZCh0aGlzKSk7XG4gICAgdGhpcy5yZW1vdGUgPSBzZXRSZW1vdGU7XG4gICAgdGhpcy5hY2Nlc3MgPSBzZXRBY2Nlc3M7XG4gICAgdGhpcy5jYWNoaW5nID0gc2V0Q2FjaGluZztcbiAgICB0aGlzLl90YXNrcyA9IHt9O1xuICAgIHRoaXMuX3J1bm5pbmcgPSB7fTtcbiAgICB0aGlzLl90aW1lU3RhcnRlZCA9IHt9O1xuICAgIGV2ZW50SGFuZGxpbmcodGhpcywgJ2RvbmUnLCAncmVxLWRvbmUnKTtcbiAgICB0aGlzLmNhY2hpbmcub25BY3RpdmF0ZShmdW5jdGlvbiAocGF0aCkge1xuICAgICAgdGhpcy5hZGRUYXNrKHBhdGgpO1xuICAgICAgdGhpcy5kb1Rhc2tzKCk7XG4gICAgfS5iaW5kKHRoaXMpKTtcbiAgfTtcblxuICBTeW5jLnByb3RvdHlwZSA9IHtcblxuICAgIG5vdzogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuICAgIH0sXG5cbiAgICBxdWV1ZUdldFJlcXVlc3Q6IGZ1bmN0aW9uIChwYXRoKSB7XG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoIChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgaWYgKCF0aGlzLnJlbW90ZS5jb25uZWN0ZWQpIHtcbiAgICAgICAgICByZWplY3QoJ2Nhbm5vdCBmdWxmaWxsIG1heEFnZSByZXF1aXJlbWVudCAtIHJlbW90ZSBpcyBub3QgY29ubmVjdGVkJyk7XG4gICAgICAgIH0gZWxzZSBpZiAoIXRoaXMucmVtb3RlLm9ubGluZSkge1xuICAgICAgICAgIHJlamVjdCgnY2Fubm90IGZ1bGZpbGwgbWF4QWdlIHJlcXVpcmVtZW50IC0gcmVtb3RlIGlzIG5vdCBvbmxpbmUnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmFkZFRhc2socGF0aCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5sb2NhbC5nZXQocGF0aCkudGhlbihmdW5jdGlvbiAocikge1xuICAgICAgICAgICAgICByZXR1cm4gcmVzb2x2ZShyKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0uYmluZCh0aGlzKSk7XG5cbiAgICAgICAgICB0aGlzLmRvVGFza3MoKTtcbiAgICAgICAgfVxuXG4gICAgICB9KTtcbiAgICB9LFxuXG4gICAgY29ycnVwdFNlcnZlckl0ZW1zTWFwOiBmdW5jdGlvbiAoaXRlbXNNYXAsIGZvcmNlMDIpIHtcbiAgICAgIGlmICgodHlwZW9mKGl0ZW1zTWFwKSAhPT0gJ29iamVjdCcpIHx8IChBcnJheS5pc0FycmF5KGl0ZW1zTWFwKSkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIGl0ZW1OYW1lIGluIGl0ZW1zTWFwKSB7XG4gICAgICAgIHZhciBpdGVtID0gaXRlbXNNYXBbaXRlbU5hbWVdO1xuXG4gICAgICAgIGlmICh0eXBlb2YoaXRlbSkgIT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZihpdGVtLkVUYWcpICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc0ZvbGRlcihpdGVtTmFtZSkpIHtcbiAgICAgICAgICBpZiAoaXRlbU5hbWUuc3Vic3RyaW5nKDAsIGl0ZW1OYW1lLmxlbmd0aC0xKS5pbmRleE9mKCcvJykgIT09IC0xKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKGl0ZW1OYW1lLmluZGV4T2YoJy8nKSAhPT0gLTEpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoZm9yY2UwMikge1xuICAgICAgICAgICAgaWYgKHR5cGVvZihpdGVtWydDb250ZW50LVR5cGUnXSkgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZihpdGVtWydDb250ZW50LUxlbmd0aCddKSAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9LFxuXG4gICAgY29ycnVwdEl0ZW1zTWFwOiBmdW5jdGlvbiAoaXRlbXNNYXApIHtcbiAgICAgIGlmICgodHlwZW9mKGl0ZW1zTWFwKSAhPT0gJ29iamVjdCcpIHx8IChBcnJheS5pc0FycmF5KGl0ZW1zTWFwKSkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIGl0ZW1OYW1lIGluIGl0ZW1zTWFwKSB7XG4gICAgICAgIGlmICh0eXBlb2YoaXRlbXNNYXBbaXRlbU5hbWVdKSAhPT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sXG5cbiAgICBjb3JydXB0UmV2aXNpb246IGZ1bmN0aW9uIChyZXYpIHtcbiAgICAgIHJldHVybiAoKHR5cGVvZihyZXYpICE9PSAnb2JqZWN0JykgfHxcbiAgICAgICAgICAgICAgKEFycmF5LmlzQXJyYXkocmV2KSkgfHxcbiAgICAgICAgICAgICAgKHJldi5yZXZpc2lvbiAmJiB0eXBlb2YocmV2LnJldmlzaW9uKSAhPT0gJ3N0cmluZycpIHx8XG4gICAgICAgICAgICAgIChyZXYuYm9keSAmJiB0eXBlb2YocmV2LmJvZHkpICE9PSAnc3RyaW5nJyAmJiB0eXBlb2YocmV2LmJvZHkpICE9PSAnb2JqZWN0JykgfHxcbiAgICAgICAgICAgICAgKHJldi5jb250ZW50VHlwZSAmJiB0eXBlb2YocmV2LmNvbnRlbnRUeXBlKSAhPT0gJ3N0cmluZycpIHx8XG4gICAgICAgICAgICAgIChyZXYuY29udGVudExlbmd0aCAmJiB0eXBlb2YocmV2LmNvbnRlbnRMZW5ndGgpICE9PSAnbnVtYmVyJykgfHxcbiAgICAgICAgICAgICAgKHJldi50aW1lc3RhbXAgJiYgdHlwZW9mKHJldi50aW1lc3RhbXApICE9PSAnbnVtYmVyJykgfHxcbiAgICAgICAgICAgICAgKHJldi5pdGVtc01hcCAmJiB0aGlzLmNvcnJ1cHRJdGVtc01hcChyZXYuaXRlbXNNYXApKSk7XG4gICAgfSxcblxuICAgIGlzQ29ycnVwdDogZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgIHJldHVybiAoKHR5cGVvZihub2RlKSAhPT0gJ29iamVjdCcpIHx8XG4gICAgICAgICAgICAgIChBcnJheS5pc0FycmF5KG5vZGUpKSB8fFxuICAgICAgICAgICAgICAodHlwZW9mKG5vZGUucGF0aCkgIT09ICdzdHJpbmcnKSB8fFxuICAgICAgICAgICAgICAodGhpcy5jb3JydXB0UmV2aXNpb24obm9kZS5jb21tb24pKSB8fFxuICAgICAgICAgICAgICAobm9kZS5sb2NhbCAmJiB0aGlzLmNvcnJ1cHRSZXZpc2lvbihub2RlLmxvY2FsKSkgfHxcbiAgICAgICAgICAgICAgKG5vZGUucmVtb3RlICYmIHRoaXMuY29ycnVwdFJldmlzaW9uKG5vZGUucmVtb3RlKSkgfHxcbiAgICAgICAgICAgICAgKG5vZGUucHVzaCAmJiB0aGlzLmNvcnJ1cHRSZXZpc2lvbihub2RlLnB1c2gpKSk7XG4gICAgfSxcblxuICAgIGhhc1Rhc2tzOiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModGhpcy5fdGFza3MpLmxlbmd0aCA+IDA7XG4gICAgfSxcblxuICAgIGNvbGxlY3REaWZmVGFza3M6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBudW0gPSAwO1xuXG4gICAgICByZXR1cm4gdGhpcy5sb2NhbC5mb3JBbGxOb2RlcyhmdW5jdGlvbiAobm9kZSkge1xuXG4gICAgICAgIGlmIChudW0gPiAxMDApIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5pc0NvcnJ1cHQobm9kZSkpIHtcbiAgICAgICAgICBsb2coJ1tTeW5jXSBXQVJOSU5HOiBjb3JydXB0IG5vZGUgaW4gbG9jYWwgY2FjaGUnLCBub2RlKTtcbiAgICAgICAgICBpZiAodHlwZW9mKG5vZGUpID09PSAnb2JqZWN0JyAmJiBub2RlLnBhdGgpIHtcbiAgICAgICAgICAgIHRoaXMuYWRkVGFzayhub2RlLnBhdGgpO1xuICAgICAgICAgICAgbnVtKys7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHRoaXMubmVlZHNGZXRjaChub2RlKSAmJiB0aGlzLmFjY2Vzcy5jaGVja1BhdGhQZXJtaXNzaW9uKG5vZGUucGF0aCwgJ3InKSkge1xuICAgICAgICAgIHRoaXMuYWRkVGFzayhub2RlLnBhdGgpO1xuICAgICAgICAgIG51bSsrO1xuICAgICAgICB9IGVsc2UgaWYgKGlzRG9jdW1lbnQobm9kZS5wYXRoKSAmJiB0aGlzLm5lZWRzUHVzaChub2RlKSAmJlxuICAgICAgICAgICAgICAgICAgIHRoaXMuYWNjZXNzLmNoZWNrUGF0aFBlcm1pc3Npb24obm9kZS5wYXRoLCAncncnKSkge1xuICAgICAgICAgIHRoaXMuYWRkVGFzayhub2RlLnBhdGgpO1xuICAgICAgICAgIG51bSsrO1xuICAgICAgICB9XG4gICAgICB9LmJpbmQodGhpcykpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gbnVtO1xuICAgICAgfSwgZnVuY3Rpb24gKGVycikge1xuICAgICAgICB0aHJvdyBlcnI7XG4gICAgICB9KTtcbiAgICB9LFxuXG4gICAgaW5Db25mbGljdDogZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgIHJldHVybiAobm9kZS5sb2NhbCAmJiBub2RlLnJlbW90ZSAmJlxuICAgICAgICAgICAgICAobm9kZS5yZW1vdGUuYm9keSAhPT0gdW5kZWZpbmVkIHx8IG5vZGUucmVtb3RlLml0ZW1zTWFwKSk7XG4gICAgfSxcblxuICAgIG5lZWRzUmVmcmVzaDogZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgIGlmIChub2RlLmNvbW1vbikge1xuICAgICAgICBpZiAoIW5vZGUuY29tbW9uLnRpbWVzdGFtcCkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAodGhpcy5ub3coKSAtIG5vZGUuY29tbW9uLnRpbWVzdGFtcCA+IGNvbmZpZy5zeW5jSW50ZXJ2YWwpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sXG5cbiAgICBuZWVkc0ZldGNoOiBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgaWYgKHRoaXMuaW5Db25mbGljdChub2RlKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmIChub2RlLmNvbW1vbiAmJiBub2RlLmNvbW1vbi5pdGVtc01hcCA9PT0gdW5kZWZpbmVkICYmIG5vZGUuY29tbW9uLmJvZHkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmIChub2RlLnJlbW90ZSAmJiBub2RlLnJlbW90ZS5pdGVtc01hcCA9PT0gdW5kZWZpbmVkICYmIG5vZGUucmVtb3RlLmJvZHkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9LFxuXG4gICAgbmVlZHNQdXNoOiBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgaWYgKHRoaXMuaW5Db25mbGljdChub2RlKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBpZiAobm9kZS5sb2NhbCAmJiAhbm9kZS5wdXNoKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBuZWVkc1JlbW90ZVB1dDogZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgIHJldHVybiBub2RlLmxvY2FsICYmIG5vZGUubG9jYWwuYm9keTtcbiAgICB9LFxuXG4gICAgbmVlZHNSZW1vdGVEZWxldGU6IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICByZXR1cm4gbm9kZS5sb2NhbCAmJiBub2RlLmxvY2FsLmJvZHkgPT09IGZhbHNlO1xuICAgIH0sXG5cbiAgICBnZXRQYXJlbnRQYXRoOiBmdW5jdGlvbiAocGF0aCkge1xuICAgICAgdmFyIHBhcnRzID0gcGF0aC5tYXRjaCgvXiguKlxcLykoW15cXC9dK1xcLz8pJC8pO1xuXG4gICAgICBpZiAocGFydHMpIHtcbiAgICAgICAgcmV0dXJuIHBhcnRzWzFdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdOb3QgYSB2YWxpZCBwYXRoOiBcIicrcGF0aCsnXCInKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgZGVsZXRlQ2hpbGRQYXRoc0Zyb21UYXNrczogZnVuY3Rpb24gKCkge1xuICAgICAgZm9yICh2YXIgcGF0aCBpbiB0aGlzLl90YXNrcykge1xuICAgICAgICB2YXIgcGF0aHMgPSBwYXRoc0Zyb21Sb290KHBhdGgpO1xuXG4gICAgICAgIGZvciAodmFyIGk9MTsgaTxwYXRocy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGlmICh0aGlzLl90YXNrc1twYXRoc1tpXV0pIHtcbiAgICAgICAgICAgIC8vIG1vdmUgcGVuZGluZyBwcm9taXNlcyB0byBwYXJlbnQgdGFza1xuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodGhpcy5fdGFza3NbcGF0aF0pICYmIHRoaXMuX3Rhc2tzW3BhdGhdLmxlbmd0aCkge1xuICAgICAgICAgICAgICBBcnJheS5wcm90b3R5cGUucHVzaC5hcHBseShcbiAgICAgICAgICAgICAgICB0aGlzLl90YXNrc1twYXRoc1tpXV0sXG4gICAgICAgICAgICAgICAgdGhpcy5fdGFza3NbcGF0aF1cbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl90YXNrc1twYXRoXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgY29sbGVjdFJlZnJlc2hUYXNrczogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMubG9jYWwuZm9yQWxsTm9kZXMoZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgdmFyIHBhcmVudFBhdGg7XG4gICAgICAgIGlmICh0aGlzLm5lZWRzUmVmcmVzaChub2RlKSkge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBwYXJlbnRQYXRoID0gdGhpcy5nZXRQYXJlbnRQYXRoKG5vZGUucGF0aCk7XG4gICAgICAgICAgfSBjYXRjaChlKSB7XG4gICAgICAgICAgICAvLyBub2RlLnBhdGggaXMgYWxyZWFkeSAnLycsIGNhbid0IHRha2UgcGFyZW50UGF0aFxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAocGFyZW50UGF0aCAmJiB0aGlzLmFjY2Vzcy5jaGVja1BhdGhQZXJtaXNzaW9uKHBhcmVudFBhdGgsICdyJykpIHtcbiAgICAgICAgICAgIHRoaXMuYWRkVGFzayhwYXJlbnRQYXRoKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMuYWNjZXNzLmNoZWNrUGF0aFBlcm1pc3Npb24obm9kZS5wYXRoLCAncicpKSB7XG4gICAgICAgICAgICB0aGlzLmFkZFRhc2sobm9kZS5wYXRoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0uYmluZCh0aGlzKSkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuZGVsZXRlQ2hpbGRQYXRoc0Zyb21UYXNrcygpO1xuICAgICAgfS5iaW5kKHRoaXMpLCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgIHRocm93IGVycjtcbiAgICAgIH0pO1xuICAgIH0sXG5cbiAgICBmbHVzaDogZnVuY3Rpb24gKG5vZGVzKSB7XG4gICAgICBmb3IgKHZhciBwYXRoIGluIG5vZGVzKSB7XG4gICAgICAgIC8vIFN0cmF0ZWd5IGlzICdGTFVTSCcgYW5kIG5vIGxvY2FsIGNoYW5nZXMgZXhpc3RcbiAgICAgICAgaWYgKHRoaXMuY2FjaGluZy5jaGVja1BhdGgocGF0aCkgPT09ICdGTFVTSCcgJiYgbm9kZXNbcGF0aF0gJiYgIW5vZGVzW3BhdGhdLmxvY2FsKSB7XG4gICAgICAgICAgbG9nKCdbU3luY10gRmx1c2hpbmcnLCBwYXRoKTtcbiAgICAgICAgICBub2Rlc1twYXRoXSA9IHVuZGVmaW5lZDsgLy8gQ2F1c2Ugbm9kZSB0byBiZSBmbHVzaGVkIGZyb20gY2FjaGVcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG5vZGVzO1xuICAgIH0sXG5cbiAgICBkb1Rhc2s6IGZ1bmN0aW9uIChwYXRoKSB7XG4gICAgICByZXR1cm4gdGhpcy5sb2NhbC5nZXROb2RlcyhbcGF0aF0pLnRoZW4oZnVuY3Rpb24gKG5vZGVzKSB7XG4gICAgICAgIHZhciBub2RlID0gbm9kZXNbcGF0aF07XG4gICAgICAgIC8vIEZpcnN0IGZldGNoOlxuICAgICAgICBpZiAodHlwZW9mKG5vZGUpID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIHJldHVybiB0YXNrRm9yKCdnZXQnLCBwYXRoLCB0aGlzLnJlbW90ZS5nZXQocGF0aCkpO1xuICAgICAgICB9XG4gICAgICAgIC8vIEZldGNoIGtub3duLXN0YWxlIGNoaWxkOlxuICAgICAgICBlbHNlIGlmIChpc1N0YWxlQ2hpbGQobm9kZSkpIHtcbiAgICAgICAgICByZXR1cm4gdGFza0ZvcignZ2V0JywgcGF0aCwgdGhpcy5yZW1vdGUuZ2V0KHBhdGgpKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBQdXNoIFBVVDpcbiAgICAgICAgZWxzZSBpZiAodGhpcy5uZWVkc1JlbW90ZVB1dChub2RlKSkge1xuICAgICAgICAgIG5vZGUucHVzaCA9IGRlZXBDbG9uZShub2RlLmxvY2FsKTtcbiAgICAgICAgICBub2RlLnB1c2gudGltZXN0YW1wID0gdGhpcy5ub3coKTtcblxuICAgICAgICAgIHJldHVybiB0aGlzLmxvY2FsLnNldE5vZGVzKHRoaXMuZmx1c2gobm9kZXMpKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBvcHRpb25zO1xuICAgICAgICAgICAgaWYgKGhhc0NvbW1vblJldmlzaW9uKG5vZGUpKSB7XG4gICAgICAgICAgICAgIG9wdGlvbnMgPSB7IGlmTWF0Y2g6IG5vZGUuY29tbW9uLnJldmlzaW9uIH07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAvLyBJbml0aWFsIFBVVCAoZmFpbCBpZiBzb21ldGhpbmcgaXMgYWxyZWFkeSB0aGVyZSlcbiAgICAgICAgICAgICAgb3B0aW9ucyA9IHsgaWZOb25lTWF0Y2g6ICcqJyB9O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdGFza0ZvcigncHV0JywgcGF0aCxcbiAgICAgICAgICAgICAgdGhpcy5yZW1vdGUucHV0KHBhdGgsIG5vZGUucHVzaC5ib2R5LCBub2RlLnB1c2guY29udGVudFR5cGUsIG9wdGlvbnMpXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH0uYmluZCh0aGlzKSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUHVzaCBERUxFVEU6XG4gICAgICAgIGVsc2UgaWYgKHRoaXMubmVlZHNSZW1vdGVEZWxldGUobm9kZSkpIHtcbiAgICAgICAgICBub2RlLnB1c2ggPSB7IGJvZHk6IGZhbHNlLCB0aW1lc3RhbXA6IHRoaXMubm93KCkgfTtcblxuICAgICAgICAgIHJldHVybiB0aGlzLmxvY2FsLnNldE5vZGVzKHRoaXMuZmx1c2gobm9kZXMpKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChoYXNDb21tb25SZXZpc2lvbihub2RlKSkge1xuICAgICAgICAgICAgICByZXR1cm4gdGFza0ZvcignZGVsZXRlJywgcGF0aCxcbiAgICAgICAgICAgICAgICB0aGlzLnJlbW90ZS5kZWxldGUocGF0aCwgeyBpZk1hdGNoOiBub2RlLmNvbW1vbi5yZXZpc2lvbiB9KVxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfSBlbHNlIHsgLy8gQXNjZXJ0YWluIGN1cnJlbnQgY29tbW9uIG9yIHJlbW90ZSByZXZpc2lvbiBmaXJzdFxuICAgICAgICAgICAgICByZXR1cm4gdGFza0ZvcignZ2V0JywgcGF0aCwgdGhpcy5yZW1vdGUuZ2V0KHBhdGgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LmJpbmQodGhpcykpO1xuICAgICAgICB9XG4gICAgICAgIC8vIENvbmRpdGlvbmFsIHJlZnJlc2g6XG4gICAgICAgIGVsc2UgaWYgKGhhc0NvbW1vblJldmlzaW9uKG5vZGUpKSB7XG4gICAgICAgICAgcmV0dXJuIHRhc2tGb3IoJ2dldCcsIHBhdGgsXG4gICAgICAgICAgICB0aGlzLnJlbW90ZS5nZXQocGF0aCwgeyBpZk5vbmVNYXRjaDogbm9kZS5jb21tb24ucmV2aXNpb24gfSlcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHJldHVybiB0YXNrRm9yKCdnZXQnLCBwYXRoLCB0aGlzLnJlbW90ZS5nZXQocGF0aCkpO1xuICAgICAgICB9XG4gICAgICB9LmJpbmQodGhpcykpO1xuICAgIH0sXG5cbiAgICBhdXRvTWVyZ2VGb2xkZXI6IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICBpZiAobm9kZS5yZW1vdGUuaXRlbXNNYXApIHtcbiAgICAgICAgbm9kZS5jb21tb24gPSBub2RlLnJlbW90ZTtcbiAgICAgICAgZGVsZXRlIG5vZGUucmVtb3RlO1xuXG4gICAgICAgIGlmIChub2RlLmNvbW1vbi5pdGVtc01hcCkge1xuICAgICAgICAgIGZvciAodmFyIGl0ZW1OYW1lIGluIG5vZGUuY29tbW9uLml0ZW1zTWFwKSB7XG4gICAgICAgICAgICBpZiAoIW5vZGUubG9jYWwuaXRlbXNNYXBbaXRlbU5hbWVdKSB7XG4gICAgICAgICAgICAgIC8vIEluZGljYXRlcyB0aGUgbm9kZSBpcyBlaXRoZXIgbmV3bHkgYmVpbmcgZmV0Y2hlZFxuICAgICAgICAgICAgICAvLyBoYXMgYmVlbiBkZWxldGVkIGxvY2FsbHkgKHdoZXRoZXIgb3Igbm90IGxlYWRpbmcgdG8gY29uZmxpY3QpO1xuICAgICAgICAgICAgICAvLyBiZWZvcmUgbGlzdGluZyBpdCBpbiBsb2NhbCBsaXN0aW5ncywgY2hlY2sgaWYgYSBsb2NhbCBkZWxldGlvblxuICAgICAgICAgICAgICAvLyBleGlzdHMuXG4gICAgICAgICAgICAgIG5vZGUubG9jYWwuaXRlbXNNYXBbaXRlbU5hbWVdID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGVxdWFsKG5vZGUubG9jYWwuaXRlbXNNYXAsIG5vZGUuY29tbW9uLml0ZW1zTWFwKSkge1xuICAgICAgICAgICAgZGVsZXRlIG5vZGUubG9jYWw7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbm9kZTtcbiAgICB9LFxuXG4gICAgYXV0b01lcmdlRG9jdW1lbnQ6IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICBoYXNOb1JlbW90ZUNoYW5nZXMgPSBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICBpZiAobm9kZS5yZW1vdGUgJiYgbm9kZS5yZW1vdGUucmV2aXNpb24gJiYgbm9kZS5yZW1vdGUucmV2aXNpb24gIT09IG5vZGUuY29tbW9uLnJldmlzaW9uKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAobm9kZS5jb21tb24uYm9keSA9PT0gdW5kZWZpbmVkICYmIG5vZGUucmVtb3RlLmJvZHkgPT09IGZhbHNlKSB8fFxuICAgICAgICAgICAgICAgKG5vZGUucmVtb3RlLmJvZHkgPT09IG5vZGUuY29tbW9uLmJvZHkgJiZcbiAgICAgICAgICAgICAgICBub2RlLnJlbW90ZS5jb250ZW50VHlwZSA9PT0gbm9kZS5jb21tb24uY29udGVudFR5cGUpO1xuICAgICAgfTtcbiAgICAgIG1lcmdlTXV0dWFsRGVsZXRpb24gPSBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICBpZiAobm9kZS5yZW1vdGUgJiYgbm9kZS5yZW1vdGUuYm9keSA9PT0gZmFsc2VcbiAgICAgICAgICAgICYmIG5vZGUubG9jYWwgJiYgbm9kZS5sb2NhbC5ib2R5ID09PSBmYWxzZSkge1xuICAgICAgICAgICBkZWxldGUgbm9kZS5sb2NhbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgIH07XG5cbiAgICAgIGlmIChoYXNOb1JlbW90ZUNoYW5nZXMobm9kZSkpIHtcbiAgICAgICAgbm9kZSA9IG1lcmdlTXV0dWFsRGVsZXRpb24obm9kZSk7XG4gICAgICAgIGRlbGV0ZSBub2RlLnJlbW90ZTtcbiAgICAgIH0gZWxzZSBpZiAobm9kZS5yZW1vdGUuYm9keSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIC8vIGtlZXAvcmV2ZXJ0OlxuICAgICAgICBsb2coJ1tTeW5jXSBFbWl0dGluZyBrZWVwL3JldmVydCcpO1xuXG4gICAgICAgIHRoaXMubG9jYWwuX2VtaXRDaGFuZ2Uoe1xuICAgICAgICAgIG9yaWdpbjogICAgICAgICAnY29uZmxpY3QnLFxuICAgICAgICAgIHBhdGg6ICAgICAgICAgICBub2RlLnBhdGgsXG4gICAgICAgICAgb2xkVmFsdWU6ICAgICAgIG5vZGUubG9jYWwuYm9keSxcbiAgICAgICAgICBuZXdWYWx1ZTogICAgICAgbm9kZS5yZW1vdGUuYm9keSxcbiAgICAgICAgICBsYXN0Q29tbW9uVmFsdWU6IG5vZGUuY29tbW9uLmJvZHksXG4gICAgICAgICAgb2xkQ29udGVudFR5cGU6IG5vZGUubG9jYWwuY29udGVudFR5cGUsXG4gICAgICAgICAgbmV3Q29udGVudFR5cGU6IG5vZGUucmVtb3RlLmNvbnRlbnRUeXBlLFxuICAgICAgICAgIGxhc3RDb21tb25Db250ZW50VHlwZTogbm9kZS5jb21tb24uY29udGVudFR5cGVcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKG5vZGUucmVtb3RlLmJvZHkpIHtcbiAgICAgICAgICBub2RlLmNvbW1vbiA9IG5vZGUucmVtb3RlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5vZGUuY29tbW9uID0ge307XG4gICAgICAgIH1cbiAgICAgICAgZGVsZXRlIG5vZGUucmVtb3RlO1xuICAgICAgICBkZWxldGUgbm9kZS5sb2NhbDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBub2RlO1xuICAgIH0sXG5cbiAgICBhdXRvTWVyZ2U6IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICBpZiAobm9kZS5yZW1vdGUpIHtcbiAgICAgICAgaWYgKG5vZGUubG9jYWwpIHtcbiAgICAgICAgICBpZiAoaXNGb2xkZXIobm9kZS5wYXRoKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYXV0b01lcmdlRm9sZGVyKG5vZGUpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hdXRvTWVyZ2VEb2N1bWVudChub2RlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7IC8vIG5vIGxvY2FsIGNoYW5nZXNcbiAgICAgICAgICBpZiAoaXNGb2xkZXIobm9kZS5wYXRoKSkge1xuICAgICAgICAgICAgaWYgKG5vZGUucmVtb3RlLml0ZW1zTWFwICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgbm9kZS5jb21tb24gPSBub2RlLnJlbW90ZTtcbiAgICAgICAgICAgICAgZGVsZXRlIG5vZGUucmVtb3RlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAobm9kZS5yZW1vdGUuYm9keSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgIHZhciBjaGFuZ2UgPSB7XG4gICAgICAgICAgICAgICAgb3JpZ2luOiAgICdyZW1vdGUnLFxuICAgICAgICAgICAgICAgIHBhdGg6ICAgICBub2RlLnBhdGgsXG4gICAgICAgICAgICAgICAgb2xkVmFsdWU6IChub2RlLmNvbW1vbi5ib2R5ID09PSBmYWxzZSA/IHVuZGVmaW5lZCA6IG5vZGUuY29tbW9uLmJvZHkpLFxuICAgICAgICAgICAgICAgIG5ld1ZhbHVlOiAobm9kZS5yZW1vdGUuYm9keSA9PT0gZmFsc2UgPyB1bmRlZmluZWQgOiBub2RlLnJlbW90ZS5ib2R5KSxcbiAgICAgICAgICAgICAgICBvbGRDb250ZW50VHlwZTogbm9kZS5jb21tb24uY29udGVudFR5cGUsXG4gICAgICAgICAgICAgICAgbmV3Q29udGVudFR5cGU6IG5vZGUucmVtb3RlLmNvbnRlbnRUeXBlXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIGlmIChjaGFuZ2Uub2xkVmFsdWUgfHwgY2hhbmdlLm5ld1ZhbHVlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5sb2NhbC5fZW1pdENoYW5nZShjaGFuZ2UpO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgaWYgKCFub2RlLnJlbW90ZS5ib2R5KSB7IC8vIG5vIHJlbW90ZSwgc28gZGVsZXRlL2Rvbid0IGNyZWF0ZVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIG5vZGUuY29tbW9uID0gbm9kZS5yZW1vdGU7XG4gICAgICAgICAgICAgIGRlbGV0ZSBub2RlLnJlbW90ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChub2RlLmNvbW1vbi5ib2R5KSB7XG4gICAgICAgICAgdGhpcy5sb2NhbC5fZW1pdENoYW5nZSh7XG4gICAgICAgICAgICBvcmlnaW46ICAgJ3JlbW90ZScsXG4gICAgICAgICAgICBwYXRoOiAgICAgbm9kZS5wYXRoLFxuICAgICAgICAgICAgb2xkVmFsdWU6IG5vZGUuY29tbW9uLmJvZHksXG4gICAgICAgICAgICBuZXdWYWx1ZTogdW5kZWZpbmVkLFxuICAgICAgICAgICAgb2xkQ29udGVudFR5cGU6IG5vZGUuY29tbW9uLmNvbnRlbnRUeXBlLFxuICAgICAgICAgICAgbmV3Q29udGVudFR5cGU6IHVuZGVmaW5lZFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBub2RlO1xuICAgIH0sXG5cbiAgICB1cGRhdGVDb21tb25UaW1lc3RhbXA6IGZ1bmN0aW9uIChwYXRoLCByZXZpc2lvbikge1xuICAgICAgcmV0dXJuIHRoaXMubG9jYWwuZ2V0Tm9kZXMoW3BhdGhdKS50aGVuKGZ1bmN0aW9uIChub2Rlcykge1xuICAgICAgICBpZiAobm9kZXNbcGF0aF0gJiYgbm9kZXNbcGF0aF0uY29tbW9uICYmIG5vZGVzW3BhdGhdLmNvbW1vbi5yZXZpc2lvbiA9PT0gcmV2aXNpb24pIHtcbiAgICAgICAgICBub2Rlc1twYXRoXS5jb21tb24udGltZXN0YW1wID0gdGhpcy5ub3coKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5sb2NhbC5zZXROb2Rlcyh0aGlzLmZsdXNoKG5vZGVzKSk7XG4gICAgICB9LmJpbmQodGhpcykpO1xuICAgIH0sXG5cbiAgICBtYXJrQ2hpbGRyZW46IGZ1bmN0aW9uIChwYXRoLCBpdGVtc01hcCwgY2hhbmdlZE5vZGVzLCBtaXNzaW5nQ2hpbGRyZW4pIHtcbiAgICAgIHZhciBwYXRocyA9IFtdO1xuICAgICAgdmFyIG1ldGEgPSB7fTtcbiAgICAgIHZhciByZWN1cnNlID0ge307XG5cbiAgICAgIGZvciAodmFyIGl0ZW0gaW4gaXRlbXNNYXApIHtcbiAgICAgICAgcGF0aHMucHVzaChwYXRoK2l0ZW0pO1xuICAgICAgICBtZXRhW3BhdGgraXRlbV0gPSBpdGVtc01hcFtpdGVtXTtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIGNoaWxkTmFtZSBpbiBtaXNzaW5nQ2hpbGRyZW4pIHtcbiAgICAgICAgcGF0aHMucHVzaChwYXRoK2NoaWxkTmFtZSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLmxvY2FsLmdldE5vZGVzKHBhdGhzKS50aGVuKGZ1bmN0aW9uIChub2Rlcykge1xuICAgICAgICB2YXIgY2FjaGluZ1N0cmF0ZWd5O1xuICAgICAgICB2YXIgbm9kZTtcblxuICAgICAgICB2YXIgbm9kZUNoYW5nZWQgPSBmdW5jdGlvbiAobm9kZSwgZXRhZykge1xuICAgICAgICAgIHJldHVybiBub2RlLmNvbW1vbi5yZXZpc2lvbiAhPT0gZXRhZyAmJiAoIW5vZGUucmVtb3RlIHx8IG5vZGUucmVtb3RlLnJldmlzaW9uICE9PSBldGFnKTtcbiAgICAgICAgfTtcblxuICAgICAgICBmb3IgKHZhciBub2RlUGF0aCBpbiBub2Rlcykge1xuICAgICAgICAgIG5vZGUgPSBub2Rlc1tub2RlUGF0aF07XG5cbiAgICAgICAgICBpZiAobWV0YVtub2RlUGF0aF0pIHtcbiAgICAgICAgICAgIGlmIChub2RlICYmIG5vZGUuY29tbW9uKSB7XG4gICAgICAgICAgICAgIGlmIChub2RlQ2hhbmdlZChub2RlLCBtZXRhW25vZGVQYXRoXS5FVGFnKSkge1xuICAgICAgICAgICAgICAgIGNoYW5nZWROb2Rlc1tub2RlUGF0aF0gPSBkZWVwQ2xvbmUobm9kZSk7XG4gICAgICAgICAgICAgICAgY2hhbmdlZE5vZGVzW25vZGVQYXRoXS5yZW1vdGUgPSB7XG4gICAgICAgICAgICAgICAgICByZXZpc2lvbjogIG1ldGFbbm9kZVBhdGhdLkVUYWcsXG4gICAgICAgICAgICAgICAgICB0aW1lc3RhbXA6IHRoaXMubm93KClcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGNoYW5nZWROb2Rlc1tub2RlUGF0aF0gPSB0aGlzLmF1dG9NZXJnZShjaGFuZ2VkTm9kZXNbbm9kZVBhdGhdKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgY2FjaGluZ1N0cmF0ZWd5ID0gdGhpcy5jYWNoaW5nLmNoZWNrUGF0aChub2RlUGF0aCk7XG4gICAgICAgICAgICAgIGlmIChjYWNoaW5nU3RyYXRlZ3kgPT09ICdBTEwnKSB7XG4gICAgICAgICAgICAgICAgY2hhbmdlZE5vZGVzW25vZGVQYXRoXSA9IHtcbiAgICAgICAgICAgICAgICAgIHBhdGg6IG5vZGVQYXRoLFxuICAgICAgICAgICAgICAgICAgY29tbW9uOiB7XG4gICAgICAgICAgICAgICAgICAgIHRpbWVzdGFtcDogdGhpcy5ub3coKVxuICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgIHJlbW90ZToge1xuICAgICAgICAgICAgICAgICAgICByZXZpc2lvbjogbWV0YVtub2RlUGF0aF0uRVRhZyxcbiAgICAgICAgICAgICAgICAgICAgdGltZXN0YW1wOiB0aGlzLm5vdygpXG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoY2hhbmdlZE5vZGVzW25vZGVQYXRoXSAmJiBtZXRhW25vZGVQYXRoXVsnQ29udGVudC1UeXBlJ10pIHtcbiAgICAgICAgICAgICAgY2hhbmdlZE5vZGVzW25vZGVQYXRoXS5yZW1vdGUuY29udGVudFR5cGUgPSBtZXRhW25vZGVQYXRoXVsnQ29udGVudC1UeXBlJ107XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChjaGFuZ2VkTm9kZXNbbm9kZVBhdGhdICYmIG1ldGFbbm9kZVBhdGhdWydDb250ZW50LUxlbmd0aCddKSB7XG4gICAgICAgICAgICAgIGNoYW5nZWROb2Rlc1tub2RlUGF0aF0ucmVtb3RlLmNvbnRlbnRMZW5ndGggPSBtZXRhW25vZGVQYXRoXVsnQ29udGVudC1MZW5ndGgnXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgaWYgKG1pc3NpbmdDaGlsZHJlbltub2RlUGF0aC5zdWJzdHJpbmcocGF0aC5sZW5ndGgpXSAmJiBub2RlICYmIG5vZGUuY29tbW9uKSB7XG4gICAgICAgICAgICBpZiAobm9kZS5jb21tb24uaXRlbXNNYXApIHtcbiAgICAgICAgICAgICAgZm9yICh2YXIgY29tbW9uSXRlbSBpbiBub2RlLmNvbW1vbi5pdGVtc01hcCkge1xuICAgICAgICAgICAgICAgIHJlY3Vyc2Vbbm9kZVBhdGgrY29tbW9uSXRlbV0gPSB0cnVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChub2RlLmxvY2FsICYmIG5vZGUubG9jYWwuaXRlbXNNYXApIHtcbiAgICAgICAgICAgICAgZm9yICh2YXIgbG9jYWxJdGVtIGluIG5vZGUubG9jYWwuaXRlbXNNYXApIHtcbiAgICAgICAgICAgICAgICByZWN1cnNlW25vZGVQYXRoK2xvY2FsSXRlbV0gPSB0cnVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChub2RlLnJlbW90ZSB8fCBpc0ZvbGRlcihub2RlUGF0aCkpIHtcbiAgICAgICAgICAgICAgY2hhbmdlZE5vZGVzW25vZGVQYXRoXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGNoYW5nZWROb2Rlc1tub2RlUGF0aF0gPSB0aGlzLmF1dG9NZXJnZShub2RlKTtcblxuICAgICAgICAgICAgICBpZiAodHlwZW9mIGNoYW5nZWROb2Rlc1tub2RlUGF0aF0gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgdmFyIHBhcmVudFBhdGggPSB0aGlzLmdldFBhcmVudFBhdGgobm9kZVBhdGgpO1xuICAgICAgICAgICAgICAgIHZhciBwYXJlbnROb2RlID0gY2hhbmdlZE5vZGVzW3BhcmVudFBhdGhdO1xuICAgICAgICAgICAgICAgIHZhciBpdGVtTmFtZSA9IG5vZGVQYXRoLnN1YnN0cmluZyhwYXRoLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgaWYgKHBhcmVudE5vZGUgJiYgcGFyZW50Tm9kZS5sb2NhbCkge1xuICAgICAgICAgICAgICAgICAgZGVsZXRlIHBhcmVudE5vZGUubG9jYWwuaXRlbXNNYXBbaXRlbU5hbWVdO1xuXG4gICAgICAgICAgICAgICAgICBpZiAoZXF1YWwocGFyZW50Tm9kZS5sb2NhbC5pdGVtc01hcCwgcGFyZW50Tm9kZS5jb21tb24uaXRlbXNNYXApKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBwYXJlbnROb2RlLmxvY2FsO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLmRlbGV0ZVJlbW90ZVRyZWVzKE9iamVjdC5rZXlzKHJlY3Vyc2UpLCBjaGFuZ2VkTm9kZXMpLnRoZW4oZnVuY3Rpb24gKGNoYW5nZWRPYmpzMikge1xuICAgICAgICAgIHJldHVybiB0aGlzLmxvY2FsLnNldE5vZGVzKHRoaXMuZmx1c2goY2hhbmdlZE9ianMyKSk7XG4gICAgICAgIH0uYmluZCh0aGlzKSk7XG4gICAgICB9LmJpbmQodGhpcykpO1xuICAgIH0sXG5cbiAgICBkZWxldGVSZW1vdGVUcmVlczogZnVuY3Rpb24gKHBhdGhzLCBjaGFuZ2VkTm9kZXMpIHtcbiAgICAgIGlmIChwYXRocy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShjaGFuZ2VkTm9kZXMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5sb2NhbC5nZXROb2RlcyhwYXRocykudGhlbihmdW5jdGlvbiAobm9kZXMpIHtcbiAgICAgICAgdmFyIHN1YlBhdGhzID0ge307XG5cbiAgICAgICAgY29sbGVjdFN1YlBhdGhzID0gZnVuY3Rpb24gKGZvbGRlciwgcGF0aCkge1xuICAgICAgICAgIGlmIChmb2xkZXIgJiYgZm9sZGVyLml0ZW1zTWFwKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpdGVtTmFtZSBpbiBmb2xkZXIuaXRlbXNNYXApIHtcbiAgICAgICAgICAgICAgc3ViUGF0aHNbcGF0aCtpdGVtTmFtZV0gPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICBmb3IgKHZhciBwYXRoIGluIG5vZGVzKSB7XG4gICAgICAgICAgdmFyIG5vZGUgPSBub2Rlc1twYXRoXTtcblxuICAgICAgICAgIC8vIFRPRE8gV2h5IGNoZWNrIGZvciB0aGUgbm9kZSBoZXJlPyBJIGRvbid0IHRoaW5rIHRoaXMgY2hlY2sgZXZlciBhcHBsaWVzXG4gICAgICAgICAgaWYgKCFub2RlKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoaXNGb2xkZXIocGF0aCkpIHtcbiAgICAgICAgICAgIGNvbGxlY3RTdWJQYXRocyhub2RlLmNvbW1vbiwgcGF0aCk7XG4gICAgICAgICAgICBjb2xsZWN0U3ViUGF0aHMobm9kZS5sb2NhbCwgcGF0aCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChub2RlLmNvbW1vbiAmJiB0eXBlb2Yobm9kZS5jb21tb24uYm9keSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICBjaGFuZ2VkTm9kZXNbcGF0aF0gPSBkZWVwQ2xvbmUobm9kZSk7XG4gICAgICAgICAgICAgIGNoYW5nZWROb2Rlc1twYXRoXS5yZW1vdGUgPSB7XG4gICAgICAgICAgICAgICAgYm9keTogICAgICBmYWxzZSxcbiAgICAgICAgICAgICAgICB0aW1lc3RhbXA6IHRoaXMubm93KClcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgY2hhbmdlZE5vZGVzW3BhdGhdID0gdGhpcy5hdXRvTWVyZ2UoY2hhbmdlZE5vZGVzW3BhdGhdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBSZWN1cnNlIHdob2xlIHRyZWUgZGVwdGggbGV2ZWxzIGF0IG9uY2U6XG4gICAgICAgIHJldHVybiB0aGlzLmRlbGV0ZVJlbW90ZVRyZWVzKE9iamVjdC5rZXlzKHN1YlBhdGhzKSwgY2hhbmdlZE5vZGVzKS50aGVuKGZ1bmN0aW9uIChjaGFuZ2VkTm9kZXMyKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMubG9jYWwuc2V0Tm9kZXModGhpcy5mbHVzaChjaGFuZ2VkTm9kZXMyKSk7XG4gICAgICAgIH0uYmluZCh0aGlzKSk7XG4gICAgICB9LmJpbmQodGhpcykpO1xuICAgIH0sXG5cbiAgICBjb21wbGV0ZUZldGNoOiBmdW5jdGlvbiAocGF0aCwgYm9keU9ySXRlbXNNYXAsIGNvbnRlbnRUeXBlLCByZXZpc2lvbikge1xuICAgICAgdmFyIHBhdGhzO1xuICAgICAgdmFyIHBhcmVudFBhdGg7XG4gICAgICB2YXIgcGF0aHNGcm9tUm9vdEFyciA9IHBhdGhzRnJvbVJvb3QocGF0aCk7XG5cbiAgICAgIGlmIChpc0ZvbGRlcihwYXRoKSkge1xuICAgICAgICBwYXRocyA9IFtwYXRoXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBhcmVudFBhdGggPSBwYXRoc0Zyb21Sb290QXJyWzFdO1xuICAgICAgICBwYXRocyA9IFtwYXRoLCBwYXJlbnRQYXRoXTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMubG9jYWwuZ2V0Tm9kZXMocGF0aHMpLnRoZW4oZnVuY3Rpb24gKG5vZGVzKSB7XG4gICAgICAgIHZhciBpdGVtTmFtZTtcbiAgICAgICAgdmFyIG1pc3NpbmdDaGlsZHJlbiA9IHt9O1xuICAgICAgICB2YXIgbm9kZSA9IG5vZGVzW3BhdGhdO1xuICAgICAgICB2YXIgcGFyZW50Tm9kZTtcblxuICAgICAgICB2YXIgY29sbGVjdE1pc3NpbmdDaGlsZHJlbiA9IGZ1bmN0aW9uIChmb2xkZXIpIHtcbiAgICAgICAgICBpZiAoZm9sZGVyICYmIGZvbGRlci5pdGVtc01hcCkge1xuICAgICAgICAgICAgZm9yICh2YXIgaXRlbU5hbWUgaW4gZm9sZGVyLml0ZW1zTWFwKSB7XG4gICAgICAgICAgICAgIGlmICghYm9keU9ySXRlbXNNYXBbaXRlbU5hbWVdKSB7XG4gICAgICAgICAgICAgICAgbWlzc2luZ0NoaWxkcmVuW2l0ZW1OYW1lXSA9IHRydWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKHR5cGVvZihub2RlKSAhPT0gJ29iamVjdCcgIHx8IG5vZGUucGF0aCAhPT0gcGF0aCB8fFxuICAgICAgICAgICAgdHlwZW9mKG5vZGUuY29tbW9uKSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICBub2RlID0ge1xuICAgICAgICAgICAgcGF0aDogcGF0aCxcbiAgICAgICAgICAgIGNvbW1vbjoge31cbiAgICAgICAgICB9O1xuICAgICAgICAgIG5vZGVzW3BhdGhdID0gbm9kZTtcbiAgICAgICAgfVxuXG4gICAgICAgIG5vZGUucmVtb3RlID0ge1xuICAgICAgICAgIHJldmlzaW9uOiByZXZpc2lvbixcbiAgICAgICAgICB0aW1lc3RhbXA6IHRoaXMubm93KClcbiAgICAgICAgfTtcblxuICAgICAgICBpZiAoaXNGb2xkZXIocGF0aCkpIHtcbiAgICAgICAgICBjb2xsZWN0TWlzc2luZ0NoaWxkcmVuKG5vZGUuY29tbW9uKTtcbiAgICAgICAgICBjb2xsZWN0TWlzc2luZ0NoaWxkcmVuKG5vZGUucmVtb3RlKTtcblxuICAgICAgICAgIG5vZGUucmVtb3RlLml0ZW1zTWFwID0ge307XG4gICAgICAgICAgZm9yIChpdGVtTmFtZSBpbiBib2R5T3JJdGVtc01hcCkge1xuICAgICAgICAgICAgbm9kZS5yZW1vdGUuaXRlbXNNYXBbaXRlbU5hbWVdID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbm9kZS5yZW1vdGUuYm9keSA9IGJvZHlPckl0ZW1zTWFwO1xuICAgICAgICAgIG5vZGUucmVtb3RlLmNvbnRlbnRUeXBlID0gY29udGVudFR5cGU7XG5cbiAgICAgICAgICBwYXJlbnROb2RlID0gbm9kZXNbcGFyZW50UGF0aF07XG4gICAgICAgICAgaWYgKHBhcmVudE5vZGUgJiYgcGFyZW50Tm9kZS5sb2NhbCAmJiBwYXJlbnROb2RlLmxvY2FsLml0ZW1zTWFwKSB7XG4gICAgICAgICAgICBpdGVtTmFtZSA9IHBhdGguc3Vic3RyaW5nKHBhcmVudFBhdGgubGVuZ3RoKTtcbiAgICAgICAgICAgIHBhcmVudE5vZGUubG9jYWwuaXRlbXNNYXBbaXRlbU5hbWVdID0gdHJ1ZTtcbiAgICAgICAgICAgIGlmIChlcXVhbChwYXJlbnROb2RlLmxvY2FsLml0ZW1zTWFwLCBwYXJlbnROb2RlLmNvbW1vbi5pdGVtc01hcCkpIHtcbiAgICAgICAgICAgICAgZGVsZXRlIHBhcmVudE5vZGUubG9jYWw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgbm9kZXNbcGF0aF0gPSB0aGlzLmF1dG9NZXJnZShub2RlKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB0b0JlU2F2ZWQ6ICAgICAgIG5vZGVzLFxuICAgICAgICAgIG1pc3NpbmdDaGlsZHJlbjogbWlzc2luZ0NoaWxkcmVuXG4gICAgICAgIH07XG4gICAgICB9LmJpbmQodGhpcykpO1xuICAgIH0sXG5cbiAgICBjb21wbGV0ZVB1c2g6IGZ1bmN0aW9uIChwYXRoLCBhY3Rpb24sIGNvbmZsaWN0LCByZXZpc2lvbikge1xuICAgICAgcmV0dXJuIHRoaXMubG9jYWwuZ2V0Tm9kZXMoW3BhdGhdKS50aGVuKGZ1bmN0aW9uIChub2Rlcykge1xuICAgICAgICB2YXIgbm9kZSA9IG5vZGVzW3BhdGhdO1xuXG4gICAgICAgIGlmICghbm9kZS5wdXNoKSB7XG4gICAgICAgICAgdGhpcy5zdG9wcGVkID0gdHJ1ZTtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NvbXBsZXRlUHVzaCBjYWxsZWQgYnV0IG5vIHB1c2ggdmVyc2lvbiEnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjb25mbGljdCkge1xuICAgICAgICAgIGxvZygnW1N5bmNdIFdlIGhhdmUgYSBjb25mbGljdCcpO1xuXG4gICAgICAgICAgaWYgKCFub2RlLnJlbW90ZSB8fCBub2RlLnJlbW90ZS5yZXZpc2lvbiAhPT0gcmV2aXNpb24pIHtcbiAgICAgICAgICAgIG5vZGUucmVtb3RlID0ge1xuICAgICAgICAgICAgICByZXZpc2lvbjogIHJldmlzaW9uIHx8ICdjb25mbGljdCcsXG4gICAgICAgICAgICAgIHRpbWVzdGFtcDogdGhpcy5ub3coKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGRlbGV0ZSBub2RlLnB1c2g7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbm9kZXNbcGF0aF0gPSB0aGlzLmF1dG9NZXJnZShub2RlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBub2RlLmNvbW1vbiA9IHtcbiAgICAgICAgICAgIHJldmlzaW9uOiAgcmV2aXNpb24sXG4gICAgICAgICAgICB0aW1lc3RhbXA6IHRoaXMubm93KClcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgaWYgKGFjdGlvbiA9PT0gJ3B1dCcpIHtcbiAgICAgICAgICAgIG5vZGUuY29tbW9uLmJvZHkgPSBub2RlLnB1c2guYm9keTtcbiAgICAgICAgICAgIG5vZGUuY29tbW9uLmNvbnRlbnRUeXBlID0gbm9kZS5wdXNoLmNvbnRlbnRUeXBlO1xuXG4gICAgICAgICAgICBpZiAoZXF1YWwobm9kZS5sb2NhbC5ib2R5LCBub2RlLnB1c2guYm9keSkgJiZcbiAgICAgICAgICAgICAgICBub2RlLmxvY2FsLmNvbnRlbnRUeXBlID09PSBub2RlLnB1c2guY29udGVudFR5cGUpIHtcbiAgICAgICAgICAgICAgZGVsZXRlIG5vZGUubG9jYWw7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGRlbGV0ZSBub2RlLnB1c2g7XG4gICAgICAgICAgfSBlbHNlIGlmIChhY3Rpb24gPT09ICdkZWxldGUnKSB7XG4gICAgICAgICAgICBpZiAobm9kZS5sb2NhbC5ib2R5ID09PSBmYWxzZSkgeyAvLyBObyBuZXcgbG9jYWwgY2hhbmdlcyBzaW5jZSBwdXNoOyBmbHVzaCBpdC5cbiAgICAgICAgICAgICAgbm9kZXNbcGF0aF0gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBkZWxldGUgbm9kZS5wdXNoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLmxvY2FsLnNldE5vZGVzKHRoaXMuZmx1c2gobm9kZXMpKTtcbiAgICAgIH0uYmluZCh0aGlzKSk7XG4gICAgfSxcblxuICAgIGRlYWxXaXRoRmFpbHVyZTogZnVuY3Rpb24gKHBhdGgsIGFjdGlvbiwgc3RhdHVzTWVhbmluZykge1xuXG4gICAgICByZXR1cm4gdGhpcy5sb2NhbC5nZXROb2RlcyhbcGF0aF0pLnRoZW4oZnVuY3Rpb24gKG5vZGVzKSB7XG4gICAgICAgIGlmIChub2Rlc1twYXRoXSkge1xuICAgICAgICAgIGRlbGV0ZSBub2Rlc1twYXRoXS5wdXNoO1xuICAgICAgICAgIHJldHVybiB0aGlzLmxvY2FsLnNldE5vZGVzKHRoaXMuZmx1c2gobm9kZXMpKTtcbiAgICAgICAgfVxuICAgICAgfS5iaW5kKHRoaXMpKTtcbiAgICB9LFxuXG4gICAgaW50ZXJwcmV0U3RhdHVzOiBmdW5jdGlvbiAoc3RhdHVzQ29kZSkge1xuICAgICAgaWYgKHN0YXR1c0NvZGUgPT09ICdvZmZsaW5lJyB8fCBzdGF0dXNDb2RlID09PSAndGltZW91dCcpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBzdWNjZXNzZnVsOiAgICAgIGZhbHNlLFxuICAgICAgICAgIG5ldHdvcmtQcm9ibGVtczogdHJ1ZSxcbiAgICAgICAgICBzdGF0dXNDb2RlOiBzdGF0dXNDb2RlXG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIHZhciBzZXJpZXMgPSBNYXRoLmZsb29yKHN0YXR1c0NvZGUgLyAxMDApO1xuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBzdWNjZXNzZnVsOiAoc2VyaWVzID09PSAyIHx8IHN0YXR1c0NvZGUgPT09IDMwNCB8fCBzdGF0dXNDb2RlID09PSA0MTIgfHwgc3RhdHVzQ29kZSA9PT0gNDA0KSxcbiAgICAgICAgY29uZmxpY3Q6ICAgKHN0YXR1c0NvZGUgPT09IDQxMiksXG4gICAgICAgIHVuQXV0aDogICAgICgoc3RhdHVzQ29kZSA9PT0gNDAxICYmIHRoaXMucmVtb3RlLnRva2VuICE9PSBBdXRob3JpemUuSU1QTElFRF9GQUtFX1RPS0VOKSB8fFxuICAgICAgICAgICAgICAgICAgICAgc3RhdHVzQ29kZSA9PT0gNDAyIHx8IHN0YXR1c0NvZGUgPT09IDQwMyksXG4gICAgICAgIG5vdEZvdW5kOiAgIChzdGF0dXNDb2RlID09PSA0MDQpLFxuICAgICAgICBjaGFuZ2VkOiAgICAoc3RhdHVzQ29kZSAhPT0gMzA0KSxcbiAgICAgICAgc3RhdHVzQ29kZTogc3RhdHVzQ29kZVxuICAgICAgfTtcbiAgICB9LFxuXG4gICAgaGFuZGxlR2V0UmVzcG9uc2U6IGZ1bmN0aW9uIChwYXRoLCBzdGF0dXMsIGJvZHlPckl0ZW1zTWFwLCBjb250ZW50VHlwZSwgcmV2aXNpb24pIHtcbiAgICAgIGlmIChzdGF0dXMubm90Rm91bmQpIHtcbiAgICAgICAgaWYgKGlzRm9sZGVyKHBhdGgpKSB7XG4gICAgICAgICAgYm9keU9ySXRlbXNNYXAgPSB7fTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBib2R5T3JJdGVtc01hcCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChzdGF0dXMuY2hhbmdlZCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb21wbGV0ZUZldGNoKHBhdGgsIGJvZHlPckl0ZW1zTWFwLCBjb250ZW50VHlwZSwgcmV2aXNpb24pLnRoZW4oZnVuY3Rpb24gKGRhdGFGcm9tRmV0Y2gpIHtcbiAgICAgICAgICBpZiAoaXNGb2xkZXIocGF0aCkpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmNvcnJ1cHRTZXJ2ZXJJdGVtc01hcChib2R5T3JJdGVtc01hcCkpIHtcbiAgICAgICAgICAgICAgbG9nKCdbU3luY10gV0FSTklORzogRGlzY2FyZGluZyBjb3JydXB0IGZvbGRlciBkZXNjcmlwdGlvbiBmcm9tIHNlcnZlciBmb3IgJyArIHBhdGgpO1xuICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZXR1cm4gdGhpcy5tYXJrQ2hpbGRyZW4ocGF0aCwgYm9keU9ySXRlbXNNYXAsIGRhdGFGcm9tRmV0Y2gudG9CZVNhdmVkLCBkYXRhRnJvbUZldGNoLm1pc3NpbmdDaGlsZHJlbikudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5sb2NhbC5zZXROb2Rlcyh0aGlzLmZsdXNoKGRhdGFGcm9tRmV0Y2gudG9CZVNhdmVkKSkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9LmJpbmQodGhpcykpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudXBkYXRlQ29tbW9uVGltZXN0YW1wKHBhdGgsIHJldmlzaW9uKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIGhhbmRsZVJlc3BvbnNlOiBmdW5jdGlvbiAocGF0aCwgYWN0aW9uLCByKSB7XG4gICAgICB2YXIgc3RhdHVzID0gdGhpcy5pbnRlcnByZXRTdGF0dXMoci5zdGF0dXNDb2RlKTtcbiAgICAgIGlmIChzdGF0dXMuc3VjY2Vzc2Z1bCkge1xuICAgICAgICBpZiAoYWN0aW9uID09PSAnZ2V0Jykge1xuICAgICAgICAgIHJldHVybiB0aGlzLmhhbmRsZUdldFJlc3BvbnNlKHBhdGgsIHN0YXR1cywgci5ib2R5LCByLmNvbnRlbnRUeXBlLCByLnJldmlzaW9uKTtcbiAgICAgICAgfSBlbHNlIGlmIChhY3Rpb24gPT09ICdwdXQnIHx8IGFjdGlvbiA9PT0gJ2RlbGV0ZScpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5jb21wbGV0ZVB1c2gocGF0aCwgYWN0aW9uLCBzdGF0dXMuY29uZmxpY3QsIHIucmV2aXNpb24pLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdjYW5ub3QgaGFuZGxlIHJlc3BvbnNlIGZvciB1bmtub3duIGFjdGlvbicsIGFjdGlvbik7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAvLyBVbnN1Y2Nlc3NmdWxcbiAgICAgICAgdmFyIGVycm9yO1xuICAgICAgICBpZiAoc3RhdHVzLnVuQXV0aCkge1xuICAgICAgICAgIGVycm9yID0gbmV3IEF1dGhvcml6ZS5VbmF1dGhvcml6ZWQoKTtcbiAgICAgICAgfSBlbHNlIGlmIChzdGF0dXMubmV0d29ya1Byb2JsZW1zKSB7XG4gICAgICAgICAgZXJyb3IgPSBuZXcgU3luYy5TeW5jRXJyb3IoJ05ldHdvcmsgcmVxdWVzdCBmYWlsZWQuJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZXJyb3IgPSBuZXcgRXJyb3IoJ0hUVFAgcmVzcG9uc2UgY29kZSAnICsgc3RhdHVzLnN0YXR1c0NvZGUgKyAnIHJlY2VpdmVkLicpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuZGVhbFdpdGhGYWlsdXJlKHBhdGgsIGFjdGlvbiwgc3RhdHVzKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB0aGlzLnJlbW90ZVN0b3JhZ2UuX2VtaXQoJ2Vycm9yJywgZXJyb3IpO1xuICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgbnVtVGhyZWFkczogMTAsXG5cbiAgICBmaW5pc2hUYXNrOiBmdW5jdGlvbiAodGFzaykge1xuICAgICAgaWYgKHRhc2suYWN0aW9uID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgZGVsZXRlIHRoaXMuX3J1bm5pbmdbdGFzay5wYXRoXTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgICByZXR1cm4gdGFzay5wcm9taXNlLnRoZW4oZnVuY3Rpb24gKHIpIHtcbiAgICAgICAgcmV0dXJuIHNlbGYuaGFuZGxlUmVzcG9uc2UodGFzay5wYXRoLCB0YXNrLmFjdGlvbiwgcik7XG4gICAgICB9LCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgIGxvZygnW1N5bmNdIHdpcmVjbGllbnQgcmVqZWN0cyBpdHMgcHJvbWlzZSEnLCB0YXNrLnBhdGgsIHRhc2suYWN0aW9uLCBlcnIpO1xuICAgICAgICByZXR1cm4gc2VsZi5oYW5kbGVSZXNwb25zZSh0YXNrLnBhdGgsIHRhc2suYWN0aW9uLCB7c3RhdHVzQ29kZTogJ29mZmxpbmUnfSk7XG4gICAgICB9KVxuXG4gICAgICAudGhlbihmdW5jdGlvbiAoY29tcGxldGVkKSB7XG4gICAgICAgIGRlbGV0ZSBzZWxmLl90aW1lU3RhcnRlZFt0YXNrLnBhdGhdO1xuICAgICAgICBkZWxldGUgc2VsZi5fcnVubmluZ1t0YXNrLnBhdGhdO1xuXG4gICAgICAgIGlmIChjb21wbGV0ZWQpIHtcbiAgICAgICAgICBpZiAoc2VsZi5fdGFza3NbdGFzay5wYXRoXSkge1xuICAgICAgICAgICAgZm9yICh2YXIgaT0wOyBpPHNlbGYuX3Rhc2tzW3Rhc2sucGF0aF0ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgc2VsZi5fdGFza3NbdGFzay5wYXRoXVtpXSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGVsZXRlIHNlbGYuX3Rhc2tzW3Rhc2sucGF0aF07XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgc2VsZi5fZW1pdCgncmVxLWRvbmUnKTtcblxuICAgICAgICBzZWxmLmNvbGxlY3RUYXNrcyhmYWxzZSkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgLy8gU2VlIGlmIHRoZXJlIGFyZSBhbnkgbW9yZSB0YXNrcyB0aGF0IGFyZSBub3QgcmVmcmVzaCB0YXNrc1xuICAgICAgICAgIGlmICghc2VsZi5oYXNUYXNrcygpIHx8IHNlbGYuc3RvcHBlZCkge1xuICAgICAgICAgICAgbG9nKCdbU3luY10gU3luYyBpcyBkb25lISBSZXNjaGVkdWxlPycsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHNlbGYuX3Rhc2tzKS5sZW5ndGgsIHNlbGYuc3RvcHBlZCk7XG4gICAgICAgICAgICBpZiAoIXNlbGYuZG9uZSkge1xuICAgICAgICAgICAgICBzZWxmLmRvbmUgPSB0cnVlO1xuICAgICAgICAgICAgICBzZWxmLl9lbWl0KCdkb25lJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIFVzZSBhIDEwbXMgdGltZW91dCB0byBsZXQgdGhlIEphdmFTY3JpcHQgcnVudGltZSBjYXRjaCBpdHMgYnJlYXRoXG4gICAgICAgICAgICAvLyAoYW5kIGhvcGVmdWxseSBmb3JjZSBhbiBJbmRleGVkREIgYXV0by1jb21taXQ/KSwgYW5kIGFsc28gdG8gY2F1c2VcbiAgICAgICAgICAgIC8vIHRoZSB0aHJlYWRzIHRvIGdldCBzdGFnZ2VyZWQgYW5kIGdldCBhIGdvb2Qgc3ByZWFkIG92ZXIgdGltZTpcbiAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICBzZWxmLmRvVGFza3MoKTtcbiAgICAgICAgICAgIH0sIDEwKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSwgZnVuY3Rpb24gKGVycikge1xuICAgICAgICBsb2coJ1tTeW5jXSBFcnJvcicsIGVycik7XG4gICAgICAgIGRlbGV0ZSBzZWxmLl90aW1lU3RhcnRlZFt0YXNrLnBhdGhdO1xuICAgICAgICBkZWxldGUgc2VsZi5fcnVubmluZ1t0YXNrLnBhdGhdO1xuICAgICAgICBzZWxmLl9lbWl0KCdyZXEtZG9uZScpO1xuICAgICAgICBpZiAoIXNlbGYuZG9uZSkge1xuICAgICAgICAgIHNlbGYuZG9uZSA9IHRydWU7XG4gICAgICAgICAgc2VsZi5fZW1pdCgnZG9uZScpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9LFxuXG4gICAgZG9UYXNrczogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIG51bVRvSGF2ZSwgbnVtQWRkZWQgPSAwLCBudW1Ub0FkZCwgcGF0aDtcbiAgICAgIGlmICh0aGlzLnJlbW90ZS5jb25uZWN0ZWQpIHtcbiAgICAgICAgaWYgKHRoaXMucmVtb3RlLm9ubGluZSkge1xuICAgICAgICAgIG51bVRvSGF2ZSA9IHRoaXMubnVtVGhyZWFkcztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBudW1Ub0hhdmUgPSAxO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBudW1Ub0hhdmUgPSAwO1xuICAgICAgfVxuICAgICAgbnVtVG9BZGQgPSBudW1Ub0hhdmUgLSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0aGlzLl9ydW5uaW5nKS5sZW5ndGg7XG4gICAgICBpZiAobnVtVG9BZGQgPD0gMCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGZvciAocGF0aCBpbiB0aGlzLl90YXNrcykge1xuICAgICAgICBpZiAoIXRoaXMuX3J1bm5pbmdbcGF0aF0pIHtcbiAgICAgICAgICB0aGlzLl90aW1lU3RhcnRlZFtwYXRoXSA9IHRoaXMubm93KCk7XG4gICAgICAgICAgdGhpcy5fcnVubmluZ1twYXRoXSA9IHRoaXMuZG9UYXNrKHBhdGgpO1xuICAgICAgICAgIHRoaXMuX3J1bm5pbmdbcGF0aF0udGhlbih0aGlzLmZpbmlzaFRhc2suYmluZCh0aGlzKSk7XG4gICAgICAgICAgbnVtQWRkZWQrKztcbiAgICAgICAgICBpZiAobnVtQWRkZWQgPj0gbnVtVG9BZGQpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIChudW1BZGRlZCA+PSBudW1Ub0FkZCk7XG4gICAgfSxcblxuICAgIGNvbGxlY3RUYXNrczogZnVuY3Rpb24gKGFsc29DaGVja1JlZnJlc2gpIHtcbiAgICAgIGlmICh0aGlzLmhhc1Rhc2tzKCkgfHwgdGhpcy5zdG9wcGVkKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMuY29sbGVjdERpZmZUYXNrcygpLnRoZW4oZnVuY3Rpb24gKG51bURpZmZzKSB7XG4gICAgICAgIGlmIChudW1EaWZmcyB8fCBhbHNvQ2hlY2tSZWZyZXNoID09PSBmYWxzZSkge1xuICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5jb2xsZWN0UmVmcmVzaFRhc2tzKCk7XG4gICAgICAgIH1cbiAgICAgIH0uYmluZCh0aGlzKSwgZnVuY3Rpb24gKGVycikge1xuICAgICAgICB0aHJvdyBlcnI7XG4gICAgICB9KTtcbiAgICB9LFxuXG4gICAgYWRkVGFzazogZnVuY3Rpb24gKHBhdGgsIGNiKSB7XG4gICAgICBpZiAoIXRoaXMuX3Rhc2tzW3BhdGhdKSB7XG4gICAgICAgIHRoaXMuX3Rhc2tzW3BhdGhdID0gW107XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mKGNiKSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aGlzLl90YXNrc1twYXRoXS5wdXNoKGNiKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTWV0aG9kOiBzeW5jXG4gICAgICoqL1xuICAgIHN5bmM6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMuZG9uZSA9IGZhbHNlO1xuXG4gICAgICBpZiAoIXRoaXMuZG9UYXNrcygpKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbGxlY3RUYXNrcygpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aGlzLmRvVGFza3MoKTtcbiAgICAgICAgICB9IGNhdGNoKGUpIHtcbiAgICAgICAgICAgIGxvZygnW1N5bmNdIGRvVGFza3MgZXJyb3InLCBlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0uYmluZCh0aGlzKSwgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICBsb2coJ1tTeW5jXSBTeW5jIGVycm9yJywgZSk7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdMb2NhbCBjYWNoZSB1bmF2YWlsYWJsZScpO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICAgIH1cbiAgICB9LFxuICB9O1xuXG5cblxuICB2YXIgc3luY0N5Y2xlQ2IsIHN5bmNPbkNvbm5lY3Q7XG4gIFN5bmMuX3JzX2luaXQgPSBmdW5jdGlvbiAocmVtb3RlU3RvcmFnZSkge1xuXG4gICAgc3luY0N5Y2xlQ2IgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAvLyBpZiAoIWNvbmZpZy5jYWNoZSkgcmV0dXJuIGZhbHNlXG4gICAgICBsb2coJ1tTeW5jXSBzeW5jQ3ljbGVDYiBjYWxsaW5nIHN5bmNDeWNsZScpO1xuICAgICAgaWYgKEVudi5pc0Jyb3dzZXIoKSkge1xuICAgICAgICBoYW5kbGVWaXNpYmlsaXR5LmJpbmQocmVtb3RlU3RvcmFnZSkoKTtcbiAgICAgIH1cblxuXG4gICAgICBpZiAoIXJlbW90ZVN0b3JhZ2Uuc3luYykge1xuICAgICAgICAvLyBDYWxsIHRoaXMgbm93IHRoYXQgYWxsIG90aGVyIG1vZHVsZXMgYXJlIGFsc28gcmVhZHk6XG4gICAgICAgIHJlbW90ZVN0b3JhZ2Uuc3luYyA9IG5ldyBTeW5jKHJlbW90ZVN0b3JhZ2UsXG4gICAgICAgICAgICByZW1vdGVTdG9yYWdlLmxvY2FsLCByZW1vdGVTdG9yYWdlLnJlbW90ZSwgcmVtb3RlU3RvcmFnZS5hY2Nlc3MsXG4gICAgICAgICAgICByZW1vdGVTdG9yYWdlLmNhY2hpbmcpO1xuXG4gICAgICAgIGlmIChyZW1vdGVTdG9yYWdlLnN5bmNTdG9wcGVkKSB7XG4gICAgICAgICAgbG9nKCdbU3luY10gSW5zdGFudGlhdGluZyBzeW5jIHN0b3BwZWQnKTtcbiAgICAgICAgICByZW1vdGVTdG9yYWdlLnN5bmMuc3RvcHBlZCA9IHRydWU7XG4gICAgICAgICAgZGVsZXRlIHJlbW90ZVN0b3JhZ2Uuc3luY1N0b3BwZWQ7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgbG9nKCdbU3luY10gc3luY0N5Y2xlQ2IgY2FsbGluZyBzeW5jQ3ljbGUnKTtcbiAgICAgIHJlbW90ZVN0b3JhZ2Uuc3luY0N5Y2xlKCk7XG4gICAgfTtcblxuICAgIHN5bmNPbkNvbm5lY3QgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJlbW90ZVN0b3JhZ2UucmVtb3ZlRXZlbnRMaXN0ZW5lcignY29ubmVjdGVkJywgc3luY09uQ29ubmVjdCk7XG4gICAgICByZW1vdGVTdG9yYWdlLnN0YXJ0U3luYygpO1xuICAgIH07XG5cbiAgICByZW1vdGVTdG9yYWdlLm9uKCdyZWFkeScsIHN5bmNDeWNsZUNiKTtcbiAgICByZW1vdGVTdG9yYWdlLm9uKCdjb25uZWN0ZWQnLCBzeW5jT25Db25uZWN0KTtcbiAgfTtcblxuICBTeW5jLl9yc19jbGVhbnVwID0gZnVuY3Rpb24gKHJlbW90ZVN0b3JhZ2UpIHtcbiAgICByZW1vdGVTdG9yYWdlLnN0b3BTeW5jKCk7XG4gICAgcmVtb3RlU3RvcmFnZS5yZW1vdmVFdmVudExpc3RlbmVyKCdyZWFkeScsIHN5bmNDeWNsZUNiKTtcbiAgICByZW1vdGVTdG9yYWdlLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2Nvbm5lY3RlZCcsIHN5bmNPbkNvbm5lY3QpO1xuXG4gICAgcmVtb3RlU3RvcmFnZS5zeW5jID0gdW5kZWZpbmVkO1xuICAgIGRlbGV0ZSByZW1vdGVTdG9yYWdlLnN5bmM7XG4gIH07XG5cbiAgXG4gIHZhciBTeW5jRXJyb3IgPSBmdW5jdGlvbiAob3JpZ2luYWxFcnJvcikge1xuICAgIHZhciBtc2cgPSAnU3luYyBmYWlsZWQ6ICc7XG4gICAgaWYgKHR5cGVvZihvcmlnaW5hbEVycm9yKSA9PT0gJ29iamVjdCcgJiYgJ21lc3NhZ2UnIGluIG9yaWdpbmFsRXJyb3IpIHtcbiAgICAgIG1zZyArPSBvcmlnaW5hbEVycm9yLm1lc3NhZ2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIG1zZyArPSBvcmlnaW5hbEVycm9yO1xuICAgIH1cbiAgICB0aGlzLm9yaWdpbmFsRXJyb3IgPSBvcmlnaW5hbEVycm9yO1xuICAgIHRoaXMubWVzc2FnZSA9IG1zZztcbiAgfTtcblxuICBTeW5jRXJyb3IucHJvdG90eXBlID0gbmV3IEVycm9yKCk7XG4gIFN5bmNFcnJvci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBTeW5jRXJyb3I7XG5cbiAgU3luYy5TeW5jRXJyb3IgPSBTeW5jRXJyb3I7XG5cbiAgbW9kdWxlLmV4cG9ydHMgPSBTeW5jO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL3N5bmMuanMiXSwic291cmNlUm9vdCI6IiJ9");
},function(module,exports,__webpack_require__){eval("/* WEBPACK VAR INJECTION */(function(global, Buffer) {'use strict';\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar log = __webpack_require__(1);\nvar util = __webpack_require__(2);\nvar eventHandling = __webpack_require__(3);\nvar Authorize = __webpack_require__(4);\n\n/**\n * Class: WireClient\n *\n * WireClient Interface\n * --------------------\n *\n * This file exposes a get/put/delete interface on top of XMLHttpRequest.\n * It requires to be configured with parameters about the remotestorage server to\n * connect to.\n * Each instance of WireClient is always associated with a single remotestorage\n * server and access token.\n *\n * Usually the WireClient instance can be accessed via `remoteStorage.remote`.\n *\n * This is the get/put/delete interface:\n *\n *   - #get() takes a path and optionally a ifNoneMatch option carrying a version\n *     string to check. It returns a promise that will be fulfilled with the HTTP\n *     response status, the response body, the MIME type as returned in the\n *     'Content-Type' header and the current revision, as returned in the 'ETag'\n *     header.\n *   - #put() takes a path, the request body and a content type string. It also\n *     accepts the ifMatch and ifNoneMatch options, that map to the If-Match and\n *     If-None-Match headers respectively. See the remotestorage-01 specification\n *     for details on handling these headers. It returns a promise, fulfilled with\n *     the same values as the one for #get().\n *   - #delete() takes a path and the ifMatch option as well. It returns a promise\n *     fulfilled with the same values as the one for #get().\n *\n * In addition to this, the WireClient has some compatibility features to work with\n * remotestorage 2012.04 compatible storages. For example it will cache revisions\n * from folder listings in-memory and return them accordingly as the \"revision\"\n * parameter in response to #get() requests. Similarly it will return 404 when it\n * receives an empty folder listing, to mimic remotestorage-01 behavior. Note\n * that it is not always possible to know the revision beforehand, hence it may\n * be undefined at times (especially for caching-roots).\n */\n\nvar hasLocalStorage;\nvar SETTINGS_KEY = 'remotestorage:wireclient';\n\nvar API_2012 = 1,\n    API_00 = 2,\n    API_01 = 3,\n    API_02 = 4,\n    API_HEAD = 5;\n\nvar STORAGE_APIS = {\n  'draft-dejong-remotestorage-00': API_00,\n  'draft-dejong-remotestorage-01': API_01,\n  'draft-dejong-remotestorage-02': API_02,\n  'https://www.w3.org/community/rww/wiki/read-write-web-00#simple': API_2012\n};\n\nvar isArrayBufferView;\n\nif (typeof ArrayBufferView === 'function') {\n  isArrayBufferView = function isArrayBufferView(object) {\n    return object && object instanceof ArrayBufferView;\n  };\n} else {\n  var arrayBufferViews = [Int8Array, Uint8Array, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array];\n  isArrayBufferView = function isArrayBufferView(object) {\n    for (var i = 0; i < 8; i++) {\n      if (object instanceof arrayBufferViews[i]) {\n        return true;\n      }\n    }\n    return false;\n  };\n}\n\nvar isFolder = util.isFolder;\nvar cleanPath = util.cleanPath;\n\nfunction addQuotes(str) {\n  if (typeof str !== 'string') {\n    return str;\n  }\n  if (str === '*') {\n    return '*';\n  }\n\n  return '\"' + str + '\"';\n}\n\nfunction stripQuotes(str) {\n  if (typeof str !== 'string') {\n    return str;\n  }\n\n  return str.replace(/^[\"']|[\"']$/g, '');\n}\n\nfunction readBinaryData(content, mimeType, callback) {\n  var blob;\n  util.globalContext.BlobBuilder = util.globalContext.BlobBuilder || util.globalContext.WebKitBlobBuilder;\n  if (typeof util.globalContext.BlobBuilder !== 'undefined') {\n    var bb = new global.BlobBuilder();\n    bb.append(content);\n    blob = bb.getBlob(mimeType);\n  } else {\n    blob = new Blob([content], { type: mimeType });\n  }\n\n  var reader = new FileReader();\n  if (typeof reader.addEventListener === 'function') {\n    reader.addEventListener('loadend', function () {\n      callback(reader.result); // reader.result contains the contents of blob as a typed array\n    });\n  } else {\n    reader.onloadend = function () {\n      callback(reader.result); // reader.result contains the contents of blob as a typed array\n    };\n  }\n  reader.readAsArrayBuffer(blob);\n}\n\nfunction getTextFromArrayBuffer(arrayBuffer, encoding) {\n  return new Promise(function (resolve, reject) {\n    if (typeof Blob === 'undefined') {\n      var buffer = new Buffer(new Uint8Array(arrayBuffer));\n      resolve(buffer.toString(encoding));\n    } else {\n      var blob;\n      util.globalContext.BlobBuilder = util.globalContext.BlobBuilder || util.globalContext.WebKitBlobBuilder;\n      if (typeof util.globalContext.BlobBuilder !== 'undefined') {\n        var bb = new global.BlobBuilder();\n        bb.append(arrayBuffer);\n        blob = bb.getBlob();\n      } else {\n        blob = new Blob([arrayBuffer]);\n      }\n\n      var fileReader = new FileReader();\n      if (typeof fileReader.addEventListener === 'function') {\n        fileReader.addEventListener('loadend', function (evt) {\n          resolve(evt.target.result);\n        });\n      } else {\n        fileReader.onloadend = function (evt) {\n          resolve(evt.target.result);\n        };\n      }\n      fileReader.readAsText(blob, encoding);\n    }\n  });\n}\n\nfunction determineCharset(mimeType) {\n  var charset = 'UTF-8';\n  var charsetMatch;\n\n  if (mimeType) {\n    charsetMatch = mimeType.match(/charset=(.+)$/);\n    if (charsetMatch) {\n      charset = charsetMatch[1];\n    }\n  }\n  return charset;\n}\n\nfunction isFolderDescription(body) {\n  return body['@context'] === 'http://remotestorage.io/spec/folder-description' && _typeof(body['items']) === 'object';\n}\n\nfunction isSuccessStatus(status) {\n  return [201, 204, 304].indexOf(status) >= 0;\n}\n\nfunction isErrorStatus(status) {\n  return [401, 403, 404, 412].indexOf(status) >= 0;\n}\n\nvar onErrorCb;\n\n/**\n * Class : WireClient\n **/\nvar WireClient = function WireClient(rs) {\n  this.rs = rs;\n  this.connected = false;\n\n  /**\n   * Event: change\n   *   Never fired for some reason\n   *   # TODO create issue and fix or remove\n   *\n   * Event: connected\n   *   Fired when the wireclient connect method realizes that it is in\n   *   possession of a token and href\n   **/\n  eventHandling(this, 'change', 'connected', 'not-connected', 'wire-busy', 'wire-done');\n\n  onErrorCb = function (error) {\n    if (error instanceof Authorize.Unauthorized) {\n      this.configure({ token: null });\n    }\n  }.bind(this);\n  rs.on('error', onErrorCb);\n  if (hasLocalStorage) {\n    var settings;\n    try {\n      settings = JSON.parse(localStorage[SETTINGS_KEY]);\n    } catch (e) {}\n    if (settings) {\n      setTimeout(function () {\n        this.configure(settings);\n      }.bind(this), 0);\n    }\n  }\n\n  this._revisionCache = {};\n\n  if (this.connected) {\n    setTimeout(this._emit.bind(this), 0, 'connected');\n  }\n};\n\n// should we put this in config ?\nWireClient.REQUEST_TIMEOUT = 30000;\n\nWireClient.prototype = {\n  /**\n   * Property: token\n   *\n   * Holds the bearer token of this WireClient, as obtained in the OAuth dance\n   *\n   * Example:\n   *   (start code)\n   *\n   *   remoteStorage.remote.token\n   *   // -> 'DEADBEEF01=='\n   */\n\n  /**\n   * Property: href\n   *\n   * Holds the server's base URL, as obtained in the Webfinger discovery\n   *\n   * Example:\n   *   (start code)\n   *\n   *   remoteStorage.remote.href\n   *   // -> 'https://storage.example.com/users/jblogg/'\n   */\n\n  /**\n   * Property: storageApi\n   *\n   * Holds the spec version the server claims to be compatible with\n   *\n   * Example:\n   *   (start code)\n   *\n   *   remoteStorage.remote.storageApi\n   *   // -> 'draft-dejong-remotestorage-01'\n   */\n\n  _request: function _request(method, uri, token, headers, body, getEtag, fakeRevision) {\n    if ((method === 'PUT' || method === 'DELETE') && uri[uri.length - 1] === '/') {\n      return Promise.reject('Don\\'t ' + method + ' on directories!');\n    }\n\n    var revision;\n    var self = this;\n\n    if (token !== Authorize.IMPLIED_FAKE_TOKEN) {\n      headers['Authorization'] = 'Bearer ' + token;\n    }\n\n    this._emit('wire-busy', {\n      method: method,\n      isFolder: isFolder(uri)\n    });\n\n    return WireClient.request(method, uri, {\n      body: body,\n      headers: headers,\n      responseType: 'arraybuffer'\n    }).then(function (response) {\n      if (!self.online) {\n        self.online = true;\n        self.rs._emit('network-online');\n      }\n      self._emit('wire-done', {\n        method: method,\n        isFolder: isFolder(uri),\n        success: true\n      });\n\n      if (isErrorStatus(response.status)) {\n        log('[WireClient] Error response status', response.status);\n        if (getEtag) {\n          revision = stripQuotes(response.getResponseHeader('ETag'));\n        } else {\n          revision = undefined;\n        }\n        return Promise.resolve({ statusCode: response.status, revision: revision });\n      } else if (isSuccessStatus(response.status) || response.status === 200 && method !== 'GET') {\n        revision = stripQuotes(response.getResponseHeader('ETag'));\n        log('[WireClient] Successful request', revision);\n        return Promise.resolve({ statusCode: response.status, revision: revision });\n      } else {\n        var mimeType = response.getResponseHeader('Content-Type');\n        if (getEtag) {\n          revision = stripQuotes(response.getResponseHeader('ETag'));\n        } else {\n          revision = response.status === 200 ? fakeRevision : undefined;\n        }\n\n        var charset = determineCharset(mimeType);\n\n        if (!mimeType || charset === 'binary') {\n          log('[WireClient] Successful request with unknown or binary mime-type', revision);\n          return Promise.resolve({ statusCode: response.status, body: response.response, contentType: mimeType, revision: revision });\n        } else {\n          return getTextFromArrayBuffer(response.response, charset).then(function (body) {\n            log('[WireClient] Successful request', revision);\n            return Promise.resolve({ statusCode: response.status, body: body, contentType: mimeType, revision: revision });\n          });\n        }\n      }\n    }, function (error) {\n      if (self.online) {\n        self.online = false;\n        self.rs._emit('network-offline');\n      }\n      self._emit('wire-done', {\n        method: method,\n        isFolder: isFolder(uri),\n        success: false\n      });\n\n      return Promise.reject(error);\n    });\n  },\n\n  /**\n   *\n   * Method: configure\n   *\n   * Sets the userAddress, href, storageApi, token, and properties of a\n   * remote store. Also sets connected and online to true and emits the\n   * 'connected' event, if both token and href are present.\n   *\n   * Parameters:\n   *   settings - An object that may contain userAddress (string or null),\n   *              href (string or null), storageApi (string or null), token (string\n   *              or null), and/or properties (the JSON-parsed properties object\n   *              from the user's WebFinger record, see section 10 of\n   *              http://tools.ietf.org/html/draft-dejong-remotestorage-03\n   *              or null).\n   *              Fields that are not included (i.e. `undefined`), stay at\n   *              their current value. To set a field, include that field\n   *              with a `string` value. To reset a field, for instance when\n   *              the user disconnected their storage, or you found that the\n   *              token you have has expired, simply set that field to `null`.\n   */\n  configure: function configure(settings) {\n    if ((typeof settings === 'undefined' ? 'undefined' : _typeof(settings)) !== 'object') {\n      throw new Error('WireClient configure settings parameter should be an object');\n    }\n    if (typeof settings.userAddress !== 'undefined') {\n      this.userAddress = settings.userAddress;\n    }\n    if (typeof settings.href !== 'undefined') {\n      this.href = settings.href;\n    }\n    if (typeof settings.storageApi !== 'undefined') {\n      this.storageApi = settings.storageApi;\n    }\n    if (typeof settings.token !== 'undefined') {\n      this.token = settings.token;\n    }\n    if (typeof settings.properties !== 'undefined') {\n      this.properties = settings.properties;\n    }\n\n    if (typeof this.storageApi !== 'undefined') {\n      this._storageApi = STORAGE_APIS[this.storageApi] || API_HEAD;\n      this.supportsRevs = this._storageApi >= API_00;\n    }\n    if (this.href && this.token) {\n      this.connected = true;\n      this.online = true;\n      this._emit('connected');\n    } else {\n      this.connected = false;\n    }\n    if (hasLocalStorage) {\n      localStorage[SETTINGS_KEY] = JSON.stringify({\n        userAddress: this.userAddress,\n        href: this.href,\n        storageApi: this.storageApi,\n        token: this.token,\n        properties: this.properties\n      });\n    }\n  },\n\n  stopWaitingForToken: function stopWaitingForToken() {\n    if (!this.connected) {\n      this._emit('not-connected');\n    }\n  },\n\n  get: function get(path, options) {\n    var self = this;\n    if (!this.connected) {\n      return Promise.reject('not connected (path: ' + path + ')');\n    }\n    if (!options) {\n      options = {};\n    }\n    var headers = {};\n    if (this.supportsRevs) {\n      if (options.ifNoneMatch) {\n        headers['If-None-Match'] = addQuotes(options.ifNoneMatch);\n      }\n    }\n    // commenting it out as this is doing nothing and jshint is complaining -les\n    // else if (options.ifNoneMatch) {\n    //   var oldRev = this._revisionCache[path];\n    // }\n\n\n    return this._request('GET', this.href + cleanPath(path), this.token, headers, undefined, this.supportsRevs, this._revisionCache[path]).then(function (r) {\n      if (!isFolder(path)) {\n        return Promise.resolve(r);\n      }\n      var itemsMap = {};\n      if (typeof r.body !== 'undefined') {\n        try {\n          r.body = JSON.parse(r.body);\n        } catch (e) {\n          return Promise.reject('Folder description at ' + self.href + cleanPath(path) + ' is not JSON');\n        }\n      }\n\n      if (r.statusCode === 200 && _typeof(r.body) === 'object') {\n        // New folder listing received\n        if (Object.keys(r.body).length === 0) {\n          // Empty folder listing of any spec\n          r.statusCode = 404;\n        } else if (isFolderDescription(r.body)) {\n          // >= 02 spec\n          for (var item in r.body.items) {\n            self._revisionCache[path + item] = r.body.items[item].ETag;\n          }\n          itemsMap = r.body.items;\n        } else {\n          // < 02 spec\n          Object.keys(r.body).forEach(function (key) {\n            self._revisionCache[path + key] = r.body[key];\n            itemsMap[key] = { 'ETag': r.body[key] };\n          });\n        }\n        r.body = itemsMap;\n        return Promise.resolve(r);\n      } else {\n        return Promise.resolve(r);\n      }\n    });\n  },\n\n  put: function put(path, body, contentType, options) {\n    if (!this.connected) {\n      return Promise.reject('not connected (path: ' + path + ')');\n    }\n    if (!options) {\n      options = {};\n    }\n    if (!contentType.match(/charset=/) && (body instanceof ArrayBuffer || isArrayBufferView(body))) {\n      contentType += '; charset=binary';\n    }\n    var headers = { 'Content-Type': contentType };\n    if (this.supportsRevs) {\n      if (options.ifMatch) {\n        headers['If-Match'] = addQuotes(options.ifMatch);\n      }\n      if (options.ifNoneMatch) {\n        headers['If-None-Match'] = addQuotes(options.ifNoneMatch);\n      }\n    }\n    return this._request('PUT', this.href + cleanPath(path), this.token, headers, body, this.supportsRevs);\n  },\n\n  'delete': function _delete(path, options) {\n    if (!this.connected) {\n      throw new Error('not connected (path: ' + path + ')');\n    }\n    if (!options) {\n      options = {};\n    }\n    var headers = {};\n    if (this.supportsRevs) {\n      if (options.ifMatch) {\n        headers['If-Match'] = addQuotes(options.ifMatch);\n      }\n    }\n    return this._request('DELETE', this.href + cleanPath(path), this.token, headers, undefined, this.supportsRevs);\n  }\n};\n\n// Shared cleanPath used by Dropbox\nWireClient.cleanPath = cleanPath;\n\n// Shared isArrayBufferView used by WireClient and Dropbox\nWireClient.isArrayBufferView = isArrayBufferView;\n\nWireClient.readBinaryData = readBinaryData;\n\n// Shared request function used by WireClient, GoogleDrive and Dropbox.\n// TODO: Should we use fetch ?\nWireClient.request = function (method, url, options) {\n  return new Promise(function (resolve, reject) {\n\n    log('[WireClient]', method, url);\n\n    var timedOut = false;\n\n    var timer = setTimeout(function () {\n      timedOut = true;\n      reject('timeout');\n    }, WireClient.REQUEST_TIMEOUT);\n\n    var xhr = new XMLHttpRequest();\n    xhr.open(method, url, true);\n\n    if (options.responseType) {\n      xhr.responseType = options.responseType;\n    }\n\n    if (options.headers) {\n      for (var key in options.headers) {\n        xhr.setRequestHeader(key, options.headers[key]);\n      }\n    }\n\n    xhr.onload = function () {\n      if (timedOut) {\n        return;\n      }\n      clearTimeout(timer);\n      resolve(xhr);\n    };\n\n    xhr.onerror = function (error) {\n      if (timedOut) {\n        return;\n      }\n      clearTimeout(timer);\n      reject(error);\n    };\n\n    var body = options.body;\n\n    if ((typeof body === 'undefined' ? 'undefined' : _typeof(body)) === 'object' && !isArrayBufferView(body) && body instanceof ArrayBuffer) {\n      body = new Uint8Array(body);\n    }\n    xhr.send(body);\n  });\n};\n\nObject.defineProperty(WireClient.prototype, 'storageType', {\n  get: function get() {\n    if (this.storageApi) {\n      var spec = this.storageApi.match(/draft-dejong-(remotestorage-\\d\\d)/);\n      return spec ? spec[1] : '2012.04';\n    }\n  }\n});\n\nWireClient._rs_init = function (remoteStorage) {\n  hasLocalStorage = util.localStorageAvailable();\n  remoteStorage.remote = new WireClient(remoteStorage);\n  this.online = true;\n};\n\nWireClient._rs_supported = function () {\n  return !!XMLHttpRequest;\n};\n\nWireClient._rs_cleanup = function (remoteStorage) {\n  if (hasLocalStorage) {\n    delete localStorage[SETTINGS_KEY];\n  }\n  remoteStorage.removeEventListener('error', onErrorCb);\n};\n\nmodule.exports = WireClient;\n/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }()), __webpack_require__(25).Buffer))\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvd2lyZWNsaWVudC5qcz83NTRlIl0sIm5hbWVzIjpbImxvZyIsInJlcXVpcmUiLCJ1dGlsIiwiZXZlbnRIYW5kbGluZyIsIkF1dGhvcml6ZSIsImhhc0xvY2FsU3RvcmFnZSIsIlNFVFRJTkdTX0tFWSIsIkFQSV8yMDEyIiwiQVBJXzAwIiwiQVBJXzAxIiwiQVBJXzAyIiwiQVBJX0hFQUQiLCJTVE9SQUdFX0FQSVMiLCJpc0FycmF5QnVmZmVyVmlldyIsIkFycmF5QnVmZmVyVmlldyIsIm9iamVjdCIsImFycmF5QnVmZmVyVmlld3MiLCJJbnQ4QXJyYXkiLCJVaW50OEFycmF5IiwiSW50MTZBcnJheSIsIlVpbnQxNkFycmF5IiwiSW50MzJBcnJheSIsIlVpbnQzMkFycmF5IiwiRmxvYXQzMkFycmF5IiwiRmxvYXQ2NEFycmF5IiwiaSIsImlzRm9sZGVyIiwiY2xlYW5QYXRoIiwiYWRkUXVvdGVzIiwic3RyIiwic3RyaXBRdW90ZXMiLCJyZXBsYWNlIiwicmVhZEJpbmFyeURhdGEiLCJjb250ZW50IiwibWltZVR5cGUiLCJjYWxsYmFjayIsImJsb2IiLCJnbG9iYWxDb250ZXh0IiwiQmxvYkJ1aWxkZXIiLCJXZWJLaXRCbG9iQnVpbGRlciIsImJiIiwiZ2xvYmFsIiwiYXBwZW5kIiwiZ2V0QmxvYiIsIkJsb2IiLCJ0eXBlIiwicmVhZGVyIiwiRmlsZVJlYWRlciIsImFkZEV2ZW50TGlzdGVuZXIiLCJyZXN1bHQiLCJvbmxvYWRlbmQiLCJyZWFkQXNBcnJheUJ1ZmZlciIsImdldFRleHRGcm9tQXJyYXlCdWZmZXIiLCJhcnJheUJ1ZmZlciIsImVuY29kaW5nIiwiUHJvbWlzZSIsInJlc29sdmUiLCJyZWplY3QiLCJidWZmZXIiLCJCdWZmZXIiLCJ0b1N0cmluZyIsImZpbGVSZWFkZXIiLCJldnQiLCJ0YXJnZXQiLCJyZWFkQXNUZXh0IiwiZGV0ZXJtaW5lQ2hhcnNldCIsImNoYXJzZXQiLCJjaGFyc2V0TWF0Y2giLCJtYXRjaCIsImlzRm9sZGVyRGVzY3JpcHRpb24iLCJib2R5IiwiaXNTdWNjZXNzU3RhdHVzIiwic3RhdHVzIiwiaW5kZXhPZiIsImlzRXJyb3JTdGF0dXMiLCJvbkVycm9yQ2IiLCJXaXJlQ2xpZW50IiwicnMiLCJjb25uZWN0ZWQiLCJlcnJvciIsIlVuYXV0aG9yaXplZCIsImNvbmZpZ3VyZSIsInRva2VuIiwiYmluZCIsIm9uIiwic2V0dGluZ3MiLCJKU09OIiwicGFyc2UiLCJsb2NhbFN0b3JhZ2UiLCJlIiwic2V0VGltZW91dCIsIl9yZXZpc2lvbkNhY2hlIiwiX2VtaXQiLCJSRVFVRVNUX1RJTUVPVVQiLCJwcm90b3R5cGUiLCJfcmVxdWVzdCIsIm1ldGhvZCIsInVyaSIsImhlYWRlcnMiLCJnZXRFdGFnIiwiZmFrZVJldmlzaW9uIiwibGVuZ3RoIiwicmV2aXNpb24iLCJzZWxmIiwiSU1QTElFRF9GQUtFX1RPS0VOIiwicmVxdWVzdCIsInJlc3BvbnNlVHlwZSIsInRoZW4iLCJyZXNwb25zZSIsIm9ubGluZSIsInN1Y2Nlc3MiLCJnZXRSZXNwb25zZUhlYWRlciIsInVuZGVmaW5lZCIsInN0YXR1c0NvZGUiLCJjb250ZW50VHlwZSIsIkVycm9yIiwidXNlckFkZHJlc3MiLCJocmVmIiwic3RvcmFnZUFwaSIsInByb3BlcnRpZXMiLCJfc3RvcmFnZUFwaSIsInN1cHBvcnRzUmV2cyIsInN0cmluZ2lmeSIsInN0b3BXYWl0aW5nRm9yVG9rZW4iLCJnZXQiLCJwYXRoIiwib3B0aW9ucyIsImlmTm9uZU1hdGNoIiwiciIsIml0ZW1zTWFwIiwiT2JqZWN0Iiwia2V5cyIsIml0ZW0iLCJpdGVtcyIsIkVUYWciLCJmb3JFYWNoIiwia2V5IiwicHV0IiwiQXJyYXlCdWZmZXIiLCJpZk1hdGNoIiwidXJsIiwidGltZWRPdXQiLCJ0aW1lciIsInhociIsIlhNTEh0dHBSZXF1ZXN0Iiwib3BlbiIsInNldFJlcXVlc3RIZWFkZXIiLCJvbmxvYWQiLCJjbGVhclRpbWVvdXQiLCJvbmVycm9yIiwic2VuZCIsImRlZmluZVByb3BlcnR5Iiwic3BlYyIsIl9yc19pbml0IiwicmVtb3RlU3RvcmFnZSIsImxvY2FsU3RvcmFnZUF2YWlsYWJsZSIsInJlbW90ZSIsIl9yc19zdXBwb3J0ZWQiLCJfcnNfY2xlYW51cCIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJtb2R1bGUiLCJleHBvcnRzIl0sIm1hcHBpbmdzIjoiQUFBQTs7OztBQUVFLElBQU1BLE1BQU0sbUJBQUFDLENBQVEsQ0FBUixDQUFaO0FBQ0EsSUFBTUMsT0FBTyxtQkFBQUQsQ0FBUSxDQUFSLENBQWI7QUFDQSxJQUFNRSxnQkFBZ0IsbUJBQUFGLENBQVEsQ0FBUixDQUF0QjtBQUNBLElBQU1HLFlBQVksbUJBQUFILENBQVEsQ0FBUixDQUFsQjs7QUFFQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFzQ0EsSUFBSUksZUFBSjtBQUNBLElBQUlDLGVBQWUsMEJBQW5COztBQUVBLElBQUlDLFdBQVcsQ0FBZjtBQUFBLElBQWtCQyxTQUFTLENBQTNCO0FBQUEsSUFBOEJDLFNBQVMsQ0FBdkM7QUFBQSxJQUEwQ0MsU0FBUyxDQUFuRDtBQUFBLElBQXNEQyxXQUFXLENBQWpFOztBQUVBLElBQUlDLGVBQWU7QUFDakIsbUNBQWlDSixNQURoQjtBQUVqQixtQ0FBaUNDLE1BRmhCO0FBR2pCLG1DQUFpQ0MsTUFIaEI7QUFJakIsb0VBQWtFSDtBQUpqRCxDQUFuQjs7QUFPQSxJQUFJTSxpQkFBSjs7QUFFQSxJQUFJLE9BQU9DLGVBQVAsS0FBNEIsVUFBaEMsRUFBNEM7QUFDMUNELHNCQUFvQiwyQkFBVUUsTUFBVixFQUFrQjtBQUFFLFdBQU9BLFVBQVdBLGtCQUFrQkQsZUFBcEM7QUFBdUQsR0FBL0Y7QUFDRCxDQUZELE1BRU87QUFDTCxNQUFJRSxtQkFBbUIsQ0FDckJDLFNBRHFCLEVBQ1ZDLFVBRFUsRUFDRUMsVUFERixFQUNjQyxXQURkLEVBRXJCQyxVQUZxQixFQUVUQyxXQUZTLEVBRUlDLFlBRkosRUFFa0JDLFlBRmxCLENBQXZCO0FBSUFYLHNCQUFv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RCxJQUFsQixDQUE5QixJQUF5REEsZ0JBQWdCb0UsV0FBN0UsRUFBMEY7QUFDeEZwRSxhQUFPLElBQUlwRCxVQUFKLENBQWVvRCxJQUFmLENBQVA7QUFDRDtBQUNEeUUsUUFBSU8sSUFBSixDQUFTaEYsSUFBVDtBQUNELEdBMUNNLENBQVA7QUEyQ0QsQ0E1Q0Q7O0FBOENBNEQsT0FBT3FCLGNBQVAsQ0FBc0IzRSxXQUFXa0IsU0FBakMsRUFBNEMsYUFBNUMsRUFBMkQ7QUFDekQ4QixPQUFLLGVBQVk7QUFDZixRQUFJLEtBQUtOLFVBQVQsRUFBcUI7QUFDbkIsVUFBSWtDLE9BQU8sS0FBS2xDLFVBQUwsQ0FBZ0JsRCxLQUFoQixDQUFzQixtQ0FBdEIsQ0FBWDtBQUNBLGFBQU9vRixPQUFPQSxLQUFLLENBQUwsQ0FBUCxHQUFpQixTQUF4QjtBQUNEO0FBQ0Y7QUFOd0QsQ0FBM0Q7O0FBVUE1RSxXQUFXNkUsUUFBWCxHQUFzQixVQUFVQyxhQUFWLEVBQXlCO0FBQzdDckosb0JBQWtCSCxLQUFLeUoscUJBQUwsRUFBbEI7QUFDQUQsZ0JBQWNFLE1BQWQsR0FBdUIsSUFBSWhGLFVBQUosQ0FBZThFLGFBQWYsQ0FBdkI7QUFDQSxPQUFLN0MsTUFBTCxHQUFjLElBQWQ7QUFDRCxDQUpEOztBQU1BakMsV0FBV2lGLGFBQVgsR0FBMkIsWUFBWTtBQUNyQyxTQUFPLENBQUMsQ0FBRWIsY0FBVjtBQUNELENBRkQ7O0FBSUFwRSxXQUFXa0YsV0FBWCxHQUF5QixVQUFVSixhQUFWLEVBQXdCO0FBQy9DLE1BQUlySixlQUFKLEVBQW9CO0FBQ2xCLFdBQU9tRixhQUFhbEYsWUFBYixDQUFQO0FBQ0Q7QUFDRG9KLGdCQUFjSyxtQkFBZCxDQUFrQyxPQUFsQyxFQUEyQ3BGLFNBQTNDO0FBQ0QsQ0FMRDs7QUFRQXFGLE9BQU9DLE9BQVAsR0FBaUJyRixVQUFqQixDIiwiZmlsZSI6IjkuanMiLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbiAgY29uc3QgbG9nID0gcmVxdWlyZSgnLi9sb2cnKTtcbiAgY29uc3QgdXRpbCA9IHJlcXVpcmUoJy4vdXRpbCcpO1xuICBjb25zdCBldmVudEhhbmRsaW5nID0gcmVxdWlyZSgnLi9ldmVudGhhbmRsaW5nJyk7XG4gIGNvbnN0IEF1dGhvcml6ZSA9IHJlcXVpcmUoJy4vYXV0aG9yaXplJyk7XG5cbiAgLyoqXG4gICAqIENsYXNzOiBXaXJlQ2xpZW50XG4gICAqXG4gICAqIFdpcmVDbGllbnQgSW50ZXJmYWNlXG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAqXG4gICAqIFRoaXMgZmlsZSBleHBvc2VzIGEgZ2V0L3B1dC9kZWxldGUgaW50ZXJmYWNlIG9uIHRvcCBvZiBYTUxIdHRwUmVxdWVzdC5cbiAgICogSXQgcmVxdWlyZXMgdG8gYmUgY29uZmlndXJlZCB3aXRoIHBhcmFtZXRlcnMgYWJvdXQgdGhlIHJlbW90ZXN0b3JhZ2Ugc2VydmVyIHRvXG4gICAqIGNvbm5lY3QgdG8uXG4gICAqIEVhY2ggaW5zdGFuY2Ugb2YgV2lyZUNsaWVudCBpcyBhbHdheXMgYXNzb2NpYXRlZCB3aXRoIGEgc2luZ2xlIHJlbW90ZXN0b3JhZ2VcbiAgICogc2VydmVyIGFuZCBhY2Nlc3MgdG9rZW4uXG4gICAqXG4gICAqIFVzdWFsbHkgdGhlIFdpcmVDbGllbnQgaW5zdGFuY2UgY2FuIGJlIGFjY2Vzc2VkIHZpYSBgcmVtb3RlU3RvcmFnZS5yZW1vdGVgLlxuICAgKlxuICAgKiBUaGlzIGlzIHRoZSBnZXQvcHV0L2RlbGV0ZSBpbnRlcmZhY2U6XG4gICAqXG4gICAqICAgLSAjZ2V0KCkgdGFrZXMgYSBwYXRoIGFuZCBvcHRpb25hbGx5IGEgaWZOb25lTWF0Y2ggb3B0aW9uIGNhcnJ5aW5nIGEgdmVyc2lvblxuICAgKiAgICAgc3RyaW5nIHRvIGNoZWNrLiBJdCByZXR1cm5zIGEgcHJvbWlzZSB0aGF0IHdpbGwgYmUgZnVsZmlsbGVkIHdpdGggdGhlIEhUVFBcbiAgICogICAgIHJlc3BvbnNlIHN0YXR1cywgdGhlIHJlc3BvbnNlIGJvZHksIHRoZSBNSU1FIHR5cGUgYXMgcmV0dXJuZWQgaW4gdGhlXG4gICAqICAgICAnQ29udGVudC1UeXBlJyBoZWFkZXIgYW5kIHRoZSBjdXJyZW50IHJldmlzaW9uLCBhcyByZXR1cm5lZCBpbiB0aGUgJ0VUYWcnXG4gICAqICAgICBoZWFkZXIuXG4gICAqICAgLSAjcHV0KCkgdGFrZXMgYSBwYXRoLCB0aGUgcmVxdWVzdCBib2R5IGFuZCBhIGNvbnRlbnQgdHlwZSBzdHJpbmcuIEl0IGFsc29cbiAgICogICAgIGFjY2VwdHMgdGhlIGlmTWF0Y2ggYW5kIGlmTm9uZU1hdGNoIG9wdGlvbnMsIHRoYXQgbWFwIHRvIHRoZSBJZi1NYXRjaCBhbmRcbiAgICogICAgIElmLU5vbmUtTWF0Y2ggaGVhZGVycyByZXNwZWN0aXZlbHkuIFNlZSB0aGUgcmVtb3Rlc3RvcmFnZS0wMSBzcGVjaWZpY2F0aW9uXG4gICAqICAgICBmb3IgZGV0YWlscyBvbiBoYW5kbGluZyB0aGVzZSBoZWFkZXJzLiBJdCByZXR1cm5zIGEgcHJvbWlzZSwgZnVsZmlsbGVkIHdpdGhcbiAgICogICAgIHRoZSBzYW1lIHZhbHVlcyBhcyB0aGUgb25lIGZvciAjZ2V0KCkuXG4gICAqICAgLSAjZGVsZXRlKCkgdGFrZXMgYSBwYXRoIGFuZCB0aGUgaWZNYXRjaCBvcHRpb24gYXMgd2VsbC4gSXQgcmV0dXJucyBhIHByb21pc2VcbiAgICogICAgIGZ1bGZpbGxlZCB3aXRoIHRoZSBzYW1lIHZhbHVlcyBhcyB0aGUgb25lIGZvciAjZ2V0KCkuXG4gICAqXG4gICAqIEluIGFkZGl0aW9uIHRvIHRoaXMsIHRoZSBXaXJlQ2xpZW50IGhhcyBzb21lIGNvbXBhdGliaWxpdHkgZmVhdHVyZXMgdG8gd29yayB3aXRoXG4gICAqIHJlbW90ZXN0b3JhZ2UgMjAxMi4wNCBjb21wYXRpYmxlIHN0b3JhZ2VzLiBGb3IgZXhhbXBsZSBpdCB3aWxsIGNhY2hlIHJldmlzaW9uc1xuICAgKiBmcm9tIGZvbGRlciBsaXN0aW5ncyBpbi1tZW1vcnkgYW5kIHJldHVybiB0aGVtIGFjY29yZGluZ2x5IGFzIHRoZSBcInJldmlzaW9uXCJcbiAgICogcGFyYW1ldGVyIGluIHJlc3BvbnNlIHRvICNnZXQoKSByZXF1ZXN0cy4gU2ltaWxhcmx5IGl0IHdpbGwgcmV0dXJuIDQwNCB3aGVuIGl0XG4gICAqIHJlY2VpdmVzIGFuIGVtcHR5IGZvbGRlciBsaXN0aW5nLCB0byBtaW1pYyByZW1vdGVzdG9yYWdlLTAxIGJlaGF2aW9yLiBOb3RlXG4gICAqIHRoYXQgaXQgaXMgbm90IGFsd2F5cyBwb3NzaWJsZSB0byBrbm93IHRoZSByZXZpc2lvbiBiZWZvcmVoYW5kLCBoZW5jZSBpdCBtYXlcbiAgICogYmUgdW5kZWZpbmVkIGF0IHRpbWVzIChlc3BlY2lhbGx5IGZvciBjYWNoaW5nLXJvb3RzKS5cbiAgICovXG5cbiAgdmFyIGhhc0xvY2FsU3RvcmFnZTtcbiAgdmFyIFNFVFRJTkdTX0tFWSA9ICdyZW1vdGVzdG9yYWdlOndpcmVjbGllbnQnO1xuXG4gIHZhciBBUElfMjAxMiA9IDEsIEFQSV8wMCA9IDIsIEFQSV8wMSA9IDMsIEFQSV8wMiA9IDQsIEFQSV9IRUFEID0gNTtcblxuICB2YXIgU1RPUkFHRV9BUElTID0ge1xuICAgICdkcmFmdC1kZWpvbmctcmVtb3Rlc3RvcmFnZS0wMCc6IEFQSV8wMCxcbiAgICAnZHJhZnQtZGVqb25nLXJlbW90ZXN0b3JhZ2UtMDEnOiBBUElfMDEsXG4gICAgJ2RyYWZ0LWRlam9uZy1yZW1vdGVzdG9yYWdlLTAyJzogQVBJXzAyLFxuICAgICdodHRwczovL3d3dy53My5vcmcvY29tbXVuaXR5L3J3dy93aWtpL3JlYWQtd3JpdGUtd2ViLTAwI3NpbXBsZSc6IEFQSV8yMDEyXG4gIH07XG5cbiAgdmFyIGlzQXJyYXlCdWZmZXJWaWV3O1xuXG4gIGlmICh0eXBlb2YoQXJyYXlCdWZmZXJWaWV3KSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGlzQXJyYXlCdWZmZXJWaWV3ID0gZnVuY3Rpb24gKG9iamVjdCkgeyByZXR1cm4gb2JqZWN0ICYmIChvYmplY3QgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlclZpZXcpOyB9O1xuICB9IGVsc2Uge1xuICAgIHZhciBhcnJheUJ1ZmZlclZpZXdzID0gW1xuICAgICAgSW50OEFycmF5LCBVaW50OEFycmF5LCBJbnQxNkFycmF5LCBVaW50MTZBcnJheSxcbiAgICAgIEludDMyQXJyYXksIFVpbnQzMkFycmF5LCBGbG9hdDMyQXJyYXksIEZsb2F0NjRBcnJheVxuICAgIF07XG4gICAgaXNBcnJheUJ1ZmZlclZpZXcgPSBmdW5jdGlvbiAob2JqZWN0KSB7XG4gICAgICBmb3IgKGxldCBpPTA7aTw4O2krKykge1xuICAgICAgICBpZiAob2JqZWN0IGluc3RhbmNlb2YgYXJyYXlCdWZmZXJWaWV3c1tpXSkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcbiAgfVxuXG4gIGNvbnN0IGlzRm9sZGVyID0gdXRpbC5pc0ZvbGRlcjtcbiAgY29uc3QgY2xlYW5QYXRoID0gdXRpbC5jbGVhblBhdGg7XG5cbiAgZnVuY3Rpb24gYWRkUXVvdGVzKHN0cikge1xuICAgIGlmICh0eXBlb2Yoc3RyKSAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHJldHVybiBzdHI7XG4gICAgfVxuICAgIGlmIChzdHIgPT09ICcqJykge1xuICAgICAgcmV0dXJuICcqJztcbiAgICB9XG5cbiAgICByZXR1cm4gJ1wiJyArIHN0ciArICdcIic7XG4gIH1cblxuICBmdW5jdGlvbiBzdHJpcFF1b3RlcyhzdHIpIHtcbiAgICBpZiAodHlwZW9mKHN0cikgIT09ICdzdHJpbmcnKSB7XG4gICAgICByZXR1cm4gc3RyO1xuICAgIH1cblxuICAgIHJldHVybiBzdHIucmVwbGFjZSgvXltcIiddfFtcIiddJC9nLCAnJyk7XG4gIH1cblxuICBmdW5jdGlvbiByZWFkQmluYXJ5RGF0YShjb250ZW50LCBtaW1lVHlwZSwgY2FsbGJhY2spIHtcbiAgICB2YXIgYmxvYjtcbiAgICB1dGlsLmdsb2JhbENvbnRleHQuQmxvYkJ1aWxkZXIgPSB1dGlsLmdsb2JhbENvbnRleHQuQmxvYkJ1aWxkZXIgfHwgdXRpbC5nbG9iYWxDb250ZXh0LldlYktpdEJsb2JCdWlsZGVyO1xuICAgIGlmICh0eXBlb2YgdXRpbC5nbG9iYWxDb250ZXh0LkJsb2JCdWlsZGVyICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgdmFyIGJiID0gbmV3IGdsb2JhbC5CbG9iQnVpbGRlcigpO1xuICAgICAgYmIuYXBwZW5kKGNvbnRlbnQpO1xuICAgICAgYmxvYiA9IGJiLmdldEJsb2IobWltZVR5cGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBibG9iID0gbmV3IEJsb2IoW2NvbnRlbnRdLCB7IHR5cGU6IG1pbWVUeXBlIH0pO1xuICAgIH1cblxuICAgIHZhciByZWFkZXIgPSBuZXcgRmlsZVJlYWRlcigpO1xuICAgIGlmICh0eXBlb2YgcmVhZGVyLmFkZEV2ZW50TGlzdGVuZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJlYWRlci5hZGRFdmVudExpc3RlbmVyKCdsb2FkZW5kJywgZnVuY3Rpb24gKCkge1xuICAgICAgICBjYWxsYmFjayhyZWFkZXIucmVzdWx0KTsgLy8gcmVhZGVyLnJlc3VsdCBjb250YWlucyB0aGUgY29udGVudHMgb2YgYmxvYiBhcyBhIHR5cGVkIGFycmF5XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVhZGVyLm9ubG9hZGVuZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBjYWxsYmFjayhyZWFkZXIucmVzdWx0KTsgLy8gcmVhZGVyLnJlc3VsdCBjb250YWlucyB0aGUgY29udGVudHMgb2YgYmxvYiBhcyBhIHR5cGVkIGFycmF5XG4gICAgICB9O1xuICAgIH1cbiAgICByZWFkZXIucmVhZEFzQXJyYXlCdWZmZXIoYmxvYik7XG4gIH1cblxuICBmdW5jdGlvbiBnZXRUZXh0RnJvbUFycmF5QnVmZmVyKGFycmF5QnVmZmVyLCBlbmNvZGluZykge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBpZiAodHlwZW9mIEJsb2IgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHZhciBidWZmZXIgPSBuZXcgQnVmZmVyKG5ldyBVaW50OEFycmF5KGFycmF5QnVmZmVyKSk7XG4gICAgICAgIHJlc29sdmUoYnVmZmVyLnRvU3RyaW5nKGVuY29kaW5nKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgYmxvYjtcbiAgICAgICAgdXRpbC5nbG9iYWxDb250ZXh0LkJsb2JCdWlsZGVyID0gdXRpbC5nbG9iYWxDb250ZXh0LkJsb2JCdWlsZGVyIHx8IHV0aWwuZ2xvYmFsQ29udGV4dC5XZWJLaXRCbG9iQnVpbGRlcjtcbiAgICAgICAgaWYgKHR5cGVvZiB1dGlsLmdsb2JhbENvbnRleHQuQmxvYkJ1aWxkZXIgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgdmFyIGJiID0gbmV3IGdsb2JhbC5CbG9iQnVpbGRlcigpO1xuICAgICAgICAgIGJiLmFwcGVuZChhcnJheUJ1ZmZlcik7XG4gICAgICAgICAgYmxvYiA9IGJiLmdldEJsb2IoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBibG9iID0gbmV3IEJsb2IoW2FycmF5QnVmZmVyXSk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZmlsZVJlYWRlciA9IG5ldyBGaWxlUmVhZGVyKCk7XG4gICAgICAgIGlmICh0eXBlb2YgZmlsZVJlYWRlci5hZGRFdmVudExpc3RlbmVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgZmlsZVJlYWRlci5hZGRFdmVudExpc3RlbmVyKCdsb2FkZW5kJywgZnVuY3Rpb24gKGV2dCkge1xuICAgICAgICAgICAgcmVzb2x2ZShldnQudGFyZ2V0LnJlc3VsdCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZmlsZVJlYWRlci5vbmxvYWRlbmQgPSBmdW5jdGlvbihldnQpIHtcbiAgICAgICAgICAgIHJlc29sdmUoZXZ0LnRhcmdldC5yZXN1bHQpO1xuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZmlsZVJlYWRlci5yZWFkQXNUZXh0KGJsb2IsIGVuY29kaW5nKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGRldGVybWluZUNoYXJzZXQobWltZVR5cGUpIHtcbiAgICB2YXIgY2hhcnNldCA9ICdVVEYtOCc7XG4gICAgdmFyIGNoYXJzZXRNYXRjaDtcblxuICAgIGlmIChtaW1lVHlwZSkge1xuICAgICAgY2hhcnNldE1hdGNoID0gbWltZVR5cGUubWF0Y2goL2NoYXJzZXQ9KC4rKSQvKTtcbiAgICAgIGlmIChjaGFyc2V0TWF0Y2gpIHtcbiAgICAgICAgY2hhcnNldCA9IGNoYXJzZXRNYXRjaFsxXTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGNoYXJzZXQ7XG4gIH1cblxuICBmdW5jdGlvbiBpc0ZvbGRlckRlc2NyaXB0aW9uKGJvZHkpIHtcbiAgICByZXR1cm4gKChib2R5WydAY29udGV4dCddID09PSAnaHR0cDovL3JlbW90ZXN0b3JhZ2UuaW8vc3BlYy9mb2xkZXItZGVzY3JpcHRpb24nKVxuICAgICAgICAgICAgICYmICh0eXBlb2YoYm9keVsnaXRlbXMnXSkgPT09ICdvYmplY3QnKSk7XG4gIH1cblxuICBmdW5jdGlvbiBpc1N1Y2Nlc3NTdGF0dXMoc3RhdHVzKSB7XG4gICAgcmV0dXJuIFsyMDEsIDIwNCwgMzA0XS5pbmRleE9mKHN0YXR1cykgPj0gMDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzRXJyb3JTdGF0dXMoc3RhdHVzKSB7XG4gICAgcmV0dXJuIFs0MDEsIDQwMywgNDA0LCA0MTJdLmluZGV4T2Yoc3RhdHVzKSA+PSAwO1xuICB9XG5cbiAgdmFyIG9uRXJyb3JDYjtcblxuICAvKipcbiAgICogQ2xhc3MgOiBXaXJlQ2xpZW50XG4gICAqKi9cbiAgdmFyIFdpcmVDbGllbnQgPSBmdW5jdGlvbiBXaXJlQ2xpZW50KHJzKSB7XG4gICAgdGhpcy5ycyA9IHJzO1xuICAgIHRoaXMuY29ubmVjdGVkID0gZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiBFdmVudDogY2hhbmdlXG4gICAgICogICBOZXZlciBmaXJlZCBmb3Igc29tZSByZWFzb25cbiAgICAgKiAgICMgVE9ETyBjcmVhdGUgaXNzdWUgYW5kIGZpeCBvciByZW1vdmVcbiAgICAgKlxuICAgICAqIEV2ZW50OiBjb25uZWN0ZWRcbiAgICAgKiAgIEZpcmVkIHdoZW4gdGhlIHdpcmVjbGllbnQgY29ubmVjdCBtZXRob2QgcmVhbGl6ZXMgdGhhdCBpdCBpcyBpblxuICAgICAqICAgcG9zc2Vzc2lvbiBvZiBhIHRva2VuIGFuZCBocmVmXG4gICAgICoqL1xuICAgIGV2ZW50SGFuZGxpbmcodGhpcywgJ2NoYW5nZScsICdjb25uZWN0ZWQnLCAnbm90LWNvbm5lY3RlZCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAnd2lyZS1idXN5JywgJ3dpcmUtZG9uZScpO1xuXG4gICAgb25FcnJvckNiID0gZnVuY3Rpb24gKGVycm9yKXtcbiAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEF1dGhvcml6ZS5VbmF1dGhvcml6ZWQpIHtcbiAgICAgICAgdGhpcy5jb25maWd1cmUoe3Rva2VuOiBudWxsfSk7XG4gICAgICB9XG4gICAgfS5iaW5kKHRoaXMpO1xuICAgIHJzLm9uKCdlcnJvcicsIG9uRXJyb3JDYik7XG4gICAgaWYgKGhhc0xvY2FsU3RvcmFnZSkge1xuICAgICAgdmFyIHNldHRpbmdzO1xuICAgICAgdHJ5IHsgc2V0dGluZ3MgPSBKU09OLnBhcnNlKGxvY2FsU3RvcmFnZVtTRVRUSU5HU19LRVldKTsgfSBjYXRjaChlKSB7fVxuICAgICAgaWYgKHNldHRpbmdzKSB7XG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHRoaXMuY29uZmlndXJlKHNldHRpbmdzKTtcbiAgICAgICAgfS5iaW5kKHRoaXMpLCAwKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLl9yZXZpc2lvbkNhY2hlID0ge307XG5cbiAgICBpZiAodGhpcy5jb25uZWN0ZWQpIHtcbiAgICAgIHNldFRpbWVvdXQodGhpcy5fZW1pdC5iaW5kKHRoaXMpLCAwLCAnY29ubmVjdGVkJyk7XG4gICAgfVxuICB9O1xuXG4gIC8vIHNob3VsZCB3ZSBwdXQgdGhpcyBpbiBjb25maWcgP1xuICBXaXJlQ2xpZW50LlJFUVVFU1RfVElNRU9VVCA9IDMwMDAwO1xuXG4gIFdpcmVDbGllbnQucHJvdG90eXBlID0ge1xuICAgIC8qKlxuICAgICAqIFByb3BlcnR5OiB0b2tlblxuICAgICAqXG4gICAgICogSG9sZHMgdGhlIGJlYXJlciB0b2tlbiBvZiB0aGlzIFdpcmVDbGllbnQsIGFzIG9idGFpbmVkIGluIHRoZSBPQXV0aCBkYW5jZVxuICAgICAqXG4gICAgICogRXhhbXBsZTpcbiAgICAgKiAgIChzdGFydCBjb2RlKVxuICAgICAqXG4gICAgICogICByZW1vdGVTdG9yYWdlLnJlbW90ZS50b2tlblxuICAgICAqICAgLy8gLT4gJ0RFQURCRUVGMDE9PSdcbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIFByb3BlcnR5OiBocmVmXG4gICAgICpcbiAgICAgKiBIb2xkcyB0aGUgc2VydmVyJ3MgYmFzZSBVUkwsIGFzIG9idGFpbmVkIGluIHRoZSBXZWJmaW5nZXIgZGlzY292ZXJ5XG4gICAgICpcbiAgICAgKiBFeGFtcGxlOlxuICAgICAqICAgKHN0YXJ0IGNvZGUpXG4gICAgICpcbiAgICAgKiAgIHJlbW90ZVN0b3JhZ2UucmVtb3RlLmhyZWZcbiAgICAgKiAgIC8vIC0+ICdodHRwczovL3N0b3JhZ2UuZXhhbXBsZS5jb20vdXNlcnMvamJsb2dnLydcbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIFByb3BlcnR5OiBzdG9yYWdlQXBpXG4gICAgICpcbiAgICAgKiBIb2xkcyB0aGUgc3BlYyB2ZXJzaW9uIHRoZSBzZXJ2ZXIgY2xhaW1zIHRvIGJlIGNvbXBhdGlibGUgd2l0aFxuICAgICAqXG4gICAgICogRXhhbXBsZTpcbiAgICAgKiAgIChzdGFydCBjb2RlKVxuICAgICAqXG4gICAgICogICByZW1vdGVTdG9yYWdlLnJlbW90ZS5zdG9yYWdlQXBpXG4gICAgICogICAvLyAtPiAnZHJhZnQtZGVqb25nLXJlbW90ZXN0b3JhZ2UtMDEnXG4gICAgICovXG5cbiAgICBfcmVxdWVzdDogZnVuY3Rpb24gKG1ldGhvZCwgdXJpLCB0b2tlbiwgaGVhZGVycywgYm9keSwgZ2V0RXRhZywgZmFrZVJldmlzaW9uKSB7XG4gICAgICBpZiAoKG1ldGhvZCA9PT0gJ1BVVCcgfHwgbWV0aG9kID09PSAnREVMRVRFJykgJiYgdXJpW3VyaS5sZW5ndGggLSAxXSA9PT0gJy8nKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdCgnRG9uXFwndCAnICsgbWV0aG9kICsgJyBvbiBkaXJlY3RvcmllcyEnKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHJldmlzaW9uO1xuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgICBpZiAodG9rZW4gIT09IEF1dGhvcml6ZS5JTVBMSUVEX0ZBS0VfVE9LRU4pIHtcbiAgICAgICAgaGVhZGVyc1snQXV0aG9yaXphdGlvbiddID0gJ0JlYXJlciAnICsgdG9rZW47XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX2VtaXQoJ3dpcmUtYnVzeScsIHtcbiAgICAgICAgbWV0aG9kOiBtZXRob2QsXG4gICAgICAgIGlzRm9sZGVyOiBpc0ZvbGRlcih1cmkpXG4gICAgICB9KTtcblxuICAgICAgcmV0dXJuIFdpcmVDbGllbnQucmVxdWVzdChtZXRob2QsIHVyaSwge1xuICAgICAgICBib2R5OiBib2R5LFxuICAgICAgICBoZWFkZXJzOiBoZWFkZXJzLFxuICAgICAgICByZXNwb25zZVR5cGU6ICdhcnJheWJ1ZmZlcidcbiAgICAgIH0pLnRoZW4oZnVuY3Rpb24ocmVzcG9uc2UpIHtcbiAgICAgICAgaWYgKCFzZWxmLm9ubGluZSkge1xuICAgICAgICAgIHNlbGYub25saW5lID0gdHJ1ZTtcbiAgICAgICAgICBzZWxmLnJzLl9lbWl0KCduZXR3b3JrLW9ubGluZScpO1xuICAgICAgICB9XG4gICAgICAgIHNlbGYuX2VtaXQoJ3dpcmUtZG9uZScsIHtcbiAgICAgICAgICBtZXRob2Q6IG1ldGhvZCxcbiAgICAgICAgICBpc0ZvbGRlcjogaXNGb2xkZXIodXJpKSxcbiAgICAgICAgICBzdWNjZXNzOiB0cnVlXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmIChpc0Vycm9yU3RhdHVzKHJlc3BvbnNlLnN0YXR1cykpIHtcbiAgICAgICAgICBsb2coJ1tXaXJlQ2xpZW50XSBFcnJvciByZXNwb25zZSBzdGF0dXMnLCByZXNwb25zZS5zdGF0dXMpO1xuICAgICAgICAgIGlmIChnZXRFdGFnKSB7XG4gICAgICAgICAgICByZXZpc2lvbiA9IHN0cmlwUXVvdGVzKHJlc3BvbnNlLmdldFJlc3BvbnNlSGVhZGVyKCdFVGFnJykpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXZpc2lvbiA9IHVuZGVmaW5lZDtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh7c3RhdHVzQ29kZTogcmVzcG9uc2Uuc3RhdHVzLCByZXZpc2lvbjogcmV2aXNpb259KTtcbiAgICAgICAgfSBlbHNlIGlmIChpc1N1Y2Nlc3NTdGF0dXMocmVzcG9uc2Uuc3RhdHVzKSB8fFxuICAgICAgICAgICAgICAgICAgIChyZXNwb25zZS5zdGF0dXMgPT09IDIwMCAmJiBtZXRob2QgIT09ICdHRVQnKSkge1xuICAgICAgICAgIHJldmlzaW9uID0gc3RyaXBRdW90ZXMocmVzcG9uc2UuZ2V0UmVzcG9uc2VIZWFkZXIoJ0VUYWcnKSk7XG4gICAgICAgICAgbG9nKCdbV2lyZUNsaWVudF0gU3VjY2Vzc2Z1bCByZXF1ZXN0JywgcmV2aXNpb24pO1xuICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoe3N0YXR1c0NvZGU6IHJlc3BvbnNlLnN0YXR1cywgcmV2aXNpb246IHJldmlzaW9ufSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIG1pbWVUeXBlID0gcmVzcG9uc2UuZ2V0UmVzcG9uc2VIZWFkZXIoJ0NvbnRlbnQtVHlwZScpO1xuICAgICAgICAgIGlmIChnZXRFdGFnKSB7XG4gICAgICAgICAgICByZXZpc2lvbiA9IHN0cmlwUXVvdGVzKHJlc3BvbnNlLmdldFJlc3BvbnNlSGVhZGVyKCdFVGFnJykpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXZpc2lvbiA9IHJlc3BvbnNlLnN0YXR1cyA9PT0gMjAwID8gZmFrZVJldmlzaW9uIDogdW5kZWZpbmVkO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBjaGFyc2V0ID0gZGV0ZXJtaW5lQ2hhcnNldChtaW1lVHlwZSk7XG5cbiAgICAgICAgICBpZiAoKCFtaW1lVHlwZSkgfHwgY2hhcnNldCA9PT0gJ2JpbmFyeScpIHtcbiAgICAgICAgICAgIGxvZygnW1dpcmVDbGllbnRdIFN1Y2Nlc3NmdWwgcmVxdWVzdCB3aXRoIHVua25vd24gb3IgYmluYXJ5IG1pbWUtdHlwZScsIHJldmlzaW9uKTtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoe3N0YXR1c0NvZGU6IHJlc3BvbnNlLnN0YXR1cywgYm9keTogcmVzcG9uc2UucmVzcG9uc2UsIGNvbnRlbnRUeXBlOiBtaW1lVHlwZSwgcmV2aXNpb246IHJldmlzaW9ufSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBnZXRUZXh0RnJvbUFycmF5QnVmZmVyKHJlc3BvbnNlLnJlc3BvbnNlLCBjaGFyc2V0KS50aGVuKGZ1bmN0aW9uIChib2R5KSB7XG4gICAgICAgICAgICAgIGxvZygnW1dpcmVDbGllbnRdIFN1Y2Nlc3NmdWwgcmVxdWVzdCcsIHJldmlzaW9uKTtcbiAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh7c3RhdHVzQ29kZTogcmVzcG9uc2Uuc3RhdHVzLCBib2R5OiBib2R5LCBjb250ZW50VHlwZTogbWltZVR5cGUsIHJldmlzaW9uOiByZXZpc2lvbn0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LCBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgaWYgKHNlbGYub25saW5lKSB7XG4gICAgICAgICAgc2VsZi5vbmxpbmUgPSBmYWxzZTtcbiAgICAgICAgICBzZWxmLnJzLl9lbWl0KCduZXR3b3JrLW9mZmxpbmUnKTtcbiAgICAgICAgfVxuICAgICAgICBzZWxmLl9lbWl0KCd3aXJlLWRvbmUnLCB7XG4gICAgICAgICAgbWV0aG9kOiBtZXRob2QsXG4gICAgICAgICAgaXNGb2xkZXI6IGlzRm9sZGVyKHVyaSksXG4gICAgICAgICAgc3VjY2VzczogZmFsc2VcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGVycm9yKTtcbiAgICAgIH0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIE1ldGhvZDogY29uZmlndXJlXG4gICAgICpcbiAgICAgKiBTZXRzIHRoZSB1c2VyQWRkcmVzcywgaHJlZiwgc3RvcmFnZUFwaSwgdG9rZW4sIGFuZCBwcm9wZXJ0aWVzIG9mIGFcbiAgICAgKiByZW1vdGUgc3RvcmUuIEFsc28gc2V0cyBjb25uZWN0ZWQgYW5kIG9ubGluZSB0byB0cnVlIGFuZCBlbWl0cyB0aGVcbiAgICAgKiAnY29ubmVjdGVkJyBldmVudCwgaWYgYm90aCB0b2tlbiBhbmQgaHJlZiBhcmUgcHJlc2VudC5cbiAgICAgKlxuICAgICAqIFBhcmFtZXRlcnM6XG4gICAgICogICBzZXR0aW5ncyAtIEFuIG9iamVjdCB0aGF0IG1heSBjb250YWluIHVzZXJBZGRyZXNzIChzdHJpbmcgb3IgbnVsbCksXG4gICAgICogICAgICAgICAgICAgIGhyZWYgKHN0cmluZyBvciBudWxsKSwgc3RvcmFnZUFwaSAoc3RyaW5nIG9yIG51bGwpLCB0b2tlbiAoc3RyaW5nXG4gICAgICogICAgICAgICAgICAgIG9yIG51bGwpLCBhbmQvb3IgcHJvcGVydGllcyAodGhlIEpTT04tcGFyc2VkIHByb3BlcnRpZXMgb2JqZWN0XG4gICAgICogICAgICAgICAgICAgIGZyb20gdGhlIHVzZXIncyBXZWJGaW5nZXIgcmVjb3JkLCBzZWUgc2VjdGlvbiAxMCBvZlxuICAgICAqICAgICAgICAgICAgICBodHRwOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9kcmFmdC1kZWpvbmctcmVtb3Rlc3RvcmFnZS0wM1xuICAgICAqICAgICAgICAgICAgICBvciBudWxsKS5cbiAgICAgKiAgICAgICAgICAgICAgRmllbGRzIHRoYXQgYXJlIG5vdCBpbmNsdWRlZCAoaS5lLiBgdW5kZWZpbmVkYCksIHN0YXkgYXRcbiAgICAgKiAgICAgICAgICAgICAgdGhlaXIgY3VycmVudCB2YWx1ZS4gVG8gc2V0IGEgZmllbGQsIGluY2x1ZGUgdGhhdCBmaWVsZFxuICAgICAqICAgICAgICAgICAgICB3aXRoIGEgYHN0cmluZ2AgdmFsdWUuIFRvIHJlc2V0IGEgZmllbGQsIGZvciBpbnN0YW5jZSB3aGVuXG4gICAgICogICAgICAgICAgICAgIHRoZSB1c2VyIGRpc2Nvbm5lY3RlZCB0aGVpciBzdG9yYWdlLCBvciB5b3UgZm91bmQgdGhhdCB0aGVcbiAgICAgKiAgICAgICAgICAgICAgdG9rZW4geW91IGhhdmUgaGFzIGV4cGlyZWQsIHNpbXBseSBzZXQgdGhhdCBmaWVsZCB0byBgbnVsbGAuXG4gICAgICovXG4gICAgY29uZmlndXJlOiBmdW5jdGlvbiAoc2V0dGluZ3MpIHtcbiAgICAgIGlmICh0eXBlb2Ygc2V0dGluZ3MgIT09ICdvYmplY3QnKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignV2lyZUNsaWVudCBjb25maWd1cmUgc2V0dGluZ3MgcGFyYW1ldGVyIHNob3VsZCBiZSBhbiBvYmplY3QnKTtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2Ygc2V0dGluZ3MudXNlckFkZHJlc3MgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHRoaXMudXNlckFkZHJlc3MgPSBzZXR0aW5ncy51c2VyQWRkcmVzcztcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2Ygc2V0dGluZ3MuaHJlZiAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgdGhpcy5ocmVmID0gc2V0dGluZ3MuaHJlZjtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2Ygc2V0dGluZ3Muc3RvcmFnZUFwaSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgdGhpcy5zdG9yYWdlQXBpID0gc2V0dGluZ3Muc3RvcmFnZUFwaTtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2Ygc2V0dGluZ3MudG9rZW4gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHRoaXMudG9rZW4gPSBzZXR0aW5ncy50b2tlbjtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2Ygc2V0dGluZ3MucHJvcGVydGllcyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgdGhpcy5wcm9wZXJ0aWVzID0gc2V0dGluZ3MucHJvcGVydGllcztcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiB0aGlzLnN0b3JhZ2VBcGkgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHRoaXMuX3N0b3JhZ2VBcGkgPSBTVE9SQUdFX0FQSVNbdGhpcy5zdG9yYWdlQXBpXSB8fCBBUElfSEVBRDtcbiAgICAgICAgdGhpcy5zdXBwb3J0c1JldnMgPSB0aGlzLl9zdG9yYWdlQXBpID49IEFQSV8wMDtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmhyZWYgJiYgdGhpcy50b2tlbikge1xuICAgICAgICB0aGlzLmNvbm5lY3RlZCA9IHRydWU7XG4gICAgICAgIHRoaXMub25saW5lID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5fZW1pdCgnY29ubmVjdGVkJyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmNvbm5lY3RlZCA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgaWYgKGhhc0xvY2FsU3RvcmFnZSkge1xuICAgICAgICBsb2NhbFN0b3JhZ2VbU0VUVElOR1NfS0VZXSA9IEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICB1c2VyQWRkcmVzczogdGhpcy51c2VyQWRkcmVzcyxcbiAgICAgICAgICBocmVmOiB0aGlzLmhyZWYsXG4gICAgICAgICAgc3RvcmFnZUFwaTogdGhpcy5zdG9yYWdlQXBpLFxuICAgICAgICAgIHRva2VuOiB0aGlzLnRva2VuLFxuICAgICAgICAgIHByb3BlcnRpZXM6IHRoaXMucHJvcGVydGllc1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgc3RvcFdhaXRpbmdGb3JUb2tlbjogZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKCF0aGlzLmNvbm5lY3RlZCkge1xuICAgICAgICB0aGlzLl9lbWl0KCdub3QtY29ubmVjdGVkJyk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIGdldDogZnVuY3Rpb24gKHBhdGgsIG9wdGlvbnMpIHtcbiAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgIGlmICghdGhpcy5jb25uZWN0ZWQpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KCdub3QgY29ubmVjdGVkIChwYXRoOiAnICsgcGF0aCArICcpJyk7XG4gICAgICB9XG4gICAgICBpZiAoIW9wdGlvbnMpIHsgb3B0aW9ucyA9IHt9OyB9XG4gICAgICB2YXIgaGVhZGVycyA9IHt9O1xuICAgICAgaWYgKHRoaXMuc3VwcG9ydHNSZXZzKSB7XG4gICAgICAgIGlmIChvcHRpb25zLmlmTm9uZU1hdGNoKSB7XG4gICAgICAgICAgaGVhZGVyc1snSWYtTm9uZS1NYXRjaCddID0gYWRkUXVvdGVzKG9wdGlvbnMuaWZOb25lTWF0Y2gpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBjb21tZW50aW5nIGl0IG91dCBhcyB0aGlzIGlzIGRvaW5nIG5vdGhpbmcgYW5kIGpzaGludCBpcyBjb21wbGFpbmluZyAtbGVzXG4gICAgICAvLyBlbHNlIGlmIChvcHRpb25zLmlmTm9uZU1hdGNoKSB7XG4gICAgICAvLyAgIHZhciBvbGRSZXYgPSB0aGlzLl9yZXZpc2lvbkNhY2hlW3BhdGhdO1xuICAgICAgLy8gfVxuXG5cbiAgICAgIHJldHVybiB0aGlzLl9yZXF1ZXN0KCdHRVQnLCB0aGlzLmhyZWYgKyBjbGVhblBhdGgocGF0aCksIHRoaXMudG9rZW4sIGhlYWRlcnMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdW5kZWZpbmVkLCB0aGlzLnN1cHBvcnRzUmV2cywgdGhpcy5fcmV2aXNpb25DYWNoZVtwYXRoXSlcbiAgICAgIC50aGVuKGZ1bmN0aW9uIChyKSB7XG4gICAgICAgIGlmICghaXNGb2xkZXIocGF0aCkpIHtcbiAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHIpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBpdGVtc01hcCA9IHt9O1xuICAgICAgICBpZiAodHlwZW9mKHIuYm9keSkgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHIuYm9keSA9IEpTT04ucGFyc2Uoci5ib2R5KTtcbiAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoJ0ZvbGRlciBkZXNjcmlwdGlvbiBhdCAnICsgc2VsZi5ocmVmICsgY2xlYW5QYXRoKHBhdGgpICsgJyBpcyBub3QgSlNPTicpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChyLnN0YXR1c0NvZGUgPT09IDIwMCAmJiB0eXBlb2Yoci5ib2R5KSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgLy8gTmV3IGZvbGRlciBsaXN0aW5nIHJlY2VpdmVkXG4gICAgICAgICAgaWYgKE9iamVjdC5rZXlzKHIuYm9keSkubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgLy8gRW1wdHkgZm9sZGVyIGxpc3Rpbmcgb2YgYW55IHNwZWNcbiAgICAgICAgICAgIHIuc3RhdHVzQ29kZSA9IDQwNDtcbiAgICAgICAgICB9IGVsc2UgaWYgKGlzRm9sZGVyRGVzY3JpcHRpb24oci5ib2R5KSkge1xuICAgICAgICAgIC8vID49IDAyIHNwZWNcbiAgICAgICAgICAgIGZvciAodmFyIGl0ZW0gaW4gci5ib2R5Lml0ZW1zKSB7XG4gICAgICAgICAgICAgIHNlbGYuX3JldmlzaW9uQ2FjaGVbcGF0aCArIGl0ZW1dID0gci5ib2R5Lml0ZW1zW2l0ZW1dLkVUYWc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpdGVtc01hcCA9IHIuYm9keS5pdGVtcztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIDwgMDIgc3BlY1xuICAgICAgICAgICAgT2JqZWN0LmtleXMoci5ib2R5KS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpe1xuICAgICAgICAgICAgICBzZWxmLl9yZXZpc2lvbkNhY2hlW3BhdGggKyBrZXldID0gci5ib2R5W2tleV07XG4gICAgICAgICAgICAgIGl0ZW1zTWFwW2tleV0gPSB7J0VUYWcnOiByLmJvZHlba2V5XX07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgci5ib2R5ID0gaXRlbXNNYXA7XG4gICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHIpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9LFxuXG4gICAgcHV0OiBmdW5jdGlvbiAocGF0aCwgYm9keSwgY29udGVudFR5cGUsIG9wdGlvbnMpIHtcbiAgICAgIGlmICghdGhpcy5jb25uZWN0ZWQpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KCdub3QgY29ubmVjdGVkIChwYXRoOiAnICsgcGF0aCArICcpJyk7XG4gICAgICB9XG4gICAgICBpZiAoIW9wdGlvbnMpIHsgb3B0aW9ucyA9IHt9OyB9XG4gICAgICBpZiAoKCFjb250ZW50VHlwZS5tYXRjaCgvY2hhcnNldD0vKSkgJiYgKGJvZHkgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlciB8fCBpc0FycmF5QnVmZmVyVmlldyhib2R5KSkpIHtcbiAgICAgICAgY29udGVudFR5cGUgKz0gICc7IGNoYXJzZXQ9YmluYXJ5JztcbiAgICAgIH1cbiAgICAgIHZhciBoZWFkZXJzID0geyAnQ29udGVudC1UeXBlJzogY29udGVudFR5cGUgfTtcbiAgICAgIGlmICh0aGlzLnN1cHBvcnRzUmV2cykge1xuICAgICAgICBpZiAob3B0aW9ucy5pZk1hdGNoKSB7XG4gICAgICAgICAgaGVhZGVyc1snSWYtTWF0Y2gnXSA9IGFkZFF1b3RlcyhvcHRpb25zLmlmTWF0Y2gpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zLmlmTm9uZU1hdGNoKSB7XG4gICAgICAgICAgaGVhZGVyc1snSWYtTm9uZS1NYXRjaCddID0gYWRkUXVvdGVzKG9wdGlvbnMuaWZOb25lTWF0Y2gpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5fcmVxdWVzdCgnUFVUJywgdGhpcy5ocmVmICsgY2xlYW5QYXRoKHBhdGgpLCB0aGlzLnRva2VuLFxuICAgICAgICAgICAgICAgICAgICAgaGVhZGVycywgYm9keSwgdGhpcy5zdXBwb3J0c1JldnMpO1xuICAgIH0sXG5cbiAgICAnZGVsZXRlJzogZnVuY3Rpb24gKHBhdGgsIG9wdGlvbnMpIHtcbiAgICAgIGlmICghdGhpcy5jb25uZWN0ZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdub3QgY29ubmVjdGVkIChwYXRoOiAnICsgcGF0aCArICcpJyk7XG4gICAgICB9XG4gICAgICBpZiAoIW9wdGlvbnMpIHsgb3B0aW9ucyA9IHt9OyB9XG4gICAgICB2YXIgaGVhZGVycyA9IHt9O1xuICAgICAgaWYgKHRoaXMuc3VwcG9ydHNSZXZzKSB7XG4gICAgICAgIGlmIChvcHRpb25zLmlmTWF0Y2gpIHtcbiAgICAgICAgICBoZWFkZXJzWydJZi1NYXRjaCddID0gYWRkUXVvdGVzKG9wdGlvbnMuaWZNYXRjaCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLl9yZXF1ZXN0KCdERUxFVEUnLCB0aGlzLmhyZWYgKyBjbGVhblBhdGgocGF0aCksIHRoaXMudG9rZW4sXG4gICAgICAgICAgICAgICAgICAgICBoZWFkZXJzLFxuICAgICAgICAgICAgICAgICAgICAgdW5kZWZpbmVkLCB0aGlzLnN1cHBvcnRzUmV2cyk7XG4gICAgfVxuICB9O1xuXG4gIC8vIFNoYXJlZCBjbGVhblBhdGggdXNlZCBieSBEcm9wYm94XG4gIFdpcmVDbGllbnQuY2xlYW5QYXRoID0gY2xlYW5QYXRoO1xuXG4gIC8vIFNoYXJlZCBpc0FycmF5QnVmZmVyVmlldyB1c2VkIGJ5IFdpcmVDbGllbnQgYW5kIERyb3Bib3hcbiAgV2lyZUNsaWVudC5pc0FycmF5QnVmZmVyVmlldyA9IGlzQXJyYXlCdWZmZXJWaWV3O1xuXG4gIFdpcmVDbGllbnQucmVhZEJpbmFyeURhdGEgPSByZWFkQmluYXJ5RGF0YTtcblxuICAvLyBTaGFyZWQgcmVxdWVzdCBmdW5jdGlvbiB1c2VkIGJ5IFdpcmVDbGllbnQsIEdvb2dsZURyaXZlIGFuZCBEcm9wYm94LlxuICAvLyBUT0RPOiBTaG91bGQgd2UgdXNlIGZldGNoID9cbiAgV2lyZUNsaWVudC5yZXF1ZXN0ID0gZnVuY3Rpb24gKG1ldGhvZCwgdXJsLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlICgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG5cbiAgICAgIGxvZygnW1dpcmVDbGllbnRdJywgbWV0aG9kLCB1cmwpO1xuXG4gICAgICB2YXIgdGltZWRPdXQgPSBmYWxzZTtcblxuICAgICAgdmFyIHRpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRpbWVkT3V0ID0gdHJ1ZTtcbiAgICAgICAgcmVqZWN0KCd0aW1lb3V0Jyk7XG4gICAgICB9LCBXaXJlQ2xpZW50LlJFUVVFU1RfVElNRU9VVCk7XG5cbiAgICAgIHZhciB4aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcbiAgICAgIHhoci5vcGVuKG1ldGhvZCwgdXJsLCB0cnVlKTtcblxuICAgICAgaWYgKG9wdGlvbnMucmVzcG9uc2VUeXBlKSB7XG4gICAgICAgIHhoci5yZXNwb25zZVR5cGUgPSBvcHRpb25zLnJlc3BvbnNlVHlwZTtcbiAgICAgIH1cblxuICAgICAgaWYgKG9wdGlvbnMuaGVhZGVycykge1xuICAgICAgICBmb3IgKHZhciBrZXkgaW4gb3B0aW9ucy5oZWFkZXJzKSB7XG4gICAgICAgICAgeGhyLnNldFJlcXVlc3RIZWFkZXIoa2V5LCBvcHRpb25zLmhlYWRlcnNba2V5XSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgeGhyLm9ubG9hZCA9ICgpID0+IHtcbiAgICAgICAgaWYgKHRpbWVkT3V0KSB7IHJldHVybjsgfVxuICAgICAgICBjbGVhclRpbWVvdXQodGltZXIpO1xuICAgICAgICByZXNvbHZlKHhocik7XG4gICAgICB9O1xuXG4gICAgICB4aHIub25lcnJvciA9IChlcnJvcikgPT4ge1xuICAgICAgICBpZiAodGltZWRPdXQpIHsgcmV0dXJuOyB9XG4gICAgICAgIGNsZWFyVGltZW91dCh0aW1lcik7XG4gICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICB9O1xuXG4gICAgICB2YXIgYm9keSA9IG9wdGlvbnMuYm9keTtcblxuICAgICAgaWYgKHR5cGVvZihib2R5KSA9PT0gJ29iamVjdCcgJiYgIWlzQXJyYXlCdWZmZXJWaWV3KGJvZHkpICYmIGJvZHkgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgICAgICBib2R5ID0gbmV3IFVpbnQ4QXJyYXkoYm9keSk7XG4gICAgICB9XG4gICAgICB4aHIuc2VuZChib2R5KTtcbiAgICB9KTtcbiAgfTtcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoV2lyZUNsaWVudC5wcm90b3R5cGUsICdzdG9yYWdlVHlwZScsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICh0aGlzLnN0b3JhZ2VBcGkpIHtcbiAgICAgICAgdmFyIHNwZWMgPSB0aGlzLnN0b3JhZ2VBcGkubWF0Y2goL2RyYWZ0LWRlam9uZy0ocmVtb3Rlc3RvcmFnZS1cXGRcXGQpLyk7XG4gICAgICAgIHJldHVybiBzcGVjID8gc3BlY1sxXSA6ICcyMDEyLjA0JztcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuXG5cbiAgV2lyZUNsaWVudC5fcnNfaW5pdCA9IGZ1bmN0aW9uIChyZW1vdGVTdG9yYWdlKSB7XG4gICAgaGFzTG9jYWxTdG9yYWdlID0gdXRpbC5sb2NhbFN0b3JhZ2VBdmFpbGFibGUoKTtcbiAgICByZW1vdGVTdG9yYWdlLnJlbW90ZSA9IG5ldyBXaXJlQ2xpZW50KHJlbW90ZVN0b3JhZ2UpO1xuICAgIHRoaXMub25saW5lID0gdHJ1ZTtcbiAgfTtcblxuICBXaXJlQ2xpZW50Ll9yc19zdXBwb3J0ZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuICEhIFhNTEh0dHBSZXF1ZXN0O1xuICB9O1xuXG4gIFdpcmVDbGllbnQuX3JzX2NsZWFudXAgPSBmdW5jdGlvbiAocmVtb3RlU3RvcmFnZSl7XG4gICAgaWYgKGhhc0xvY2FsU3RvcmFnZSl7XG4gICAgICBkZWxldGUgbG9jYWxTdG9yYWdlW1NFVFRJTkdTX0tFWV07XG4gICAgfVxuICAgIHJlbW90ZVN0b3JhZ2UucmVtb3ZlRXZlbnRMaXN0ZW5lcignZXJyb3InLCBvbkVycm9yQ2IpO1xuICB9O1xuXG5cbiAgbW9kdWxlLmV4cG9ydHMgPSBXaXJlQ2xpZW50O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL3dpcmVjbGllbnQuanMiXSwic291cmNlUm9vdCI6IiJ9");
},function(module,exports){eval("'use strict';\n\n// var SETTINGS_KEY = \"remotestorage:access\";\n\n/**\n * Class: Access\n *\n * Keeps track of claimed access and scopes.\n */\nvar Access = function Access() {\n  this.reset();\n};\n\nAccess.prototype = {\n\n  /**\n   * Method: claim\n   *\n   * Claim access on a given scope with given mode.\n   *\n   * Parameters:\n   *   scope - An access scope, such as \"contacts\" or \"calendar\"\n   *   mode  - Access mode. Either \"r\" for read-only or \"rw\" for read/write\n   *\n   * Example:\n   *   (start code)\n   *   remoteStorage.access.claim('contacts', 'r');\n   *   remoteStorage.access.claim('pictures', 'rw');\n   *   (end code)\n   *\n   * Root access:\n   *   Claiming root access, meaning complete access to all files and folders\n   *   of a storage, can be done using an asterisk:\n   *\n   *   (start code)\n   *   remoteStorage.access.claim('*', 'rw');\n   *   (end code)\n   */\n  claim: function claim(scope, mode) {\n    if (typeof scope !== 'string' || scope.indexOf('/') !== -1 || scope.length === 0) {\n      throw new Error('Scope should be a non-empty string without forward slashes');\n    }\n    if (!mode.match(/^rw?$/)) {\n      throw new Error('Mode should be either \\'r\\' or \\'rw\\'');\n    }\n    this._adjustRootPaths(scope);\n    this.scopeModeMap[scope] = mode;\n  },\n\n  get: function get(scope) {\n    return this.scopeModeMap[scope];\n  },\n\n  remove: function remove(scope) {\n    var savedMap = {};\n    var name;\n    for (name in this.scopeModeMap) {\n      savedMap[name] = this.scopeModeMap[name];\n    }\n    this.reset();\n    delete savedMap[scope];\n    for (name in savedMap) {\n      this.set(name, savedMap[name]);\n    }\n  },\n\n  /**\n   * Verify permission for a given scope.\n   */\n  checkPermission: function checkPermission(scope, mode) {\n    var actualMode = this.get(scope);\n    return actualMode && (mode === 'r' || actualMode === 'rw');\n  },\n\n  /**\n   * Verify permission for a given path.\n   */\n  checkPathPermission: function checkPathPermission(path, mode) {\n    if (this.checkPermission('*', mode)) {\n      return true;\n    }\n    return !!this.checkPermission(this._getModuleName(path), mode);\n  },\n\n  reset: function reset() {\n    this.rootPaths = [];\n    this.scopeModeMap = {};\n  },\n\n  /**\n   * Return the module name for a given path.\n   */\n  _getModuleName: function _getModuleName(path) {\n    if (path[0] !== '/') {\n      throw new Error('Path should start with a slash');\n    }\n    var moduleMatch = path.replace(/^\\/public/, '').match(/^\\/([^\\/]*)\\//);\n    return moduleMatch ? moduleMatch[1] : '*';\n  },\n\n  _adjustRootPaths: function _adjustRootPaths(newScope) {\n    if ('*' in this.scopeModeMap || newScope === '*') {\n      this.rootPaths = ['/'];\n    } else if (!(newScope in this.scopeModeMap)) {\n      this.rootPaths.push('/' + newScope + '/');\n      this.rootPaths.push('/public/' + newScope + '/');\n    }\n  },\n\n  _scopeNameForParameter: function _scopeNameForParameter(scope) {\n    if (scope.name === '*' && this.storageType) {\n      if (this.storageType === '2012.04') {\n        return '';\n      } else if (this.storageType.match(/remotestorage-0[01]/)) {\n        return 'root';\n      }\n    }\n    return scope.name;\n  },\n\n  setStorageType: function setStorageType(type) {\n    this.storageType = type;\n  }\n};\n\n/**\n * Property: scopes\n *\n * Holds an array of claimed scopes in the form\n * > { name: \"<scope-name>\", mode: \"<mode>\" }\n */\nObject.defineProperty(Access.prototype, 'scopes', {\n  get: function get() {\n    return Object.keys(this.scopeModeMap).map(function (key) {\n      return { name: key, mode: this.scopeModeMap[key] };\n    }.bind(this));\n  }\n});\n\nObject.defineProperty(Access.prototype, 'scopeParameter', {\n  get: function get() {\n    return this.scopes.map(function (scope) {\n      return this._scopeNameForParameter(scope) + ':' + scope.mode;\n    }.bind(this)).join(' ');\n  }\n});\n\nAccess._rs_init = function () {};\n\nmodule.exports = Access;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvYWNjZXNzLmpzPzcwN2MiXSwibmFtZXMiOlsiQWNjZXNzIiwicmVzZXQiLCJwcm90b3R5cGUiLCJjbGFpbSIsInNjb3BlIiwibW9kZSIsImluZGV4T2YiLCJsZW5ndGgiLCJFcnJvciIsIm1hdGNoIiwiX2FkanVzdFJvb3RQYXRocyIsInNjb3BlTW9kZU1hcCIsImdldCIsInJlbW92ZSIsInNhdmVkTWFwIiwibmFtZSIsInNldCIsImNoZWNrUGVybWlzc2lvbiIsImFjdHVhbE1vZGUiLCJjaGVja1BhdGhQZXJtaXNzaW9uIiwicGF0aCIsIl9nZXRNb2R1bGVOYW1lIiwicm9vdFBhdGhzIiwibW9kdWxlTWF0Y2giLCJyZXBsYWNlIiwibmV3U2NvcGUiLCJwdXNoIiwiX3Njb3BlTmFtZUZvclBhcmFtZXRlciIsInN0b3JhZ2VUeXBlIiwic2V0U3RvcmFnZVR5cGUiLCJ0eXBlIiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJrZXlzIiwibWFwIiwia2V5IiwiYmluZCIsInNjb3BlcyIsImpvaW4iLCJfcnNfaW5pdCIsIm1vZHVsZSIsImV4cG9ydHMiXSwibWFwcGluZ3MiOiI7O0FBQUU7O0FBRUE7Ozs7O0FBS0EsSUFBSUEsU0FBUyxTQUFUQSxNQUFTLEdBQVc7QUFDdEIsT0FBS0MsS0FBTDtBQUNELENBRkQ7O0FBSUFELE9BQU9FLFNBQVAsR0FBbUI7O0FBRWpCOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQXVCQUMsU0FBTyxlQUFTQyxLQUFULEVBQWdCQyxJQUFoQixFQUFzQjtBQUMzQixRQUFJLE9BQU9ELEtBQVAsS0FBa0IsUUFBbEIsSUFBOEJBLE1BQU1FLE9BQU4sQ0FBYyxHQUFkLE1BQXVCLENBQUMsQ0FBdEQsSUFBMkRGLE1BQU1HLE1BQU4sS0FBaUIsQ0FBaEYsRUFBbUY7QUFDakYsWUFBTSxJQUFJQyxLQUFKLENBQVUsNERBQVYsQ0FBTjtBQUNEO0FBQ0QsUUFBSSxDQUFDSCxLQUFLSSxLQUFMLENBQVcsT0FBWCxD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ZUFBTyxNQUFQO0FBQ0Q7QUFDRjtBQUNELFdBQU9MLE1BQU1XLElBQWI7QUFDRCxHQXpHZ0I7O0FBMkdqQmMsa0JBQWdCLHdCQUFTQyxJQUFULEVBQWU7QUFDN0IsU0FBS0YsV0FBTCxHQUFtQkUsSUFBbkI7QUFDRDtBQTdHZ0IsQ0FBbkI7O0FBZ0hBOzs7Ozs7QUFNQUMsT0FBT0MsY0FBUCxDQUFzQmhDLE9BQU9FLFNBQTdCLEVBQXdDLFFBQXhDLEVBQWtEO0FBQ2hEVSxPQUFLLGVBQVc7QUFDZCxXQUFPbUIsT0FBT0UsSUFBUCxDQUFZLEtBQUt0QixZQUFqQixFQUErQnVCLEdBQS9CLENBQW1DLFVBQVNDLEdBQVQsRUFBYztBQUN0RCxhQUFPLEVBQUVwQixNQUFNb0IsR0FBUixFQUFhOUIsTUFBTSxLQUFLTSxZQUFMLENBQWtCd0IsR0FBbEIsQ0FBbkIsRUFBUDtBQUNELEtBRnlDLENBRXhDQyxJQUZ3QyxDQUVuQyxJQUZtQyxDQUFuQyxDQUFQO0FBR0Q7QUFMK0MsQ0FBbEQ7O0FBUUFMLE9BQU9DLGNBQVAsQ0FBc0JoQyxPQUFPRSxTQUE3QixFQUF3QyxnQkFBeEMsRUFBMEQ7QUFDeERVLE9BQUssZUFBVztBQUNkLFdBQU8sS0FBS3lCLE1BQUwsQ0FBWUgsR0FBWixDQUFnQixVQUFTOUIsS0FBVCxFQUFnQjtBQUNyQyxhQUFPLEtBQUt1QixzQkFBTCxDQUE0QnZCLEtBQTVCLElBQXFDLEdBQXJDLEdBQTJDQSxNQUFNQyxJQUF4RDtBQUNELEtBRnNCLENBRXJCK0IsSUFGcUIsQ0FFaEIsSUFGZ0IsQ0FBaEIsRUFFT0UsSUFGUCxDQUVZLEdBRlosQ0FBUDtBQUdEO0FBTHVELENBQTFEOztBQVNBdEMsT0FBT3VDLFFBQVAsR0FBa0IsWUFBVyxDQUFFLENBQS9COztBQUVBQyxPQUFPQyxPQUFQLEdBQWlCekMsTUFBakIiLCJmaWxlIjoiMTAuanMiLCJzb3VyY2VzQ29udGVudCI6WyIgIC8vIHZhciBTRVRUSU5HU19LRVkgPSBcInJlbW90ZXN0b3JhZ2U6YWNjZXNzXCI7XG5cbiAgLyoqXG4gICAqIENsYXNzOiBBY2Nlc3NcbiAgICpcbiAgICogS2VlcHMgdHJhY2sgb2YgY2xhaW1lZCBhY2Nlc3MgYW5kIHNjb3Blcy5cbiAgICovXG4gIHZhciBBY2Nlc3MgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLnJlc2V0KCk7XG4gIH07XG5cbiAgQWNjZXNzLnByb3RvdHlwZSA9IHtcblxuICAgIC8qKlxuICAgICAqIE1ldGhvZDogY2xhaW1cbiAgICAgKlxuICAgICAqIENsYWltIGFjY2VzcyBvbiBhIGdpdmVuIHNjb3BlIHdpdGggZ2l2ZW4gbW9kZS5cbiAgICAgKlxuICAgICAqIFBhcmFtZXRlcnM6XG4gICAgICogICBzY29wZSAtIEFuIGFjY2VzcyBzY29wZSwgc3VjaCBhcyBcImNvbnRhY3RzXCIgb3IgXCJjYWxlbmRhclwiXG4gICAgICogICBtb2RlICAtIEFjY2VzcyBtb2RlLiBFaXRoZXIgXCJyXCIgZm9yIHJlYWQtb25seSBvciBcInJ3XCIgZm9yIHJlYWQvd3JpdGVcbiAgICAgKlxuICAgICAqIEV4YW1wbGU6XG4gICAgICogICAoc3RhcnQgY29kZSlcbiAgICAgKiAgIHJlbW90ZVN0b3JhZ2UuYWNjZXNzLmNsYWltKCdjb250YWN0cycsICdyJyk7XG4gICAgICogICByZW1vdGVTdG9yYWdlLmFjY2Vzcy5jbGFpbSgncGljdHVyZXMnLCAncncnKTtcbiAgICAgKiAgIChlbmQgY29kZSlcbiAgICAgKlxuICAgICAqIFJvb3QgYWNjZXNzOlxuICAgICAqICAgQ2xhaW1pbmcgcm9vdCBhY2Nlc3MsIG1lYW5pbmcgY29tcGxldGUgYWNjZXNzIHRvIGFsbCBmaWxlcyBhbmQgZm9sZGVyc1xuICAgICAqICAgb2YgYSBzdG9yYWdlLCBjYW4gYmUgZG9uZSB1c2luZyBhbiBhc3RlcmlzazpcbiAgICAgKlxuICAgICAqICAgKHN0YXJ0IGNvZGUpXG4gICAgICogICByZW1vdGVTdG9yYWdlLmFjY2Vzcy5jbGFpbSgnKicsICdydycpO1xuICAgICAqICAgKGVuZCBjb2RlKVxuICAgICAqL1xuICAgIGNsYWltOiBmdW5jdGlvbihzY29wZSwgbW9kZSkge1xuICAgICAgaWYgKHR5cGVvZihzY29wZSkgIT09ICdzdHJpbmcnIHx8IHNjb3BlLmluZGV4T2YoJy8nKSAhPT0gLTEgfHwgc2NvcGUubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignU2NvcGUgc2hvdWxkIGJlIGEgbm9uLWVtcHR5IHN0cmluZyB3aXRob3V0IGZvcndhcmQgc2xhc2hlcycpO1xuICAgICAgfVxuICAgICAgaWYgKCFtb2RlLm1hdGNoKC9ecnc/JC8pKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTW9kZSBzaG91bGQgYmUgZWl0aGVyIFxcJ3JcXCcgb3IgXFwncndcXCcnKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX2FkanVzdFJvb3RQYXRocyhzY29wZSk7XG4gICAgICB0aGlzLnNjb3BlTW9kZU1hcFtzY29wZV0gPSBtb2RlO1xuICAgIH0sXG5cbiAgICBnZXQ6IGZ1bmN0aW9uKHNjb3BlKSB7XG4gICAgICByZXR1cm4gdGhpcy5zY29wZU1vZGVNYXBbc2NvcGVdO1xuICAgIH0sXG5cbiAgICByZW1vdmU6IGZ1bmN0aW9uKHNjb3BlKSB7XG4gICAgICB2YXIgc2F2ZWRNYXAgPSB7fTtcbiAgICAgIHZhciBuYW1lO1xuICAgICAgZm9yIChuYW1lIGluIHRoaXMuc2NvcGVNb2RlTWFwKSB7XG4gICAgICAgIHNhdmVkTWFwW25hbWVdID0gdGhpcy5zY29wZU1vZGVNYXBbbmFtZV07XG4gICAgICB9XG4gICAgICB0aGlzLnJlc2V0KCk7XG4gICAgICBkZWxldGUgc2F2ZWRNYXBbc2NvcGVdO1xuICAgICAgZm9yIChuYW1lIGluIHNhdmVkTWFwKSB7XG4gICAgICAgIHRoaXMuc2V0KG5hbWUsIHNhdmVkTWFwW25hbWVdKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVmVyaWZ5IHBlcm1pc3Npb24gZm9yIGEgZ2l2ZW4gc2NvcGUuXG4gICAgICovXG4gICAgY2hlY2tQZXJtaXNzaW9uOiBmdW5jdGlvbihzY29wZSwgbW9kZSkge1xuICAgICAgdmFyIGFjdHVhbE1vZGUgPSB0aGlzLmdldChzY29wZSk7XG4gICAgICByZXR1cm4gYWN0dWFsTW9kZSAmJiAobW9kZSA9PT0gJ3InIHx8IGFjdHVhbE1vZGUgPT09ICdydycpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBWZXJpZnkgcGVybWlzc2lvbiBmb3IgYSBnaXZlbiBwYXRoLlxuICAgICAqL1xuICAgIGNoZWNrUGF0aFBlcm1pc3Npb246IGZ1bmN0aW9uKHBhdGgsIG1vZGUpIHtcbiAgICAgIGlmICh0aGlzLmNoZWNrUGVybWlzc2lvbignKicsIG1vZGUpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuICEhdGhpcy5jaGVja1Blcm1pc3Npb24odGhpcy5fZ2V0TW9kdWxlTmFtZShwYXRoKSwgbW9kZSk7XG4gICAgfSxcblxuICAgIHJlc2V0OiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMucm9vdFBhdGhzID0gW107XG4gICAgICB0aGlzLnNjb3BlTW9kZU1hcCA9IHt9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gdGhlIG1vZHVsZSBuYW1lIGZvciBhIGdpdmVuIHBhdGguXG4gICAgICovXG4gICAgX2dldE1vZHVsZU5hbWU6IGZ1bmN0aW9uKHBhdGgpIHtcbiAgICAgIGlmIChwYXRoWzBdICE9PSAnLycpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQYXRoIHNob3VsZCBzdGFydCB3aXRoIGEgc2xhc2gnKTtcbiAgICAgIH1cbiAgICAgIHZhciBtb2R1bGVNYXRjaCA9IHBhdGgucmVwbGFjZSgvXlxcL3B1YmxpYy8sICcnKS5tYXRjaCgvXlxcLyhbXlxcL10qKVxcLy8pO1xuICAgICAgcmV0dXJuIG1vZHVsZU1hdGNoID8gbW9kdWxlTWF0Y2hbMV0gOiAnKic7XG4gICAgfSxcblxuICAgIF9hZGp1c3RSb290UGF0aHM6IGZ1bmN0aW9uKG5ld1Njb3BlKSB7XG4gICAgICBpZiAoJyonIGluIHRoaXMuc2NvcGVNb2RlTWFwIHx8IG5ld1Njb3BlID09PSAnKicpIHtcbiAgICAgICAgdGhpcy5yb290UGF0aHMgPSBbJy8nXTtcbiAgICAgIH0gZWxzZSBpZiAoISAobmV3U2NvcGUgaW4gdGhpcy5zY29wZU1vZGVNYXApKSB7XG4gICAgICAgIHRoaXMucm9vdFBhdGhzLnB1c2goJy8nICsgbmV3U2NvcGUgKyAnLycpO1xuICAgICAgICB0aGlzLnJvb3RQYXRocy5wdXNoKCcvcHVibGljLycgKyBuZXdTY29wZSArICcvJyk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIF9zY29wZU5hbWVGb3JQYXJhbWV0ZXI6IGZ1bmN0aW9uKHNjb3BlKSB7XG4gICAgICBpZiAoc2NvcGUubmFtZSA9PT0gJyonICYmIHRoaXMuc3RvcmFnZVR5cGUpIHtcbiAgICAgICAgaWYgKHRoaXMuc3RvcmFnZVR5cGUgPT09ICcyMDEyLjA0Jykge1xuICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLnN0b3JhZ2VUeXBlLm1hdGNoKC9yZW1vdGVzdG9yYWdlLTBbMDFdLykpIHtcbiAgICAgICAgICByZXR1cm4gJ3Jvb3QnO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gc2NvcGUubmFtZTtcbiAgICB9LFxuXG4gICAgc2V0U3RvcmFnZVR5cGU6IGZ1bmN0aW9uKHR5cGUpIHtcbiAgICAgIHRoaXMuc3RvcmFnZVR5cGUgPSB0eXBlO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogUHJvcGVydHk6IHNjb3Blc1xuICAgKlxuICAgKiBIb2xkcyBhbiBhcnJheSBvZiBjbGFpbWVkIHNjb3BlcyBpbiB0aGUgZm9ybVxuICAgKiA+IHsgbmFtZTogXCI8c2NvcGUtbmFtZT5cIiwgbW9kZTogXCI8bW9kZT5cIiB9XG4gICAqL1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQWNjZXNzLnByb3RvdHlwZSwgJ3Njb3BlcycsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKHRoaXMuc2NvcGVNb2RlTWFwKS5tYXAoZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgIHJldHVybiB7IG5hbWU6IGtleSwgbW9kZTogdGhpcy5zY29wZU1vZGVNYXBba2V5XSB9O1xuICAgICAgfS5iaW5kKHRoaXMpKTtcbiAgICB9XG4gIH0pO1xuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBY2Nlc3MucHJvdG90eXBlLCAnc2NvcGVQYXJhbWV0ZXInLCB7XG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLnNjb3Blcy5tYXAoZnVuY3Rpb24oc2NvcGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3Njb3BlTmFtZUZvclBhcmFtZXRlcihzY29wZSkgKyAnOicgKyBzY29wZS5tb2RlO1xuICAgICAgfS5iaW5kKHRoaXMpKS5qb2luKCcgJyk7XG4gICAgfVxuICB9KTtcblxuXG4gIEFjY2Vzcy5fcnNfaW5pdCA9IGZ1bmN0aW9uKCkge307XG5cbiAgbW9kdWxlLmV4cG9ydHMgPSBBY2Nlc3M7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvYWNjZXNzLmpzIl0sInNvdXJjZVJvb3QiOiIifQ==")},function(module,exports,__webpack_require__){eval("'use strict';\n\n/**\n * Class: Caching\n *\n * Holds/manages caching configuration.\n *\n * Caching strategies:\n *\n *   For each subtree, you can set the caching strategy to 'ALL',\n *   'SEEN' (default), and 'FLUSH'.\n *\n *   - 'ALL' means that once all outgoing changes have been pushed, sync\n *         will start retrieving nodes to cache pro-actively. If a local\n *         copy exists of everything, it will check on each sync whether\n *         the ETag of the root folder changed, and retrieve remote changes\n *         if they exist.\n *   - 'SEEN' does this only for documents and folders that have been either\n *         read from or written to at least once since connecting to the current\n *         remote backend, plus their parent/ancestor folders up to the root\n *         (to make tree-based sync possible).\n *   - 'FLUSH' will only cache outgoing changes, and forget them as soon as\n *         they have been saved to remote successfully.\n *\n **/\n\nvar util = __webpack_require__(2);\nvar log = __webpack_require__(1);\n\nvar containingFolder = util.containingFolder;\n\nvar Caching = function Caching() {\n  this.reset();\n};\n\nCaching.prototype = {\n  pendingActivations: [],\n\n  /**\n   * Method: set\n   *\n   * Configure caching for a given path explicitly.\n   *\n   * Not needed when using <enable>/<disable>.\n   *\n   * Parameters:\n   *   path     - Path to cache\n   *   strategy - Caching strategy. One of 'ALL', 'SEEN', or 'FLUSH'.\n   *\n   * Example:\n   *   (start code)\n   *   remoteStorage.caching.set('/bookmarks/archive')\n   */\n  set: function set(path, strategy) {\n    if (typeof path !== 'string') {\n      throw new Error('path should be a string');\n    }\n    if (!util.isFolder(path)) {\n      throw new Error('path should be a folder');\n    }\n    if (this._remoteStorage && this._remoteStorage.access && !this._remoteStorage.access.checkPathPermission(path, 'r')) {\n      throw new Error('No access to path \"' + path + '\". You have to claim access to it first.');\n    }\n    if (!strategy.match(/^(FLUSH|SEEN|ALL)$/)) {\n      throw new Error(\"strategy should be 'FLUSH', 'SEEN', or 'ALL'\");\n    }\n\n    this._rootPaths[path] = strategy;\n\n    if (strategy === 'ALL') {\n      if (this.activateHandler) {\n        this.activateHandler(path);\n      } else {\n        this.pendingActivations.push(path);\n      }\n    }\n  },\n\n  /**\n   * Method: enable\n   *\n   * Enable caching for a given path.\n   *\n   * Uses caching strategy 'ALL'.\n   *\n   * Parameters:\n   *   path - Path to enable caching for\n   */\n  enable: function enable(path) {\n    this.set(path, 'ALL');\n  },\n\n  /**\n   * Method: disable\n   *\n   * Disable caching for a given path.\n   *\n   * Uses caching strategy 'FLUSH' (meaning items are only cached until\n   * successfully pushed to the remote).\n   *\n   * Parameters:\n   *   path - Path to disable caching for\n   */\n  disable: function disable(path) {\n    this.set(path, 'FLUSH');\n  },\n\n  /**\n   * Method: onActivate\n   *\n   * Set a callback for when caching is activated for a path.\n   *\n   * Parameters:\n   *   callback - Callback function\n   */\n  onActivate: function onActivate(cb) {\n    var i;\n    log('[Caching] Setting activate handler', cb, this.pendingActivations);\n    this.activateHandler = cb;\n    for (i = 0; i < this.pendingActivations.length; i++) {\n      cb(this.pendingActivations[i]);\n    }\n    delete this.pendingActivations;\n  },\n\n  /**\n   * Method: checkPath\n   *\n   * Retrieve caching setting for a given path, or its next parent\n   * with a caching strategy set.\n   *\n   * Parameters:\n   *   path - Path to retrieve setting for\n   **/\n  checkPath: function checkPath(path) {\n    if (this._rootPaths[path] !== undefined) {\n      return this._rootPaths[path];\n    } else if (path === '/') {\n      return 'SEEN';\n    } else {\n      return this.checkPath(containingFolder(path));\n    }\n  },\n\n  /**\n   * Method: reset\n   *\n   * Reset the state of caching by deleting all caching information.\n   **/\n  reset: function reset() {\n    this._rootPaths = {};\n    this._remoteStorage = null;\n  }\n};\n\nCaching._rs_init = function (remoteStorage) {\n  this._remoteStorage = remoteStorage;\n};\n\nmodule.exports = Caching;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvY2FjaGluZy5qcz9kMGY4Il0sIm5hbWVzIjpbInV0aWwiLCJyZXF1aXJlIiwibG9nIiwiY29udGFpbmluZ0ZvbGRlciIsIkNhY2hpbmciLCJyZXNldCIsInByb3RvdHlwZSIsInBlbmRpbmdBY3RpdmF0aW9ucyIsInNldCIsInBhdGgiLCJzdHJhdGVneSIsIkVycm9yIiwiaXNGb2xkZXIiLCJfcmVtb3RlU3RvcmFnZSIsImFjY2VzcyIsImNoZWNrUGF0aFBlcm1pc3Npb24iLCJtYXRjaCIsIl9yb290UGF0aHMiLCJhY3RpdmF0ZUhhbmRsZXIiLCJwdXNoIiwiZW5hYmxlIiwiZGlzYWJsZSIsIm9uQWN0aXZhdGUiLCJjYiIsImkiLCJsZW5ndGgiLCJjaGVja1BhdGgiLCJ1bmRlZmluZWQiLCJfcnNfaW5pdCIsInJlbW90ZVN0b3JhZ2UiLCJtb2R1bGUiLCJleHBvcnRzIl0sIm1hcHBpbmdzIjoiOztBQUFFOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUF3QkEsSUFBSUEsT0FBTyxtQkFBQUMsQ0FBUSxDQUFSLENBQVg7QUFDQSxJQUFJQyxNQUFNLG1CQUFBRCxDQUFRLENBQVIsQ0FBVjs7QUFFQSxJQUFJRSxtQkFBbUJILEtBQUtHLGdCQUE1Qjs7QUFFQSxJQUFJQyxVQUFVLFNBQVZBLE9BQVUsR0FBWTtBQUN4QixPQUFLQyxLQUFMO0FBQ0QsQ0FGRDs7QUFJQUQsUUFBUUUsU0FBUixHQUFvQjtBQUNsQkMsc0JBQW9CLEVBREY7O0FBR2xCOzs7Ozs7Ozs7Ozs7Ozs7QUFlQUMsT0FBSyxhQUFVQyxJQUFWLEVBQWdCQyxRQUFoQixFQUEwQjtBQUM3QixRQUFJLE9BQU9ELElBQVAsS0FBZ0IsUUFBcEIsRUFBOEI7QUFDNUIsWUFBTSxJQUFJRSxLQUFKLENBQVUseUJBQVYsQ0FBTjtBQUNEO0FBQ0QsUUFBSSxDQUFDWCxLQUFLWSxRQUFMLENBQWNILElBQWQsQ0FBTCxFQUEwQjtBQUN4QixZQUFNLElBQUlFLEtBQUosQ0FBVSx5QkFBVixDQUFOO0FBQ0Q7QUFDRCxRQUFJLEtBQUtFLGNBQUwsSUFBdUIsS0FBS0EsY0FBTCxDQUFvQkMsTUFBM0MsSUFDQSxDQUFDLEtBQUtELGNBQUwsQ0FBb0JDLE1BQXBCLENBQTJCQyxtQkFBM0IsQ0FBK0NOLElBQS9DLEVBQXFELEdBQXJELENBREwsRUFDZ0U7QUFDOUQsWUFBTSxJQUFJRSxLQUFKLENBQVUsd0JBQXNCRixJQUF0QixHQUEyQiwwQ0FBckMsQ0FBTjtBQUNEO0FBQ0QsUUFBSSxDQUFDQyxTQUFTTSxLQUFULENBQWUsb0JBQWYsQ0FBTCxFQUEyQztBQUN6QyxZQUFNLElBQUlMLEtBQUosQ0FBVSw4Q0FBVixDQUFOO0FBQ0Q7O0FBRUQsU0FBS00sVUFBTCxDQUFnQlIsSUFBaEIsSUFBd0JDLFFBQXhCOztBQUVBLFFBQUlBLGFBQWEsS0FBakIsRUFBd0I7QUFDdEIsVUFBSSxLQUFLUSxlQUFULEVBQTBCO0FBQ3hCLGFBQUtBLGVBQUwsQ0FBcUJULElBQXJCO0FBQ0QsT0FGRCxNQUVPO0FBQ0wsYUFBS0Ysa0JBQUwsQ0FBd0JZLElBQXhCLENBQTZCVixJQUE3QjtBQUNEO0FBQ0Y7QUFDRixHQTFDaUI7O0FBNENsQjs7Ozs7Ozs7OztBQVVBVyxVQUFRLGdCQUFVWCxJQUFWLEVBQWdCO0FBQ3RCLFNBQUtELEdBQUwsQ0FBU0MsSUFBVCxFQUFlLEtBQWY7QUFDRCxHQXhEaUI7O0FBMERsQjs7Ozs7Ozs7Ozs7QUFXQVksV0FBUyxpQkFBVVosSUFBVixFQUFnQjtBQUN2QixTQUFLRCxHQUFMLENBQVNDLElBQVQsRUFBZSxPQUFmO0FBQ0QsR0F2RWlCOztBQXlFbEI7Ozs7Ozs7O0FBUUFhLGNBQVksb0JBQVVDLEVBQVYsRUFBYztBQUN4QixRQUFJQyxDQUFKO0FBQ0F0QixRQUFJLG9DQUFKLEVBQTBDcUIsRUFBMUMsRUFBOEMsS0FBS2hCLGtCQUFuRDtBQUNBLFNBQUtXLGVBQUwsR0FBdUJLLEVBQXZCO0FBQ0EsU0FBS0MsSUFBRSxDQUFQLEVBQVVBLElBQUUsS0FBS2pCLGtCQUFMLENBQXdCa0IsTUFBcEMsRUFBNENELEdBQTVDLEVBQWlEO0FBQy9DRCxTQUFHLEtBQUtoQixrQkFBTCxDQUF3QmlCLENBQXhCLENBQUg7QUFDRDtBQUNELFdBQU8sS0FBS2pCLGtCQUFaO0FBQ0QsR0F6RmlCOztBQTJGbEI7Ozs7Ozs7OztBQVNBbUIsYUFBVyxtQkFBVWpCLElBQVYsRUFBZ0I7QUFDekIsUUFBSSxLQUFLUSxVQUFMLENBQWdCUixJQUFoQixNQUEwQmtCLFNBQTlCLEVBQXlDO0FBQ3ZDLGFBQU8sS0FBS1YsVUFBTCxDQUFnQlIsSUFBaEIsQ0FBUDtBQUNELEtBRkQsTUFFTyxJQUFJQSxTQUFTLEdBQWIsRUFBa0I7QUFDdkIsYUFBTyxNQUFQO0FBQ0QsS0FGTSxNQUVBO0FBQ0wsYUFBTyxLQUFLaUIsU0FBTCxDQUFldkIsaUJBQWlCTSxJQUFqQixDQUFmLENBQVA7QUFDRDtBQUNGLEdBNUdpQjs7QUE4R2xCOzs7OztBQUtBSixTQUFPLGlCQUFZO0FBQ2pCLFNBQUtZLFVBQUwsR0FBa0IsRUFBbEI7QUFDQSxTQUFLSixjQUFMLEdBQXNCLElBQXRCO0FBQ0Q7QUF0SGlCLENBQXBCOztBQTBIQVQsUUFBUXdCLFFBQVIsR0FBbUIsVUFBVUMsYUFBVixFQUF5QjtBQUMxQyxPQUFLaEIsY0FBTCxHQUFzQmdCLGFBQXRCO0FBQ0QsQ0FGRDs7QUFJRkMsT0FBT0MsT0FBUCxHQUFpQjNCLE9BQWpCIiwiZmlsZSI6IjExLmpzIiwic291cmNlc0NvbnRlbnQiOlsiICAvKipcbiAgICogQ2xhc3M6IENhY2hpbmdcbiAgICpcbiAgICogSG9sZHMvbWFuYWdlcyBjYWNoaW5nIGNvbmZpZ3VyYXRpb24uXG4gICAqXG4gICAqIENhY2hpbmcgc3RyYXRlZ2llczpcbiAgICpcbiAgICogICBGb3IgZWFjaCBzdWJ0cmVlLCB5b3UgY2FuIHNldCB0aGUgY2FjaGluZyBzdHJhdGVneSB0byAnQUxMJyxcbiAgICogICAnU0VFTicgKGRlZmF1bHQpLCBhbmQgJ0ZMVVNIJy5cbiAgICpcbiAgICogICAtICdBTEwnIG1lYW5zIHRoYXQgb25jZSBhbGwgb3V0Z29pbmcgY2hhbmdlcyBoYXZlIGJlZW4gcHVzaGVkLCBzeW5jXG4gICAqICAgICAgICAgd2lsbCBzdGFydCByZXRyaWV2aW5nIG5vZGVzIHRvIGNhY2hlIHByby1hY3RpdmVseS4gSWYgYSBsb2NhbFxuICAgKiAgICAgICAgIGNvcHkgZXhpc3RzIG9mIGV2ZXJ5dGhpbmcsIGl0IHdpbGwgY2hlY2sgb24gZWFjaCBzeW5jIHdoZXRoZXJcbiAgICogICAgICAgICB0aGUgRVRhZyBvZiB0aGUgcm9vdCBmb2xkZXIgY2hhbmdlZCwgYW5kIHJldHJpZXZlIHJlbW90ZSBjaGFuZ2VzXG4gICAqICAgICAgICAgaWYgdGhleSBleGlzdC5cbiAgICogICAtICdTRUVOJyBkb2VzIHRoaXMgb25seSBmb3IgZG9jdW1lbnRzIGFuZCBmb2xkZXJzIHRoYXQgaGF2ZSBiZWVuIGVpdGhlclxuICAgKiAgICAgICAgIHJlYWQgZnJvbSBvciB3cml0dGVuIHRvIGF0IGxlYXN0IG9uY2Ugc2luY2UgY29ubmVjdGluZyB0byB0aGUgY3VycmVudFxuICAgKiAgICAgICAgIHJlbW90ZSBiYWNrZW5kLCBwbHVzIHRoZWlyIHBhcmVudC9hbmNlc3RvciBmb2xkZXJzIHVwIHRvIHRoZSByb290XG4gICAqICAgICAgICAgKHRvIG1ha2UgdHJlZS1iYXNlZCBzeW5jIHBvc3NpYmxlKS5cbiAgICogICAtICdGTFVTSCcgd2lsbCBvbmx5IGNhY2hlIG91dGdvaW5nIGNoYW5nZXMsIGFuZCBmb3JnZXQgdGhlbSBhcyBzb29uIGFzXG4gICAqICAgICAgICAgdGhleSBoYXZlIGJlZW4gc2F2ZWQgdG8gcmVtb3RlIHN1Y2Nlc3NmdWxseS5cbiAgICpcbiAgICoqL1xuXG4gIHZhciB1dGlsID0gcmVxdWlyZSgnLi91dGlsJyk7XG4gIHZhciBsb2cgPSByZXF1aXJlKCcuL2xvZycpO1xuXG4gIHZhciBjb250YWluaW5nRm9sZGVyID0gdXRpbC5jb250YWluaW5nRm9sZGVyO1xuXG4gIHZhciBDYWNoaW5nID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMucmVzZXQoKTtcbiAgfTtcblxuICBDYWNoaW5nLnByb3RvdHlwZSA9IHtcbiAgICBwZW5kaW5nQWN0aXZhdGlvbnM6IFtdLFxuXG4gICAgLyoqXG4gICAgICogTWV0aG9kOiBzZXRcbiAgICAgKlxuICAgICAqIENvbmZpZ3VyZSBjYWNoaW5nIGZvciBhIGdpdmVuIHBhdGggZXhwbGljaXRseS5cbiAgICAgKlxuICAgICAqIE5vdCBuZWVkZWQgd2hlbiB1c2luZyA8ZW5hYmxlPi88ZGlzYWJsZT4uXG4gICAgICpcbiAgICAgKiBQYXJhbWV0ZXJzOlxuICAgICAqICAgcGF0aCAgICAgLSBQYXRoIHRvIGNhY2hlXG4gICAgICogICBzdHJhdGVneSAtIENhY2hpbmcgc3RyYXRlZ3kuIE9uZSBvZiAnQUxMJywgJ1NFRU4nLCBvciAnRkxVU0gnLlxuICAgICAqXG4gICAgICogRXhhbXBsZTpcbiAgICAgKiAgIChzdGFydCBjb2RlKVxuICAgICAqICAgcmVtb3RlU3RvcmFnZS5jYWNoaW5nLnNldCgnL2Jvb2ttYXJrcy9hcmNoaXZlJylcbiAgICAgKi9cbiAgICBzZXQ6IGZ1bmN0aW9uIChwYXRoLCBzdHJhdGVneSkge1xuICAgICAgaWYgKHR5cGVvZiBwYXRoICE9PSAnc3RyaW5nJykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3BhdGggc2hvdWxkIGJlIGEgc3RyaW5nJyk7XG4gICAgICB9XG4gICAgICBpZiAoIXV0aWwuaXNGb2xkZXIocGF0aCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdwYXRoIHNob3VsZCBiZSBhIGZvbGRlcicpO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuX3JlbW90ZVN0b3JhZ2UgJiYgdGhpcy5fcmVtb3RlU3RvcmFnZS5hY2Nlc3MgJiZcbiAgICAgICAgICAhdGhpcy5fcmVtb3RlU3RvcmFnZS5hY2Nlc3MuY2hlY2tQYXRoUGVybWlzc2lvbihwYXRoLCAncicpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTm8gYWNjZXNzIHRvIHBhdGggXCInK3BhdGgrJ1wiLiBZb3UgaGF2ZSB0byBjbGFpbSBhY2Nlc3MgdG8gaXQgZmlyc3QuJyk7XG4gICAgICB9XG4gICAgICBpZiAoIXN0cmF0ZWd5Lm1hdGNoKC9eKEZMVVNIfFNFRU58QUxMKSQvKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJzdHJhdGVneSBzaG91bGQgYmUgJ0ZMVVNIJywgJ1NFRU4nLCBvciAnQUxMJ1wiKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fcm9vdFBhdGhzW3BhdGhdID0gc3RyYXRlZ3k7XG5cbiAgICAgIGlmIChzdHJhdGVneSA9PT0gJ0FMTCcpIHtcbiAgICAgICAgaWYgKHRoaXMuYWN0aXZhdGVIYW5kbGVyKSB7XG4gICAgICAgICAgdGhpcy5hY3RpdmF0ZUhhbmRsZXIocGF0aCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5wZW5kaW5nQWN0aXZhdGlvbnMucHVzaChwYXRoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNZXRob2Q6IGVuYWJsZVxuICAgICAqXG4gICAgICogRW5hYmxlIGNhY2hpbmcgZm9yIGEgZ2l2ZW4gcGF0aC5cbiAgICAgKlxuICAgICAqIFVzZXMgY2FjaGluZyBzdHJhdGVneSAnQUxMJy5cbiAgICAgKlxuICAgICAqIFBhcmFtZXRlcnM6XG4gICAgICogICBwYXRoIC0gUGF0aCB0byBlbmFibGUgY2FjaGluZyBmb3JcbiAgICAgKi9cbiAgICBlbmFibGU6IGZ1bmN0aW9uIChwYXRoKSB7XG4gICAgICB0aGlzLnNldChwYXRoLCAnQUxMJyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1ldGhvZDogZGlzYWJsZVxuICAgICAqXG4gICAgICogRGlzYWJsZSBjYWNoaW5nIGZvciBhIGdpdmVuIHBhdGguXG4gICAgICpcbiAgICAgKiBVc2VzIGNhY2hpbmcgc3RyYXRlZ3kgJ0ZMVVNIJyAobWVhbmluZyBpdGVtcyBhcmUgb25seSBjYWNoZWQgdW50aWxcbiAgICAgKiBzdWNjZXNzZnVsbHkgcHVzaGVkIHRvIHRoZSByZW1vdGUpLlxuICAgICAqXG4gICAgICogUGFyYW1ldGVyczpcbiAgICAgKiAgIHBhdGggLSBQYXRoIHRvIGRpc2FibGUgY2FjaGluZyBmb3JcbiAgICAgKi9cbiAgICBkaXNhYmxlOiBmdW5jdGlvbiAocGF0aCkge1xuICAgICAgdGhpcy5zZXQocGF0aCwgJ0ZMVVNIJyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1ldGhvZDogb25BY3RpdmF0ZVxuICAgICAqXG4gICAgICogU2V0IGEgY2FsbGJhY2sgZm9yIHdoZW4gY2FjaGluZyBpcyBhY3RpdmF0ZWQgZm9yIGEgcGF0aC5cbiAgICAgKlxuICAgICAqIFBhcmFtZXRlcnM6XG4gICAgICogICBjYWxsYmFjayAtIENhbGxiYWNrIGZ1bmN0aW9uXG4gICAgICovXG4gICAgb25BY3RpdmF0ZTogZnVuY3Rpb24gKGNiKSB7XG4gICAgICB2YXIgaTtcbiAgICAgIGxvZygnW0NhY2hpbmddIFNldHRpbmcgYWN0aXZhdGUgaGFuZGxlcicsIGNiLCB0aGlzLnBlbmRpbmdBY3RpdmF0aW9ucyk7XG4gICAgICB0aGlzLmFjdGl2YXRlSGFuZGxlciA9IGNiO1xuICAgICAgZm9yIChpPTA7IGk8dGhpcy5wZW5kaW5nQWN0aXZhdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY2IodGhpcy5wZW5kaW5nQWN0aXZhdGlvbnNbaV0pO1xuICAgICAgfVxuICAgICAgZGVsZXRlIHRoaXMucGVuZGluZ0FjdGl2YXRpb25zO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNZXRob2Q6IGNoZWNrUGF0aFxuICAgICAqXG4gICAgICogUmV0cmlldmUgY2FjaGluZyBzZXR0aW5nIGZvciBhIGdpdmVuIHBhdGgsIG9yIGl0cyBuZXh0IHBhcmVudFxuICAgICAqIHdpdGggYSBjYWNoaW5nIHN0cmF0ZWd5IHNldC5cbiAgICAgKlxuICAgICAqIFBhcmFtZXRlcnM6XG4gICAgICogICBwYXRoIC0gUGF0aCB0byByZXRyaWV2ZSBzZXR0aW5nIGZvclxuICAgICAqKi9cbiAgICBjaGVja1BhdGg6IGZ1bmN0aW9uIChwYXRoKSB7XG4gICAgICBpZiAodGhpcy5fcm9vdFBhdGhzW3BhdGhdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3Jvb3RQYXRoc1twYXRoXTtcbiAgICAgIH0gZWxzZSBpZiAocGF0aCA9PT0gJy8nKSB7XG4gICAgICAgIHJldHVybiAnU0VFTic7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdGhpcy5jaGVja1BhdGgoY29udGFpbmluZ0ZvbGRlcihwYXRoKSk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1ldGhvZDogcmVzZXRcbiAgICAgKlxuICAgICAqIFJlc2V0IHRoZSBzdGF0ZSBvZiBjYWNoaW5nIGJ5IGRlbGV0aW5nIGFsbCBjYWNoaW5nIGluZm9ybWF0aW9uLlxuICAgICAqKi9cbiAgICByZXNldDogZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5fcm9vdFBhdGhzID0ge307XG4gICAgICB0aGlzLl9yZW1vdGVTdG9yYWdlID0gbnVsbDtcbiAgICB9XG4gIH07XG5cblxuICBDYWNoaW5nLl9yc19pbml0ID0gZnVuY3Rpb24gKHJlbW90ZVN0b3JhZ2UpIHtcbiAgICB0aGlzLl9yZW1vdGVTdG9yYWdlID0gcmVtb3RlU3RvcmFnZTtcbiAgfTtcblxubW9kdWxlLmV4cG9ydHMgPSBDYWNoaW5nO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2NhY2hpbmcuanMiXSwic291cmNlUm9vdCI6IiJ9")},function(module,exports,__webpack_require__){eval('\'use strict\';\n\nvar _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };\n\nvar log = __webpack_require__(1);\nvar util = __webpack_require__(2);\nvar WebFinger = __webpack_require__(32);\n\n// feature detection flags\nvar haveXMLHttpRequest, hasLocalStorage;\n\n// used to store settings in localStorage\nvar SETTINGS_KEY = \'remotestorage:discover\';\n\n// cache loaded from localStorage\nvar cachedInfo = {};\n\n/**\n * Class: Discover\n *\n * This function deals with the Webfinger lookup, discovering a connecting\n * user\'s storage details.\n *\n * The discovery timeout can be configured via\n * `config.discoveryTimeout` (in ms).\n *\n * Arguments:\n *\n *   userAddress - user@host\n *\n * Returns:\n *\n * A promise for an object with the following properties.\n *\n *   href - Storage base URL,\n *   storageType - Storage type,\n *   authUrl - OAuth URL,\n *   properties - Webfinger link properties\n **/\n\nvar Discover = function Discover(userAddress) {\n  return new Promise(function (resolve, reject) {\n\n    if (userAddress in cachedInfo) {\n      return resolve(cachedInfo[userAddress]);\n    }\n\n    var webFinger = new WebFinger({\n      tls_only: false,\n      uri_fallback: true,\n      request_timeout: 5000\n    });\n\n    return webFinger.lookup(userAddress, function (err, response) {\n      if (err) {\n        return reject(err);\n      } else if (_typeof(response.idx.links.remotestorage) !== \'object\' || typeof response.idx.links.remotestorage.length !== \'number\' || response.idx.links.remotestorage.length <= 0) {\n        log("[Discover] WebFinger record for " + userAddress + " does not have remotestorage defined in the links section ", JSON.stringify(response.json));\n        return reject("WebFinger record for " + userAddress + " does not have remotestorage defined in the links section.");\n      }\n\n      var rs = response.idx.links.remotestorage[0];\n      var authURL = rs.properties[\'http://tools.ietf.org/html/rfc6749#section-4.2\'] || rs.properties[\'auth-endpoint\'];\n      var storageType = rs.properties[\'http://remotestorage.io/spec/version\'] || rs.type;\n\n      // cache fetched data\n      cachedInfo[userAddress] = { href: rs.href, storageType: storageType, authURL: authURL, properties: rs.properties };\n\n      if (hasLocalStorage) {\n        localStorage[SETTINGS_KEY] = JSON.stringify({ cache: cachedInfo });\n      }\n\n      return resolve(cachedInfo[userAddress]);\n    });\n  });\n};\n\nDiscover.DiscoveryError = function (message) {\n  Error.apply(this, arguments);\n  this.message = message;\n};\n\nDiscover.DiscoveryError.prototype = Object.create(Error.prototype);\n\nDiscover._rs_init = function (remoteStorage) {\n  hasLocalStorage = util.localStorageAvailable();\n  if (hasLocalStorage) {\n    var settings;\n    try {\n      settings = JSON.parse(localStorage[SETTINGS_KEY]);\n    } catch (e) {}\n    if (settings) {\n      cachedInfo = settings.cache;\n    }\n  }\n};\n\nDiscover._rs_supported = function () {\n  haveXMLHttpRequest = !!util.globalContext.XMLHttpRequest;\n  return haveXMLHttpRequest;\n};\n\nDiscover._rs_cleanup = function () {\n  if (hasLocalStorage) {\n    delete localStorage[SETTINGS_KEY];\n  }\n};\n\nmodule.exports = Discover;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvZGlzY292ZXIuanM/MTQyOSJdLCJuYW1lcyI6WyJsb2ciLCJyZXF1aXJlIiwidXRpbCIsIldlYkZpbmdlciIsImhhdmVYTUxIdHRwUmVxdWVzdCIsImhhc0xvY2FsU3RvcmFnZSIsIlNFVFRJTkdTX0tFWSIsImNhY2hlZEluZm8iLCJEaXNjb3ZlciIsInVzZXJBZGRyZXNzIiwiUHJvbWlzZSIsInJlc29sdmUiLCJyZWplY3QiLCJ3ZWJGaW5nZXIiLCJ0bHNfb25seSIsInVyaV9mYWxsYmFjayIsInJlcXVlc3RfdGltZW91dCIsImxvb2t1cCIsImVyciIsInJlc3BvbnNlIiwiaWR4IiwibGlua3MiLCJyZW1vdGVzdG9yYWdlIiwibGVuZ3RoIiwiSlNPTiIsInN0cmluZ2lmeSIsImpzb24iLCJycyIsImF1dGhVUkwiLCJwcm9wZXJ0aWVzIiwic3RvcmFnZVR5cGUiLCJ0eXBlIiwiaHJlZiIsImxvY2FsU3RvcmFnZSIsImNhY2hlIiwiRGlzY292ZXJ5RXJyb3IiLCJtZXNzYWdlIiwiRXJyb3IiLCJhcHBseSIsImFyZ3VtZW50cyIsInByb3RvdHlwZSIsIk9iamVjdCIsImNyZWF0ZSIsIl9yc19pbml0IiwicmVtb3RlU3RvcmFnZSIsImxvY2FsU3RvcmFnZUF2YWlsYWJsZSIsInNldHRpbmdzIiwicGFyc2UiLCJlIiwiX3JzX3N1cHBvcnRlZCIsImdsb2JhbENvbnRleHQiLCJYTUxIdHRwUmVxdWVzdCIsIl9yc19jbGVhbnVwIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7QUFFQSxJQUFNQSxNQUFNLG1CQUFBQyxDQUFRLENBQVIsQ0FBWjtBQUNBLElBQU1DLE9BQU8sbUJBQUFELENBQVEsQ0FBUixDQUFiO0FBQ0EsSUFBTUUsWUFBWSxtQkFBQUYsQ0FBUSxFQUFSLENBQWxCOztBQUVBO0FBQ0EsSUFBSUcsa0JBQUosRUFBd0JDLGVBQXhCOztBQUVBO0FBQ0EsSUFBSUMsZUFBZSx3QkFBbkI7O0FBRUE7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MUIsU0FBU3lDLGFBQVQsR0FBeUIsWUFBWTtBQUNuQzdDLHVCQUFxQixDQUFDLENBQUVGLEtBQUtnRCxhQUFMLENBQW1CQyxjQUEzQztBQUNBLFNBQU8vQyxrQkFBUDtBQUNELENBSEQ7O0FBS0FJLFNBQVM0QyxXQUFULEdBQXVCLFlBQVk7QUFDakMsTUFBSS9DLGVBQUosRUFBcUI7QUFDbkIsV0FBTzRCLGFBQWEzQixZQUFiLENBQVA7QUFDRDtBQUNGLENBSkQ7O0FBT0ErQyxPQUFPQyxPQUFQLEdBQWlCOUMsUUFBakIiLCJmaWxlIjoiMTIuanMiLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmNvbnN0IGxvZyA9IHJlcXVpcmUoJy4vbG9nJyk7XG5jb25zdCB1dGlsID0gcmVxdWlyZSgnLi91dGlsJyk7XG5jb25zdCBXZWJGaW5nZXIgPSByZXF1aXJlKCd3ZWJmaW5nZXIuanMnKTtcblxuLy8gZmVhdHVyZSBkZXRlY3Rpb24gZmxhZ3NcbnZhciBoYXZlWE1MSHR0cFJlcXVlc3QsIGhhc0xvY2FsU3RvcmFnZTtcblxuLy8gdXNlZCB0byBzdG9yZSBzZXR0aW5ncyBpbiBsb2NhbFN0b3JhZ2VcbnZhciBTRVRUSU5HU19LRVkgPSAncmVtb3Rlc3RvcmFnZTpkaXNjb3Zlcic7XG5cbi8vIGNhY2hlIGxvYWRlZCBmcm9tIGxvY2FsU3RvcmFnZVxudmFyIGNhY2hlZEluZm8gPSB7fTtcblxuLyoqXG4gKiBDbGFzczogRGlzY292ZXJcbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIGRlYWxzIHdpdGggdGhlIFdlYmZpbmdlciBsb29rdXAsIGRpc2NvdmVyaW5nIGEgY29ubmVjdGluZ1xuICogdXNlcidzIHN0b3JhZ2UgZGV0YWlscy5cbiAqXG4gKiBUaGUgZGlzY292ZXJ5IHRpbWVvdXQgY2FuIGJlIGNvbmZpZ3VyZWQgdmlhXG4gKiBgY29uZmlnLmRpc2NvdmVyeVRpbWVvdXRgIChpbiBtcykuXG4gKlxuICogQXJndW1lbnRzOlxuICpcbiAqICAgdXNlckFkZHJlc3MgLSB1c2VyQGhvc3RcbiAqXG4gKiBSZXR1cm5zOlxuICpcbiAqIEEgcHJvbWlzZSBmb3IgYW4gb2JqZWN0IHdpdGggdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzLlxuICpcbiAqICAgaHJlZiAtIFN0b3JhZ2UgYmFzZSBVUkwsXG4gKiAgIHN0b3JhZ2VUeXBlIC0gU3RvcmFnZSB0eXBlLFxuICogICBhdXRoVXJsIC0gT0F1dGggVVJMLFxuICogICBwcm9wZXJ0aWVzIC0gV2ViZmluZ2VyIGxpbmsgcHJvcGVydGllc1xuICoqL1xuXG5jb25zdCBEaXNjb3ZlciA9IGZ1bmN0aW9uIERpc2NvdmVyKHVzZXJBZGRyZXNzKSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG5cbiAgICBpZiAodXNlckFkZHJlc3MgaW4gY2FjaGVkSW5mbykge1xuICAgICAgcmV0dXJuIHJlc29sdmUoY2FjaGVkSW5mb1t1c2VyQWRkcmVzc10pO1xuICAgIH1cblxuICAgIHZhciB3ZWJGaW5nZXIgPSBuZXcgV2ViRmluZ2VyKHtcbiAgICAgIHRsc19vbmx5OiBmYWxzZSxcbiAgICAgIHVyaV9mYWxsYmFjazogdHJ1ZSxcbiAgICAgIHJlcXVlc3RfdGltZW91dDogNTAwMFxuICAgIH0pO1xuXG4gICAgcmV0dXJuIHdlYkZpbmdlci5sb29rdXAodXNlckFkZHJlc3MsIGZ1bmN0aW9uIChlcnIsIHJlc3BvbnNlKSB7XG4gICAgICBpZiAoZXJyKSB7XG4gICAgICAgIHJldHVybiByZWplY3QoZXJyKTtcbiAgICAgIH0gZWxzZSBpZiAoKHR5cGVvZiByZXNwb25zZS5pZHgubGlua3MucmVtb3Rlc3RvcmFnZSAhPT0gJ29iamVjdCcpIHx8XG4gICAgICAgICAgICAgICAgICh0eXBlb2YgcmVzcG9uc2UuaWR4LmxpbmtzLnJlbW90ZXN0b3JhZ2UubGVuZ3RoICE9PSAnbnVtYmVyJykgfHxcbiAgICAgICAgICAgICAgICAgKHJlc3BvbnNlLmlkeC5saW5rcy5yZW1vdGVzdG9yYWdlLmxlbmd0aCA8PSAwKSkge1xuICAgICAgICBsb2coXCJbRGlzY292ZXJdIFdlYkZpbmdlciByZWNvcmQgZm9yIFwiICsgdXNlckFkZHJlc3MgKyBcIiBkb2VzIG5vdCBoYXZlIHJlbW90ZXN0b3JhZ2UgZGVmaW5lZCBpbiB0aGUgbGlua3Mgc2VjdGlvbiBcIiwgSlNPTi5zdHJpbmdpZnkocmVzcG9uc2UuanNvbikpO1xuICAgICAgICByZXR1cm4gcmVqZWN0KFwiV2ViRmluZ2VyIHJlY29yZCBmb3IgXCIgKyB1c2VyQWRkcmVzcyArIFwiIGRvZXMgbm90IGhhdmUgcmVtb3Rlc3RvcmFnZSBkZWZpbmVkIGluIHRoZSBsaW5rcyBzZWN0aW9uLlwiKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHJzID0gcmVzcG9uc2UuaWR4LmxpbmtzLnJlbW90ZXN0b3JhZ2VbMF07XG4gICAgICB2YXIgYXV0aFVSTCA9IHJzLnByb3BlcnRpZXNbJ2h0dHA6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzY3NDkjc2VjdGlvbi00LjInXSB8fFxuICAgICAgICAgICAgICAgICAgICBycy5wcm9wZXJ0aWVzWydhdXRoLWVuZHBvaW50J107XG4gICAgICB2YXIgc3RvcmFnZVR5cGUgPSBycy5wcm9wZXJ0aWVzWydodHRwOi8vcmVtb3Rlc3RvcmFnZS5pby9zcGVjL3ZlcnNpb24nXSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgcnMudHlwZTtcblxuICAgICAgLy8gY2FjaGUgZmV0Y2hlZCBkYXRhXG4gICAgICBjYWNoZWRJbmZvW3VzZXJBZGRyZXNzXSA9IHsgaHJlZjogcnMuaHJlZiwgc3RvcmFnZVR5cGU6IHN0b3JhZ2VUeXBlLCBhdXRoVVJMOiBhdXRoVVJMLCBwcm9wZXJ0aWVzOiBycy5wcm9wZXJ0aWVzIH07XG5cbiAgICAgIGlmIChoYXNMb2NhbFN0b3JhZ2UpIHtcbiAgICAgICAgbG9jYWxTdG9yYWdlW1NFVFRJTkdTX0tFWV0gPSBKU09OLnN0cmluZ2lmeSh7IGNhY2hlOiBjYWNoZWRJbmZvIH0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzb2x2ZShjYWNoZWRJbmZvW3VzZXJBZGRyZXNzXSk7XG4gICAgfSk7XG4gIH0pO1xufTtcblxuXG5EaXNjb3Zlci5EaXNjb3ZlcnlFcnJvciA9IGZ1bmN0aW9uIChtZXNzYWdlKSB7XG4gIEVycm9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XG59O1xuXG5EaXNjb3Zlci5EaXNjb3ZlcnlFcnJvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEVycm9yLnByb3RvdHlwZSk7XG5cblxuRGlzY292ZXIuX3JzX2luaXQgPSBmdW5jdGlvbiAocmVtb3RlU3RvcmFnZSkge1xuICBoYXNMb2NhbFN0b3JhZ2UgPSB1dGlsLmxvY2FsU3RvcmFnZUF2YWlsYWJsZSgpO1xuICBpZiAoaGFzTG9jYWxTdG9yYWdlKSB7XG4gICAgdmFyIHNldHRpbmdzO1xuICAgIHRyeSB7IHNldHRpbmdzID0gSlNPTi5wYXJzZShsb2NhbFN0b3JhZ2VbU0VUVElOR1NfS0VZXSk7IH0gY2F0Y2goZSkge31cbiAgICBpZiAoc2V0dGluZ3MpIHtcbiAgICAgIGNhY2hlZEluZm8gPSBzZXR0aW5ncy5jYWNoZTtcbiAgICB9XG4gIH1cbn07XG5cbkRpc2NvdmVyLl9yc19zdXBwb3J0ZWQgPSBmdW5jdGlvbiAoKSB7XG4gIGhhdmVYTUxIdHRwUmVxdWVzdCA9ICEhIHV0aWwuZ2xvYmFsQ29udGV4dC5YTUxIdHRwUmVxdWVzdDtcbiAgcmV0dXJuIGhhdmVYTUxIdHRwUmVxdWVzdDtcbn07XG5cbkRpc2NvdmVyLl9yc19jbGVhbnVwID0gZnVuY3Rpb24gKCkge1xuICBpZiAoaGFzTG9jYWxTdG9yYWdlKSB7XG4gICAgZGVsZXRlIGxvY2FsU3RvcmFnZVtTRVRUSU5HU19LRVldO1xuICB9XG59O1xuXG5cbm1vZHVsZS5leHBvcnRzID0gRGlzY292ZXI7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvZGlzY292ZXIuanMiXSwic291cmNlUm9vdCI6IiJ9');
},function(module,exports,__webpack_require__){eval("'use strict';\n\nvar Authorize = __webpack_require__(4);\nvar BaseClient = __webpack_require__(6);\nvar WireClient = __webpack_require__(9);\nvar util = __webpack_require__(2);\nvar eventHandling = __webpack_require__(3);\nvar Sync = __webpack_require__(8);\n\n/**\n * File: Dropbox\n *\n * WORK IN PROGRESS, NOT RECOMMENDED FOR PRODUCTION USE\n *\n * Dropbox backend for RemoteStorage.js\n * This file exposes a get/put/delete interface which is compatible with\n * <WireClient>.\n *\n * When remoteStorage.backend is set to 'dropbox', this backend will\n * initialize and replace remoteStorage.remote with remoteStorage.dropbox.\n *\n * In order to ensure compatibility with the public folder, <BaseClient.getItemURL>\n * gets hijacked to return the Dropbox public share URL.\n *\n * To use this backend, you need to specify the Dropbox app key like so:\n *\n * (start code)\n *\n * remoteStorage.setApiKeys('dropbox', {\n *   appKey: 'your-app-key'\n * });\n *\n * (end code)\n *\n * An app key can be obtained by registering your app at https://www.dropbox.com/developers/apps\n *\n * Known issues:\n *\n *   - Storing files larger than 150MB is not yet supported\n *   - Listing and deleting folders with more than 10'000 files will cause problems\n *   - Content-Type is not fully supported due to limitations of the Dropbox API\n *   - Dropbox preserves cases but is not case-sensitive\n *   - getItemURL is asynchronous which means getIetmURL returns useful values\n *     after the syncCycle\n */\n\nvar hasLocalStorage;\nvar AUTH_URL = 'https://www.dropbox.com/1/oauth2/authorize';\nvar SETTINGS_KEY = 'remotestorage:dropbox';\nvar PATH_PREFIX = '/remotestorage';\n\nvar isFolder = util.isFolder;\n\n/**\n * Function: getDropboxPath(path)\n *\n * Map a local path to a path in DropBox.\n */\nvar getDropboxPath = function getDropboxPath(path) {\n  return WireClient.cleanPath(PATH_PREFIX + '/' + path);\n};\n\nvar encodeQuery = function encodeQuery(obj) {\n  var pairs = [];\n\n  for (var key in obj) {\n    if (obj.hasOwnProperty(key)) {\n      pairs.push(encodeURIComponent(key) + '=' + encodeURIComponent(obj[key]));\n    }\n  }\n\n  return pairs.join('&');\n};\n\n/**\n * class: LowerCaseCache\n *\n * A cache which automatically converts all keys to lower case and can\n * propagate changes up to parent folders.\n *\n * By default the set and delete methods are aliased to justSet and justDelete.\n *\n * Parameters:\n *\n *   defaultValue - the value that is returned for all keys that don't exist\n *                  in the cache\n */\nfunction LowerCaseCache(defaultValue) {\n  this.defaultValue = defaultValue;\n  this._storage = {};\n  this.set = this.justSet;\n  this.delete = this.justDelete;\n}\n\nLowerCaseCache.prototype = {\n  /**\n   * Method: get\n   *\n   * Get a value from the cache or defaultValue, if the key is not in the\n   * cache.\n   */\n  get: function get(key) {\n    key = key.toLowerCase();\n    var stored = this._storage[key];\n    if (typeof stored === 'undefined') {\n      stored = this.defaultValue;\n      this._storage[key] = stored;\n    }\n    return stored;\n  },\n\n  /**\n   * Method: propagateSet\n   *\n   * Set a value and also update the parent folders with that value.\n   */\n  propagateSet: function propagateSet(key, value) {\n    key = key.toLowerCase();\n    if (this._storage[key] === value) {\n      return value;\n    }\n    this._propagate(key, value);\n    this._storage[key] = value;\n    return value;\n  },\n\n  /**\n   * Method: propagateDelete\n   *\n   * Delete a value and propagate the changes to the parent folders.\n   */\n  propagateDelete: function propagateDelete(key) {\n    key = key.toLowerCase();\n    this._propagate(key, this._storage[key]);\n    return delete this._storage[key];\n  },\n\n  _activatePropagation: function _activatePropagation() {\n    this.set = this.propagateSet;\n    this.delete = this.propagateDelete;\n    return true;\n  },\n\n  /**\n   * Method: justSet\n   *\n   * Set a value without propagating.\n   */\n  justSet: function justSet(key, value) {\n    key = key.toLowerCase();\n    this._storage[key] = value;\n    return value;\n  },\n\n  /**\n   * Method: justDelete\n   *\n   * Delete a value without propagating.\n   */\n  justDelete: function justDelete(key, value) {\n    key = key.toLowerCase();\n    return delete this._storage[key];\n  },\n\n  _propagate: function _propagate(key, rev) {\n    var folders = key.split('/').slice(0, -1);\n    var path = '';\n\n    for (var i = 0, len = folders.length; i < len; i++) {\n      path += folders[i] + '/';\n      if (!rev) {\n        rev = this._storage[path] + 1;\n      }\n      this._storage[path] = rev;\n    }\n  }\n};\n\nvar onErrorCb;\n\n/**\n * Class: Dropbox\n */\nvar Dropbox = function Dropbox(rs) {\n\n  this.rs = rs;\n  this.connected = false;\n  this.rs = rs;\n  var self = this;\n\n  onErrorCb = function onErrorCb(error) {\n    if (error instanceof Authorize.Unauthorized) {\n      // Delete all the settings - see the documentation of wireclient.configure\n      self.configure({\n        userAddress: null,\n        href: null,\n        storageApi: null,\n        token: null,\n        options: null\n      });\n    }\n  };\n\n  eventHandling(this, 'change', 'connected', 'wire-busy', 'wire-done', 'not-connected');\n  rs.on('error', onErrorCb);\n\n  this.clientId = rs.apiKeys.dropbox.appKey;\n  this._revCache = new LowerCaseCache('rev');\n  this._itemRefs = {};\n  this._metadataCache = {};\n\n  hasLocalStorage = util.localStorageAvailable();\n\n  if (hasLocalStorage) {\n    var settings;\n    try {\n      settings = JSON.parse(localStorage.getItem(SETTINGS_KEY));\n    } catch (e) {}\n    if (settings) {\n      this.configure(settings);\n    }\n    try {\n      this._itemRefs = JSON.parse(localStorage.getItem(SETTINGS_KEY + ':shares'));\n    } catch (e) {}\n  }\n  if (this.connected) {\n    setTimeout(this._emit.bind(this), 0, 'connected');\n  }\n};\n\nDropbox.prototype = {\n  online: true,\n\n  /**\n   * Method: connect\n   *\n   * Set the backed to 'dropbox' and start the authentication flow in order\n   * to obtain an API token from Dropbox.\n   */\n  connect: function connect() {\n    // TODO handling when token is already present\n    this.rs.setBackend('dropbox');\n    if (this.token) {\n      hookIt(this.rs);\n    } else {\n      Authorize(this.rs, AUTH_URL, '', String(Authorize.getLocation()), this.clientId);\n    }\n  },\n\n  /**\n   * Method : configure(settings)\n   * Accepts its parameters according to the <WireClient>.\n   * Sets the connected flag\n   **/\n  configure: function configure(settings) {\n    // We only update this.userAddress if settings.userAddress is set to a string or to null:\n    if (typeof settings.userAddress !== 'undefined') {\n      this.userAddress = settings.userAddress;\n    }\n    // Same for this.token. If only one of these two is set, we leave the other one at its existing value:\n    if (typeof settings.token !== 'undefined') {\n      this.token = settings.token;\n    }\n\n    var writeSettingsToCache = function writeSettingsToCache() {\n      if (hasLocalStorage) {\n        localStorage.setItem(SETTINGS_KEY, JSON.stringify({\n          userAddress: this.userAddress,\n          token: this.token\n        }));\n      }\n    };\n\n    var handleError = function handleError() {\n      this.connected = false;\n      if (hasLocalStorage) {\n        localStorage.removeItem(SETTINGS_KEY);\n      }\n    };\n\n    if (this.token) {\n      this.connected = true;\n      if (this.userAddress) {\n        this._emit('connected');\n        writeSettingsToCache.apply(this);\n      } else {\n        this.info().then(function (info) {\n          this.userAddress = info.email;\n          this._emit('connected');\n          writeSettingsToCache.apply(this);\n        }.bind(this)).catch(function () {\n          handleError.apply(this);\n          this.rs._emit('error', new Error('Could not fetch user info.'));\n        }.bind(this));\n      }\n    } else {\n      handleError.apply(this);\n    }\n  },\n\n  /**\n   * Method: stopWaitingForToken\n   *\n   * Stop waiting for the token and emit not-connected\n   */\n  stopWaitingForToken: function stopWaitingForToken() {\n    if (!this.connected) {\n      this._emit('not-connected');\n    }\n  },\n\n  /**\n   * Method: _getFolder\n   *\n   * Get all items in a folder.\n   *\n   * Parameters:\n   *\n   *   path - path of the folder to get, with leading slash\n   *   options - not used\n   *\n   * Returns:\n   *\n   *  statusCode - HTTP status code\n   *  body - array of the items found\n   *  contentType - 'application/json; charset=UTF-8'\n   *  revision - revision of the folder\n   */\n  _getFolder: function _getFolder(path, options) {\n    // FIXME simplify promise handling\n    var url = 'https://api.dropbox.com/1/metadata/auto' + getDropboxPath(path);\n    var revCache = this._revCache;\n    var self = this;\n\n    return this._request('GET', url, {}).then(function (resp) {\n      var status = resp.status;\n      if (status === 304) {\n        return Promise.resolve({ statusCode: status });\n      }\n      var listing, body, mime, rev;\n      try {\n        body = JSON.parse(resp.responseText);\n      } catch (e) {\n        return Promise.reject(e);\n      }\n      rev = self._revCache.get(path);\n      mime = 'application/json; charset=UTF-8';\n      if (body.contents) {\n        listing = body.contents.reduce(function (m, item) {\n          var itemName = item.path.split('/').slice(-1)[0] + (item.is_dir ? '/' : '');\n          if (item.is_dir) {\n            m[itemName] = { ETag: revCache.get(path + itemName) };\n          } else {\n            m[itemName] = { ETag: item.rev };\n          }\n          return m;\n        }, {});\n      }\n      return Promise.resolve({ statusCode: status, body: listing, contentType: mime, revision: rev });\n    });\n  },\n\n  /**\n   * Method: get\n   *\n   * Compatible with <WireClient.get>\n   *\n   * Checks for the path in _revCache and decides based on that if file has\n   * changed. Calls _getFolder is the path points to a folder.\n   *\n   * Calls <Dropbox.share> afterwards to fill _itemRefs.\n   */\n  get: function get(path, options) {\n    if (!this.connected) {\n      return Promise.reject(\"not connected (path: \" + path + \")\");\n    }\n    var url = 'https://api-content.dropbox.com/1/files/auto' + getDropboxPath(path);\n    var self = this;\n\n    var savedRev = this._revCache.get(path);\n    if (savedRev === null) {\n      // file was deleted server side\n      return Promise.resolve({ statusCode: 404 });\n    }\n    if (options && options.ifNoneMatch && savedRev && savedRev === options.ifNoneMatch) {\n      // nothing changed.\n      return Promise.resolve({ statusCode: 304 });\n    }\n\n    //use _getFolder for folders\n    if (path.substr(-1) === '/') {\n      return this._getFolder(path, options);\n    }\n\n    return this._request('GET', url, {}).then(function (resp) {\n      var status = resp.status;\n      var meta, body, mime, rev;\n      if (status !== 200) {\n        return Promise.resolve({ statusCode: status });\n      }\n\n      body = resp.responseText;\n      try {\n        meta = JSON.parse(resp.getResponseHeader('x-dropbox-metadata'));\n      } catch (e) {\n        return Promise.reject(e);\n      }\n\n      mime = meta.mime_type; //resp.getResponseHeader('Content-Type');\n      rev = meta.rev;\n      self._revCache.set(path, rev);\n      self._shareIfNeeded(path); // The shared link expires every 4 hours\n\n      // handling binary\n      if (!resp.getResponseHeader('Content-Type') || resp.getResponseHeader('Content-Type').match(/charset=binary/)) {\n\n        // TOFIX: would be better to make readBinaryData return a Promise - les\n        return new Promise(function (resolve, reject) {\n          WireClient.readBinaryData(resp.response, mime, function (result) {\n            resolve({\n              statusCode: status,\n              body: result,\n              contentType: mime,\n              revision: rev\n            });\n          });\n        });\n      }\n\n      // handling json (always try)\n      // comment it out as this is always true (false && false || true)\n      // and jshint is complaining\n      // if (mime && mime.search('application/json') >= 0 || true) {\n      try {\n        body = JSON.parse(body);\n        mime = 'application/json; charset=UTF-8';\n      } catch (e) {}\n      //Failed parsing Json, assume it is something else then\n\n      // }\n\n      return Promise.resolve({ statusCode: status, body: body, contentType: mime, revision: rev });\n    });\n  },\n\n  /**\n   * Method: put\n   *\n   * Compatible with <WireClient>\n   *\n   * Checks for the path in _revCache and decides based on that if file has\n   * changed.\n   *\n   * Calls <Dropbox.share> afterwards to fill _itemRefs.\n   */\n  put: function put(path, body, contentType, options) {\n    var self = this;\n\n    if (!this.connected) {\n      throw new Error(\"not connected (path: \" + path + \")\");\n    }\n\n    //check if file has changed and return 412\n    var savedRev = this._revCache.get(path);\n    if (options && options.ifMatch && savedRev && savedRev !== options.ifMatch) {\n      return Promise.resolve({ statusCode: 412, revision: savedRev });\n    }\n    if (options && options.ifNoneMatch === '*' && savedRev && savedRev !== 'rev') {\n      return Promise.resolve({ statusCode: 412, revision: savedRev });\n    }\n\n    if (!contentType.match(/charset=/) && (body instanceof ArrayBuffer || WireClient.isArrayBufferView(body))) {\n      contentType += '; charset=binary';\n    }\n\n    if (body.length > 150 * 1024 * 1024) {\n      //https://www.dropbox.com/developers/core/docs#chunked-upload\n      return Promise.reject(new Error(\"Cannot upload file larger than 150MB\"));\n    }\n\n    var result;\n    var needsMetadata = options && (options.ifMatch || options.ifNoneMatch === '*');\n    var uploadParams = {\n      body: body,\n      contentType: contentType,\n      path: path\n    };\n\n    if (needsMetadata) {\n      result = this._getMetadata(path).then(function (metadata) {\n        if (options && options.ifNoneMatch === '*' && metadata) {\n          // if !!metadata === true, the file exists\n          return Promise.resolve({\n            statusCode: 412,\n            revision: metadata.rev\n          });\n        }\n\n        if (options && options.ifMatch && metadata && metadata.rev !== options.ifMatch) {\n          return Promise.resolve({\n            statusCode: 412,\n            revision: metadata.rev\n          });\n        }\n\n        return self._uploadSimple(uploadParams);\n      });\n    } else {\n      result = self._uploadSimple(uploadParams);\n    }\n\n    return result.then(function (ret) {\n      self._shareIfNeeded(path);\n      return ret;\n    });\n  },\n\n  /**\n   * Method: delete\n   *\n   * Compatible with <WireClient.delete>\n   *\n   * Checks for the path in _revCache and decides based on that if file has\n   * changed.\n   *\n   * Calls <Dropbox.share> afterwards to fill _itemRefs.\n   */\n  'delete': function _delete(path, options) {\n    var self = this;\n\n    if (!this.connected) {\n      throw new Error(\"not connected (path: \" + path + \")\");\n    }\n\n    //check if file has changed and return 412\n    var savedRev = this._revCache.get(path);\n    if (options && options.ifMatch && savedRev && options.ifMatch !== savedRev) {\n      return Promise.resolve({ statusCode: 412, revision: savedRev });\n    }\n\n    if (options && options.ifMatch) {\n      return this._getMetadata(path).then(function (metadata) {\n        if (options && options.ifMatch && metadata && metadata.rev !== options.ifMatch) {\n          return Promise.resolve({\n            statusCode: 412,\n            revision: metadata.rev\n          });\n        }\n\n        return self._deleteSimple(path);\n      });\n    }\n\n    return self._deleteSimple(path);\n  },\n\n  /**\n   * Method: _shareIfNeeded\n   *\n   * Calls share, if the provided path resides in a public folder.\n   */\n  _shareIfNeeded: function _shareIfNeeded(path) {\n    if (path.match(/^\\/public\\/.*[^\\/]$/) && this._itemRefs[path] === undefined) {\n      this.share(path);\n    }\n  },\n\n  /**\n   * Method: share\n   *\n   * Gets a publicly-accessible URL for the path from Dropbox and stores it\n   * in _itemRefs.\n   *\n   * Returns:\n   *\n   *   A promise for the URL\n   */\n  share: function share(path) {\n    var self = this;\n    var url = 'https://api.dropbox.com/1/media/auto' + getDropboxPath(path);\n\n    return this._request('POST', url, {}).then(function (response) {\n      if (response.status !== 200) {\n        return Promise.reject(new Error('Invalid Dropbox API response status when sharing \"' + path + '\":' + response.status));\n      }\n\n      try {\n        response = JSON.parse(response.responseText);\n      } catch (e) {\n        return Promise.reject(new Error('Invalid Dropbox API response when sharing \"' + path + '\": ' + response.responseText));\n      }\n\n      self._itemRefs[path] = response.url;\n\n      if (hasLocalStorage) {\n        localStorage.setItem(SETTINGS_KEY + ':shares', JSON.stringify(self._itemRefs));\n      }\n\n      return Promise.resolve(url);\n    }, function (error) {\n      err.message = 'Sharing dropbox file or folder (\"' + path + '\") failed.' + err.message;\n      return Promise.reject(error);\n    });\n  },\n\n  /**\n   * Method: info\n   *\n   * Fetches the user's info from dropbox and returns a promise for it.\n   *\n   * Returns:\n   *\n   *   A promise to the user's info\n   */\n  info: function info() {\n    var url = 'https://api.dropbox.com/1/account/info';\n    // requesting user info(mainly for userAdress)\n    return this._request('GET', url, {}).then(function (resp) {\n      try {\n        var info = JSON.parse(resp.responseText);\n        return Promise.resolve(info);\n      } catch (e) {\n        return Promise.reject(e);\n      }\n    });\n  },\n\n  /**\n   * Method: _request\n   *\n   * Make a HTTP request.\n   *\n   * Options:\n   *\n   *   headers - an object containing the request headers\n   *\n   * Parameters:\n   *\n   *   method - the method to use\n   *   url - the URL to make the request to\n   *   options - see above\n   */\n  _request: function _request(method, url, options) {\n    var self = this;\n\n    if (!options.headers) {\n      options.headers = {};\n    }\n    options.headers['Authorization'] = 'Bearer ' + this.token;\n\n    this._emit('wire-busy', {\n      method: method,\n      isFolder: isFolder(url)\n    });\n\n    return WireClient.request.call(this, method, url, options).then(function (xhr) {\n      // 503 means retry this later\n      if (xhr && xhr.status === 503) {\n        if (self.online) {\n          self.online = false;\n          self.rs._emit('network-offline');\n        }\n        return setTimeout(self._request(method, url, options), 3210);\n      } else {\n        if (!self.online) {\n          self.online = true;\n          self.rs._emit('network-online');\n        }\n        self._emit('wire-done', {\n          method: method,\n          isFolder: isFolder(url),\n          success: true\n        });\n\n        return Promise.resolve(xhr);\n      }\n    }, function (error) {\n      if (self.online) {\n        self.online = false;\n        self.rs._emit('network-offline');\n      }\n      self._emit('wire-done', {\n        method: method,\n        isFolder: isFolder(url),\n        success: false\n      });\n\n      return Promise.reject(error);\n    });\n  },\n\n  /**\n   * Method: fetchDelta\n   *\n   * Fetches the revision of all the files from dropbox API and puts them\n   * into _revCache. These values can then be used to determine if something\n   * has changed.\n   */\n  fetchDelta: function fetchDelta() {\n    // TODO: Handle `has_more`\n\n    var args = Array.prototype.slice.call(arguments);\n    var self = this;\n    var body = { path_prefix: PATH_PREFIX };\n\n    if (self._deltaCursor) {\n      body.cursor = self._deltaCursor;\n    }\n\n    return self._request('POST', 'https://api.dropbox.com/1/delta', {\n      body: encodeQuery(body),\n      headers: {\n        'Content-Type': 'application/x-www-form-urlencoded'\n      }\n    }).then(function (response) {\n      // break if status != 200\n      if (response.status !== 200) {\n        if (response.status === 400) {\n          self.rs._emit('error', new Authorize.Unauthorized());\n          return Promise.resolve(args);\n        } else {\n          return Promise.reject(\"dropbox.fetchDelta returned \" + response.status + response.responseText);\n        }\n      }\n\n      var delta;\n      try {\n        delta = JSON.parse(response.responseText);\n      } catch (error) {\n        log('fetchDeltas can not parse response', error);\n        return Promise.reject(\"can not parse response of fetchDelta : \" + error.message);\n      }\n      // break if no entries found\n      if (!delta.entries) {\n        return Promise.reject('dropbox.fetchDeltas failed, no entries found');\n      }\n\n      // Dropbox sends the complete state\n      if (delta.reset) {\n        self._revCache = new LowerCaseCache('rev');\n      }\n\n      //saving the cursor for requesting further deltas in relation to the cursor position\n      if (delta.cursor) {\n        self._deltaCursor = delta.cursor;\n      }\n\n      //updating revCache\n      delta.entries.forEach(function (entry) {\n        var path = entry[0].substr(PATH_PREFIX.length);\n        var rev;\n        if (!entry[1]) {\n          rev = null;\n        } else {\n          if (entry[1].is_dir) {\n            return;\n          }\n          rev = entry[1].rev;\n        }\n        self._revCache.set(path, rev);\n      });\n      return Promise.resolve(args);\n    }, function (err) {\n      this.rs.log('fetchDeltas', err);\n      this.rs._emit('error', new Sync.SyncError('fetchDeltas failed.' + err));\n      return Promise.resolve(args);\n    }.bind(this)).then(function () {\n      if (self._revCache) {\n        var args = Array.prototype.slice.call(arguments);\n        self._revCache._activatePropagation();\n        return Promise.resolve(args);\n      }\n    });\n  },\n\n  /**\n   * Method: _getMetadata\n   *\n   * Gets metadata for a path (can point to either a file or a folder).\n   *\n   * Options:\n   *\n   *   list - if path points to a folder, specifies whether to list the\n   *          metadata of the folder's children. False by default.\n   *\n   * Parameters:\n   *\n   *   path - the path to get metadata for\n   *   options - see above\n   *\n   * Returns:\n   *\n   *   A promise for the metadata\n   */\n  _getMetadata: function _getMetadata(path, options) {\n    var self = this;\n    var cached = this._metadataCache[path];\n    var url = 'https://api.dropbox.com/1/metadata/auto' + getDropboxPath(path);\n    url += '?list=' + (options && options.list ? 'true' : 'false');\n    if (cached && cached.hash) {\n      url += '&hash=' + encodeURIComponent(cached.hash);\n    }\n    return this._request('GET', url, {}).then(function (resp) {\n      if (resp.status === 304) {\n        return Promise.resolve(cached);\n      } else if (resp.status === 200) {\n        var response = JSON.parse(resp.responseText);\n        self._metadataCache[path] = response;\n        return Promise.resolve(response);\n      } else {\n        // The file doesn't exist\n        return Promise.resolve();\n      }\n    });\n  },\n\n  /**\n   * Method: _uploadSimple\n   *\n   * Upload a simple file (the size is no more than 150MB).\n   *\n   * Parameters:\n   *\n   *   ifMatch - same as for get\n   *   path - path of the file\n   *   body - contents of the file to upload\n   *   contentType - mime type of the file\n   *\n   * Returns:\n   *\n   *   statusCode - HTTP status code\n   *   revision - revision of the newly-created file, if any\n   */\n  _uploadSimple: function _uploadSimple(params) {\n    var self = this;\n    var url = 'https://api-content.dropbox.com/1/files_put/auto' + getDropboxPath(params.path) + '?';\n\n    if (params && params.ifMatch) {\n      url += \"parent_rev=\" + encodeURIComponent(params.ifMatch);\n    }\n\n    return self._request('PUT', url, {\n      body: params.body,\n      headers: {\n        'Content-Type': params.contentType\n      }\n    }).then(function (resp) {\n      if (resp.status !== 200) {\n        return Promise.resolve({ statusCode: resp.status });\n      }\n\n      var response;\n\n      try {\n        response = JSON.parse(resp.responseText);\n      } catch (e) {\n        return Promise.reject(e);\n      }\n\n      // Conflict happened. Delete the copy created by dropbox\n      if (response.path !== getDropboxPath(params.path)) {\n        var deleteUrl = 'https://api.dropbox.com/1/fileops/delete?root=auto&path=' + encodeURIComponent(response.path);\n        self._request('POST', deleteUrl, {});\n\n        return self._getMetadata(params.path).then(function (metadata) {\n          return Promise.resolve({\n            statusCode: 412,\n            revision: metadata.rev\n          });\n        });\n      }\n\n      self._revCache.propagateSet(params.path, response.rev);\n      return Promise.resolve({ statusCode: resp.status });\n    });\n  },\n\n  /**\n   * Method: _deleteSimple\n   *\n   * Deletes a file or a folder. If the folder contains more than 10'000 items\n   * (recursively) then the operation may not complete successfully. If that\n   * is the case, an Error gets thrown.\n   *\n   * Parameters:\n   *\n   *   path - the path to delete\n   *\n   * Returns:\n   *\n   *   statusCode - HTTP status code\n   */\n  _deleteSimple: function _deleteSimple(path) {\n    var self = this;\n    var url = 'https://api.dropbox.com/1/fileops/delete?root=auto&path=' + encodeURIComponent(getDropboxPath(path));\n\n    return self._request('POST', url, {}).then(function (resp) {\n      if (resp.status === 406) {\n        // Too many files would be involved in the operation for it to\n        // complete successfully.\n        // TODO: Handle this somehow\n        return Promise.reject(new Error(\"Cannot delete '\" + path + \"': too many files involved\"));\n      }\n\n      if (resp.status === 200 || resp.status === 404) {\n        self._revCache.delete(path);\n        delete self._itemRefs[path];\n      }\n\n      return Promise.resolve({ statusCode: resp.status });\n    });\n  }\n};\n\n// Hooking and unhooking the sync\n\nfunction hookSync(rs) {\n  if (rs._dropboxOrigSync) {\n    return;\n  } // already hooked\n  rs._dropboxOrigSync = rs.sync.sync.bind(rs.sync);\n  rs.sync.sync = function () {\n    return this.dropbox.fetchDelta.apply(this.dropbox, arguments).then(rs._dropboxOrigSync, function (err) {\n      rs._emit('error', new Sync.SyncError(err));\n      return Promise.reject(err);\n    });\n  }.bind(rs);\n}\n\nfunction unHookSync(rs) {\n  if (!rs._dropboxOrigSync) {\n    return;\n  } // not hooked\n  rs.sync.sync = rs._dropboxOrigSync;\n  delete rs._dropboxOrigSync;\n}\n\n// Hooking and unhooking getItemURL\n\nfunction hookGetItemURL(rs) {\n  if (rs._origBaseClientGetItemURL) {\n    return;\n  }\n  rs._origBaseClientGetItemURL = BaseClient.prototype.getItemURL;\n  BaseClient.prototype.getItemURL = function (path) {\n    var ret = rs.dropbox._itemRefs[path];\n    return ret ? ret : '';\n  };\n}\n\nfunction unHookGetItemURL(rs) {\n  if (!rs._origBaseClientGetItemURL) {\n    return;\n  }\n  BaseClient.prototype.getItemURL = rs._origBaseClientGetItemURL;\n  delete rs._origBaseClientGetItemURL;\n}\n\nfunction hookRemote(rs) {\n  if (rs._origRemote) {\n    return;\n  }\n  rs._origRemote = rs.remote;\n  rs.remote = rs.dropbox;\n}\n\nfunction unHookRemote(rs) {\n  if (rs._origRemote) {\n    rs.remote = rs._origRemote;\n    delete rs._origRemote;\n  }\n}\n\nfunction hookIt(rs) {\n  hookRemote(rs);\n  if (rs.sync) {\n    hookSync(rs);\n  } else {\n    // when sync is not available yet, we wait for the remote to be connected,\n    // at which point sync should be available as well\n    rs.on('connected', function () {\n      if (rs.sync) {\n        hookSync(rs);\n      }\n    });\n  }\n  hookGetItemURL(rs);\n}\n\nfunction unHookIt(rs) {\n  unHookRemote(rs);\n  unHookSync(rs);\n  unHookGetItemURL(rs);\n}\n\nDropbox._rs_init = function (rs) {\n  hasLocalStorage = util.localStorageAvailable();\n  if (rs.apiKeys.dropbox) {\n    rs.dropbox = new Dropbox(rs);\n  }\n  if (rs.backend === 'dropbox') {\n    hookIt(rs);\n  }\n};\n\nDropbox._rs_supported = function () {\n  return true;\n};\n\nDropbox._rs_cleanup = function (rs) {\n  unHookIt(rs);\n  if (hasLocalStorage) {\n    localStorage.removeItem(SETTINGS_KEY);\n  }\n  rs.removeEventListener('error', onErrorCb);\n  rs.setBackend(undefined);\n};\n\nmodule.exports = Dropbox;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvZHJvcGJveC5qcz9mYzg5Il0sIm5hbWVzIjpbIkF1dGhvcml6ZSIsInJlcXVpcmUiLCJCYXNlQ2xpZW50IiwiV2lyZUNsaWVudCIsInV0aWwiLCJldmVudEhhbmRsaW5nIiwiU3luYyIsImhhc0xvY2FsU3RvcmFnZSIsIkFVVEhfVVJMIiwiU0VUVElOR1NfS0VZIiwiUEFUSF9QUkVGSVgiLCJpc0ZvbGRlciIsImdldERyb3Bib3hQYXRoIiwicGF0aCIsImNsZWFuUGF0aCIsImVuY29kZVF1ZXJ5Iiwib2JqIiwicGFpcnMiLCJrZXkiLCJoYXNPd25Qcm9wZXJ0eSIsInB1c2giLCJlbmNvZGVVUklDb21wb25lbnQiLCJqb2luIiwiTG93ZXJDYXNlQ2FjaGUiLCJkZWZhdWx0VmFsdWUiLCJfc3RvcmFnZSIsInNldCIsImp1c3RTZXQiLCJkZWxldGUiLCJqdXN0RGVsZXRlIiwicHJvdG90eXBlIiwiZ2V0IiwidG9Mb3dlckNhc2UiLCJzdG9yZWQiLCJwcm9wYWdhdGVTZXQiLCJ2YWx1ZSIsIl9wcm9wYWdhdGUiLCJwcm9wYWdhdGVEZWxldGUiLCJfYWN0aXZhdGVQcm9wYWdhdGlvbiIsInJldiIsImZvbGRlcnMiLCJzcGxpdCIsInNsaWNlIiwiaSIsImxlbiIsImxlbmd0aCIsIm9uRXJyb3JDYiIsIkRyb3Bib3giLCJycyIsImNvbm5lY3RlZCIsInNlbGYiLCJlcnJvciIsIlVuYXV0aG9yaXplZCIsImNvbmZpZ3VyZSIsInVzZXJBZGRyZXNzIiwiaHJlZiIsInN0b3JhZ2VBcGkiLCJ0b2tlbiIsIm9wdGlvbnMiLCJvbiIsImNsaWVudElkIiwiYXBpS2V5cyIsImRyb3Bib3giLCJhcHBLZXkiLCJfcmV2Q2FjaGUiLCJfaXRlbVJlZnMiLCJfbWV0YWRhdGFDYWNoZSIsImxvY2FsU3RvcmFnZUF2YWlsYWJsZSIsInNldHRpbmdzIiwiSlNPTiIsInBhcnNlIiwibG9jYWxTdG9yYWdlIiwiZ2V0SXRlbSIsImUiLCJzZXRUaW1lb3V0IiwiX2VtaXQiLCJiaW5kIiwib25saW5lIiwiY29ubmVjdCIsInNldEJhY2tlbmQiLCJob29rSXQiLCJTdHJpbmciLCJnZXRMb2NhdGlvbiIsIndyaXRlU2V0dGluZ3NUb0NhY2hlIiwic2V0SXRlbSIsInN0cmluZ2lmeSIsImhhbmRsZUVycm9yIiwicmVtb3ZlSXRlbSIsImFwcGx5IiwiaW5mbyIsInRoZW4iLCJlbWFpbCIsImNhdGNoIiwiRXJyb3IiLCJzdG9wV2FpdGluZ0ZvclRva2VuIiwiX2dldEZvbGRlciIsInVybCIsInJldkNhY2hlIiwiX3JlcXVlc3QiLCJyZXNwIiwic3RhdHVzIiwiUHJvbWlzZSIsInJlc29sdmUiLCJzdGF0dXNDb2RlIiwibGlzdGluZyIsImJvZHkiLCJtaW1lIiwicmVzcG9uc2VUZXh0IiwicmVqZWN0IiwiY29udGVudHMiLCJyZWR1Y2UiLCJtIiwiaXRlbSIsIml0ZW1OYW1lIiwiaXNfZGlyIiwiRVRhZyIsImNvbnRlbnRUeXBlIiwicmV2aXNpb24iLCJzYXZlZFJldiIsImlmTm9uZU1hdGNoIiwic3Vic3RyIiwibWV0YSIsImdldFJlc3BvbnNlSGVhZGVyIiwibWltZV90eXBlIiwiX3NoYXJlSWZOZWVkZWQiLCJtYXRjaCIsInJlYWRCaW5hcnlEYXRhIiwicmVzcG9uc2UiLCJyZXN1bHQiLCJwdXQiLCJpZk1hdGNoIiwiQXJyYXlCdWZmZXIiLCJpc0FycmF5QnVmZmVyVmlldyIsIm5lZWRzTWV0YWRhdGEiLCJ1cGxvYWRQYXJhbXMiLCJfZ2V0TWV0YWRhdGEiLCJtZXRhZGF0YSIsIl91cGxvYWRTaW1wbGUiLCJyZXQiLCJfZGVsZXRlU2ltcGxlIiwidW5kZWZpbmVkIiwic2hhcmUiLCJlcnIiLCJtZXNzYWdlIiwibWV0aG9kIiwiaGVhZGVycyIsInJlcXVlc3QiLCJjYWxsIiwieGhyIiwic3VjY2VzcyIsImZldGNoRGVsdGEiLCJhcmdzIiwiQXJyYXkiLCJhcmd1bWVudHMiLCJwYXRoX3ByZWZpeCIsIl9kZWx0YUN1cnNvciIsImN1cnNvciIsImRlbHRhIiwibG9nIiwiZW50cmllcyIsInJlc2V0IiwiZm9yRWFjaCIsImVudHJ5IiwiU3luY0Vycm9yIiwiY2FjaGVkIiwibGlzdCIsImhhc2giLCJwYXJhbXMiLCJkZWxldGVVcmwiLCJob29rU3luYyIsIl9kcm9wYm94T3JpZ1N5bmMiLCJzeW5jIiwidW5Ib29rU3luYyIsImhvb2tHZXRJdGVtVVJMIiwiX29yaWdCYXNlQ2xpZW50R2V0SXRlbVVSTCIsImdldEl0ZW1VUkwiLCJ1bkhvb2tHZXRJdGVtVVJMIiwiaG9va1JlbW90ZSIsIl9vcmlnUmVtb3RlIiwicmVtb3RlIiwidW5Ib29rUmVtb3RlIiwidW5Ib29rSXQiLCJfcnNfaW5pdCIsImJhY2tlbmQiLCJfcnNfc3VwcG9ydGVkIiwiX3JzX2NsZWFudXAiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJtYXBwaW5ncyI6Ijs7QUFBRSxJQUFJQSxZQUFZLG1CQUFBQyxDQUFRLENBQVIsQ0FBaEI7QUFDQSxJQUFJQyxhQUFhLG1CQUFBRCxDQUFRLENBQVIsQ0FBakI7QUFDQSxJQUFJRSxhQUFhLG1CQUFBRixDQUFRLENBQVIsQ0FBakI7QUFDQSxJQUFJRyxPQUFPLG1CQUFBSCxDQUFRLENBQVIsQ0FBWDtBQUNBLElBQUlJLGdCQUFnQixtQkFBQUosQ0FBUSxDQUFSLENBQXBCO0FBQ0EsSUFBSUssT0FBTyxtQkFBQUwsQ0FBUSxDQUFSLENBQVg7O0FBRUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFxQ0EsSUFBSU0sZUFBSjtBQUNBLElBQUlDLFdBQVcsNENBQWY7QUFDQSxJQUFJQyxlQUFlLHVCQUFuQjtBQUNBLElBQUlDLGNBQWMsZ0JBQWxCOztBQUVBLElBQUlDLFdBQVdQLEtBQUtPLFFBQXBCOztBQUVBOzs7OztBQUtBLElBQUlDLGlCQUFpQixTQUFqQkEsY0FBaUIsQ0FBVUMsSUFBVixFQUFnQjtBQUNuQyxTQUFPVixXQUFXVyxTQUFYLENBQXFCSixjQUFjLEdBQWQsR0FBb0JHLElBQXpDLENBQVA7QUFDRCxD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ZUFBYXBJLEVBQWI7QUFDQTRILGFBQVc1SCxFQUFYO0FBQ0FnSSxtQkFBaUJoSSxFQUFqQjtBQUNEOztBQUVERCxRQUFRdUksUUFBUixHQUFtQixVQUFVdEksRUFBVixFQUFjO0FBQy9CekMsb0JBQWtCSCxLQUFLK0QscUJBQUwsRUFBbEI7QUFDQSxNQUFLbkIsR0FBR2EsT0FBSCxDQUFXQyxPQUFoQixFQUEwQjtBQUN4QmQsT0FBR2MsT0FBSCxHQUFhLElBQUlmLE9BQUosQ0FBWUMsRUFBWixDQUFiO0FBQ0Q7QUFDRCxNQUFJQSxHQUFHdUksT0FBSCxLQUFlLFNBQW5CLEVBQThCO0FBQzVCdkcsV0FBT2hDLEVBQVA7QUFDRDtBQUNGLENBUkQ7O0FBVUFELFFBQVF5SSxhQUFSLEdBQXdCLFlBQVk7QUFDbEMsU0FBTyxJQUFQO0FBQ0QsQ0FGRDs7QUFJQXpJLFFBQVEwSSxXQUFSLEdBQXNCLFVBQVV6SSxFQUFWLEVBQWM7QUFDbENxSSxXQUFTckksRUFBVDtBQUNBLE1BQUl6QyxlQUFKLEVBQW9CO0FBQ2xCZ0UsaUJBQWFnQixVQUFiLENBQXdCOUUsWUFBeEI7QUFDRDtBQUNEdUMsS0FBRzBJLG1CQUFILENBQXVCLE9BQXZCLEVBQWdDNUksU0FBaEM7QUFDQUUsS0FBRytCLFVBQUgsQ0FBYzZELFNBQWQ7QUFDRCxDQVBEOztBQVVBK0MsT0FBT0MsT0FBUCxHQUFpQjdJLE9BQWpCIiwiZmlsZSI6IjEzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiICB2YXIgQXV0aG9yaXplID0gcmVxdWlyZSgnLi9hdXRob3JpemUnKTtcbiAgdmFyIEJhc2VDbGllbnQgPSByZXF1aXJlKCcuL2Jhc2VjbGllbnQnKTtcbiAgdmFyIFdpcmVDbGllbnQgPSByZXF1aXJlKCcuL3dpcmVjbGllbnQnKTtcbiAgdmFyIHV0aWwgPSByZXF1aXJlKCcuL3V0aWwnKTtcbiAgdmFyIGV2ZW50SGFuZGxpbmcgPSByZXF1aXJlKCcuL2V2ZW50aGFuZGxpbmcnKTtcbiAgdmFyIFN5bmMgPSByZXF1aXJlKCcuL3N5bmMnKTtcblxuICAvKipcbiAgICogRmlsZTogRHJvcGJveFxuICAgKlxuICAgKiBXT1JLIElOIFBST0dSRVNTLCBOT1QgUkVDT01NRU5ERUQgRk9SIFBST0RVQ1RJT04gVVNFXG4gICAqXG4gICAqIERyb3Bib3ggYmFja2VuZCBmb3IgUmVtb3RlU3RvcmFnZS5qc1xuICAgKiBUaGlzIGZpbGUgZXhwb3NlcyBhIGdldC9wdXQvZGVsZXRlIGludGVyZmFjZSB3aGljaCBpcyBjb21wYXRpYmxlIHdpdGhcbiAgICogPFdpcmVDbGllbnQ+LlxuICAgKlxuICAgKiBXaGVuIHJlbW90ZVN0b3JhZ2UuYmFja2VuZCBpcyBzZXQgdG8gJ2Ryb3Bib3gnLCB0aGlzIGJhY2tlbmQgd2lsbFxuICAgKiBpbml0aWFsaXplIGFuZCByZXBsYWNlIHJlbW90ZVN0b3JhZ2UucmVtb3RlIHdpdGggcmVtb3RlU3RvcmFnZS5kcm9wYm94LlxuICAgKlxuICAgKiBJbiBvcmRlciB0byBlbnN1cmUgY29tcGF0aWJpbGl0eSB3aXRoIHRoZSBwdWJsaWMgZm9sZGVyLCA8QmFzZUNsaWVudC5nZXRJdGVtVVJMPlxuICAgKiBnZXRzIGhpamFja2VkIHRvIHJldHVybiB0aGUgRHJvcGJveCBwdWJsaWMgc2hhcmUgVVJMLlxuICAgKlxuICAgKiBUbyB1c2UgdGhpcyBiYWNrZW5kLCB5b3UgbmVlZCB0byBzcGVjaWZ5IHRoZSBEcm9wYm94IGFwcCBrZXkgbGlrZSBzbzpcbiAgICpcbiAgICogKHN0YXJ0IGNvZGUpXG4gICAqXG4gICAqIHJlbW90ZVN0b3JhZ2Uuc2V0QXBpS2V5cygnZHJvcGJveCcsIHtcbiAgICogICBhcHBLZXk6ICd5b3VyLWFwcC1rZXknXG4gICAqIH0pO1xuICAgKlxuICAgKiAoZW5kIGNvZGUpXG4gICAqXG4gICAqIEFuIGFwcCBrZXkgY2FuIGJlIG9idGFpbmVkIGJ5IHJlZ2lzdGVyaW5nIHlvdXIgYXBwIGF0IGh0dHBzOi8vd3d3LmRyb3Bib3guY29tL2RldmVsb3BlcnMvYXBwc1xuICAgKlxuICAgKiBLbm93biBpc3N1ZXM6XG4gICAqXG4gICAqICAgLSBTdG9yaW5nIGZpbGVzIGxhcmdlciB0aGFuIDE1ME1CIGlzIG5vdCB5ZXQgc3VwcG9ydGVkXG4gICAqICAgLSBMaXN0aW5nIGFuZCBkZWxldGluZyBmb2xkZXJzIHdpdGggbW9yZSB0aGFuIDEwJzAwMCBmaWxlcyB3aWxsIGNhdXNlIHByb2JsZW1zXG4gICAqICAgLSBDb250ZW50LVR5cGUgaXMgbm90IGZ1bGx5IHN1cHBvcnRlZCBkdWUgdG8gbGltaXRhdGlvbnMgb2YgdGhlIERyb3Bib3ggQVBJXG4gICAqICAgLSBEcm9wYm94IHByZXNlcnZlcyBjYXNlcyBidXQgaXMgbm90IGNhc2Utc2Vuc2l0aXZlXG4gICAqICAgLSBnZXRJdGVtVVJMIGlzIGFzeW5jaHJvbm91cyB3aGljaCBtZWFucyBnZXRJZXRtVVJMIHJldHVybnMgdXNlZnVsIHZhbHVlc1xuICAgKiAgICAgYWZ0ZXIgdGhlIHN5bmNDeWNsZVxuICAgKi9cblxuICB2YXIgaGFzTG9jYWxTdG9yYWdlO1xuICB2YXIgQVVUSF9VUkwgPSAnaHR0cHM6Ly93d3cuZHJvcGJveC5jb20vMS9vYXV0aDIvYXV0aG9yaXplJztcbiAgdmFyIFNFVFRJTkdTX0tFWSA9ICdyZW1vdGVzdG9yYWdlOmRyb3Bib3gnO1xuICB2YXIgUEFUSF9QUkVGSVggPSAnL3JlbW90ZXN0b3JhZ2UnO1xuXG4gIHZhciBpc0ZvbGRlciA9IHV0aWwuaXNGb2xkZXI7XG5cbiAgLyoqXG4gICAqIEZ1bmN0aW9uOiBnZXREcm9wYm94UGF0aChwYXRoKVxuICAgKlxuICAgKiBNYXAgYSBsb2NhbCBwYXRoIHRvIGEgcGF0aCBpbiBEcm9wQm94LlxuICAgKi9cbiAgdmFyIGdldERyb3Bib3hQYXRoID0gZnVuY3Rpb24gKHBhdGgpIHtcbiAgICByZXR1cm4gV2lyZUNsaWVudC5jbGVhblBhdGgoUEFUSF9QUkVGSVggKyAnLycgKyBwYXRoKTtcbiAgfTtcblxuICB2YXIgZW5jb2RlUXVlcnkgPSBmdW5jdGlvbiAob2JqKSB7XG4gICAgdmFyIHBhaXJzID0gW107XG5cbiAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgICBpZiAob2JqLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgcGFpcnMucHVzaChlbmNvZGVVUklDb21wb25lbnQoa2V5KSArICc9JyArIGVuY29kZVVSSUNvbXBvbmVudChvYmpba2V5XSkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBwYWlycy5qb2luKCcmJyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIGNsYXNzOiBMb3dlckNhc2VDYWNoZVxuICAgKlxuICAgKiBBIGNhY2hlIHdoaWNoIGF1dG9tYXRpY2FsbHkgY29udmVydHMgYWxsIGtleXMgdG8gbG93ZXIgY2FzZSBhbmQgY2FuXG4gICAqIHByb3BhZ2F0ZSBjaGFuZ2VzIHVwIHRvIHBhcmVudCBmb2xkZXJzLlxuICAgKlxuICAgKiBCeSBkZWZhdWx0IHRoZSBzZXQgYW5kIGRlbGV0ZSBtZXRob2RzIGFyZSBhbGlhc2VkIHRvIGp1c3RTZXQgYW5kIGp1c3REZWxldGUuXG4gICAqXG4gICAqIFBhcmFtZXRlcnM6XG4gICAqXG4gICAqICAgZGVmYXVsdFZhbHVlIC0gdGhlIHZhbHVlIHRoYXQgaXMgcmV0dXJuZWQgZm9yIGFsbCBrZXlzIHRoYXQgZG9uJ3QgZXhpc3RcbiAgICogICAgICAgICAgICAgICAgICBpbiB0aGUgY2FjaGVcbiAgICovXG4gIGZ1bmN0aW9uIExvd2VyQ2FzZUNhY2hlKGRlZmF1bHRWYWx1ZSl7XG4gICAgdGhpcy5kZWZhdWx0VmFsdWUgPSBkZWZhdWx0VmFsdWU7XG4gICAgdGhpcy5fc3RvcmFnZSA9IHsgfTtcbiAgICB0aGlzLnNldCA9IHRoaXMuanVzdFNldDtcbiAgICB0aGlzLmRlbGV0ZSA9IHRoaXMuanVzdERlbGV0ZTtcbiAgfVxuXG4gIExvd2VyQ2FzZUNhY2hlLnByb3RvdHlwZSA9IHtcbiAgICAvKipcbiAgICAgKiBNZXRob2Q6IGdldFxuICAgICAqXG4gICAgICogR2V0IGEgdmFsdWUgZnJvbSB0aGUgY2FjaGUgb3IgZGVmYXVsdFZhbHVlLCBpZiB0aGUga2V5IGlzIG5vdCBpbiB0aGVcbiAgICAgKiBjYWNoZS5cbiAgICAgKi9cbiAgICBnZXQgOiBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICBrZXkgPSBrZXkudG9Mb3dlckNhc2UoKTtcbiAgICAgIHZhciBzdG9yZWQgPSB0aGlzLl9zdG9yYWdlW2tleV07XG4gICAgICBpZiAodHlwZW9mIHN0b3JlZCA9PT0gJ3VuZGVmaW5lZCcpe1xuICAgICAgICBzdG9yZWQgPSB0aGlzLmRlZmF1bHRWYWx1ZTtcbiAgICAgICAgdGhpcy5fc3RvcmFnZVtrZXldID0gc3RvcmVkO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHN0b3JlZDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTWV0aG9kOiBwcm9wYWdhdGVTZXRcbiAgICAgKlxuICAgICAqIFNldCBhIHZhbHVlIGFuZCBhbHNvIHVwZGF0ZSB0aGUgcGFyZW50IGZvbGRlcnMgd2l0aCB0aGF0IHZhbHVlLlxuICAgICAqL1xuICAgIHByb3BhZ2F0ZVNldCA6IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gICAgICBrZXkgPSBrZXkudG9Mb3dlckNhc2UoKTtcbiAgICAgIGlmICh0aGlzLl9zdG9yYWdlW2tleV0gPT09IHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX3Byb3BhZ2F0ZShrZXksIHZhbHVlKTtcbiAgICAgIHRoaXMuX3N0b3JhZ2Vba2V5XSA9IHZhbHVlO1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNZXRob2Q6IHByb3BhZ2F0ZURlbGV0ZVxuICAgICAqXG4gICAgICogRGVsZXRlIGEgdmFsdWUgYW5kIHByb3BhZ2F0ZSB0aGUgY2hhbmdlcyB0byB0aGUgcGFyZW50IGZvbGRlcnMuXG4gICAgICovXG4gICAgcHJvcGFnYXRlRGVsZXRlIDogZnVuY3Rpb24gKGtleSkge1xuICAgICAga2V5ID0ga2V5LnRvTG93ZXJDYXNlKCk7XG4gICAgICB0aGlzLl9wcm9wYWdhdGUoa2V5LCB0aGlzLl9zdG9yYWdlW2tleV0pO1xuICAgICAgcmV0dXJuIGRlbGV0ZSB0aGlzLl9zdG9yYWdlW2tleV07XG4gICAgfSxcblxuICAgIF9hY3RpdmF0ZVByb3BhZ2F0aW9uOiBmdW5jdGlvbiAoKXtcbiAgICAgIHRoaXMuc2V0ID0gdGhpcy5wcm9wYWdhdGVTZXQ7XG4gICAgICB0aGlzLmRlbGV0ZSA9IHRoaXMucHJvcGFnYXRlRGVsZXRlO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1ldGhvZDoganVzdFNldFxuICAgICAqXG4gICAgICogU2V0IGEgdmFsdWUgd2l0aG91dCBwcm9wYWdhdGluZy5cbiAgICAgKi9cbiAgICBqdXN0U2V0IDogZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgICAgIGtleSA9IGtleS50b0xvd2VyQ2FzZSgpO1xuICAgICAgdGhpcy5fc3RvcmFnZVtrZXldID0gdmFsdWU7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1ldGhvZDoganVzdERlbGV0ZVxuICAgICAqXG4gICAgICogRGVsZXRlIGEgdmFsdWUgd2l0aG91dCBwcm9wYWdhdGluZy5cbiAgICAgKi9cbiAgICBqdXN0RGVsZXRlIDogZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgICAgIGtleSA9IGtleS50b0xvd2VyQ2FzZSgpO1xuICAgICAgcmV0dXJuIGRlbGV0ZSB0aGlzLl9zdG9yYWdlW2tleV07XG4gICAgfSxcblxuICAgIF9wcm9wYWdhdGU6IGZ1bmN0aW9uIChrZXksIHJldil7XG4gICAgICB2YXIgZm9sZGVycyA9IGtleS5zcGxpdCgnLycpLnNsaWNlKDAsLTEpO1xuICAgICAgdmFyIHBhdGggPSAnJztcblxuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGZvbGRlcnMubGVuZ3RoOyBpIDwgbGVuOyBpKyspe1xuICAgICAgICBwYXRoICs9IGZvbGRlcnNbaV0rJy8nO1xuICAgICAgICBpZiAoIXJldikge1xuICAgICAgICAgIHJldiA9IHRoaXMuX3N0b3JhZ2VbcGF0aF0rMTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9zdG9yYWdlW3BhdGhdID0gIHJldjtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgdmFyIG9uRXJyb3JDYjtcblxuICAvKipcbiAgICogQ2xhc3M6IERyb3Bib3hcbiAgICovXG4gIHZhciBEcm9wYm94ID0gZnVuY3Rpb24gKHJzKSB7XG5cbiAgICB0aGlzLnJzID0gcnM7XG4gICAgdGhpcy5jb25uZWN0ZWQgPSBmYWxzZTtcbiAgICB0aGlzLnJzID0gcnM7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgb25FcnJvckNiID0gZnVuY3Rpb24gKGVycm9yKXtcbiAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEF1dGhvcml6ZS5VbmF1dGhvcml6ZWQpIHtcbiAgICAgICAgLy8gRGVsZXRlIGFsbCB0aGUgc2V0dGluZ3MgLSBzZWUgdGhlIGRvY3VtZW50YXRpb24gb2Ygd2lyZWNsaWVudC5jb25maWd1cmVcbiAgICAgICAgc2VsZi5jb25maWd1cmUoe1xuICAgICAgICAgIHVzZXJBZGRyZXNzOiBudWxsLFxuICAgICAgICAgIGhyZWY6IG51bGwsXG4gICAgICAgICAgc3RvcmFnZUFwaTogbnVsbCxcbiAgICAgICAgICB0b2tlbjogbnVsbCxcbiAgICAgICAgICBvcHRpb25zOiBudWxsXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBldmVudEhhbmRsaW5nKHRoaXMsICdjaGFuZ2UnLCAnY29ubmVjdGVkJywgJ3dpcmUtYnVzeScsICd3aXJlLWRvbmUnLCAnbm90LWNvbm5lY3RlZCcpO1xuICAgIHJzLm9uKCdlcnJvcicsIG9uRXJyb3JDYik7XG5cbiAgICB0aGlzLmNsaWVudElkID0gcnMuYXBpS2V5cy5kcm9wYm94LmFwcEtleTtcbiAgICB0aGlzLl9yZXZDYWNoZSA9IG5ldyBMb3dlckNhc2VDYWNoZSgncmV2Jyk7XG4gICAgdGhpcy5faXRlbVJlZnMgPSB7fTtcbiAgICB0aGlzLl9tZXRhZGF0YUNhY2hlID0ge307XG5cbiAgICBoYXNMb2NhbFN0b3JhZ2UgPSB1dGlsLmxvY2FsU3RvcmFnZUF2YWlsYWJsZSgpO1xuXG4gICAgaWYgKGhhc0xvY2FsU3RvcmFnZSl7XG4gICAgICB2YXIgc2V0dGluZ3M7XG4gICAgICB0cnkge1xuICAgICAgICBzZXR0aW5ncyA9IEpTT04ucGFyc2UobG9jYWxTdG9yYWdlLmdldEl0ZW0oU0VUVElOR1NfS0VZKSk7XG4gICAgICB9IGNhdGNoKGUpe31cbiAgICAgIGlmIChzZXR0aW5ncykge1xuICAgICAgICB0aGlzLmNvbmZpZ3VyZShzZXR0aW5ncyk7XG4gICAgICB9XG4gICAgICB0cnkge1xuICAgICAgICB0aGlzLl9pdGVtUmVmcyA9IEpTT04ucGFyc2UobG9jYWxTdG9yYWdlLmdldEl0ZW0oU0VUVElOR1NfS0VZKyc6c2hhcmVzJykpO1xuICAgICAgfSBjYXRjaChlKSB7ICB9XG4gICAgfVxuICAgIGlmICh0aGlzLmNvbm5lY3RlZCkge1xuICAgICAgc2V0VGltZW91dCh0aGlzLl9lbWl0LmJpbmQodGhpcyksIDAsICdjb25uZWN0ZWQnKTtcbiAgICB9XG4gIH07XG5cbiAgRHJvcGJveC5wcm90b3R5cGUgPSB7XG4gICAgb25saW5lOiB0cnVlLFxuXG4gICAgLyoqXG4gICAgICogTWV0aG9kOiBjb25uZWN0XG4gICAgICpcbiAgICAgKiBTZXQgdGhlIGJhY2tlZCB0byAnZHJvcGJveCcgYW5kIHN0YXJ0IHRoZSBhdXRoZW50aWNhdGlvbiBmbG93IGluIG9yZGVyXG4gICAgICogdG8gb2J0YWluIGFuIEFQSSB0b2tlbiBmcm9tIERyb3Bib3guXG4gICAgICovXG4gICAgY29ubmVjdDogZnVuY3Rpb24gKCkge1xuICAgICAgLy8gVE9ETyBoYW5kbGluZyB3aGVuIHRva2VuIGlzIGFscmVhZHkgcHJlc2VudFxuICAgICAgdGhpcy5ycy5zZXRCYWNrZW5kKCdkcm9wYm94Jyk7XG4gICAgICBpZiAodGhpcy50b2tlbil7XG4gICAgICAgIGhvb2tJdCh0aGlzLnJzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIEF1dGhvcml6ZSh0aGlzLnJzLCBBVVRIX1VSTCwgJycsIFN0cmluZyhBdXRob3JpemUuZ2V0TG9jYXRpb24oKSksIHRoaXMuY2xpZW50SWQpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNZXRob2QgOiBjb25maWd1cmUoc2V0dGluZ3MpXG4gICAgICogQWNjZXB0cyBpdHMgcGFyYW1ldGVycyBhY2NvcmRpbmcgdG8gdGhlIDxXaXJlQ2xpZW50Pi5cbiAgICAgKiBTZXRzIHRoZSBjb25uZWN0ZWQgZmxhZ1xuICAgICAqKi9cbiAgICBjb25maWd1cmU6IGZ1bmN0aW9uIChzZXR0aW5ncykge1xuICAgICAgLy8gV2Ugb25seSB1cGRhdGUgdGhpcy51c2VyQWRkcmVzcyBpZiBzZXR0aW5ncy51c2VyQWRkcmVzcyBpcyBzZXQgdG8gYSBzdHJpbmcgb3IgdG8gbnVsbDpcbiAgICAgIGlmICh0eXBlb2Ygc2V0dGluZ3MudXNlckFkZHJlc3MgIT09ICd1bmRlZmluZWQnKSB7IHRoaXMudXNlckFkZHJlc3MgPSBzZXR0aW5ncy51c2VyQWRkcmVzczsgfVxuICAgICAgLy8gU2FtZSBmb3IgdGhpcy50b2tlbi4gSWYgb25seSBvbmUgb2YgdGhlc2UgdHdvIGlzIHNldCwgd2UgbGVhdmUgdGhlIG90aGVyIG9uZSBhdCBpdHMgZXhpc3RpbmcgdmFsdWU6XG4gICAgICBpZiAodHlwZW9mIHNldHRpbmdzLnRva2VuICE9PSAndW5kZWZpbmVkJykgeyB0aGlzLnRva2VuID0gc2V0dGluZ3MudG9rZW47IH1cblxuICAgICAgdmFyIHdyaXRlU2V0dGluZ3NUb0NhY2hlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmIChoYXNMb2NhbFN0b3JhZ2UpIHtcbiAgICAgICAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbShTRVRUSU5HU19LRVksIEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICAgIHVzZXJBZGRyZXNzOiB0aGlzLnVzZXJBZGRyZXNzLFxuICAgICAgICAgICAgdG9rZW46IHRoaXMudG9rZW5cbiAgICAgICAgICB9KSk7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIHZhciBoYW5kbGVFcnJvciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLmNvbm5lY3RlZCA9IGZhbHNlO1xuICAgICAgICBpZiAoaGFzTG9jYWxTdG9yYWdlKSB7XG4gICAgICAgICAgbG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0oU0VUVElOR1NfS0VZKTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgaWYgKHRoaXMudG9rZW4pIHtcbiAgICAgICAgdGhpcy5jb25uZWN0ZWQgPSB0cnVlO1xuICAgICAgICBpZiAodGhpcy51c2VyQWRkcmVzcykge1xuICAgICAgICAgIHRoaXMuX2VtaXQoJ2Nvbm5lY3RlZCcpO1xuICAgICAgICAgIHdyaXRlU2V0dGluZ3NUb0NhY2hlLmFwcGx5KHRoaXMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuaW5mbygpLnRoZW4oZnVuY3Rpb24gKGluZm8pe1xuICAgICAgICAgICAgdGhpcy51c2VyQWRkcmVzcyA9IGluZm8uZW1haWw7XG4gICAgICAgICAgICB0aGlzLl9lbWl0KCdjb25uZWN0ZWQnKTtcbiAgICAgICAgICAgIHdyaXRlU2V0dGluZ3NUb0NhY2hlLmFwcGx5KHRoaXMpO1xuICAgICAgICAgIH0uYmluZCh0aGlzKSkuY2F0Y2goZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBoYW5kbGVFcnJvci5hcHBseSh0aGlzKTtcbiAgICAgICAgICAgIHRoaXMucnMuX2VtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCdDb3VsZCBub3QgZmV0Y2ggdXNlciBpbmZvLicpKTtcbiAgICAgICAgICB9LmJpbmQodGhpcykpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBoYW5kbGVFcnJvci5hcHBseSh0aGlzKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTWV0aG9kOiBzdG9wV2FpdGluZ0ZvclRva2VuXG4gICAgICpcbiAgICAgKiBTdG9wIHdhaXRpbmcgZm9yIHRoZSB0b2tlbiBhbmQgZW1pdCBub3QtY29ubmVjdGVkXG4gICAgICovXG4gICAgc3RvcFdhaXRpbmdGb3JUb2tlbjogZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKCF0aGlzLmNvbm5lY3RlZCkge1xuICAgICAgICB0aGlzLl9lbWl0KCdub3QtY29ubmVjdGVkJyk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1ldGhvZDogX2dldEZvbGRlclxuICAgICAqXG4gICAgICogR2V0IGFsbCBpdGVtcyBpbiBhIGZvbGRlci5cbiAgICAgKlxuICAgICAqIFBhcmFtZXRlcnM6XG4gICAgICpcbiAgICAgKiAgIHBhdGggLSBwYXRoIG9mIHRoZSBmb2xkZXIgdG8gZ2V0LCB3aXRoIGxlYWRpbmcgc2xhc2hcbiAgICAgKiAgIG9wdGlvbnMgLSBub3QgdXNlZFxuICAgICAqXG4gICAgICogUmV0dXJuczpcbiAgICAgKlxuICAgICAqICBzdGF0dXNDb2RlIC0gSFRUUCBzdGF0dXMgY29kZVxuICAgICAqICBib2R5IC0gYXJyYXkgb2YgdGhlIGl0ZW1zIGZvdW5kXG4gICAgICogIGNvbnRlbnRUeXBlIC0gJ2FwcGxpY2F0aW9uL2pzb247IGNoYXJzZXQ9VVRGLTgnXG4gICAgICogIHJldmlzaW9uIC0gcmV2aXNpb24gb2YgdGhlIGZvbGRlclxuICAgICAqL1xuICAgIF9nZXRGb2xkZXI6IGZ1bmN0aW9uIChwYXRoLCBvcHRpb25zKSB7XG4gICAgICAvLyBGSVhNRSBzaW1wbGlmeSBwcm9taXNlIGhhbmRsaW5nXG4gICAgICB2YXIgdXJsID0gJ2h0dHBzOi8vYXBpLmRyb3Bib3guY29tLzEvbWV0YWRhdGEvYXV0bycgKyBnZXREcm9wYm94UGF0aChwYXRoKTtcbiAgICAgIHZhciByZXZDYWNoZSA9IHRoaXMuX3JldkNhY2hlO1xuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgICByZXR1cm4gdGhpcy5fcmVxdWVzdCgnR0VUJywgdXJsLCB7fSkudGhlbihmdW5jdGlvbiAocmVzcCkge1xuICAgICAgICB2YXIgc3RhdHVzID0gcmVzcC5zdGF0dXM7XG4gICAgICAgIGlmIChzdGF0dXMgPT09IDMwNCkge1xuICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoe3N0YXR1c0NvZGU6IHN0YXR1c30pO1xuICAgICAgICB9XG4gICAgICAgIHZhciBsaXN0aW5nLCBib2R5LCBtaW1lLCByZXY7XG4gICAgICAgIHRyeXtcbiAgICAgICAgICBib2R5ID0gSlNPTi5wYXJzZShyZXNwLnJlc3BvbnNlVGV4dCk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV2ID0gc2VsZi5fcmV2Q2FjaGUuZ2V0KHBhdGgpO1xuICAgICAgICBtaW1lID0gJ2FwcGxpY2F0aW9uL2pzb247IGNoYXJzZXQ9VVRGLTgnO1xuICAgICAgICBpZiAoYm9keS5jb250ZW50cykge1xuICAgICAgICAgIGxpc3RpbmcgPSBib2R5LmNvbnRlbnRzLnJlZHVjZShmdW5jdGlvbiAobSwgaXRlbSkge1xuICAgICAgICAgICAgdmFyIGl0ZW1OYW1lID0gaXRlbS5wYXRoLnNwbGl0KCcvJykuc2xpY2UoLTEpWzBdICsgKCBpdGVtLmlzX2RpciA/ICcvJyA6ICcnICk7XG4gICAgICAgICAgICBpZiAoaXRlbS5pc19kaXIpe1xuICAgICAgICAgICAgICBtW2l0ZW1OYW1lXSA9IHsgRVRhZzogcmV2Q2FjaGUuZ2V0KHBhdGgraXRlbU5hbWUpIH07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBtW2l0ZW1OYW1lXSA9IHsgRVRhZzogaXRlbS5yZXYgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBtO1xuICAgICAgICAgIH0sIHt9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHtzdGF0dXNDb2RlOiBzdGF0dXMsIGJvZHk6IGxpc3RpbmcsIGNvbnRlbnRUeXBlOiBtaW1lLCByZXZpc2lvbjogcmV2fSk7XG4gICAgICB9KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTWV0aG9kOiBnZXRcbiAgICAgKlxuICAgICAqIENvbXBhdGlibGUgd2l0aCA8V2lyZUNsaWVudC5nZXQ+XG4gICAgICpcbiAgICAgKiBDaGVja3MgZm9yIHRoZSBwYXRoIGluIF9yZXZDYWNoZSBhbmQgZGVjaWRlcyBiYXNlZCBvbiB0aGF0IGlmIGZpbGUgaGFzXG4gICAgICogY2hhbmdlZC4gQ2FsbHMgX2dldEZvbGRlciBpcyB0aGUgcGF0aCBwb2ludHMgdG8gYSBmb2xkZXIuXG4gICAgICpcbiAgICAgKiBDYWxscyA8RHJvcGJveC5zaGFyZT4gYWZ0ZXJ3YXJkcyB0byBmaWxsIF9pdGVtUmVmcy5cbiAgICAgKi9cbiAgICBnZXQ6IGZ1bmN0aW9uIChwYXRoLCBvcHRpb25zKSB7XG4gICAgICBpZiAoISB0aGlzLmNvbm5lY3RlZCkgeyByZXR1cm4gUHJvbWlzZS5yZWplY3QoXCJub3QgY29ubmVjdGVkIChwYXRoOiBcIiArIHBhdGggKyBcIilcIik7IH1cbiAgICAgIHZhciB1cmwgPSAnaHR0cHM6Ly9hcGktY29udGVudC5kcm9wYm94LmNvbS8xL2ZpbGVzL2F1dG8nICsgZ2V0RHJvcGJveFBhdGgocGF0aCk7XG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAgIHZhciBzYXZlZFJldiA9IHRoaXMuX3JldkNhY2hlLmdldChwYXRoKTtcbiAgICAgIGlmIChzYXZlZFJldiA9PT0gbnVsbCkge1xuICAgICAgICAvLyBmaWxlIHdhcyBkZWxldGVkIHNlcnZlciBzaWRlXG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoe3N0YXR1c0NvZGU6IDQwNH0pO1xuICAgICAgfVxuICAgICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5pZk5vbmVNYXRjaCAmJlxuICAgICAgICAgc2F2ZWRSZXYgJiYgKHNhdmVkUmV2ID09PSBvcHRpb25zLmlmTm9uZU1hdGNoKSkge1xuICAgICAgICAvLyBub3RoaW5nIGNoYW5nZWQuXG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoe3N0YXR1c0NvZGU6IDMwNH0pO1xuICAgICAgfVxuXG4gICAgICAvL3VzZSBfZ2V0Rm9sZGVyIGZvciBmb2xkZXJzXG4gICAgICBpZiAocGF0aC5zdWJzdHIoLTEpID09PSAnLycpIHsgcmV0dXJuIHRoaXMuX2dldEZvbGRlcihwYXRoLCBvcHRpb25zKTsgfVxuXG4gICAgICByZXR1cm4gdGhpcy5fcmVxdWVzdCgnR0VUJywgdXJsLCB7fSkudGhlbihmdW5jdGlvbiAocmVzcCkge1xuICAgICAgICB2YXIgc3RhdHVzID0gcmVzcC5zdGF0dXM7XG4gICAgICAgIHZhciBtZXRhLCBib2R5LCBtaW1lLCByZXY7XG4gICAgICAgIGlmIChzdGF0dXMgIT09IDIwMCkge1xuICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoe3N0YXR1c0NvZGU6IHN0YXR1c30pO1xuICAgICAgICB9XG5cbiAgICAgICAgYm9keSA9IHJlc3AucmVzcG9uc2VUZXh0O1xuICAgICAgICB0cnkge1xuICAgICAgICAgIG1ldGEgPSBKU09OLnBhcnNlKCByZXNwLmdldFJlc3BvbnNlSGVhZGVyKCd4LWRyb3Bib3gtbWV0YWRhdGEnKSApO1xuICAgICAgICB9IGNhdGNoKGUpIHtcbiAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZSk7XG4gICAgICAgIH1cblxuICAgICAgICBtaW1lID0gbWV0YS5taW1lX3R5cGU7IC8vcmVzcC5nZXRSZXNwb25zZUhlYWRlcignQ29udGVudC1UeXBlJyk7XG4gICAgICAgIHJldiA9IG1ldGEucmV2O1xuICAgICAgICBzZWxmLl9yZXZDYWNoZS5zZXQocGF0aCwgcmV2KTtcbiAgICAgICAgc2VsZi5fc2hhcmVJZk5lZWRlZChwYXRoKTsgLy8gVGhlIHNoYXJlZCBsaW5rIGV4cGlyZXMgZXZlcnkgNCBob3Vyc1xuXG4gICAgICAgIC8vIGhhbmRsaW5nIGJpbmFyeVxuICAgICAgICBpZiAoIXJlc3AuZ2V0UmVzcG9uc2VIZWFkZXIoJ0NvbnRlbnQtVHlwZScpIHx8XG4gICAgICAgICAgICByZXNwLmdldFJlc3BvbnNlSGVhZGVyKCdDb250ZW50LVR5cGUnKS5tYXRjaCgvY2hhcnNldD1iaW5hcnkvKSkge1xuXG4gICAgICAgICAgLy8gVE9GSVg6IHdvdWxkIGJlIGJldHRlciB0byBtYWtlIHJlYWRCaW5hcnlEYXRhIHJldHVybiBhIFByb21pc2UgLSBsZXNcbiAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoIChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIFdpcmVDbGllbnQucmVhZEJpbmFyeURhdGEocmVzcC5yZXNwb25zZSwgbWltZSwgZnVuY3Rpb24gKHJlc3VsdCkge1xuICAgICAgICAgICAgICByZXNvbHZlKHtcbiAgICAgICAgICAgICAgICBzdGF0dXNDb2RlOiBzdGF0dXMsXG4gICAgICAgICAgICAgICAgYm9keTogcmVzdWx0LFxuICAgICAgICAgICAgICAgIGNvbnRlbnRUeXBlOiBtaW1lLFxuICAgICAgICAgICAgICAgIHJldmlzaW9uOiByZXZcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gaGFuZGxpbmcganNvbiAoYWx3YXlzIHRyeSlcbiAgICAgICAgLy8gY29tbWVudCBpdCBvdXQgYXMgdGhpcyBpcyBhbHdheXMgdHJ1ZSAoZmFsc2UgJiYgZmFsc2UgfHwgdHJ1ZSlcbiAgICAgICAgLy8gYW5kIGpzaGludCBpcyBjb21wbGFpbmluZ1xuICAgICAgICAvLyBpZiAobWltZSAmJiBtaW1lLnNlYXJjaCgnYXBwbGljYXRpb24vanNvbicpID49IDAgfHwgdHJ1ZSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGJvZHkgPSBKU09OLnBhcnNlKGJvZHkpO1xuICAgICAgICAgIG1pbWUgPSAnYXBwbGljYXRpb24vanNvbjsgY2hhcnNldD1VVEYtOCc7XG4gICAgICAgIH0gY2F0Y2goZSkge1xuICAgICAgICAgIC8vRmFpbGVkIHBhcnNpbmcgSnNvbiwgYXNzdW1lIGl0IGlzIHNvbWV0aGluZyBlbHNlIHRoZW5cbiAgICAgICAgfVxuICAgICAgICAvLyB9XG5cbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh7c3RhdHVzQ29kZTogc3RhdHVzLCBib2R5OiBib2R5LCBjb250ZW50VHlwZTogbWltZSwgcmV2aXNpb246IHJldn0pO1xuICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1ldGhvZDogcHV0XG4gICAgICpcbiAgICAgKiBDb21wYXRpYmxlIHdpdGggPFdpcmVDbGllbnQ+XG4gICAgICpcbiAgICAgKiBDaGVja3MgZm9yIHRoZSBwYXRoIGluIF9yZXZDYWNoZSBhbmQgZGVjaWRlcyBiYXNlZCBvbiB0aGF0IGlmIGZpbGUgaGFzXG4gICAgICogY2hhbmdlZC5cbiAgICAgKlxuICAgICAqIENhbGxzIDxEcm9wYm94LnNoYXJlPiBhZnRlcndhcmRzIHRvIGZpbGwgX2l0ZW1SZWZzLlxuICAgICAqL1xuICAgIHB1dDogZnVuY3Rpb24gKHBhdGgsIGJvZHksIGNvbnRlbnRUeXBlLCBvcHRpb25zKSB7XG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAgIGlmICghdGhpcy5jb25uZWN0ZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibm90IGNvbm5lY3RlZCAocGF0aDogXCIgKyBwYXRoICsgXCIpXCIpO1xuICAgICAgfVxuXG4gICAgICAvL2NoZWNrIGlmIGZpbGUgaGFzIGNoYW5nZWQgYW5kIHJldHVybiA0MTJcbiAgICAgIHZhciBzYXZlZFJldiA9IHRoaXMuX3JldkNhY2hlLmdldChwYXRoKTtcbiAgICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMuaWZNYXRjaCAmJlxuICAgICAgICAgIHNhdmVkUmV2ICYmIChzYXZlZFJldiAhPT0gb3B0aW9ucy5pZk1hdGNoKSkge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHtzdGF0dXNDb2RlOiA0MTIsIHJldmlzaW9uOiBzYXZlZFJldn0pO1xuICAgICAgfVxuICAgICAgaWYgKG9wdGlvbnMgJiYgKG9wdGlvbnMuaWZOb25lTWF0Y2ggPT09ICcqJykgJiZcbiAgICAgICAgICBzYXZlZFJldiAmJiAoc2F2ZWRSZXYgIT09ICdyZXYnKSkge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHtzdGF0dXNDb2RlOiA0MTIsIHJldmlzaW9uOiBzYXZlZFJldn0pO1xuICAgICAgfVxuXG4gICAgICBpZiAoKCFjb250ZW50VHlwZS5tYXRjaCgvY2hhcnNldD0vKSkgJiZcbiAgICAgICAgICAoYm9keSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyIHx8IFdpcmVDbGllbnQuaXNBcnJheUJ1ZmZlclZpZXcoYm9keSkpKSB7XG4gICAgICAgIGNvbnRlbnRUeXBlICs9ICc7IGNoYXJzZXQ9YmluYXJ5JztcbiAgICAgIH1cblxuICAgICAgaWYgKGJvZHkubGVuZ3RoID4gMTUwICogMTAyNCAqIDEwMjQpIHtcbiAgICAgICAgLy9odHRwczovL3d3dy5kcm9wYm94LmNvbS9kZXZlbG9wZXJzL2NvcmUvZG9jcyNjaHVua2VkLXVwbG9hZFxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKFwiQ2Fubm90IHVwbG9hZCBmaWxlIGxhcmdlciB0aGFuIDE1ME1CXCIpKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHJlc3VsdDtcbiAgICAgIHZhciBuZWVkc01ldGFkYXRhID0gb3B0aW9ucyAmJiAob3B0aW9ucy5pZk1hdGNoIHx8IChvcHRpb25zLmlmTm9uZU1hdGNoID09PSAnKicpKTtcbiAgICAgIHZhciB1cGxvYWRQYXJhbXMgPSB7XG4gICAgICAgIGJvZHk6IGJvZHksXG4gICAgICAgIGNvbnRlbnRUeXBlOiBjb250ZW50VHlwZSxcbiAgICAgICAgcGF0aDogcGF0aFxuICAgICAgfTtcblxuICAgICAgaWYgKG5lZWRzTWV0YWRhdGEpIHtcbiAgICAgICAgcmVzdWx0ID0gdGhpcy5fZ2V0TWV0YWRhdGEocGF0aCkudGhlbihmdW5jdGlvbiAobWV0YWRhdGEpIHtcbiAgICAgICAgICBpZiAob3B0aW9ucyAmJiAob3B0aW9ucy5pZk5vbmVNYXRjaCA9PT0gJyonKSAmJiBtZXRhZGF0YSkge1xuICAgICAgICAgICAgLy8gaWYgISFtZXRhZGF0YSA9PT0gdHJ1ZSwgdGhlIGZpbGUgZXhpc3RzXG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHtcbiAgICAgICAgICAgICAgc3RhdHVzQ29kZTogNDEyLFxuICAgICAgICAgICAgICByZXZpc2lvbjogbWV0YWRhdGEucmV2XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLmlmTWF0Y2ggJiYgbWV0YWRhdGEgJiYgKG1ldGFkYXRhLnJldiAhPT0gb3B0aW9ucy5pZk1hdGNoKSkge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh7XG4gICAgICAgICAgICAgIHN0YXR1c0NvZGU6IDQxMixcbiAgICAgICAgICAgICAgcmV2aXNpb246IG1ldGFkYXRhLnJldlxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHNlbGYuX3VwbG9hZFNpbXBsZSh1cGxvYWRQYXJhbXMpO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc3VsdCA9IHNlbGYuX3VwbG9hZFNpbXBsZSh1cGxvYWRQYXJhbXMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzdWx0LnRoZW4oZnVuY3Rpb24gKHJldCkge1xuICAgICAgICBzZWxmLl9zaGFyZUlmTmVlZGVkKHBhdGgpO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1ldGhvZDogZGVsZXRlXG4gICAgICpcbiAgICAgKiBDb21wYXRpYmxlIHdpdGggPFdpcmVDbGllbnQuZGVsZXRlPlxuICAgICAqXG4gICAgICogQ2hlY2tzIGZvciB0aGUgcGF0aCBpbiBfcmV2Q2FjaGUgYW5kIGRlY2lkZXMgYmFzZWQgb24gdGhhdCBpZiBmaWxlIGhhc1xuICAgICAqIGNoYW5nZWQuXG4gICAgICpcbiAgICAgKiBDYWxscyA8RHJvcGJveC5zaGFyZT4gYWZ0ZXJ3YXJkcyB0byBmaWxsIF9pdGVtUmVmcy5cbiAgICAgKi9cbiAgICAnZGVsZXRlJzogZnVuY3Rpb24gKHBhdGgsIG9wdGlvbnMpIHtcbiAgICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgICAgaWYgKCF0aGlzLmNvbm5lY3RlZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJub3QgY29ubmVjdGVkIChwYXRoOiBcIiArIHBhdGggKyBcIilcIik7XG4gICAgICB9XG5cbiAgICAgIC8vY2hlY2sgaWYgZmlsZSBoYXMgY2hhbmdlZCBhbmQgcmV0dXJuIDQxMlxuICAgICAgdmFyIHNhdmVkUmV2ID0gdGhpcy5fcmV2Q2FjaGUuZ2V0KHBhdGgpO1xuICAgICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5pZk1hdGNoICYmIHNhdmVkUmV2ICYmIChvcHRpb25zLmlmTWF0Y2ggIT09IHNhdmVkUmV2KSkge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHsgc3RhdHVzQ29kZTogNDEyLCByZXZpc2lvbjogc2F2ZWRSZXYgfSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMuaWZNYXRjaCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZ2V0TWV0YWRhdGEocGF0aCkudGhlbihmdW5jdGlvbiAobWV0YWRhdGEpIHtcbiAgICAgICAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLmlmTWF0Y2ggJiYgbWV0YWRhdGEgJiYgKG1ldGFkYXRhLnJldiAhPT0gb3B0aW9ucy5pZk1hdGNoKSkge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh7XG4gICAgICAgICAgICAgIHN0YXR1c0NvZGU6IDQxMixcbiAgICAgICAgICAgICAgcmV2aXNpb246IG1ldGFkYXRhLnJldlxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHNlbGYuX2RlbGV0ZVNpbXBsZShwYXRoKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzZWxmLl9kZWxldGVTaW1wbGUocGF0aCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1ldGhvZDogX3NoYXJlSWZOZWVkZWRcbiAgICAgKlxuICAgICAqIENhbGxzIHNoYXJlLCBpZiB0aGUgcHJvdmlkZWQgcGF0aCByZXNpZGVzIGluIGEgcHVibGljIGZvbGRlci5cbiAgICAgKi9cbiAgICBfc2hhcmVJZk5lZWRlZDogZnVuY3Rpb24gKHBhdGgpIHtcbiAgICAgIGlmIChwYXRoLm1hdGNoKC9eXFwvcHVibGljXFwvLipbXlxcL10kLykgJiYgdGhpcy5faXRlbVJlZnNbcGF0aF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLnNoYXJlKHBhdGgpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNZXRob2Q6IHNoYXJlXG4gICAgICpcbiAgICAgKiBHZXRzIGEgcHVibGljbHktYWNjZXNzaWJsZSBVUkwgZm9yIHRoZSBwYXRoIGZyb20gRHJvcGJveCBhbmQgc3RvcmVzIGl0XG4gICAgICogaW4gX2l0ZW1SZWZzLlxuICAgICAqXG4gICAgICogUmV0dXJuczpcbiAgICAgKlxuICAgICAqICAgQSBwcm9taXNlIGZvciB0aGUgVVJMXG4gICAgICovXG4gICAgc2hhcmU6IGZ1bmN0aW9uIChwYXRoKSB7XG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICB2YXIgdXJsID0gJ2h0dHBzOi8vYXBpLmRyb3Bib3guY29tLzEvbWVkaWEvYXV0bycgKyBnZXREcm9wYm94UGF0aChwYXRoKTtcblxuICAgICAgcmV0dXJuIHRoaXMuX3JlcXVlc3QoJ1BPU1QnLCB1cmwsIHt9KS50aGVuKGZ1bmN0aW9uIChyZXNwb25zZSkge1xuICAgICAgICBpZiAocmVzcG9uc2Uuc3RhdHVzICE9PSAyMDApIHtcbiAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKCdJbnZhbGlkIERyb3Bib3ggQVBJIHJlc3BvbnNlIHN0YXR1cyB3aGVuIHNoYXJpbmcgXCInICsgcGF0aCArICdcIjonICsgcmVzcG9uc2Uuc3RhdHVzKSk7XG4gICAgICAgIH1cblxuICAgICAgICB0cnkge1xuICAgICAgICAgIHJlc3BvbnNlID0gSlNPTi5wYXJzZShyZXNwb25zZS5yZXNwb25zZVRleHQpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcignSW52YWxpZCBEcm9wYm94IEFQSSByZXNwb25zZSB3aGVuIHNoYXJpbmcgXCInICsgcGF0aCArICdcIjogJyArIHJlc3BvbnNlLnJlc3BvbnNlVGV4dCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgc2VsZi5faXRlbVJlZnNbcGF0aF0gPSByZXNwb25zZS51cmw7XG5cbiAgICAgICAgaWYgKGhhc0xvY2FsU3RvcmFnZSkge1xuICAgICAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKFNFVFRJTkdTX0tFWSsnOnNoYXJlcycsIEpTT04uc3RyaW5naWZ5KHNlbGYuX2l0ZW1SZWZzKSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHVybCk7XG4gICAgICB9LCBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgZXJyLm1lc3NhZ2UgPSAnU2hhcmluZyBkcm9wYm94IGZpbGUgb3IgZm9sZGVyIChcIicgKyBwYXRoICsgJ1wiKSBmYWlsZWQuJyArIGVyci5tZXNzYWdlO1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZXJyb3IpO1xuICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1ldGhvZDogaW5mb1xuICAgICAqXG4gICAgICogRmV0Y2hlcyB0aGUgdXNlcidzIGluZm8gZnJvbSBkcm9wYm94IGFuZCByZXR1cm5zIGEgcHJvbWlzZSBmb3IgaXQuXG4gICAgICpcbiAgICAgKiBSZXR1cm5zOlxuICAgICAqXG4gICAgICogICBBIHByb21pc2UgdG8gdGhlIHVzZXIncyBpbmZvXG4gICAgICovXG4gICAgaW5mbzogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHVybCA9ICdodHRwczovL2FwaS5kcm9wYm94LmNvbS8xL2FjY291bnQvaW5mbyc7XG4gICAgICAvLyByZXF1ZXN0aW5nIHVzZXIgaW5mbyhtYWlubHkgZm9yIHVzZXJBZHJlc3MpXG4gICAgICByZXR1cm4gdGhpcy5fcmVxdWVzdCgnR0VUJywgdXJsLCB7fSkudGhlbihmdW5jdGlvbiAocmVzcCl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdmFyIGluZm8gPSBKU09OLnBhcnNlKHJlc3AucmVzcG9uc2VUZXh0KTtcbiAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGluZm8pO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGUpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTWV0aG9kOiBfcmVxdWVzdFxuICAgICAqXG4gICAgICogTWFrZSBhIEhUVFAgcmVxdWVzdC5cbiAgICAgKlxuICAgICAqIE9wdGlvbnM6XG4gICAgICpcbiAgICAgKiAgIGhlYWRlcnMgLSBhbiBvYmplY3QgY29udGFpbmluZyB0aGUgcmVxdWVzdCBoZWFkZXJzXG4gICAgICpcbiAgICAgKiBQYXJhbWV0ZXJzOlxuICAgICAqXG4gICAgICogICBtZXRob2QgLSB0aGUgbWV0aG9kIHRvIHVzZVxuICAgICAqICAgdXJsIC0gdGhlIFVSTCB0byBtYWtlIHRoZSByZXF1ZXN0IHRvXG4gICAgICogICBvcHRpb25zIC0gc2VlIGFib3ZlXG4gICAgICovXG4gICAgX3JlcXVlc3Q6IGZ1bmN0aW9uIChtZXRob2QsIHVybCwgb3B0aW9ucykge1xuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgICBpZiAoISBvcHRpb25zLmhlYWRlcnMpIHsgb3B0aW9ucy5oZWFkZXJzID0ge307IH1cbiAgICAgIG9wdGlvbnMuaGVhZGVyc1snQXV0aG9yaXphdGlvbiddID0gJ0JlYXJlciAnICsgdGhpcy50b2tlbjtcblxuICAgICAgdGhpcy5fZW1pdCgnd2lyZS1idXN5Jywge1xuICAgICAgICBtZXRob2Q6IG1ldGhvZCxcbiAgICAgICAgaXNGb2xkZXI6IGlzRm9sZGVyKHVybClcbiAgICAgIH0pO1xuXG4gICAgICByZXR1cm4gV2lyZUNsaWVudC5yZXF1ZXN0LmNhbGwodGhpcywgbWV0aG9kLCB1cmwsIG9wdGlvbnMpLnRoZW4oZnVuY3Rpb24oeGhyKSB7XG4gICAgICAgIC8vIDUwMyBtZWFucyByZXRyeSB0aGlzIGxhdGVyXG4gICAgICAgIGlmICh4aHIgJiYgeGhyLnN0YXR1cyA9PT0gNTAzKSB7XG4gICAgICAgICAgaWYgKHNlbGYub25saW5lKSB7XG4gICAgICAgICAgICBzZWxmLm9ubGluZSA9IGZhbHNlO1xuICAgICAgICAgICAgc2VsZi5ycy5fZW1pdCgnbmV0d29yay1vZmZsaW5lJyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBzZXRUaW1lb3V0KHNlbGYuX3JlcXVlc3QobWV0aG9kLCB1cmwsIG9wdGlvbnMpLCAzMjEwKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoIXNlbGYub25saW5lKSB7XG4gICAgICAgICAgICBzZWxmLm9ubGluZSA9IHRydWU7XG4gICAgICAgICAgICBzZWxmLnJzLl9lbWl0KCduZXR3b3JrLW9ubGluZScpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBzZWxmLl9lbWl0KCd3aXJlLWRvbmUnLCB7XG4gICAgICAgICAgICBtZXRob2Q6IG1ldGhvZCxcbiAgICAgICAgICAgIGlzRm9sZGVyOiBpc0ZvbGRlcih1cmwpLFxuICAgICAgICAgICAgc3VjY2VzczogdHJ1ZVxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh4aHIpO1xuICAgICAgICB9XG4gICAgICB9LCBmdW5jdGlvbihlcnJvcikge1xuICAgICAgICBpZiAoc2VsZi5vbmxpbmUpIHtcbiAgICAgICAgICBzZWxmLm9ubGluZSA9IGZhbHNlO1xuICAgICAgICAgIHNlbGYucnMuX2VtaXQoJ25ldHdvcmstb2ZmbGluZScpO1xuICAgICAgICB9XG4gICAgICAgIHNlbGYuX2VtaXQoJ3dpcmUtZG9uZScsIHtcbiAgICAgICAgICBtZXRob2Q6IG1ldGhvZCxcbiAgICAgICAgICBpc0ZvbGRlcjogaXNGb2xkZXIodXJsKSxcbiAgICAgICAgICBzdWNjZXNzOiBmYWxzZVxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZXJyb3IpO1xuICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1ldGhvZDogZmV0Y2hEZWx0YVxuICAgICAqXG4gICAgICogRmV0Y2hlcyB0aGUgcmV2aXNpb24gb2YgYWxsIHRoZSBmaWxlcyBmcm9tIGRyb3Bib3ggQVBJIGFuZCBwdXRzIHRoZW1cbiAgICAgKiBpbnRvIF9yZXZDYWNoZS4gVGhlc2UgdmFsdWVzIGNhbiB0aGVuIGJlIHVzZWQgdG8gZGV0ZXJtaW5lIGlmIHNvbWV0aGluZ1xuICAgICAqIGhhcyBjaGFuZ2VkLlxuICAgICAqL1xuICAgIGZldGNoRGVsdGE6IGZ1bmN0aW9uICgpIHtcbiAgICAgIC8vIFRPRE86IEhhbmRsZSBgaGFzX21vcmVgXG5cbiAgICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcbiAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgIHZhciBib2R5ID0geyBwYXRoX3ByZWZpeDogUEFUSF9QUkVGSVggfTtcblxuICAgICAgaWYgKHNlbGYuX2RlbHRhQ3Vyc29yKSB7XG4gICAgICAgIGJvZHkuY3Vyc29yID0gc2VsZi5fZGVsdGFDdXJzb3I7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzZWxmLl9yZXF1ZXN0KCdQT1NUJywgJ2h0dHBzOi8vYXBpLmRyb3Bib3guY29tLzEvZGVsdGEnLCB7XG4gICAgICAgIGJvZHk6IGVuY29kZVF1ZXJ5KGJvZHkpLFxuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQnXG4gICAgICAgIH1cbiAgICAgIH0pLnRoZW4oZnVuY3Rpb24gKHJlc3BvbnNlKSB7XG4gICAgICAgIC8vIGJyZWFrIGlmIHN0YXR1cyAhPSAyMDBcbiAgICAgICAgaWYgKHJlc3BvbnNlLnN0YXR1cyAhPT0gMjAwICkge1xuICAgICAgICAgIGlmIChyZXNwb25zZS5zdGF0dXMgPT09IDQwMCkge1xuICAgICAgICAgICAgc2VsZi5ycy5fZW1pdCgnZXJyb3InLCBuZXcgQXV0aG9yaXplLlVuYXV0aG9yaXplZCgpKTtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoYXJncyk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChcImRyb3Bib3guZmV0Y2hEZWx0YSByZXR1cm5lZCBcIityZXNwb25zZS5zdGF0dXMrcmVzcG9uc2UucmVzcG9uc2VUZXh0KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZGVsdGE7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgZGVsdGEgPSBKU09OLnBhcnNlKHJlc3BvbnNlLnJlc3BvbnNlVGV4dCk7XG4gICAgICAgIH0gY2F0Y2goZXJyb3IpIHtcbiAgICAgICAgICBsb2coJ2ZldGNoRGVsdGFzIGNhbiBub3QgcGFyc2UgcmVzcG9uc2UnLGVycm9yKTtcbiAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoXCJjYW4gbm90IHBhcnNlIHJlc3BvbnNlIG9mIGZldGNoRGVsdGEgOiBcIitlcnJvci5tZXNzYWdlKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBicmVhayBpZiBubyBlbnRyaWVzIGZvdW5kXG4gICAgICAgIGlmICghZGVsdGEuZW50cmllcykge1xuICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdCgnZHJvcGJveC5mZXRjaERlbHRhcyBmYWlsZWQsIG5vIGVudHJpZXMgZm91bmQnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIERyb3Bib3ggc2VuZHMgdGhlIGNvbXBsZXRlIHN0YXRlXG4gICAgICAgIGlmIChkZWx0YS5yZXNldCkge1xuICAgICAgICAgIHNlbGYuX3JldkNhY2hlID0gbmV3IExvd2VyQ2FzZUNhY2hlKCdyZXYnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vc2F2aW5nIHRoZSBjdXJzb3IgZm9yIHJlcXVlc3RpbmcgZnVydGhlciBkZWx0YXMgaW4gcmVsYXRpb24gdG8gdGhlIGN1cnNvciBwb3NpdGlvblxuICAgICAgICBpZiAoZGVsdGEuY3Vyc29yKSB7XG4gICAgICAgICAgc2VsZi5fZGVsdGFDdXJzb3IgPSBkZWx0YS5jdXJzb3I7XG4gICAgICAgIH1cblxuICAgICAgICAvL3VwZGF0aW5nIHJldkNhY2hlXG4gICAgICAgIGRlbHRhLmVudHJpZXMuZm9yRWFjaChmdW5jdGlvbiAoZW50cnkpIHtcbiAgICAgICAgICB2YXIgcGF0aCA9IGVudHJ5WzBdLnN1YnN0cihQQVRIX1BSRUZJWC5sZW5ndGgpO1xuICAgICAgICAgIHZhciByZXY7XG4gICAgICAgICAgaWYgKCFlbnRyeVsxXSl7XG4gICAgICAgICAgICByZXYgPSBudWxsO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoZW50cnlbMV0uaXNfZGlyKSB7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldiA9IGVudHJ5WzFdLnJldjtcbiAgICAgICAgICB9XG4gICAgICAgICAgc2VsZi5fcmV2Q2FjaGUuc2V0KHBhdGgsIHJldik7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGFyZ3MpO1xuICAgICAgfSwgZnVuY3Rpb24gKGVycikge1xuICAgICAgICB0aGlzLnJzLmxvZygnZmV0Y2hEZWx0YXMnLCBlcnIpO1xuICAgICAgICB0aGlzLnJzLl9lbWl0KCdlcnJvcicsIG5ldyBTeW5jLlN5bmNFcnJvcignZmV0Y2hEZWx0YXMgZmFpbGVkLicgKyBlcnIpKTtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShhcmdzKTtcbiAgICAgIH0uYmluZCh0aGlzKSkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChzZWxmLl9yZXZDYWNoZSkge1xuICAgICAgICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcbiAgICAgICAgICBzZWxmLl9yZXZDYWNoZS5fYWN0aXZhdGVQcm9wYWdhdGlvbigpO1xuICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoYXJncyk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNZXRob2Q6IF9nZXRNZXRhZGF0YVxuICAgICAqXG4gICAgICogR2V0cyBtZXRhZGF0YSBmb3IgYSBwYXRoIChjYW4gcG9pbnQgdG8gZWl0aGVyIGEgZmlsZSBvciBhIGZvbGRlcikuXG4gICAgICpcbiAgICAgKiBPcHRpb25zOlxuICAgICAqXG4gICAgICogICBsaXN0IC0gaWYgcGF0aCBwb2ludHMgdG8gYSBmb2xkZXIsIHNwZWNpZmllcyB3aGV0aGVyIHRvIGxpc3QgdGhlXG4gICAgICogICAgICAgICAgbWV0YWRhdGEgb2YgdGhlIGZvbGRlcidzIGNoaWxkcmVuLiBGYWxzZSBieSBkZWZhdWx0LlxuICAgICAqXG4gICAgICogUGFyYW1ldGVyczpcbiAgICAgKlxuICAgICAqICAgcGF0aCAtIHRoZSBwYXRoIHRvIGdldCBtZXRhZGF0YSBmb3JcbiAgICAgKiAgIG9wdGlvbnMgLSBzZWUgYWJvdmVcbiAgICAgKlxuICAgICAqIFJldHVybnM6XG4gICAgICpcbiAgICAgKiAgIEEgcHJvbWlzZSBmb3IgdGhlIG1ldGFkYXRhXG4gICAgICovXG4gICAgX2dldE1ldGFkYXRhOiBmdW5jdGlvbiAocGF0aCwgb3B0aW9ucykge1xuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgdmFyIGNhY2hlZCA9IHRoaXMuX21ldGFkYXRhQ2FjaGVbcGF0aF07XG4gICAgICB2YXIgdXJsID0gJ2h0dHBzOi8vYXBpLmRyb3Bib3guY29tLzEvbWV0YWRhdGEvYXV0bycgKyBnZXREcm9wYm94UGF0aChwYXRoKTtcbiAgICAgIHVybCArPSAnP2xpc3Q9JyArICgob3B0aW9ucyAmJiBvcHRpb25zLmxpc3QpID8gJ3RydWUnIDogJ2ZhbHNlJyk7XG4gICAgICBpZiAoY2FjaGVkICYmIGNhY2hlZC5oYXNoKSB7XG4gICAgICAgIHVybCArPSAnJmhhc2g9JyArIGVuY29kZVVSSUNvbXBvbmVudChjYWNoZWQuaGFzaCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5fcmVxdWVzdCgnR0VUJywgdXJsLCB7fSkudGhlbihmdW5jdGlvbiAocmVzcCkge1xuICAgICAgICBpZiAocmVzcC5zdGF0dXMgPT09IDMwNCkge1xuICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoY2FjaGVkKTtcbiAgICAgICAgfSBlbHNlIGlmIChyZXNwLnN0YXR1cyA9PT0gMjAwKSB7XG4gICAgICAgICAgdmFyIHJlc3BvbnNlID0gSlNPTi5wYXJzZShyZXNwLnJlc3BvbnNlVGV4dCk7XG4gICAgICAgICAgc2VsZi5fbWV0YWRhdGFDYWNoZVtwYXRoXSA9IHJlc3BvbnNlO1xuICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUocmVzcG9uc2UpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIFRoZSBmaWxlIGRvZXNuJ3QgZXhpc3RcbiAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNZXRob2Q6IF91cGxvYWRTaW1wbGVcbiAgICAgKlxuICAgICAqIFVwbG9hZCBhIHNpbXBsZSBmaWxlICh0aGUgc2l6ZSBpcyBubyBtb3JlIHRoYW4gMTUwTUIpLlxuICAgICAqXG4gICAgICogUGFyYW1ldGVyczpcbiAgICAgKlxuICAgICAqICAgaWZNYXRjaCAtIHNhbWUgYXMgZm9yIGdldFxuICAgICAqICAgcGF0aCAtIHBhdGggb2YgdGhlIGZpbGVcbiAgICAgKiAgIGJvZHkgLSBjb250ZW50cyBvZiB0aGUgZmlsZSB0byB1cGxvYWRcbiAgICAgKiAgIGNvbnRlbnRUeXBlIC0gbWltZSB0eXBlIG9mIHRoZSBmaWxlXG4gICAgICpcbiAgICAgKiBSZXR1cm5zOlxuICAgICAqXG4gICAgICogICBzdGF0dXNDb2RlIC0gSFRUUCBzdGF0dXMgY29kZVxuICAgICAqICAgcmV2aXNpb24gLSByZXZpc2lvbiBvZiB0aGUgbmV3bHktY3JlYXRlZCBmaWxlLCBpZiBhbnlcbiAgICAgKi9cbiAgICBfdXBsb2FkU2ltcGxlOiBmdW5jdGlvbiAocGFyYW1zKSB7XG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICB2YXIgdXJsID0gJ2h0dHBzOi8vYXBpLWNvbnRlbnQuZHJvcGJveC5jb20vMS9maWxlc19wdXQvYXV0bycgKyBnZXREcm9wYm94UGF0aChwYXJhbXMucGF0aCkgKyAnPyc7XG5cbiAgICAgIGlmIChwYXJhbXMgJiYgcGFyYW1zLmlmTWF0Y2gpIHtcbiAgICAgICAgdXJsICs9IFwicGFyZW50X3Jldj1cIiArIGVuY29kZVVSSUNvbXBvbmVudChwYXJhbXMuaWZNYXRjaCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzZWxmLl9yZXF1ZXN0KCdQVVQnLCB1cmwsIHtcbiAgICAgICAgYm9keTogcGFyYW1zLmJvZHksXG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAnQ29udGVudC1UeXBlJzogcGFyYW1zLmNvbnRlbnRUeXBlXG4gICAgICAgIH1cbiAgICAgIH0pLnRoZW4oZnVuY3Rpb24gKHJlc3ApIHtcbiAgICAgICAgaWYgKHJlc3Auc3RhdHVzICE9PSAyMDApIHtcbiAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHsgc3RhdHVzQ29kZTogcmVzcC5zdGF0dXMgfSk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcmVzcG9uc2U7XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXNwb25zZSA9IEpTT04ucGFyc2UocmVzcC5yZXNwb25zZVRleHQpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ29uZmxpY3QgaGFwcGVuZWQuIERlbGV0ZSB0aGUgY29weSBjcmVhdGVkIGJ5IGRyb3Bib3hcbiAgICAgICAgaWYgKHJlc3BvbnNlLnBhdGggIT09IGdldERyb3Bib3hQYXRoKHBhcmFtcy5wYXRoKSkge1xuICAgICAgICAgIHZhciBkZWxldGVVcmwgPSAnaHR0cHM6Ly9hcGkuZHJvcGJveC5jb20vMS9maWxlb3BzL2RlbGV0ZT9yb290PWF1dG8mcGF0aD0nICsgZW5jb2RlVVJJQ29tcG9uZW50KHJlc3BvbnNlLnBhdGgpO1xuICAgICAgICAgIHNlbGYuX3JlcXVlc3QoJ1BPU1QnLCBkZWxldGVVcmwsIHt9KTtcblxuICAgICAgICAgIHJldHVybiBzZWxmLl9nZXRNZXRhZGF0YShwYXJhbXMucGF0aCkudGhlbihmdW5jdGlvbiAobWV0YWRhdGEpIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoe1xuICAgICAgICAgICAgICBzdGF0dXNDb2RlOiA0MTIsXG4gICAgICAgICAgICAgIHJldmlzaW9uOiBtZXRhZGF0YS5yZXZcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgc2VsZi5fcmV2Q2FjaGUucHJvcGFnYXRlU2V0KHBhcmFtcy5wYXRoLCByZXNwb25zZS5yZXYpO1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHsgc3RhdHVzQ29kZTogcmVzcC5zdGF0dXMgfSk7XG4gICAgICB9KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTWV0aG9kOiBfZGVsZXRlU2ltcGxlXG4gICAgICpcbiAgICAgKiBEZWxldGVzIGEgZmlsZSBvciBhIGZvbGRlci4gSWYgdGhlIGZvbGRlciBjb250YWlucyBtb3JlIHRoYW4gMTAnMDAwIGl0ZW1zXG4gICAgICogKHJlY3Vyc2l2ZWx5KSB0aGVuIHRoZSBvcGVyYXRpb24gbWF5IG5vdCBjb21wbGV0ZSBzdWNjZXNzZnVsbHkuIElmIHRoYXRcbiAgICAgKiBpcyB0aGUgY2FzZSwgYW4gRXJyb3IgZ2V0cyB0aHJvd24uXG4gICAgICpcbiAgICAgKiBQYXJhbWV0ZXJzOlxuICAgICAqXG4gICAgICogICBwYXRoIC0gdGhlIHBhdGggdG8gZGVsZXRlXG4gICAgICpcbiAgICAgKiBSZXR1cm5zOlxuICAgICAqXG4gICAgICogICBzdGF0dXNDb2RlIC0gSFRUUCBzdGF0dXMgY29kZVxuICAgICAqL1xuICAgIF9kZWxldGVTaW1wbGU6IGZ1bmN0aW9uIChwYXRoKSB7XG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICB2YXIgdXJsID0gJ2h0dHBzOi8vYXBpLmRyb3Bib3guY29tLzEvZmlsZW9wcy9kZWxldGU/cm9vdD1hdXRvJnBhdGg9JyArIGVuY29kZVVSSUNvbXBvbmVudChnZXREcm9wYm94UGF0aChwYXRoKSk7XG5cbiAgICAgIHJldHVybiBzZWxmLl9yZXF1ZXN0KCdQT1NUJywgdXJsLCB7fSkudGhlbihmdW5jdGlvbiAocmVzcCkge1xuICAgICAgICBpZiAocmVzcC5zdGF0dXMgPT09IDQwNikge1xuICAgICAgICAgIC8vIFRvbyBtYW55IGZpbGVzIHdvdWxkIGJlIGludm9sdmVkIGluIHRoZSBvcGVyYXRpb24gZm9yIGl0IHRvXG4gICAgICAgICAgLy8gY29tcGxldGUgc3VjY2Vzc2Z1bGx5LlxuICAgICAgICAgIC8vIFRPRE86IEhhbmRsZSB0aGlzIHNvbWVob3dcbiAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKFwiQ2Fubm90IGRlbGV0ZSAnXCIgKyBwYXRoICsgXCInOiB0b28gbWFueSBmaWxlcyBpbnZvbHZlZFwiKSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocmVzcC5zdGF0dXMgPT09IDIwMCB8fCByZXNwLnN0YXR1cyA9PT0gNDA0KSB7XG4gICAgICAgICAgc2VsZi5fcmV2Q2FjaGUuZGVsZXRlKHBhdGgpO1xuICAgICAgICAgIGRlbGV0ZSBzZWxmLl9pdGVtUmVmc1twYXRoXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoeyBzdGF0dXNDb2RlOiByZXNwLnN0YXR1cyB9KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcblxuICAvLyBIb29raW5nIGFuZCB1bmhvb2tpbmcgdGhlIHN5bmNcblxuICBmdW5jdGlvbiBob29rU3luYyhycykge1xuICAgIGlmIChycy5fZHJvcGJveE9yaWdTeW5jKSB7IHJldHVybjsgfSAvLyBhbHJlYWR5IGhvb2tlZFxuICAgIHJzLl9kcm9wYm94T3JpZ1N5bmMgPSBycy5zeW5jLnN5bmMuYmluZChycy5zeW5jKTtcbiAgICBycy5zeW5jLnN5bmMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5kcm9wYm94LmZldGNoRGVsdGEuYXBwbHkodGhpcy5kcm9wYm94LCBhcmd1bWVudHMpLlxuICAgICAgICB0aGVuKHJzLl9kcm9wYm94T3JpZ1N5bmMsIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICBycy5fZW1pdCgnZXJyb3InLCBuZXcgU3luYy5TeW5jRXJyb3IoZXJyKSk7XG4gICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGVycik7XG4gICAgICAgIH0pO1xuICAgIH0uYmluZChycyk7XG4gIH1cblxuICBmdW5jdGlvbiB1bkhvb2tTeW5jKHJzKSB7XG4gICAgaWYgKCEgcnMuX2Ryb3Bib3hPcmlnU3luYykgeyByZXR1cm47IH0gLy8gbm90IGhvb2tlZFxuICAgIHJzLnN5bmMuc3luYyA9IHJzLl9kcm9wYm94T3JpZ1N5bmM7XG4gICAgZGVsZXRlIHJzLl9kcm9wYm94T3JpZ1N5bmM7XG4gIH1cblxuICAvLyBIb29raW5nIGFuZCB1bmhvb2tpbmcgZ2V0SXRlbVVSTFxuXG4gIGZ1bmN0aW9uIGhvb2tHZXRJdGVtVVJMKHJzKSB7XG4gICAgaWYgKHJzLl9vcmlnQmFzZUNsaWVudEdldEl0ZW1VUkwpIHsgcmV0dXJuOyB9XG4gICAgcnMuX29yaWdCYXNlQ2xpZW50R2V0SXRlbVVSTCA9IEJhc2VDbGllbnQucHJvdG90eXBlLmdldEl0ZW1VUkw7XG4gICAgQmFzZUNsaWVudC5wcm90b3R5cGUuZ2V0SXRlbVVSTCA9IGZ1bmN0aW9uIChwYXRoKXtcbiAgICAgIHZhciByZXQgPSBycy5kcm9wYm94Ll9pdGVtUmVmc1twYXRoXTtcbiAgICAgIHJldHVybiAgcmV0ID8gcmV0IDogJyc7XG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHVuSG9va0dldEl0ZW1VUkwocnMpe1xuICAgIGlmICghIHJzLl9vcmlnQmFzZUNsaWVudEdldEl0ZW1VUkwpIHsgcmV0dXJuOyB9XG4gICAgQmFzZUNsaWVudC5wcm90b3R5cGUuZ2V0SXRlbVVSTCA9IHJzLl9vcmlnQmFzZUNsaWVudEdldEl0ZW1VUkw7XG4gICAgZGVsZXRlIHJzLl9vcmlnQmFzZUNsaWVudEdldEl0ZW1VUkw7XG4gIH1cblxuICBmdW5jdGlvbiBob29rUmVtb3RlKHJzKXtcbiAgICBpZiAocnMuX29yaWdSZW1vdGUpIHsgcmV0dXJuOyB9XG4gICAgcnMuX29yaWdSZW1vdGUgPSBycy5yZW1vdGU7XG4gICAgcnMucmVtb3RlID0gcnMuZHJvcGJveDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHVuSG9va1JlbW90ZShycyl7XG4gICAgaWYgKHJzLl9vcmlnUmVtb3RlKSB7XG4gICAgICBycy5yZW1vdGUgPSBycy5fb3JpZ1JlbW90ZTtcbiAgICAgIGRlbGV0ZSBycy5fb3JpZ1JlbW90ZTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBob29rSXQocnMpe1xuICAgIGhvb2tSZW1vdGUocnMpO1xuICAgIGlmIChycy5zeW5jKSB7XG4gICAgICBob29rU3luYyhycyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHdoZW4gc3luYyBpcyBub3QgYXZhaWxhYmxlIHlldCwgd2Ugd2FpdCBmb3IgdGhlIHJlbW90ZSB0byBiZSBjb25uZWN0ZWQsXG4gICAgICAvLyBhdCB3aGljaCBwb2ludCBzeW5jIHNob3VsZCBiZSBhdmFpbGFibGUgYXMgd2VsbFxuICAgICAgcnMub24oJ2Nvbm5lY3RlZCcsIGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAocnMuc3luYykge1xuICAgICAgICAgIGhvb2tTeW5jKHJzKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIGhvb2tHZXRJdGVtVVJMKHJzKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHVuSG9va0l0KHJzKXtcbiAgICB1bkhvb2tSZW1vdGUocnMpO1xuICAgIHVuSG9va1N5bmMocnMpO1xuICAgIHVuSG9va0dldEl0ZW1VUkwocnMpO1xuICB9XG5cbiAgRHJvcGJveC5fcnNfaW5pdCA9IGZ1bmN0aW9uIChycykge1xuICAgIGhhc0xvY2FsU3RvcmFnZSA9IHV0aWwubG9jYWxTdG9yYWdlQXZhaWxhYmxlKCk7XG4gICAgaWYgKCBycy5hcGlLZXlzLmRyb3Bib3ggKSB7XG4gICAgICBycy5kcm9wYm94ID0gbmV3IERyb3Bib3gocnMpO1xuICAgIH1cbiAgICBpZiAocnMuYmFja2VuZCA9PT0gJ2Ryb3Bib3gnKSB7XG4gICAgICBob29rSXQocnMpO1xuICAgIH1cbiAgfTtcblxuICBEcm9wYm94Ll9yc19zdXBwb3J0ZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH07XG5cbiAgRHJvcGJveC5fcnNfY2xlYW51cCA9IGZ1bmN0aW9uIChycykge1xuICAgIHVuSG9va0l0KHJzKTtcbiAgICBpZiAoaGFzTG9jYWxTdG9yYWdlKXtcbiAgICAgIGxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKFNFVFRJTkdTX0tFWSk7XG4gICAgfVxuICAgIHJzLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2Vycm9yJywgb25FcnJvckNiKTtcbiAgICBycy5zZXRCYWNrZW5kKHVuZGVmaW5lZCk7XG4gIH07XG5cblxuICBtb2R1bGUuZXhwb3J0cyA9IERyb3Bib3g7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvZHJvcGJveC5qcyJdLCJzb3VyY2VSb290IjoiIn0=");
},function(module,exports,__webpack_require__){eval('\'use strict\';\n\nvar eventHandling = __webpack_require__(3);\n\nvar mode = typeof window !== \'undefined\' ? \'browser\' : \'node\',\n    env = {},\n    isBackground = false;\n\nvar Env = function Env() {\n  return env;\n};\n\nEnv.isBrowser = function () {\n  return mode === "browser";\n};\n\nEnv.isNode = function () {\n  return mode === "node";\n};\n\nEnv.goBackground = function () {\n  isBackground = true;\n  Env._emit("background");\n};\n\nEnv.goForeground = function () {\n  isBackground = false;\n  Env._emit("foreground");\n};\n\nEnv._rs_init = function (remoteStorage) {\n  eventHandling(Env, "background", "foreground");\n\n  function visibility() {\n    if (document[env.hiddenProperty]) {\n      Env.goBackground();\n    } else {\n      Env.goForeground();\n    }\n  }\n\n  if (mode === \'browser\') {\n    if (typeof document.hidden !== "undefined") {\n      env.hiddenProperty = "hidden";\n      env.visibilityChangeEvent = "visibilitychange";\n    } else if (typeof document.mozHidden !== "undefined") {\n      env.hiddenProperty = "mozHidden";\n      env.visibilityChangeEvent = "mozvisibilitychange";\n    } else if (typeof document.msHidden !== "undefined") {\n      env.hiddenProperty = "msHidden";\n      env.visibilityChangeEvent = "msvisibilitychange";\n    } else if (typeof document.webkitHidden !== "undefined") {\n      env.hiddenProperty = "webkitHidden";\n      env.visibilityChangeEvent = "webkitvisibilitychange";\n    }\n    document.addEventListener(env.visibilityChangeEvent, visibility, false);\n    visibility();\n  }\n};\n\nEnv._rs_cleanup = function (remoteStorage) {};\n\nmodule.exports = Env;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvZW52LmpzP2M5OWIiXSwibmFtZXMiOlsiZXZlbnRIYW5kbGluZyIsInJlcXVpcmUiLCJtb2RlIiwid2luZG93IiwiZW52IiwiaXNCYWNrZ3JvdW5kIiwiRW52IiwiaXNCcm93c2VyIiwiaXNOb2RlIiwiZ29CYWNrZ3JvdW5kIiwiX2VtaXQiLCJnb0ZvcmVncm91bmQiLCJfcnNfaW5pdCIsInJlbW90ZVN0b3JhZ2UiLCJ2aXNpYmlsaXR5IiwiZG9jdW1lbnQiLCJoaWRkZW5Qcm9wZXJ0eSIsImhpZGRlbiIsInZpc2liaWxpdHlDaGFuZ2VFdmVudCIsIm1vekhpZGRlbiIsIm1zSGlkZGVuIiwid2Via2l0SGlkZGVuIiwiYWRkRXZlbnRMaXN0ZW5lciIsIl9yc19jbGVhbnVwIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJtYXBwaW5ncyI6Ijs7QUFBRSxJQUFJQSxnQkFBZ0IsbUJBQUFDLENBQVEsQ0FBUixDQUFwQjs7QUFFQSxJQUFJQyxPQUFPLE9BQU9DLE1BQVAsS0FBbUIsV0FBbkIsR0FBaUMsU0FBakMsR0FBNkMsTUFBeEQ7QUFBQSxJQUNJQyxNQUFNLEVBRFY7QUFBQSxJQUVJQyxlQUFlLEtBRm5COztBQUtBLElBQUlDLE1BQU0sU0FBTkEsR0FBTSxHQUFZO0FBQ3BCLFNBQU9GLEdBQVA7QUFDRCxDQUZEOztBQUlBRSxJQUFJQyxTQUFKLEdBQWdCLFlBQVk7QUFDMUIsU0FBT0wsU0FBUyxTQUFoQjtBQUNELENBRkQ7O0FBSUFJLElBQUlFLE1BQUosR0FBYSxZQUFZO0FBQ3ZCLFNBQU9OLFNBQVMsTUFBaEI7QUFDRCxDQUZEOztBQUlBSSxJQUFJRyxZQUFKLEdBQW1CLFlBQVk7QUFDN0JKLGlCQUFlLElBQWY7QUFDQUMsTUFBSUksS0FBSixDQUFVLFlBQVY7QUFDRCxDQUhEOztBQUtBSixJQUFJSyxZQUFKLEdBQW1CLFlBQVk7QUFDN0JOLGlCQUFlLEtBQWY7QUFDQUMsTUFBSUksS0FBSixDQUFVLFlBQVY7QUFDRCxDQUhEOztBQUtBSixJQUFJTSxRQUFKLEdBQWUsVUFBVUMsYUFBVixFQUF5QjtBQUN0Q2IsZ0JBQWNNLEdBQWQsRUFBbUIsWUFBbkIsRUFBaUMsWUFBakM7O0FBRUEsV0FBU1EsVUFBVCxHQUFzQjtBQUNwQixRQUFJQyxTQUFTWCxJQUFJWSxjQUFiLENBQUosRUFBa0M7QUFDaENWLFVBQUlHLFlBQUo7QUFDRCxLQUZELE1BRU87QUFDTEgsVUFBSUssWUFBSjtBQUNEO0FBQ0Y7O0FBRUQsTUFBS1QsU0FBUyxTQUFkLEVBQXlCO0FBQ3ZCLFFBQUssT0FBT2EsU0FBU0UsTUFBaEIsS0FBNEIsV0FBakMsRUFBK0M7QUFDN0NiLFVBQUlZLGNBQUosR0FBcUIsUUFBckI7QUFDQVosVUFBSWMscUJBQUosR0FBNEIsa0JBQTVCO0FBQ0QsS0FIRCxNQUdPLElBQUssT0FBT0gsU0FBU0ksU0FBaEIsS0FBK0IsV0FBcEMsRUFBa0Q7QUFDdkRmLFVBQUlZLGNBQUosR0FBcUIsV0FBckI7QUFDQVosVUFBSWMscUJBQUosR0FBNEIscUJBQTVCO0FBQ0QsS0FITSxNQUdBLElBQUssT0FBT0gsU0FBU0ssUUFBaEIsS0FBOEIsV0FBbkMsRUFBaUQ7QUFDdERoQixVQUFJWSxjQUFKLEdBQXFCLFVBQXJCO0FBQ0FaLFVBQUljLHFCQUFKLEdBQTRCLG9CQUE1QjtBQUNELEtBSE0sTUFHQSxJQUFLLE9BQU9ILFNBQVNNLFlBQWhCLEtBQWtDLFdBQXZDLEVBQXFEO0FBQzFEakIsVUFBSVksY0FBSixHQUFxQixjQUFyQjtBQUNBWixVQUFJYyxxQkFBSixHQUE0Qix3QkFBNUI7QUFDRDtBQUNESCxhQUFTTyxnQkFBVCxDQUEwQmxCLElBQUljLHFCQUE5QixFQUFxREosVUFBckQsRUFBaUUsS0FBakU7QUFDQUE7QUFDRDtBQUNGLENBNUJEOztBQThCQVIsSUFBSWlCLFdBQUosR0FBa0IsVUFBVVYsYUFBVixFQUF5QixDQUMxQyxDQUREOztBQUlBVyxPQUFPQyxPQUFQLEdBQWlCbkIsR0FBakIiLCJmaWxlIjoiMTQuanMiLCJzb3VyY2VzQ29udGVudCI6WyIgIHZhciBldmVudEhhbmRsaW5nID0gcmVxdWlyZSgnLi9ldmVudGhhbmRsaW5nJyk7XG4gIFxuICB2YXIgbW9kZSA9IHR5cGVvZih3aW5kb3cpICE9PSAndW5kZWZpbmVkJyA/ICdicm93c2VyJyA6ICdub2RlJyxcbiAgICAgIGVudiA9IHt9LFxuICAgICAgaXNCYWNrZ3JvdW5kID0gZmFsc2U7XG5cblxuICB2YXIgRW52ID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBlbnY7XG4gIH07XG5cbiAgRW52LmlzQnJvd3NlciA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gbW9kZSA9PT0gXCJicm93c2VyXCI7XG4gIH07XG5cbiAgRW52LmlzTm9kZSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gbW9kZSA9PT0gXCJub2RlXCI7XG4gIH07XG5cbiAgRW52LmdvQmFja2dyb3VuZCA9IGZ1bmN0aW9uICgpIHtcbiAgICBpc0JhY2tncm91bmQgPSB0cnVlO1xuICAgIEVudi5fZW1pdChcImJhY2tncm91bmRcIik7XG4gIH07XG5cbiAgRW52LmdvRm9yZWdyb3VuZCA9IGZ1bmN0aW9uICgpIHtcbiAgICBpc0JhY2tncm91bmQgPSBmYWxzZTtcbiAgICBFbnYuX2VtaXQoXCJmb3JlZ3JvdW5kXCIpO1xuICB9O1xuXG4gIEVudi5fcnNfaW5pdCA9IGZ1bmN0aW9uIChyZW1vdGVTdG9yYWdlKSB7XG4gICAgZXZlbnRIYW5kbGluZyhFbnYsIFwiYmFja2dyb3VuZFwiLCBcImZvcmVncm91bmRcIik7XG5cbiAgICBmdW5jdGlvbiB2aXNpYmlsaXR5KCkge1xuICAgICAgaWYgKGRvY3VtZW50W2Vudi5oaWRkZW5Qcm9wZXJ0eV0pIHtcbiAgICAgICAgRW52LmdvQmFja2dyb3VuZCgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgRW52LmdvRm9yZWdyb3VuZCgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICggbW9kZSA9PT0gJ2Jyb3dzZXInKSB7XG4gICAgICBpZiAoIHR5cGVvZihkb2N1bWVudC5oaWRkZW4pICE9PSBcInVuZGVmaW5lZFwiICkge1xuICAgICAgICBlbnYuaGlkZGVuUHJvcGVydHkgPSBcImhpZGRlblwiO1xuICAgICAgICBlbnYudmlzaWJpbGl0eUNoYW5nZUV2ZW50ID0gXCJ2aXNpYmlsaXR5Y2hhbmdlXCI7XG4gICAgICB9IGVsc2UgaWYgKCB0eXBlb2YoZG9jdW1lbnQubW96SGlkZGVuKSAhPT0gXCJ1bmRlZmluZWRcIiApIHtcbiAgICAgICAgZW52LmhpZGRlblByb3BlcnR5ID0gXCJtb3pIaWRkZW5cIjtcbiAgICAgICAgZW52LnZpc2liaWxpdHlDaGFuZ2VFdmVudCA9IFwibW96dmlzaWJpbGl0eWNoYW5nZVwiO1xuICAgICAgfSBlbHNlIGlmICggdHlwZW9mKGRvY3VtZW50Lm1zSGlkZGVuKSAhPT0gXCJ1bmRlZmluZWRcIiApIHtcbiAgICAgICAgZW52LmhpZGRlblByb3BlcnR5ID0gXCJtc0hpZGRlblwiO1xuICAgICAgICBlbnYudmlzaWJpbGl0eUNoYW5nZUV2ZW50ID0gXCJtc3Zpc2liaWxpdHljaGFuZ2VcIjtcbiAgICAgIH0gZWxzZSBpZiAoIHR5cGVvZihkb2N1bWVudC53ZWJraXRIaWRkZW4pICE9PSBcInVuZGVmaW5lZFwiICkge1xuICAgICAgICBlbnYuaGlkZGVuUHJvcGVydHkgPSBcIndlYmtpdEhpZGRlblwiO1xuICAgICAgICBlbnYudmlzaWJpbGl0eUNoYW5nZUV2ZW50ID0gXCJ3ZWJraXR2aXNpYmlsaXR5Y2hhbmdlXCI7XG4gICAgICB9XG4gICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKGVudi52aXNpYmlsaXR5Q2hhbmdlRXZlbnQsIHZpc2liaWxpdHksIGZhbHNlKTtcbiAgICAgIHZpc2liaWxpdHkoKTtcbiAgICB9XG4gIH07XG5cbiAgRW52Ll9yc19jbGVhbnVwID0gZnVuY3Rpb24gKHJlbW90ZVN0b3JhZ2UpIHtcbiAgfTtcblxuXG4gIG1vZHVsZS5leHBvcnRzID0gRW52O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2Vudi5qcyJdLCJzb3VyY2VSb290IjoiIn0=')},function(module,exports,__webpack_require__){eval("'use strict';\n\nvar _GoogleDrive$prototyp;\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n/**\n * Class: GoogleDrive\n *\n * WORK IN PROGRESS, NOT RECOMMENDED FOR PRODUCTION USE\n *\n * To use this backend, you need to specify the app's client ID like so:\n *\n * (start code)\n *\n * remoteStorage.setApiKeys('googledrive', {\n *   clientId: 'your-client-id'\n * });\n *\n * (end code)\n *\n * An client ID can be obtained by registering your app in the Google\n * Developers Console: https://developers.google.com/drive/web/auth/web-client\n *\n * Docs: https://developers.google.com/drive/web/auth/web-client#create_a_client_id_and_client_secret\n **/\n\nvar Authorize = __webpack_require__(4);\nvar WireClient = __webpack_require__(9);\nvar eventHandling = __webpack_require__(3);\nvar util = __webpack_require__(2);\n\nvar BASE_URL = 'https://www.googleapis.com';\nvar AUTH_URL = 'https://accounts.google.com/o/oauth2/auth';\nvar AUTH_SCOPE = 'https://www.googleapis.com/auth/drive';\nvar SETTINGS_KEY = 'remotestorage:googledrive';\n\nvar GD_DIR_MIME_TYPE = 'application/vnd.google-apps.folder';\nvar RS_DIR_MIME_TYPE = 'application/json; charset=UTF-8';\n\nvar isFolder = util.isFolder;\nvar hasLocalStorage;\n\n// function buildQueryString(params) {\n//   return Object.keys(params).map(function (key) {\n//     return encodeURIComponent(key) + '=' + encodeURIComponent(params[key]);\n//   }).join('&');\n// }\n\n// function fileNameFromMeta(meta) {\n//   return encodeURIComponent(meta.title) + (meta.mimeType === GD_DIR_MIME_TYPE ? '/' : '');\n// }\n\nfunction metaTitleFromFileName(filename) {\n  if (filename.substr(-1) === '/') {\n    filename = filename.substr(0, filename.length - 1);\n  }\n  return decodeURIComponent(filename);\n}\n\nfunction parentPath(path) {\n  return path.replace(/[^\\/]+\\/?$/, '');\n}\n\nfunction baseName(path) {\n  var parts = path.split('/');\n  if (path.substr(-1) === '/') {\n    return parts[parts.length - 2] + '/';\n  } else {\n    return parts[parts.length - 1];\n  }\n}\n\nvar Cache = function Cache(maxAge) {\n  this.maxAge = maxAge;\n  this._items = {};\n};\n\nCache.prototype = {\n  get: function get(key) {\n    var item = this._items[key];\n    var now = new Date().getTime();\n    return item && item.t >= now - this.maxAge ? item.v : undefined;\n  },\n\n  set: function set(key, value) {\n    this._items[key] = {\n      v: value,\n      t: new Date().getTime()\n    };\n  }\n};\n\nvar GoogleDrive = function GoogleDrive(remoteStorage, clientId) {\n\n  eventHandling(this, 'change', 'connected', 'wire-busy', 'wire-done', 'not-connected');\n\n  this.rs = remoteStorage;\n  this.clientId = clientId;\n\n  this._fileIdCache = new Cache(60 * 5); // ids expire after 5 minutes (is this a good idea?)\n\n  hasLocalStorage = util.localStorageAvailable();\n\n  if (hasLocalStorage) {\n    var settings;\n    try {\n      settings = JSON.parse(localStorage.getItem(SETTINGS_KEY));\n    } catch (e) {}\n    if (settings) {\n      this.configure(settings);\n    }\n  }\n};\n\nGoogleDrive.prototype = (_GoogleDrive$prototyp = {\n  connected: false,\n  online: true,\n\n  configure: function configure(settings) {\n    // Settings parameter compatible with WireClient\n    // We only update this.userAddress if settings.userAddress is set to a string or to null\n    if (typeof settings.userAddress !== 'undefined') {\n      this.userAddress = settings.userAddress;\n    }\n    // Same for this.token. If only one of these two is set, we leave the other one at its existing value\n    if (typeof settings.token !== 'undefined') {\n      this.token = settings.token;\n    }\n\n    var writeSettingsToCache = function writeSettingsToCache() {\n      if (hasLocalStorage) {\n        localStorage.setItem(SETTINGS_KEY, JSON.stringify({\n          userAddress: this.userAddress,\n          token: this.token\n        }));\n      }\n    };\n\n    var handleError = function handleError() {\n      this.connected = false;\n      delete this.token;\n      if (hasLocalStorage) {\n        localStorage.removeItem(SETTINGS_KEY);\n      }\n    };\n\n    if (this.token) {\n      this.connected = true;\n\n      if (this.userAddress) {\n        this._emit('connected');\n        writeSettingsToCache.apply(this);\n      } else {\n        this.info().then(function (info) {\n          this.userAddress = info.user.emailAddress;\n          this.rs.widget.view.setUserAddress(this.userAddress);\n          this._emit('connected');\n          writeSettingsToCache.apply(this);\n        }.bind(this)).catch(function () {\n          handleError.apply(this);\n          this.rs._emit('error', new Error('Could not fetch user info.'));\n        }.bind(this));\n      }\n    } else {\n      handleError.apply(this);\n    }\n  },\n\n  connect: function connect() {\n    this.rs.setBackend('googledrive');\n    Authorize(this.rs, AUTH_URL, AUTH_SCOPE, String(Authorize.getLocation()), this.clientId);\n  },\n\n  stopWaitingForToken: function stopWaitingForToken() {\n    if (!this.connected) {\n      this._emit('not-connected');\n    }\n  },\n\n  get: function get(path, options) {\n    if (path.substr(-1) === '/') {\n      return this._getFolder(path, options);\n    } else {\n      return this._getFile(path, options);\n    }\n  },\n\n  put: function put(path, body, contentType, options) {\n    var self = this;\n    function putDone(response) {\n      if (response.status >= 200 && response.status < 300) {\n        var meta = JSON.parse(response.responseText);\n        var etagWithoutQuotes = meta.etag.substring(1, meta.etag.length - 1);\n        return Promise.resolve({ statusCode: 200, contentType: meta.mimeType, revision: etagWithoutQuotes });\n      } else if (response.status === 412) {\n        return Promise.resolve({ statusCode: 412, revision: 'conflict' });\n      } else {\n        return Promise.reject(\"PUT failed with status \" + response.status + \" (\" + response.responseText + \")\");\n      }\n    }\n    return self._getFileId(path).then(function (id) {\n      if (id) {\n        if (options && options.ifNoneMatch === '*') {\n          return putDone({ status: 412 });\n        }\n        return self._updateFile(id, path, body, contentType, options).then(putDone);\n      } else {\n        return self._createFile(path, body, contentType, options).then(putDone);\n      }\n    });\n  },\n\n  'delete': function _delete(path, options) {\n    var self = this;\n    return self._getFileId(path).then(function (id) {\n      if (!id) {\n        // File doesn't exist. Ignore.\n        return Promise.resolve({ statusCode: 200 });\n      }\n\n      return self._getMeta(id).then(function (meta) {\n        var etagWithoutQuotes;\n        if ((typeof meta === 'undefined' ? 'undefined' : _typeof(meta)) === 'object' && typeof meta.etag === 'string') {\n          etagWithoutQuotes = meta.etag.substring(1, meta.etag.length - 1);\n        }\n        if (options && options.ifMatch && options.ifMatch !== etagWithoutQuotes) {\n          return { statusCode: 412, revision: etagWithoutQuotes };\n        }\n\n        return self._request('DELETE', BASE_URL + '/drive/v2/files/' + id, {}).then(function (response) {\n          if (response.status === 200 || response.status === 204) {\n            return { statusCode: 200 };\n          } else {\n            return Promise.reject(\"Delete failed: \" + response.status + \" (\" + response.responseText + \")\");\n          }\n        });\n      });\n    });\n  },\n\n  /**\n   * Method: info\n   *\n   * Fetches the user's info from Google and returns a promise for it.\n   *\n   * Returns:\n   *\n   *   A promise to the user's info\n   */\n  info: function info() {\n    var url = BASE_URL + '/drive/v2/about?fields=user';\n    // requesting user info(mainly for userAdress)\n    return this._request('GET', url, {}).then(function (resp) {\n      try {\n        var info = JSON.parse(resp.responseText);\n        return Promise.resolve(info);\n      } catch (e) {\n        return Promise.reject(e);\n      }\n    });\n  },\n\n  _updateFile: function _updateFile(id, path, body, contentType, options) {\n    var self = this;\n    var metadata = {\n      mimeType: contentType\n    };\n    var headers = {\n      'Content-Type': 'application/json; charset=UTF-8'\n    };\n\n    if (options && options.ifMatch) {\n      headers['If-Match'] = '\"' + options.ifMatch + '\"';\n    }\n\n    return self._request('PUT', BASE_URL + '/upload/drive/v2/files/' + id + '?uploadType=resumable', {\n      body: JSON.stringify(metadata),\n      headers: headers\n    }).then(function (response) {\n      if (response.status === 412) {\n        return response;\n      } else {\n        return self._request('PUT', response.getResponseHeader('Location'), {\n          body: contentType.match(/^application\\/json/) ? JSON.stringify(body) : body\n        });\n      }\n    });\n  },\n\n  _createFile: function _createFile(path, body, contentType, options) {\n    var self = this;\n    return self._getParentId(path).then(function (parentId) {\n      var fileName = baseName(path);\n      var metadata = {\n        title: metaTitleFromFileName(fileName),\n        mimeType: contentType,\n        parents: [{\n          kind: \"drive#fileLink\",\n          id: parentId\n        }]\n      };\n      return self._request('POST', BASE_URL + '/upload/drive/v2/files?uploadType=resumable', {\n        body: JSON.stringify(metadata),\n        headers: {\n          'Content-Type': 'application/json; charset=UTF-8'\n        }\n      }).then(function (response) {\n        return self._request('POST', response.getResponseHeader('Location'), {\n          body: contentType.match(/^application\\/json/) ? JSON.stringify(body) : body\n        });\n      });\n    });\n  },\n\n  _getFile: function _getFile(path, options) {\n    var self = this;\n    return self._getFileId(path).then(function (id) {\n      return self._getMeta(id).then(function (meta) {\n        var etagWithoutQuotes;\n        if ((typeof meta === 'undefined' ? 'undefined' : _typeof(meta)) === 'object' && typeof meta.etag === 'string') {\n          etagWithoutQuotes = meta.etag.substring(1, meta.etag.length - 1);\n        }\n\n        if (options && options.ifNoneMatch && etagWithoutQuotes === options.ifNoneMatch) {\n          return Promise.resolve({ statusCode: 304 });\n        }\n\n        var options2 = {};\n        if (!meta.downloadUrl) {\n          if (meta.exportLinks && meta.exportLinks['text/html']) {\n            // Documents that were generated inside GoogleDocs have no\n            // downloadUrl, but you can export them to text/html instead:\n            meta.mimeType += ';export=text/html';\n            meta.downloadUrl = meta.exportLinks['text/html'];\n          } else {\n            // empty file\n            return Promise.resolve({ statusCode: 200, body: '', contentType: meta.mimeType, revision: etagWithoutQuotes });\n          }\n        }\n\n        if (meta.mimeType.match(/charset=binary/)) {\n          options2.responseType = 'blob';\n        }\n        return self._request('GET', meta.downloadUrl, options2).then(function (response) {\n          var body = response.response;\n          if (meta.mimeType.match(/^application\\/json/)) {\n            try {\n              body = JSON.parse(body);\n            } catch (e) {}\n          }\n          return Promise.resolve({ statusCode: 200, body: body, contentType: meta.mimeType, revision: etagWithoutQuotes });\n        });\n      });\n    });\n  },\n\n  _getFolder: function _getFolder(path, options) {\n    var self = this;\n    return self._getFileId(path).then(function (id) {\n      var query, fields, data, etagWithoutQuotes, itemsMap;\n      if (!id) {\n        return Promise.resolve({ statusCode: 404 });\n      }\n\n      query = '\\'' + id + '\\' in parents';\n      fields = 'items(downloadUrl,etag,fileSize,id,mimeType,title)';\n      return self._request('GET', BASE_URL + '/drive/v2/files?' + 'q=' + encodeURIComponent(query) + '&fields=' + encodeURIComponent(fields) + '&maxResults=1000', {}).then(function (response) {\n        if (response.status !== 200) {\n          return Promise.reject('request failed or something: ' + response.status);\n        }\n\n        try {\n          data = JSON.parse(response.responseText);\n        } catch (e) {\n          return Promise.reject('non-JSON response from GoogleDrive');\n        }\n\n        itemsMap = {};\n        for (var i = 0, len = data.items.length; i < len; i++) {\n          etagWithoutQuotes = data.items[i].etag.substring(1, data.items[i].etag.length - 1);\n          if (data.items[i].mimeType === GD_DIR_MIME_TYPE) {\n            self._fileIdCache.set(path + data.items[i].title + '/', data.items[i].id);\n            itemsMap[data.items[i].title + '/'] = {\n              ETag: etagWithoutQuotes\n            };\n          } else {\n            self._fileIdCache.set(path + data.items[i].title, data.items[i].id);\n            itemsMap[data.items[i].title] = {\n              ETag: etagWithoutQuotes,\n              'Content-Type': data.items[i].mimeType,\n              'Content-Length': data.items[i].fileSize\n            };\n          }\n        }\n        // FIXME: add revision of folder!\n        return Promise.resolve({ statusCode: 200, body: itemsMap, contentType: RS_DIR_MIME_TYPE, revision: undefined });\n      });\n    });\n  },\n\n  _getParentId: function _getParentId(path) {\n    var foldername = parentPath(path);\n    var self = this;\n    return self._getFileId(foldername).then(function (parentId) {\n      if (parentId) {\n        return Promise.resolve(parentId);\n      } else {\n        return self._createFolder(foldername);\n      }\n    });\n  },\n\n  _createFolder: function _createFolder(path) {\n    var self = this;\n    return self._getParentId(path).then(function (parentId) {\n      return self._request('POST', BASE_URL + '/drive/v2/files', {\n        body: JSON.stringify({\n          title: metaTitleFromFileName(baseName(path)),\n          mimeType: GD_DIR_MIME_TYPE,\n          parents: [{\n            id: parentId\n          }]\n        }),\n        headers: {\n          'Content-Type': 'application/json; charset=UTF-8'\n        }\n      }).then(function (response) {\n        var meta = JSON.parse(response.responseText);\n        return Promise.resolve(meta.id);\n      });\n    });\n  },\n\n  _getFileId: function _getFileId(path) {\n    var self = this;\n    var id;\n    if (path === '/') {\n      // \"root\" is a special alias for the fileId of the root folder\n      return Promise.resolve('root');\n    } else if (id = this._fileIdCache.get(path)) {\n      // id is cached.\n      return Promise.resolve(id);\n    }\n    // id is not cached (or file doesn't exist).\n    // load parent folder listing to propagate / update id cache.\n    return self._getFolder(parentPath(path)).then(function () {\n      id = self._fileIdCache.get(path);\n      if (!id) {\n        if (path.substr(-1) === '/') {\n          return self._createFolder(path).then(function () {\n            return self._getFileId(path);\n          });\n        } else {\n          return Promise.resolve();\n        }\n      }\n      return Promise.resolve(id);\n    });\n  },\n\n  _getMeta: function _getMeta(id) {\n    return this._request('GET', BASE_URL + '/drive/v2/files/' + id, {}).then(function (response) {\n      if (response.status === 200) {\n        return Promise.resolve(JSON.parse(response.responseText));\n      } else {\n        return Promise.reject(\"request (getting metadata for \" + id + \") failed with status: \" + response.status);\n      }\n    });\n  }\n\n}, _defineProperty(_GoogleDrive$prototyp, 'info', function info() {\n  var url = BASE_URL + '/drive/v2/about';\n  // requesting user info(mainly for userAdress)\n  return this._request('GET', url, {}).then(function (resp) {\n    try {\n      var info = JSON.parse(resp.responseText);\n      return Promise.resolve(info);\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  });\n}), _defineProperty(_GoogleDrive$prototyp, '_request', function _request(method, url, options) {\n  var self = this;\n\n  if (!options.headers) {\n    options.headers = {};\n  }\n  options.headers['Authorization'] = 'Bearer ' + self.token;\n\n  this._emit('wire-busy', {\n    method: method,\n    isFolder: isFolder(url)\n  });\n\n  return WireClient.request.call(this, method, url, options).then(function (xhr) {\n    // Google tokens expire from time to time...\n    if (xhr && xhr.status === 401) {\n      self.connect();\n      return;\n    } else {\n      if (!self.online) {\n        self.online = true;\n        self.rs._emit('network-online');\n      }\n      self._emit('wire-done', {\n        method: method,\n        isFolder: isFolder(url),\n        success: true\n      });\n\n      return Promise.resolve(xhr);\n    }\n  }, function (error) {\n    if (self.online) {\n      self.online = false;\n      self.rs._emit('network-offline');\n    }\n    self._emit('wire-done', {\n      method: method,\n      isFolder: isFolder(url),\n      success: false\n    });\n\n    return Promise.reject(error);\n  });\n}), _GoogleDrive$prototyp);\n\nGoogleDrive._rs_init = function (remoteStorage) {\n  var config = remoteStorage.apiKeys.googledrive;\n  if (config) {\n    remoteStorage.googledrive = new GoogleDrive(remoteStorage, config.clientId);\n    if (remoteStorage.backend === 'googledrive') {\n      remoteStorage._origRemote = remoteStorage.remote;\n      remoteStorage.remote = remoteStorage.googledrive;\n    }\n  }\n};\n\nGoogleDrive._rs_supported = function (rs) {\n  return true;\n};\n\nGoogleDrive._rs_cleanup = function (remoteStorage) {\n  remoteStorage.setBackend(undefined);\n  if (remoteStorage._origRemote) {\n    remoteStorage.remote = remoteStorage._origRemote;\n    delete remoteStorage._origRemote;\n  }\n};\n\nmodule.exports = GoogleDrive;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvZ29vZ2xlZHJpdmUuanM/MTJkZiJdLCJuYW1lcyI6WyJBdXRob3JpemUiLCJyZXF1aXJlIiwiV2lyZUNsaWVudCIsImV2ZW50SGFuZGxpbmciLCJ1dGlsIiwiQkFTRV9VUkwiLCJBVVRIX1VSTCIsIkFVVEhfU0NPUEUiLCJTRVRUSU5HU19LRVkiLCJHRF9ESVJfTUlNRV9UWVBFIiwiUlNfRElSX01JTUVfVFlQRSIsImlzRm9sZGVyIiwiaGFzTG9jYWxTdG9yYWdlIiwibWV0YVRpdGxlRnJvbUZpbGVOYW1lIiwiZmlsZW5hbWUiLCJzdWJzdHIiLCJsZW5ndGgiLCJkZWNvZGVVUklDb21wb25lbnQiLCJwYXJlbnRQYXRoIiwicGF0aCIsInJlcGxhY2UiLCJiYXNlTmFtZSIsInBhcnRzIiwic3BsaXQiLCJDYWNoZSIsIm1heEFnZSIsIl9pdGVtcyIsInByb3RvdHlwZSIsImdldCIsImtleSIsIml0ZW0iLCJub3ciLCJEYXRlIiwiZ2V0VGltZSIsInQiLCJ2IiwidW5kZWZpbmVkIiwic2V0IiwidmFsdWUiLCJHb29nbGVEcml2ZSIsInJlbW90ZVN0b3JhZ2UiLCJjbGllbnRJZCIsInJzIiwiX2ZpbGVJZENhY2hlIiwibG9jYWxTdG9yYWdlQXZhaWxhYmxlIiwic2V0dGluZ3MiLCJKU09OIiwicGFyc2UiLCJsb2NhbFN0b3JhZ2UiLCJnZXRJdGVtIiwiZSIsImNvbmZpZ3VyZSIsImNvbm5lY3RlZCIsIm9ubGluZSIsInVzZXJBZGRyZXNzIiwidG9rZW4iLCJ3cml0ZVNldHRpbmdzVG9DYWNoZSIsInNldEl0ZW0iLCJzdHJpbmdpZnkiLCJoYW5kbGVFcnJvciIsInJlbW92ZUl0ZW0iLCJfZW1pdCIsImFwcGx5IiwiaW5mbyIsInRoZW4iLCJ1c2VyIiwiZW1haWxBZGRyZXNzIiwid2lkZ2V0IiwidmlldyIsInNldFVzZXJBZGRyZXNzIiwiYmluZCIsImNhdGNoIiwiRXJyb3IiLCJjb25uZWN0Iiwic2V0QmFja2VuZCIsIlN0cmluZyIsImdldExvY2F0aW9uIiwic3RvcFdhaXRpbmdGb3JUb2tlbiIsIm9wdGlvbnMiLCJfZ2V0Rm9sZGVyIiwiX2dldEZpbGUiLCJwdXQiLCJib2R5IiwiY29udGVudFR5cGUiLCJzZWxmIiwicHV0RG9uZSIsInJlc3BvbnNlIiwic3RhdHVzIiwibWV0YSIsInJlc3BvbnNlVGV4dCIsImV0YWdXaXRob3V0UXVvdGVzIiwiZXRhZyIsInN1YnN0cmluZyIsIlByb21pc2UiLCJyZXNvbHZlIiwic3RhdHVzQ29kZSIsIm1pbWVUeXBlIiwicmV2aXNpb24iLCJyZWplY3QiLCJfZ2V0RmlsZUlkIiwiaWQiLCJpZk5vbmVNYXRjaCIsIl91cGRhdGVGaWxlIiwiX2NyZWF0ZUZpbGUiLCJfZ2V0TWV0YSIsImlmTWF0Y2giLCJfcmVxdWVzdCIsInVybCIsInJlc3AiLCJtZXRhZGF0YSIsImhlYWRlcnMiLCJnZXRSZXNwb25zZUhlYWRlciIsIm1hdGNoIiwiX2dldFBhcmVudElkIiwicGFyZW50SWQiLCJmaWxlTmFtZSIsInRpdGxlIiwicGFyZW50cyIsImtpbmQiLCJvcHRpb25zMiIsImRvd25sb2FkVXJsIiwiZXhwb3J0TGlua3MiLCJyZXNwb25zZVR5cGUiLCJxdWVyeSIsImZpZWxkcyIsImRhdGEiLCJpdGVtc01hcCIsImVuY29kZVVSSUNvbXBvbmVudCIsImkiLCJsZW4iLCJpdGVtcyIsIkVUYWciLCJmaWxlU2l6ZSIsImZvbGRlcm5hbWUiLCJfY3JlYXRlRm9sZGVyIiwibWV0aG9kIiwicmVxdWVzdCIsImNhbGwiLCJ4aHIiLCJzdWNjZXNzIiwiZXJyb3IiLCJfcnNfaW5pdCIsImNvbmZpZyIsImFwaUtleXMiLCJnb29nbGVkcml2ZSIsImJhY2tlbmQiLCJfb3JpZ1JlbW90ZSIsInJlbW90ZSIsIl9yc19zdXBwb3J0ZWQiLCJfcnNfY2xlYW51cCIsIm1vZHVsZSIsImV4cG9ydHMiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQ0U7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQXFCQSxJQUFJQSxZQUFZLG1CQUFBQyxDQUFRLENBQVIsQ0FBaEI7QUFDQSxJQUFJQyxhQUFhLG1CQUFBRCxDQUFRLENBQVIsQ0FBakI7QUFDQSxJQUFJRSxnQkFBZ0IsbUJBQUFGLENBQVEsQ0FBUixDQUFwQjtBQUNBLElBQUlHLE9BQU8sbUJBQUFILENBQVEsQ0FBUixDQUFYOztBQUVBLElBQUlJLFdBQVcsNEJBQWY7QUFDQSxJQUFJQyxXQUFXLDJDQUFmO0FBQ0EsSUFBSUMsYUFBYSx1Q0FBakI7QUFDQSxJQUFJQyxlQUFlLDJCQUFuQjs7QUFFQSxJQUFJQyxtQkFBbUIsb0NBQXZCO0FBQ0EsSUFBSUMsbUJBQW1CLGlDQUF2Qjs7QUFFQSxJQUFJQyxXQUFXUCxLQUFLTyxRQUFwQjtBQUNBLElBQUlDLGVBQUo7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsU0FBU0MscUJBQVQsQ0FBK0JDLFFBQS9CLEVBQXlDO0FBQ3ZDLE1BQUlBLFNBQVNDLE1BQVQsQ0FBZ0IsQ0FBQyxDQUFqQixNQUF3QixHQUE1QixFQUFpQztBQUMvQkQsZUFBV0EsU0FBU0MsTUFBVCxDQUFnQixDQUFoQixFQUFtQkQsU0FBU0UsTUFBVCxHQUFrQixDQUFyQyxDQUFYO0FBQ0Q7QUFDRCxTQUFPQyxtQkFBbUJILFFBQW5CLENBQVA7QUFDRDs7QUFFRCxTQUFTSSxVQUFULENBQW9CQyxJQUFwQixFQUEwQjtBQUN4QixTQUFPQSxLQUFLQyxPQUFMLENBQWEsWUFBYixFQUEyQixFQUEzQixDQUFQO0FBQ0Q7O0FBRUQsU0FBU0MsUUFBVCxDQUFrQkYsSUFBbEIsRUFBd0I7QUFDdEIsTUFBSUcsUUFBUUgsS0FBS0ksS0FBTCxDQUFXLEdBQVgsQ0FBWjtBQUNBLE1BQUlKLEtBQUtKLE1BQUwsQ0FBWSxDQUFDLENBQWIsTUFBb0IsR0FBeEIsRUFBNkI7QUFDM0IsV0FBT08sTUFBTUEsTUFBTU4sTUFBTixHQUFhLENBQW5CLElBQXNCLEdBQTdCO0FBQ0QsR0FGRCxNQUVPO0FBQ0wsV0FBT00sTUFBTUEsTUFBTU4sTUFBTixHQUFhLENBQW5CLENBQVA7QUFDRDtBQUNGOztBQUVELElBQUlRLFFBQVEsU0FBUkEsS0FBUSxDQUFVQyxNQUFWLEVBQWtCO0FBQzVCLE9BQUtBLE1BQUwsR0FBY0EsTUFBZDtBQUNBLE9BQUtDLE1BQUwsR0FBYyxFQUFkO0FBQ0QsQ0FIRDs7QUFLQUYsTUFBTUcsU0FBTixHQUFrQjtBQUNoQkMsT0FBSyxhQUFVQyxHQUFWLEVBQWU7QUFDbEIsUUFBSUMsT0FBTyxLQUFLSixNQUFMLENBQVlHLEdBQVosQ0FBWDtBQUNBLFFBQUlFLE1BQU0sSUFBSUMsSUFBSixHQUFXQyxPQUFYLEVBQVY7QUFDQSxXQUFRSCxRQUFRQSxLQUFLSSxDQUFMLElBQVdILE1BQU0sS0FBS04sTUFBL0IsR0FBMENLLEtBQUtLLENBQS9DLEdBQW1EQyxTQUExRDtBQUNELEdBTGU7O0FBT2hCQyxPQUFLLGFBQVVSLEdBQVYsRUFBZVMsS0FBZixFQUFzQjtBQUN6QixTQUFLWixNQUFMLENBQVlHLEdBQVosSUFBbUI7QUFDakJNLFNBQUdHLEtBRGM7QUFFakJKLFNBQUcsSUFBSUYsSUFBSixHQUFXQyxPQUFYO0FBRmMsS0FBbkI7QUFJRDtBQVplLENBQWxCOztBQWVBLElBQUlNLGNBQWMsU0FBZEEsV0FBYyxDQUFVQyxhQUFWLEVBQXlCQyxRQUF6QixFQUFtQzs7QUFFbkR0QyxnQkFBYyxJQUFkLEVBQW9CLFFBQXBCLEVBQThCLFdBQTlCLEVBQTJDLFdBQTNDLEVBQXdELFdBQXhELEVBQXFFLGVBQXJFOztBQUVBLE9BQUt1QyxFQUFMLEdBQVVGLGFBQVY7QUFDQSxPQUFLQyxRQUFMLEdBQWdCQSxRQUFoQjs7QUFFQSxPQUFLRSxZQUFMLEdBQW9CLElBQUluQixLQUFKLENBQVUsS0FBSyxDQUFmLENBQXBCLENBUG1ELENBT1o7O0FBRXZDWixvQkFBa0JSLEtBQUt3QyxxQkFBTCxFQUFsQjs7QUFFQSxNQUFJaEMsZUFBSixFQUFvQjtBQUNsQixRQUFJaUMsUUFBSjtBQUNBLFFBQUk7QUFDRkEsaUJBQVdDLEtBQUtDLEtBQUwsQ0FBV0MsYUFBYUMsT0FBYixDQUFxQnpDLFlBQXJCLENBQVgsQ0FBWDtBQUNELEtBRkQsQ0FFRSxPQUFNMEMsQ0FBTixFQUFRLENBQUU7QUFDWixRQUFJTCxRQUFKLEVBQWM7QUFDWixXQUFLTSxTQUFMLENBQWVOLFFBQWY7QUFDRDtBQUNGO0FBRUYsQ0FyQkQ7O0FBdUJBTixZQUFZWixTQUFaO0FBQ0V5QixhQUFXLEtBRGI7QUFFRUMsVUFBUSxJQUZWOztBQUlFRixhQUFXLG1CQUFVTixRQUFWLEVBQW9CO0FBQUU7QUFDL0I7QUFDQSxRQUFJLE9BQU9BLFNBQVNTLFdBQWhCLEtBQWdDLFdBQXBDLEVBQWlEO0FBQUUsV0FBS0EsV0FBTCxHQUFtQlQsU0FBU1MsV0FBNUI7QUFBMEM7QUFDN0Y7QUFDQSxRQUFJLE9BQU9ULFNBQVNVLEtBQWhCLEtBQTBCLFdBQTlCLEVBQTJDO0FBQUUsV0FBS0EsS0FBTCxHQUFhVixTQUFTVSxLQUF0QjtBQUE4Qjs7QUFFM0UsUUFBSUMsdUJBQXVCLFNBQXZCQSxvQkFBdUIsR0FBVztBQUNwQyxVQUFJNUMsZUFBSixFQUFxQjtBQUNuQm9DLHFCQUFhUyxPQUFiLENBQXFCakQsWUFBckIsRUFBbUNzQyxLQUFLWSxTQUFMLENBQWU7QUFDaERKLHVCQUFhLEtBQUtBLFdBRDhCO0FBRWhEQyxpQkFBTyxLQUFLQTtBQUZvQyxTQUFmLENBQW5DO0FBSUQ7QUFDRixLQVBEOztBQVNBLFFBQUlJLGNBQWMsU0FBZEEsV0FBYyxHQUFXO0FBQzNCLFdBQUtQLFNBQUwsR0FBaUIsS0FBakI7QUFDQSxhQUFPLEtBQUtHLEtBQVo7QUFDQSxVQUFJM0MsZUFBSixFQUFxQjtBQUNuQm9DLHFCQUFhWSxVQUFiLENBQXdCcEQsWUFBeEI7QUFDRDtBQUNGLEtBTkQ7O0FBUUEsUUFBSSxLQUFLK0MsS0FBVCxFQUFnQjtBQUNkLFdBQUtILFNBQUwsR0FBaUIsSUFBakI7O0FBRUEsVUFBSSxLQUFLRSxXQUFULEVBQXNCO0FBQ3BCLGFBQUtPLEtBQUwsQ0FBVyxXQUFYO0FBQ0FMLDZCQUFxQk0sS0FBckIsQ0FBMkIsSUFBM0I7QUFDRCxPQUhELE1BR087QUFDTCxhQUFLQyxJQUFMLEdBQVlDLElBQVosQ0FBaUIsVUFBU0QsSUFBVCxFQUFlO0FBQzlCLGVBQUtULFdBQUwsR0FBbUJTLEtBQUtFLElBQUwsQ0FBVUMsWUFBN0I7QUFDQSxlQUFLeEIsRUFBTCxDQUFReUIsTUFBUixDQUFlQyxJQUFmLENBQW9CQyxjQUFwQixDQUFtQyxLQUFLZixXQUF4QztBQUNBLGVBQUtPLEtBQUwsQ0FBVyxXQUFYO0FBQ0FMLCtCQUFxQk0sS0FBckIsQ0FBMkIsSUFBM0I7QUFDRCxTQUxnQixDQUtmUSxJQUxlLENBS1YsSUFMVSxDQUFqQixFQUtjQyxLQUxkLENBS29CLFlBQVc7QUFDN0JaLHNCQUFZRyxLQUFaLENBQWtCLElBQWxCO0FBQ0EsZUFBS3BCLEVBQUwsQ0FBUW1CLEtBQVIsQ0FBYyxPQUFkLEVBQXVCLElBQUlXLEtBQUosQ0FBVSw0QkFBVixDQUF2QjtBQUNELFNBSG1CLENBR2xCRixJQUhrQixDQUdiLElBSGEsQ0FMcEI7QUFTRDtBQUNGLEtBakJELE1BaUJPO0FBQ0xYLGtCQUFZRyxLQUFaLENBQWtCLElBQWxCO0FBQ0Q7QUFDRixHQS9DSDs7QUFpREVXLFdBQVMsbUJBQVk7QUFDbkIsU0FBSy9CLEVBQUwsQ0FBUWdDLFVBQVIsQ0FBbUIsYUFBbkI7QUFDQTFFLGNBQVUsS0FBSzBDLEVBQWYsRUFBbUJwQyxRQUFuQixFQUE2QkMsVUFBN0IsRUFBeUNvRSxPQUFPM0UsVUFBVTRFLFdBQVYsRUFBUCxDQUF6QyxFQUEwRSxLQUFLbkMsUUFBL0U7QUFDRCxHQXBESDs7QUFzREVvQyx1QkFBcUIsK0JBQVk7QUFDL0IsUUFBSSxDQUFDLEtBQUt6QixTQUFWLEVBQXFCO0FBQ25CLFdBQUtTLEtBQUwsQ0FBVyxlQUFYO0FBQ0Q7QUFDRixHQTFESDs7QUE0REVqQyxPQUFLLGFBQVVULElBQVYsRUFBZ0IyRCxPQUFoQixFQUF5QjtBQUM1QixRQUFJM0QsS0FBS0osTUFBTCxDQUFZLENBQUMsQ0FBYixNQUFvQixHQUF4QixFQUE2QjtBQUMzQixhQUFPLEtBQUtnRSxVQUFMLENBQWdCNUQsSUFBaEIsRUFBc0IyRCxPQUF0QixDQUFQO0FBQ0QsS0FGRCxNQUVPO0FBQ0wsYUFBTyxLQUFLRSxRQUFMLENBQWM3RCxJQUFkLEVBQW9CMkQsT0FBcEIsQ0FBUDtBQUNEO0FBQ0YsR0FsRUg7O0FBb0VFRyxPQUFLLGFBQVU5RCxJQUFWLEVBQWdCK0QsSUFBaEIsRUFBc0JDLFdBQXRCLEVBQW1DTCxPQUFuQyxFQUE0QztBQUMvQyxRQUFJTSxPQUFPLElBQVg7QUFDQSxhQUFTQyxPQUFULENBQWlCQyxRQUFqQixFQUEyQjtBQUN6QixVQUFJQSxTQUFTQyxNQUFULElBQW1CLEdBQW5CLElBQTBCRCxTQUFTQyxNQUFULEdBQWtCLEdBQWhELEVBQXFEO0FBQ25ELFlBQUlDLE9BQU8xQyxLQUFLQyxLQUFMLENBQVd1QyxTQUFTRyxZQUFwQixDQUFYO0FBQ0EsWUFBSUMsb0JBQW9CRixLQUFLRyxJQUFMLENBQVVDLFNBQVYsQ0FBb0IsQ0FBcEIsRUFBdUJKLEtBQUtHLElBQUwsQ0FBVTNFLE1BQVYsR0FBaUIsQ0FBeEMsQ0FBeEI7QUFDQSxlQUFPNkUsUUFBUUMsT0FBUixDQUFnQixFQUFDQyxZQUFZLEdBQWIsRUFBa0JaLGFBQWFLLEtBQUtRLFFBQXBDLEVBQThDQyxVQUFVUCxpQkFBeEQsRUFBaEIsQ0FBUDtBQUNELE9BSkQsTUFJTyxJQUFJSixTQUFTQyxNQUFULEtBQW9CLEdBQXhCLEVBQTZCO0FBQ2xDLGVBQU9NLFFBQVFDLE9BQVIsQ0FBZ0IsRUFBQ0MsWUFBWSxHQUFiLEVBQWtCRSxVQUFVLFVBQTVCLEVBQWhCLENBQVA7QUFDRCxPQUZNLE1BRUE7QUFDTCxlQUFPSixRQUFRSyxNQUFSLENBQWUsNEJBQTRCWixTQUFTQyxNQUFyQyxHQUE4QyxJQUE5QyxHQUFxREQsU0FBU0csWUFBOUQsR0FBNkUsR0FBNUYsQ0FBUDtBQUNEO0FBQ0Y7QUFDRCxXQUFPTCxLQUFLZSxVQUFMLENBQWdCaEYsSUFBaEIsRUFBc0I2QyxJQUF0QixDQUEyQixVQUFVb0MsRUFBVixFQUFjO0FBQzlDLFVBQUlBLEVBQUosRUFBUTtBQUNOLFlBQUl0QixXQUFZQSxRQUFRdUIsV0FBUixLQUF3QixHQUF4QyxFQUE4QztBQUM1QyxpQkFBT2hCLFFBQVEsRUFBRUUsUUFBUSxHQUFWLEVBQVIsQ0FBUDtBQUNEO0FBQ0QsZUFBT0gsS0FBS2tCLFdBQUwsQ0FBaUJGLEVBQWpCLEVBQXFCakYsSUFBckIsRUFBMkIrRCxJQUEzQixFQUFpQ0MsV0FBakMsRUFBOENMLE9BQTlDLEVBQXVEZCxJQUF2RCxDQUE0RHFCLE9BQTVELENBQVA7QUFDRCxPQUxELE1BS087QUFDTCxlQUFPRCxLQUFLbUIsV0FBTCxDQUFpQnBGLElBQWpCLEVBQXVCK0QsSUFBdkIsRUFBNkJDLFdBQTdCLEVBQTBDTCxPQUExQyxFQUFtRGQsSUFBbkQsQ0FBd0RxQixPQUF4RCxDQUFQO0FBQ0Q7QUFDRixLQVRNLENBQVA7QUFVRCxHQTNGSDs7QUE2RkUsWUFBVSxpQkFBVWxFLElBQVYsRUFBZ0IyRCxPQUFoQixFQUF5QjtBQUNqQyxRQUFJTSxPQUFPLElBQVg7QUFDQSxXQUFPQSxLQUFLZSxVQUFMLENBQWdCaEYsSUFBaEIsRUFBc0I2QyxJQUF0QixDQUEyQixVQUFVb0MsRUFBVixFQUFjO0FBQzlDLFVBQUksQ0FBQ0EsRUFBTCxFQUFTO0FBQ1A7QUFDQSxlQUFPUCxRQUFRQyxPQUFSLENBQWdCLEVBQUNDLFlBQVksR0FBYixFQUFoQixDQUFQO0FBQ0Q7O0FBRUQsYUFBT1gsS0FBS29CLFFBQUwsQ0FBY0osRUFBZCxFQUFrQnBDLElBQWxCLENBQXVCLFVBQVV3QixJQUFWLEVBQWdCO0FBQzVDLFlBQUlFLGlCQUFKO0FBQ0EsWUFBSyxRQUFPRixJQUFQLHlDQUFPQSxJQUFQLE9BQWdCLFFBQWpCLElBQStCLE9BQU9BLEtBQUtHLElBQVosS0FBcUIsUUFBeEQsRUFBbUU7QUFDakVELDhCQUFvQkYsS0FBS0csSUFBTCxDQUFVQyxTQUFWLENBQW9CLENBQXBCLEVBQXVCSixLQUFLRyxJQUFMLENBQVUzRSxNQUFWLEdBQWlCLENBQXhDLENBQXBCO0FBQ0Q7QUFDRCxZQUFJOEQsV0FBV0EsUUFBUTJCLE9BQW5CLElBQStCM0IsUUFBUTJCLE9BQVIsS0FBb0JmLGlCQUF2RCxFQUEyRTtBQUN6RSxpQkFBTyxFQUFDSyxZQUFZLEdBQWIsRUFBa0JFLFVBQVVQLGlCQUE1QixFQUFQO0FBQ0Q7O0FBRUQsZUFBT04sS0FBS3NCLFFBQUwsQ0FBYyxRQUFkLEVBQXdCckcsV0FBVyxrQkFBWCxHQUFnQytGLEVBQXhELEVBQTRELEVBQTVELEVBQWdFcEMsSUFBaEUsQ0FBcUUsVUFBVXNCLFFBQVYsRUFBb0I7QUFDOUYsY0FBSUEsU0FBU0MsTUFBVCxLQUFvQixHQUFwQixJQUEyQkQsU0FBU0MsTUFBVCxLQUFvQixHQUFuRCxFQUF3RDtBQUN0RCxtQkFBTyxFQUFDUSxZQUFZLEdBQWIsRUFBUDtBQUNELFdBRkQsTUFFTztBQUNMLG1CQUFPRixRQUFRSyxNQUFSLENBQWUsb0JBQW9CWixTQUFTQyxNQUE3QixHQUFzQyxJQUF0QyxHQUE2Q0QsU0FBU0csWUFBdEQsR0FBcUUsR0FBcEYsQ0FBUDtBQUNEO0FBQ0YsU0FOTSxDQUFQO0FBT0QsT0FoQk0sQ0FBUDtBQWlCRCxLQXZCTSxDQUFQO0FBd0JELEdBdkhIOztBQXlIRTs7Ozs7Ozs7O0FBU0ExQixRQUFNLGdCQUFZO0FBQ2hCLFFBQUk0QyxNQUFNdEcsV0FBVyw2QkFBckI7QUFDQTtBQUNBLFdBQU8sS0FBS3FHLFFBQUwsQ0FBYyxLQUFkLEVBQXFCQyxHQUFyQixFQUEwQixFQUExQixFQUE4QjNDLElBQTlCLENBQW1DLFVBQVU0QyxJQUFWLEVBQWU7QUFDdkQsVUFBSTtBQUNGLFlBQUk3QyxPQUFPakIsS0FBS0MsS0FBTCxDQUFXNkQsS0FBS25CLFlBQWhCLENBQVg7QUFDQSxlQUFPSSxRQUFRQyxPQUFSLENBQWdCL0IsSUFBaEIsQ0FBUDtBQUNELE9BSEQsQ0FHRSxPQUFPYixDQUFQLEVBQVU7QUFDVixlQUFPMkMsUUFBUUssTUFBUixDQUFlaEQsQ0FBZixDQUFQO0FBQ0Q7QUFDRixLQVBNLENBQVA7QUFRRCxHQTdJSDs7QUErSUVvRCxlQUFhLHFCQUFVRixFQUFWLEVBQWNqRixJQUFkLEVBQW9CK0QsSUFBcEIsRUFBMEJDLFdBQTFCLEVBQXVDTCxPQUF2QyxFQUFnRDtBQUMzRCxRQUFJTSxPQUFPLElBQVg7QUFDQSxRQUFJeUIsV0FBVztBQUNiYixnQkFBVWI7QUFERyxLQUFmO0FBR0EsUUFBSTJCLFVBQVU7QUFDWixzQkFBZ0I7QUFESixLQUFkOztBQUlBLFFBQUloQyxXQUFXQSxRQUFRMkIsT0FBdkIsRUFBZ0M7QUFDOUJLLGNBQVEsVUFBUixJQUFzQixNQUFNaEMsUUFBUTJCLE9BQWQsR0FBd0IsR0FBOUM7QUFDRDs7QUFFRCxXQUFPckIsS0FBS3NCLFFBQUwsQ0FBYyxLQUFkLEVBQXFCckcsV0FBVyx5QkFBWCxHQUF1QytGLEVBQXZDLEdBQTRDLHVCQUFqRSxFQUEwRjtBQUMvRmxCLFlBQU1wQyxLQUFLWSxTQUFMLENBQWVtRCxRQUFmLENBRHlGO0FBRS9GQyxlQUFTQTtBQUZzRixLQUExRixFQUdKOUMsSUFISSxDQUdDLFVBQVVzQixRQUFWLEVBQW9CO0FBQzFCLFVBQUlBLFNBQVNDLE1BQVQsS0FBb0IsR0FBeEIsRUFBNkI7QUFDM0IsZUFBUUQsUUFBUjtBQUNELE9BRkQsTUFFTztBQUNMLGVBQU9GLEtBQUtzQixRQUFMLENBQWMsS0FBZCxFQUFxQnBCLFNBQVN5QixpQkFBVCxDQUEyQixVQUEzQixDQUFyQixFQUE2RDtBQUNsRTdCLGdCQUFNQyxZQUFZNkIsS0FBWixDQUFrQixvQkFBbEIsSUFBMENsRSxLQUFLWSxTQUFMLENBQWV3QixJQUFmLENBQTFDLEdBQWlFQTtBQURMLFNBQTdELENBQVA7QUFHRDtBQUNGLEtBWE0sQ0FBUDtBQVlELEdBeEtIOztBQTBLRXFCLGVBQWEscUJBQVVwRixJQUFWLEVBQWdCK0QsSUFBaEIsRUFBc0JDLFdBQXRCLEVBQW1DTCxPQUFuQyxFQUE0QztBQUN2RCxRQUFJTSxPQUFPLElBQVg7QUFDQSxXQUFPQSxLQUFLNkIsWUFBTCxDQUFrQjlGLElBQWxCLEVBQXdCNkMsSUFBeEIsQ0FBNkIsVUFBVWtELFFBQVYsRUFBb0I7QUFDdEQsVUFBSUMsV0FBVzlGLFNBQVNGLElBQVQsQ0FBZjtBQUNBLFVBQUkwRixXQUFXO0FBQ2JPLGVBQU92RyxzQkFBc0JzRyxRQUF0QixDQURNO0FBRWJuQixrQkFBVWIsV0FGRztBQUdia0MsaUJBQVMsQ0FBQztBQUNSQyxnQkFBTSxnQkFERTtBQUVSbEIsY0FBSWM7QUFGSSxTQUFEO0FBSEksT0FBZjtBQVFBLGFBQU85QixLQUFLc0IsUUFBTCxDQUFjLE1BQWQsRUFBc0JyRyxXQUFXLDZDQUFqQyxFQUFnRjtBQUNyRjZFLGNBQU1wQyxLQUFLWSxTQUFMLENBQWVtRCxRQUFmLENBRCtFO0FBRXJGQyxpQkFBUztBQUNQLDBCQUFnQjtBQURUO0FBRjRFLE9BQWhGLEVBS0o5QyxJQUxJLENBS0MsVUFBVXNCLFFBQVYsRUFBb0I7QUFDMUIsZUFBT0YsS0FBS3NCLFFBQUwsQ0FBYyxNQUFkLEVBQXNCcEIsU0FBU3lCLGlCQUFULENBQTJCLFVBQTNCLENBQXRCLEVBQThEO0FBQ25FN0IsZ0JBQU1DLFlBQVk2QixLQUFaLENBQWtCLG9CQUFsQixJQUEwQ2xFLEtBQUtZLFNBQUwsQ0FBZXdCLElBQWYsQ0FBMUMsR0FBaUVBO0FBREosU0FBOUQsQ0FBUDtBQUdELE9BVE0sQ0FBUDtBQVVELEtBcEJNLENBQVA7QUFxQkQsR0FqTUg7O0FBbU1FRixZQUFVLGtCQUFVN0QsSUFBVixFQUFnQjJELE9BQWhCLEVBQXlCO0FBQ2pDLFFBQUlNLE9BQU8sSUFBWDtBQUNBLFdBQU9BLEtBQUtlLFVBQUwsQ0FBZ0JoRixJQUFoQixFQUFzQjZDLElBQXRCLENBQTJCLFVBQVVvQyxFQUFWLEVBQWM7QUFDOUMsYUFBT2hCLEtBQUtvQixRQUFMLENBQWNKLEVBQWQsRUFBa0JwQyxJQUFsQixDQUF1QixVQUFVd0IsSUFBVixFQUFnQjtBQUM1QyxZQUFJRSxpQkFBSjtBQUNBLFlBQUksUUFBT0YsSUFBUCx5Q0FBT0EsSUFBUCxPQUFpQixRQUFqQixJQUE2QixPQUFPQSxLQUFLRyxJQUFaLEtBQXNCLFFBQXZELEVBQWlFO0FBQy9ERCw4QkFBb0JGLEtBQUtHLElBQUwsQ0FBVUMsU0FBVixDQUFvQixDQUFwQixFQUF1QkosS0FBS0csSUFBTCxDQUFVM0UsTUFBVixHQUFpQixDQUF4QyxDQUFwQjtBQUNEOztBQUVELFlBQUk4RCxXQUFXQSxRQUFRdUIsV0FBbkIsSUFBbUNYLHNCQUFzQlosUUFBUXVCLFdBQXJFLEVBQW1GO0FBQ2pGLGlCQUFPUixRQUFRQyxPQUFSLENBQWdCLEVBQUNDLFlBQVksR0FBYixFQUFoQixDQUFQO0FBQ0Q7O0FBRUQsWUFBSXdCLFdBQVcsRUFBZjtBQUNBLFlBQUksQ0FBQy9CLEtBQUtnQyxXQUFWLEVBQXVCO0FBQ3JCLGNBQUloQyxLQUFLaUMsV0FBTCxJQUFvQmpDLEtBQUtpQyxXQUFMLENBQWlCLFdBQWpCLENBQXhCLEVBQXVEO0FBQ3JEO0FBQ0E7QUFDQWpDLGlCQUFLUSxRQUFMLElBQWlCLG1CQUFqQjtBQUNBUixpQkFBS2dDLFdBQUwsR0FBbUJoQyxLQUFLaUMsV0FBTCxDQUFpQixXQUFqQixDQUFuQjtBQUNELFdBTEQsTUFLTztBQUNMO0FBQ0EsbUJBQU81QixRQUFRQyxPQUFSLENBQWdCLEVBQUNDLFlBQVksR0FBYixFQUFrQmIsTUFBTSxFQUF4QixFQUE0QkMsYUFBYUssS0FBS1EsUUFBOUMsRUFBd0RDLFVBQVVQLGlCQUFsRSxFQUFoQixDQUFQO0FBQ0Q7QUFDRjs7QUFFRCxZQUFJRixLQUFLUSxRQUFMLENBQWNnQixLQUFkLENBQW9CLGdCQUFwQixDQUFKLEVBQTJDO0FBQ3pDTyxtQkFBU0csWUFBVCxHQUF3QixNQUF4QjtBQUNEO0FBQ0QsZUFBT3RDLEtBQUtzQixRQUFMLENBQWMsS0FBZCxFQUFxQmxCLEtBQUtnQyxXQUExQixFQUF1Q0QsUUFBdkMsRUFBaUR2RCxJQUFqRCxDQUFzRCxVQUFVc0IsUUFBVixFQUFvQjtBQUMvRSxjQUFJSixPQUFPSSxTQUFTQSxRQUFwQjtBQUNBLGNBQUlFLEtBQUtRLFFBQUwsQ0FBY2dCLEtBQWQsQ0FBb0Isb0JBQXBCLENBQUosRUFBK0M7QUFDN0MsZ0JBQUk7QUFDRjlCLHFCQUFPcEMsS0FBS0MsS0FBTCxDQUFXbUMsSUFBWCxDQUFQO0FBQ0QsYUFGRCxDQUVFLE9BQU1oQyxDQUFOLEVBQVMsQ0FBRTtBQUNkO0FBQ0QsaUJBQU8yQyxRQUFRQyxPQUFSLENBQWdCLEVBQUNDLFlBQVksR0FBYixFQUFrQmIsTUFBTUEsSUFBeEIsRUFBOEJDLGFBQWFLLEtBQUtRLFFBQWhELEVBQTBEQyxVQUFVUCxpQkFBcEUsRUFBaEIsQ0FBUDtBQUNELFNBUk0sQ0FBUDtBQVNELE9BbkNNLENBQVA7QUFvQ0QsS0FyQ00sQ0FBUDtBQXNDRCxHQTNPSDs7QUE2T0VYLGNBQVksb0JBQVU1RCxJQUFWLEVBQWdCMkQsT0FBaEIsRUFBeUI7QUFDbkMsUUFBSU0sT0FBTyxJQUFYO0FBQ0EsV0FBT0EsS0FBS2UsVUFBTCxDQUFnQmhGLElBQWhCLEVBQXNCNkMsSUFBdEIsQ0FBMkIsVUFBVW9DLEVBQVYsRUFBYztBQUM5QyxVQUFJdUIsS0FBSixFQUFXQyxNQUFYLEVBQW1CQyxJQUFuQixFQUF5Qm5DLGlCQUF6QixFQUE0Q29DLFFBQTVDO0FBQ0EsVUFBSSxDQUFFMUIsRUFBTixFQUFVO0FBQ1IsZUFBT1AsUUFBUUMsT0FBUixDQUFnQixFQUFDQyxZQUFZLEdBQWIsRUFBaEIsQ0FBUDtBQUNEOztBQUVENEIsY0FBUSxPQUFPdkIsRUFBUCxHQUFZLGVBQXBCO0FBQ0F3QixlQUFTLG9EQUFUO0FBQ0EsYUFBT3hDLEtBQUtzQixRQUFMLENBQWMsS0FBZCxFQUFxQnJHLFdBQVcsa0JBQVgsR0FDdEIsSUFEc0IsR0FDZjBILG1CQUFtQkosS0FBbkIsQ0FEZSxHQUV0QixVQUZzQixHQUVUSSxtQkFBbUJILE1BQW5CLENBRlMsR0FHdEIsa0JBSEMsRUFJSCxFQUpHLEVBS041RCxJQUxNLENBS0QsVUFBVXNCLFFBQVYsRUFBb0I7QUFDeEIsWUFBSUEsU0FBU0MsTUFBVCxLQUFvQixHQUF4QixFQUE2QjtBQUMzQixpQkFBT00sUUFBUUssTUFBUixDQUFlLGtDQUFrQ1osU0FBU0MsTUFBMUQsQ0FBUDtBQUNEOztBQUVELFlBQUk7QUFDRnNDLGlCQUFPL0UsS0FBS0MsS0FBTCxDQUFXdUMsU0FBU0csWUFBcEIsQ0FBUDtBQUNELFNBRkQsQ0FFRSxPQUFNdkMsQ0FBTixFQUFTO0FBQ1QsaUJBQU8yQyxRQUFRSyxNQUFSLENBQWUsb0NBQWYsQ0FBUDtBQUNEOztBQUVENEIsbUJBQVcsRUFBWDtBQUNBLGFBQUssSUFBSUUsSUFBSSxDQUFSLEVBQVdDLE1BQU1KLEtBQUtLLEtBQUwsQ0FBV2xILE1BQWpDLEVBQXlDZ0gsSUFBSUMsR0FBN0MsRUFBa0RELEdBQWxELEVBQXVEO0FBQ3JEdEMsOEJBQW9CbUMsS0FBS0ssS0FBTCxDQUFXRixDQUFYLEVBQWNyQyxJQUFkLENBQW1CQyxTQUFuQixDQUE2QixDQUE3QixFQUFnQ2lDLEtBQUtLLEtBQUwsQ0FBV0YsQ0FBWCxFQUFjckMsSUFBZCxDQUFtQjNFLE1BQW5CLEdBQTBCLENBQTFELENBQXBCO0FBQ0EsY0FBSTZHLEtBQUtLLEtBQUwsQ0FBV0YsQ0FBWCxFQUFjaEMsUUFBZCxLQUEyQnZGLGdCQUEvQixFQUFpRDtBQUMvQzJFLGlCQUFLekMsWUFBTCxDQUFrQk4sR0FBbEIsQ0FBc0JsQixPQUFPMEcsS0FBS0ssS0FBTCxDQUFXRixDQUFYLEVBQWNaLEtBQXJCLEdBQTZCLEdBQW5ELEVBQXdEUyxLQUFLSyxLQUFMLENBQVdGLENBQVgsRUFBYzVCLEVBQXRFO0FBQ0EwQixxQkFBU0QsS0FBS0ssS0FBTCxDQUFXRixDQUFYLEVBQWNaLEtBQWQsR0FBc0IsR0FBL0IsSUFBc0M7QUFDcENlLG9CQUFNekM7QUFEOEIsYUFBdEM7QUFHRCxXQUxELE1BS087QUFDTE4saUJBQUt6QyxZQUFMLENBQWtCTixHQUFsQixDQUFzQmxCLE9BQU8wRyxLQUFLSyxLQUFMLENBQVdGLENBQVgsRUFBY1osS0FBM0MsRUFBa0RTLEtBQUtLLEtBQUwsQ0FBV0YsQ0FBWCxFQUFjNUIsRUFBaEU7QUFDQTBCLHFCQUFTRCxLQUFLSyxLQUFMLENBQVdGLENBQVgsRUFBY1osS0FBdkIsSUFBZ0M7QUFDOUJlLG9CQUFNekMsaUJBRHdCO0FBRTlCLDhCQUFnQm1DLEtBQUtLLEtBQUwsQ0FBV0YsQ0FBWCxFQUFjaEMsUUFGQTtBQUc5QixnQ0FBa0I2QixLQUFLSyxLQUFMLENBQVdGLENBQVgsRUFBY0k7QUFIRixhQUFoQztBQUtEO0FBQ0Y7QUFDRDtBQUNBLGVBQU92QyxRQUFRQyxPQUFSLENBQWdCLEVBQUNDLFlBQVksR0FBYixFQUFrQmIsTUFBTTRDLFFBQXhCLEVBQWtDM0MsYUFBYXpFLGdCQUEvQyxFQUFpRXVGLFVBQVU3RCxTQUEzRSxFQUFoQixDQUFQO0FBQ0QsT0FuQ00sQ0FBUDtBQW9DRCxLQTVDTSxDQUFQO0FBNkNELEdBNVJIOztBQThSRTZFLGdCQUFjLHNCQUFVOUYsSUFBVixFQUFnQjtBQUM1QixRQUFJa0gsYUFBYW5ILFdBQVdDLElBQVgsQ0FBakI7QUFDQSxRQUFJaUUsT0FBTyxJQUFYO0FBQ0EsV0FBT0EsS0FBS2UsVUFBTCxDQUFnQmtDLFVBQWhCLEVBQTRCckUsSUFBNUIsQ0FBaUMsVUFBVWtELFFBQVYsRUFBb0I7QUFDMUQsVUFBSUEsUUFBSixFQUFjO0FBQ1osZUFBT3JCLFFBQVFDLE9BQVIsQ0FBZ0JvQixRQUFoQixDQUFQO0FBQ0QsT0FGRCxNQUVPO0FBQ0wsZUFBTzlCLEtBQUtrRCxhQUFMLENBQW1CRCxVQUFuQixDQUFQO0FBQ0Q7QUFDRixLQU5NLENBQVA7QUFPRCxHQXhTSDs7QUEwU0VDLGlCQUFlLHVCQUFVbkgsSUFBVixFQUFnQjtBQUM3QixRQUFJaUUsT0FBTyxJQUFYO0FBQ0EsV0FBT0EsS0FBSzZCLFlBQUwsQ0FBa0I5RixJQUFsQixFQUF3QjZDLElBQXhCLENBQTZCLFVBQVVrRCxRQUFWLEVBQW9CO0FBQ3RELGFBQU85QixLQUFLc0IsUUFBTCxDQUFjLE1BQWQsRUFBc0JyRyxXQUFXLGlCQUFqQyxFQUFvRDtBQUN6RDZFLGNBQU1wQyxLQUFLWSxTQUFMLENBQWU7QUFDbkIwRCxpQkFBT3ZHLHNCQUFzQlEsU0FBU0YsSUFBVCxDQUF0QixDQURZO0FBRW5CNkUsb0JBQVV2RixnQkFGUztBQUduQjRHLG1CQUFTLENBQUM7QUFDUmpCLGdCQUFJYztBQURJLFdBQUQ7QUFIVSxTQUFmLENBRG1EO0FBUXpESixpQkFBUztBQUNQLDBCQUFnQjtBQURUO0FBUmdELE9BQXBELEVBV0o5QyxJQVhJLENBV0MsVUFBVXNCLFFBQVYsRUFBb0I7QUFDMUIsWUFBSUUsT0FBTzFDLEtBQUtDLEtBQUwsQ0FBV3VDLFNBQVNHLFlBQXBCLENBQVg7QUFDQSxlQUFPSSxRQUFRQyxPQUFSLENBQWdCTixLQUFLWSxFQUFyQixDQUFQO0FBQ0QsT0FkTSxDQUFQO0FBZUQsS0FoQk0sQ0FBUDtBQWlCRCxHQTdUSDs7QUErVEVELGNBQVksb0JBQVVoRixJQUFWLEVBQWdCO0FBQzFCLFFBQUlpRSxPQUFPLElBQVg7QUFDQSxRQUFJZ0IsRUFBSjtBQUNBLFFBQUlqRixTQUFTLEdBQWIsRUFBa0I7QUFDaEI7QUFDQSxhQUFPMEUsUUFBUUMsT0FBUixDQUFnQixNQUFoQixDQUFQO0FBQ0QsS0FIRCxNQUdPLElBQUtNLEtBQUssS0FBS3pELFlBQUwsQ0FBa0JmLEdBQWxCLENBQXNCVCxJQUF0QixDQUFWLEVBQXdDO0FBQzdDO0FBQ0EsYUFBTzBFLFFBQVFDLE9BQVIsQ0FBZ0JNLEVBQWhCLENBQVA7QUFDRDtBQUNEO0FBQ0E7QUFDQSxXQUFPaEIsS0FBS0wsVUFBTCxDQUFnQjdELFdBQVdDLElBQVgsQ0FBaEIsRUFBa0M2QyxJQUFsQyxDQUF1QyxZQUFZO0FBQ3hEb0MsV0FBS2hCLEtBQUt6QyxZQUFMLENBQWtCZixHQUFsQixDQUFzQlQsSUFBdEIsQ0FBTDtBQUNBLFVBQUksQ0FBQ2lGLEVBQUwsRUFBUztBQUNQLFlBQUlqRixLQUFLSixNQUFMLENBQVksQ0FBQyxDQUFiLE1BQW9CLEdBQXhCLEVBQTZCO0FBQzNCLGlCQUFPcUUsS0FBS2tELGFBQUwsQ0FBbUJuSCxJQUFuQixFQUF5QjZDLElBQXpCLENBQThCLFlBQVk7QUFDL0MsbUJBQU9vQixLQUFLZSxVQUFMLENBQWdCaEYsSUFBaEIsQ0FBUDtBQUNELFdBRk0sQ0FBUDtBQUdELFNBSkQsTUFJTztBQUNMLGlCQUFPMEUsUUFBUUMsT0FBUixFQUFQO0FBQ0Q7QUFDRjtBQUNELGFBQU9ELFFBQVFDLE9BQVIsQ0FBZ0JNLEVBQWhCLENBQVA7QUFDRCxLQVpNLENBQVA7QUFhRCxHQXhWSDs7QUEwVkVJLFlBQVUsa0JBQVVKLEVBQVYsRUFBYztBQUN0QixXQUFPLEtBQUtNLFFBQUwsQ0FBYyxLQUFkLEVBQXFCckcsV0FBVyxrQkFBWCxHQUFnQytGLEVBQXJELEVBQXlELEVBQXpELEVBQTZEcEMsSUFBN0QsQ0FBa0UsVUFBVXNCLFFBQVYsRUFBb0I7QUFDM0YsVUFBSUEsU0FBU0MsTUFBVCxLQUFvQixHQUF4QixFQUE2QjtBQUMzQixlQUFPTSxRQUFRQyxPQUFSLENBQWdCaEQsS0FBS0MsS0FBTCxDQUFXdUMsU0FBU0csWUFBcEIsQ0FBaEIsQ0FBUDtBQUNELE9BRkQsTUFFTztBQUNMLGVBQU9JLFFBQVFLLE1BQVIsQ0FBZSxtQ0FBbUNFLEVBQW5DLEdBQXdDLHdCQUF4QyxHQUFtRWQsU0FBU0MsTUFBM0YsQ0FBUDtBQUNEO0FBQ0YsS0FOTSxDQUFQO0FBT0Q7O0FBbFdILGtEQTZXUSxnQkFBWTtBQUNoQixNQUFJb0IsTUFBTXRHLFdBQVcsaUJBQXJCO0FBQ0E7QUFDQSxTQUFPLEtBQUtxRyxRQUFMLENBQWMsS0FBZCxFQUFxQkMsR0FBckIsRUFBMEIsRUFBMUIsRUFBOEIzQyxJQUE5QixDQUFtQyxVQUFVNEMsSUFBVixFQUFlO0FBQ3ZELFFBQUk7QUFDRixVQUFJN0MsT0FBT2pCLEtBQUtDLEtBQUwsQ0FBVzZELEtBQUtuQixZQUFoQixDQUFYO0FBQ0EsYUFBT0ksUUFBUUMsT0FBUixDQUFnQi9CLElBQWhCLENBQVA7QUFDRCxLQUhELENBR0UsT0FBT2IsQ0FBUCxFQUFVO0FBQ1YsYUFBTzJDLFFBQVFLLE1BQVIsQ0FBZWhELENBQWYsQ0FBUDtBQUNEO0FBQ0YsR0FQTSxDQUFQO0FBUUQsQ0F4WEgsc0RBMlhZLGtCQUFVcUYsTUFBVixFQUFrQjVCLEdBQWxCLEVBQXVCN0IsT0FBdkIsRUFBZ0M7QUFDeEMsTUFBSU0sT0FBTyxJQUFYOztBQUVBLE1BQUksQ0FBRU4sUUFBUWdDLE9BQWQsRUFBdUI7QUFBRWhDLFlBQVFnQyxPQUFSLEdBQWtCLEVBQWxCO0FBQXVCO0FBQ2hEaEMsVUFBUWdDLE9BQVIsQ0FBZ0IsZUFBaEIsSUFBbUMsWUFBWTFCLEtBQUs3QixLQUFwRDs7QUFFQSxPQUFLTSxLQUFMLENBQVcsV0FBWCxFQUF3QjtBQUN0QjBFLFlBQVFBLE1BRGM7QUFFdEI1SCxjQUFVQSxTQUFTZ0csR0FBVDtBQUZZLEdBQXhCOztBQUtBLFNBQU96RyxXQUFXc0ksT0FBWCxDQUFtQkMsSUFBbkIsQ0FBd0IsSUFBeEIsRUFBOEJGLE1BQTlCLEVBQXNDNUIsR0FBdEMsRUFBMkM3QixPQUEzQyxFQUFvRGQsSUFBcEQsQ0FBeUQsVUFBUzBFLEdBQVQsRUFBYztBQUM1RTtBQUNBLFFBQUlBLE9BQU9BLElBQUluRCxNQUFKLEtBQWUsR0FBMUIsRUFBK0I7QUFDN0JILFdBQUtYLE9BQUw7QUFDQTtBQUNELEtBSEQsTUFHTztBQUNMLFVBQUksQ0FBQ1csS0FBSy9CLE1BQVYsRUFBa0I7QUFDaEIrQixhQUFLL0IsTUFBTCxHQUFjLElBQWQ7QUFDQStCLGFBQUsxQyxFQUFMLENBQVFtQixLQUFSLENBQWMsZ0JBQWQ7QUFDRDtBQUNEdUIsV0FBS3ZCLEtBQUwsQ0FBVyxXQUFYLEVBQXdCO0FBQ3RCMEUsZ0JBQVFBLE1BRGM7QUFFdEI1SCxrQkFBVUEsU0FBU2dHLEdBQVQsQ0FGWTtBQUd0QmdDLGlCQUFTO0FBSGEsT0FBeEI7O0FBTUEsYUFBTzlDLFFBQVFDLE9BQVIsQ0FBZ0I0QyxHQUFoQixDQUFQO0FBQ0Q7QUFDRixHQWxCTSxFQWtCSixVQUFTRSxLQUFULEVBQWdCO0FBQ2pCLFFBQUl4RCxLQUFLL0IsTUFBVCxFQUFpQjtBQUNmK0IsV0FBSy9CLE1BQUwsR0FBYyxLQUFkO0FBQ0ErQixXQUFLMUMsRUFBTCxDQUFRbUIsS0FBUixDQUFjLGlCQUFkO0FBQ0Q7QUFDRHVCLFNBQUt2QixLQUFMLENBQVcsV0FBWCxFQUF3QjtBQUN0QjBFLGNBQVFBLE1BRGM7QUFFdEI1SCxnQkFBVUEsU0FBU2dHLEdBQVQsQ0FGWTtBQUd0QmdDLGVBQVM7QUFIYSxLQUF4Qjs7QUFNQSxXQUFPOUMsUUFBUUssTUFBUixDQUFlMEMsS0FBZixDQUFQO0FBQ0QsR0E5Qk0sQ0FBUDtBQStCRCxDQXJhSDs7QUF3YUFyRyxZQUFZc0csUUFBWixHQUF1QixVQUFVckcsYUFBVixFQUF5QjtBQUM5QyxNQUFJc0csU0FBU3RHLGNBQWN1RyxPQUFkLENBQXNCQyxXQUFuQztBQUNBLE1BQUlGLE1BQUosRUFBWTtBQUNWdEcsa0JBQWN3RyxXQUFkLEdBQTRCLElBQUl6RyxXQUFKLENBQWdCQyxhQUFoQixFQUErQnNHLE9BQU9yRyxRQUF0QyxDQUE1QjtBQUNBLFFBQUlELGNBQWN5RyxPQUFkLEtBQTBCLGFBQTlCLEVBQTZDO0FBQzNDekcsb0JBQWMwRyxXQUFkLEdBQTRCMUcsY0FBYzJHLE1BQTFDO0FBQ0EzRyxvQkFBYzJHLE1BQWQsR0FBdUIzRyxjQUFjd0csV0FBckM7QUFDRDtBQUNGO0FBQ0YsQ0FURDs7QUFXQXpHLFlBQVk2RyxhQUFaLEdBQTRCLFVBQVUxRyxFQUFWLEVBQWM7QUFDeEMsU0FBTyxJQUFQO0FBQ0QsQ0FGRDs7QUFJQUgsWUFBWThHLFdBQVosR0FBMEIsVUFBVTdHLGFBQVYsRUFBeUI7QUFDakRBLGdCQUFja0MsVUFBZCxDQUF5QnRDLFNBQXpCO0FBQ0EsTUFBSUksY0FBYzBHLFdBQWxCLEVBQStCO0FBQzdCMUcsa0JBQWMyRyxNQUFkLEdBQXVCM0csY0FBYzBHLFdBQXJDO0FBQ0EsV0FBTzFHLGNBQWMwRyxXQUFyQjtBQUNEO0FBQ0YsQ0FORDs7QUFTQUksT0FBT0MsT0FBUCxHQUFpQmhILFdBQWpCIiwiZmlsZSI6IjE1LmpzIiwic291cmNlc0NvbnRlbnQiOlsiXG4gIC8qKlxuICAgKiBDbGFzczogR29vZ2xlRHJpdmVcbiAgICpcbiAgICogV09SSyBJTiBQUk9HUkVTUywgTk9UIFJFQ09NTUVOREVEIEZPUiBQUk9EVUNUSU9OIFVTRVxuICAgKlxuICAgKiBUbyB1c2UgdGhpcyBiYWNrZW5kLCB5b3UgbmVlZCB0byBzcGVjaWZ5IHRoZSBhcHAncyBjbGllbnQgSUQgbGlrZSBzbzpcbiAgICpcbiAgICogKHN0YXJ0IGNvZGUpXG4gICAqXG4gICAqIHJlbW90ZVN0b3JhZ2Uuc2V0QXBpS2V5cygnZ29vZ2xlZHJpdmUnLCB7XG4gICAqICAgY2xpZW50SWQ6ICd5b3VyLWNsaWVudC1pZCdcbiAgICogfSk7XG4gICAqXG4gICAqIChlbmQgY29kZSlcbiAgICpcbiAgICogQW4gY2xpZW50IElEIGNhbiBiZSBvYnRhaW5lZCBieSByZWdpc3RlcmluZyB5b3VyIGFwcCBpbiB0aGUgR29vZ2xlXG4gICAqIERldmVsb3BlcnMgQ29uc29sZTogaHR0cHM6Ly9kZXZlbG9wZXJzLmdvb2dsZS5jb20vZHJpdmUvd2ViL2F1dGgvd2ViLWNsaWVudFxuICAgKlxuICAgKiBEb2NzOiBodHRwczovL2RldmVsb3BlcnMuZ29vZ2xlLmNvbS9kcml2ZS93ZWIvYXV0aC93ZWItY2xpZW50I2NyZWF0ZV9hX2NsaWVudF9pZF9hbmRfY2xpZW50X3NlY3JldFxuICAgKiovXG5cbiAgdmFyIEF1dGhvcml6ZSA9IHJlcXVpcmUoJy4vYXV0aG9yaXplJyk7XG4gIHZhciBXaXJlQ2xpZW50ID0gcmVxdWlyZSgnLi93aXJlY2xpZW50Jyk7XG4gIHZhciBldmVudEhhbmRsaW5nID0gcmVxdWlyZSgnLi9ldmVudGhhbmRsaW5nJyk7XG4gIHZhciB1dGlsID0gcmVxdWlyZSgnLi91dGlsJyk7XG5cbiAgdmFyIEJBU0VfVVJMID0gJ2h0dHBzOi8vd3d3Lmdvb2dsZWFwaXMuY29tJztcbiAgdmFyIEFVVEhfVVJMID0gJ2h0dHBzOi8vYWNjb3VudHMuZ29vZ2xlLmNvbS9vL29hdXRoMi9hdXRoJztcbiAgdmFyIEFVVEhfU0NPUEUgPSAnaHR0cHM6Ly93d3cuZ29vZ2xlYXBpcy5jb20vYXV0aC9kcml2ZSc7XG4gIHZhciBTRVRUSU5HU19LRVkgPSAncmVtb3Rlc3RvcmFnZTpnb29nbGVkcml2ZSc7XG5cbiAgdmFyIEdEX0RJUl9NSU1FX1RZUEUgPSAnYXBwbGljYXRpb24vdm5kLmdvb2dsZS1hcHBzLmZvbGRlcic7XG4gIHZhciBSU19ESVJfTUlNRV9UWVBFID0gJ2FwcGxpY2F0aW9uL2pzb247IGNoYXJzZXQ9VVRGLTgnO1xuXG4gIHZhciBpc0ZvbGRlciA9IHV0aWwuaXNGb2xkZXI7XG4gIHZhciBoYXNMb2NhbFN0b3JhZ2U7XG5cbiAgLy8gZnVuY3Rpb24gYnVpbGRRdWVyeVN0cmluZyhwYXJhbXMpIHtcbiAgLy8gICByZXR1cm4gT2JqZWN0LmtleXMocGFyYW1zKS5tYXAoZnVuY3Rpb24gKGtleSkge1xuICAvLyAgICAgcmV0dXJuIGVuY29kZVVSSUNvbXBvbmVudChrZXkpICsgJz0nICsgZW5jb2RlVVJJQ29tcG9uZW50KHBhcmFtc1trZXldKTtcbiAgLy8gICB9KS5qb2luKCcmJyk7XG4gIC8vIH1cblxuICAvLyBmdW5jdGlvbiBmaWxlTmFtZUZyb21NZXRhKG1ldGEpIHtcbiAgLy8gICByZXR1cm4gZW5jb2RlVVJJQ29tcG9uZW50KG1ldGEudGl0bGUpICsgKG1ldGEubWltZVR5cGUgPT09IEdEX0RJUl9NSU1FX1RZUEUgPyAnLycgOiAnJyk7XG4gIC8vIH1cblxuICBmdW5jdGlvbiBtZXRhVGl0bGVGcm9tRmlsZU5hbWUoZmlsZW5hbWUpIHtcbiAgICBpZiAoZmlsZW5hbWUuc3Vic3RyKC0xKSA9PT0gJy8nKSB7XG4gICAgICBmaWxlbmFtZSA9IGZpbGVuYW1lLnN1YnN0cigwLCBmaWxlbmFtZS5sZW5ndGggLSAxKTtcbiAgICB9XG4gICAgcmV0dXJuIGRlY29kZVVSSUNvbXBvbmVudChmaWxlbmFtZSk7XG4gIH1cblxuICBmdW5jdGlvbiBwYXJlbnRQYXRoKHBhdGgpIHtcbiAgICByZXR1cm4gcGF0aC5yZXBsYWNlKC9bXlxcL10rXFwvPyQvLCAnJyk7XG4gIH1cblxuICBmdW5jdGlvbiBiYXNlTmFtZShwYXRoKSB7XG4gICAgdmFyIHBhcnRzID0gcGF0aC5zcGxpdCgnLycpO1xuICAgIGlmIChwYXRoLnN1YnN0cigtMSkgPT09ICcvJykge1xuICAgICAgcmV0dXJuIHBhcnRzW3BhcnRzLmxlbmd0aC0yXSsnLyc7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBwYXJ0c1twYXJ0cy5sZW5ndGgtMV07XG4gICAgfVxuICB9XG5cbiAgdmFyIENhY2hlID0gZnVuY3Rpb24gKG1heEFnZSkge1xuICAgIHRoaXMubWF4QWdlID0gbWF4QWdlO1xuICAgIHRoaXMuX2l0ZW1zID0ge307XG4gIH07XG5cbiAgQ2FjaGUucHJvdG90eXBlID0ge1xuICAgIGdldDogZnVuY3Rpb24gKGtleSkge1xuICAgICAgdmFyIGl0ZW0gPSB0aGlzLl9pdGVtc1trZXldO1xuICAgICAgdmFyIG5vdyA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuICAgICAgcmV0dXJuIChpdGVtICYmIGl0ZW0udCA+PSAobm93IC0gdGhpcy5tYXhBZ2UpKSA/IGl0ZW0udiA6IHVuZGVmaW5lZDtcbiAgICB9LFxuXG4gICAgc2V0OiBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICAgICAgdGhpcy5faXRlbXNba2V5XSA9IHtcbiAgICAgICAgdjogdmFsdWUsXG4gICAgICAgIHQ6IG5ldyBEYXRlKCkuZ2V0VGltZSgpXG4gICAgICB9O1xuICAgIH1cbiAgfTtcblxuICB2YXIgR29vZ2xlRHJpdmUgPSBmdW5jdGlvbiAocmVtb3RlU3RvcmFnZSwgY2xpZW50SWQpIHtcblxuICAgIGV2ZW50SGFuZGxpbmcodGhpcywgJ2NoYW5nZScsICdjb25uZWN0ZWQnLCAnd2lyZS1idXN5JywgJ3dpcmUtZG9uZScsICdub3QtY29ubmVjdGVkJyk7XG5cbiAgICB0aGlzLnJzID0gcmVtb3RlU3RvcmFnZTtcbiAgICB0aGlzLmNsaWVudElkID0gY2xpZW50SWQ7XG5cbiAgICB0aGlzLl9maWxlSWRDYWNoZSA9IG5ldyBDYWNoZSg2MCAqIDUpOyAvLyBpZHMgZXhwaXJlIGFmdGVyIDUgbWludXRlcyAoaXMgdGhpcyBhIGdvb2QgaWRlYT8pXG5cbiAgICBoYXNMb2NhbFN0b3JhZ2UgPSB1dGlsLmxvY2FsU3RvcmFnZUF2YWlsYWJsZSgpO1xuXG4gICAgaWYgKGhhc0xvY2FsU3RvcmFnZSl7XG4gICAgICB2YXIgc2V0dGluZ3M7XG4gICAgICB0cnkge1xuICAgICAgICBzZXR0aW5ncyA9IEpTT04ucGFyc2UobG9jYWxTdG9yYWdlLmdldEl0ZW0oU0VUVElOR1NfS0VZKSk7XG4gICAgICB9IGNhdGNoKGUpe31cbiAgICAgIGlmIChzZXR0aW5ncykge1xuICAgICAgICB0aGlzLmNvbmZpZ3VyZShzZXR0aW5ncyk7XG4gICAgICB9XG4gICAgfVxuXG4gIH07XG5cbiAgR29vZ2xlRHJpdmUucHJvdG90eXBlID0ge1xuICAgIGNvbm5lY3RlZDogZmFsc2UsXG4gICAgb25saW5lOiB0cnVlLFxuXG4gICAgY29uZmlndXJlOiBmdW5jdGlvbiAoc2V0dGluZ3MpIHsgLy8gU2V0dGluZ3MgcGFyYW1ldGVyIGNvbXBhdGlibGUgd2l0aCBXaXJlQ2xpZW50XG4gICAgICAvLyBXZSBvbmx5IHVwZGF0ZSB0aGlzLnVzZXJBZGRyZXNzIGlmIHNldHRpbmdzLnVzZXJBZGRyZXNzIGlzIHNldCB0byBhIHN0cmluZyBvciB0byBudWxsXG4gICAgICBpZiAodHlwZW9mIHNldHRpbmdzLnVzZXJBZGRyZXNzICE9PSAndW5kZWZpbmVkJykgeyB0aGlzLnVzZXJBZGRyZXNzID0gc2V0dGluZ3MudXNlckFkZHJlc3M7IH1cbiAgICAgIC8vIFNhbWUgZm9yIHRoaXMudG9rZW4uIElmIG9ubHkgb25lIG9mIHRoZXNlIHR3byBpcyBzZXQsIHdlIGxlYXZlIHRoZSBvdGhlciBvbmUgYXQgaXRzIGV4aXN0aW5nIHZhbHVlXG4gICAgICBpZiAodHlwZW9mIHNldHRpbmdzLnRva2VuICE9PSAndW5kZWZpbmVkJykgeyB0aGlzLnRva2VuID0gc2V0dGluZ3MudG9rZW47IH1cblxuICAgICAgdmFyIHdyaXRlU2V0dGluZ3NUb0NhY2hlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmIChoYXNMb2NhbFN0b3JhZ2UpIHtcbiAgICAgICAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbShTRVRUSU5HU19LRVksIEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICAgIHVzZXJBZGRyZXNzOiB0aGlzLnVzZXJBZGRyZXNzLFxuICAgICAgICAgICAgdG9rZW46IHRoaXMudG9rZW5cbiAgICAgICAgICB9KSk7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIHZhciBoYW5kbGVFcnJvciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLmNvbm5lY3RlZCA9IGZhbHNlO1xuICAgICAgICBkZWxldGUgdGhpcy50b2tlbjtcbiAgICAgICAgaWYgKGhhc0xvY2FsU3RvcmFnZSkge1xuICAgICAgICAgIGxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKFNFVFRJTkdTX0tFWSk7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIGlmICh0aGlzLnRva2VuKSB7XG4gICAgICAgIHRoaXMuY29ubmVjdGVkID0gdHJ1ZTtcblxuICAgICAgICBpZiAodGhpcy51c2VyQWRkcmVzcykge1xuICAgICAgICAgIHRoaXMuX2VtaXQoJ2Nvbm5lY3RlZCcpO1xuICAgICAgICAgIHdyaXRlU2V0dGluZ3NUb0NhY2hlLmFwcGx5KHRoaXMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuaW5mbygpLnRoZW4oZnVuY3Rpb24oaW5mbykge1xuICAgICAgICAgICAgdGhpcy51c2VyQWRkcmVzcyA9IGluZm8udXNlci5lbWFpbEFkZHJlc3M7XG4gICAgICAgICAgICB0aGlzLnJzLndpZGdldC52aWV3LnNldFVzZXJBZGRyZXNzKHRoaXMudXNlckFkZHJlc3MpO1xuICAgICAgICAgICAgdGhpcy5fZW1pdCgnY29ubmVjdGVkJyk7XG4gICAgICAgICAgICB3cml0ZVNldHRpbmdzVG9DYWNoZS5hcHBseSh0aGlzKTtcbiAgICAgICAgICB9LmJpbmQodGhpcykpLmNhdGNoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgaGFuZGxlRXJyb3IuYXBwbHkodGhpcyk7XG4gICAgICAgICAgICB0aGlzLnJzLl9lbWl0KCdlcnJvcicsIG5ldyBFcnJvcignQ291bGQgbm90IGZldGNoIHVzZXIgaW5mby4nKSk7XG4gICAgICAgICAgfS5iaW5kKHRoaXMpKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaGFuZGxlRXJyb3IuYXBwbHkodGhpcyk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIGNvbm5lY3Q6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMucnMuc2V0QmFja2VuZCgnZ29vZ2xlZHJpdmUnKTtcbiAgICAgIEF1dGhvcml6ZSh0aGlzLnJzLCBBVVRIX1VSTCwgQVVUSF9TQ09QRSwgU3RyaW5nKEF1dGhvcml6ZS5nZXRMb2NhdGlvbigpKSwgdGhpcy5jbGllbnRJZCk7XG4gICAgfSxcblxuICAgIHN0b3BXYWl0aW5nRm9yVG9rZW46IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICghdGhpcy5jb25uZWN0ZWQpIHtcbiAgICAgICAgdGhpcy5fZW1pdCgnbm90LWNvbm5lY3RlZCcpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBnZXQ6IGZ1bmN0aW9uIChwYXRoLCBvcHRpb25zKSB7XG4gICAgICBpZiAocGF0aC5zdWJzdHIoLTEpID09PSAnLycpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2dldEZvbGRlcihwYXRoLCBvcHRpb25zKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9nZXRGaWxlKHBhdGgsIG9wdGlvbnMpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBwdXQ6IGZ1bmN0aW9uIChwYXRoLCBib2R5LCBjb250ZW50VHlwZSwgb3B0aW9ucykge1xuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgZnVuY3Rpb24gcHV0RG9uZShyZXNwb25zZSkge1xuICAgICAgICBpZiAocmVzcG9uc2Uuc3RhdHVzID49IDIwMCAmJiByZXNwb25zZS5zdGF0dXMgPCAzMDApIHtcbiAgICAgICAgICB2YXIgbWV0YSA9IEpTT04ucGFyc2UocmVzcG9uc2UucmVzcG9uc2VUZXh0KTtcbiAgICAgICAgICB2YXIgZXRhZ1dpdGhvdXRRdW90ZXMgPSBtZXRhLmV0YWcuc3Vic3RyaW5nKDEsIG1ldGEuZXRhZy5sZW5ndGgtMSk7XG4gICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh7c3RhdHVzQ29kZTogMjAwLCBjb250ZW50VHlwZTogbWV0YS5taW1lVHlwZSwgcmV2aXNpb246IGV0YWdXaXRob3V0UXVvdGVzfSk7XG4gICAgICAgIH0gZWxzZSBpZiAocmVzcG9uc2Uuc3RhdHVzID09PSA0MTIpIHtcbiAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHtzdGF0dXNDb2RlOiA0MTIsIHJldmlzaW9uOiAnY29uZmxpY3QnfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KFwiUFVUIGZhaWxlZCB3aXRoIHN0YXR1cyBcIiArIHJlc3BvbnNlLnN0YXR1cyArIFwiIChcIiArIHJlc3BvbnNlLnJlc3BvbnNlVGV4dCArIFwiKVwiKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHNlbGYuX2dldEZpbGVJZChwYXRoKS50aGVuKGZ1bmN0aW9uIChpZCkge1xuICAgICAgICBpZiAoaWQpIHtcbiAgICAgICAgICBpZiAob3B0aW9ucyAmJiAob3B0aW9ucy5pZk5vbmVNYXRjaCA9PT0gJyonKSkge1xuICAgICAgICAgICAgcmV0dXJuIHB1dERvbmUoeyBzdGF0dXM6IDQxMiB9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHNlbGYuX3VwZGF0ZUZpbGUoaWQsIHBhdGgsIGJvZHksIGNvbnRlbnRUeXBlLCBvcHRpb25zKS50aGVuKHB1dERvbmUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBzZWxmLl9jcmVhdGVGaWxlKHBhdGgsIGJvZHksIGNvbnRlbnRUeXBlLCBvcHRpb25zKS50aGVuKHB1dERvbmUpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9LFxuXG4gICAgJ2RlbGV0ZSc6IGZ1bmN0aW9uIChwYXRoLCBvcHRpb25zKSB7XG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICByZXR1cm4gc2VsZi5fZ2V0RmlsZUlkKHBhdGgpLnRoZW4oZnVuY3Rpb24gKGlkKSB7XG4gICAgICAgIGlmICghaWQpIHtcbiAgICAgICAgICAvLyBGaWxlIGRvZXNuJ3QgZXhpc3QuIElnbm9yZS5cbiAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHtzdGF0dXNDb2RlOiAyMDB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBzZWxmLl9nZXRNZXRhKGlkKS50aGVuKGZ1bmN0aW9uIChtZXRhKSB7XG4gICAgICAgICAgdmFyIGV0YWdXaXRob3V0UXVvdGVzO1xuICAgICAgICAgIGlmICgodHlwZW9mIG1ldGEgPT09ICdvYmplY3QnKSAmJiAodHlwZW9mIG1ldGEuZXRhZyA9PT0gJ3N0cmluZycpKSB7XG4gICAgICAgICAgICBldGFnV2l0aG91dFF1b3RlcyA9IG1ldGEuZXRhZy5zdWJzdHJpbmcoMSwgbWV0YS5ldGFnLmxlbmd0aC0xKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5pZk1hdGNoICYmIChvcHRpb25zLmlmTWF0Y2ggIT09IGV0YWdXaXRob3V0UXVvdGVzKSkge1xuICAgICAgICAgICAgcmV0dXJuIHtzdGF0dXNDb2RlOiA0MTIsIHJldmlzaW9uOiBldGFnV2l0aG91dFF1b3Rlc307XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHNlbGYuX3JlcXVlc3QoJ0RFTEVURScsIEJBU0VfVVJMICsgJy9kcml2ZS92Mi9maWxlcy8nICsgaWQsIHt9KS50aGVuKGZ1bmN0aW9uIChyZXNwb25zZSkge1xuICAgICAgICAgICAgaWYgKHJlc3BvbnNlLnN0YXR1cyA9PT0gMjAwIHx8IHJlc3BvbnNlLnN0YXR1cyA9PT0gMjA0KSB7XG4gICAgICAgICAgICAgIHJldHVybiB7c3RhdHVzQ29kZTogMjAwfTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChcIkRlbGV0ZSBmYWlsZWQ6IFwiICsgcmVzcG9uc2Uuc3RhdHVzICsgXCIgKFwiICsgcmVzcG9uc2UucmVzcG9uc2VUZXh0ICsgXCIpXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNZXRob2Q6IGluZm9cbiAgICAgKlxuICAgICAqIEZldGNoZXMgdGhlIHVzZXIncyBpbmZvIGZyb20gR29vZ2xlIGFuZCByZXR1cm5zIGEgcHJvbWlzZSBmb3IgaXQuXG4gICAgICpcbiAgICAgKiBSZXR1cm5zOlxuICAgICAqXG4gICAgICogICBBIHByb21pc2UgdG8gdGhlIHVzZXIncyBpbmZvXG4gICAgICovXG4gICAgaW5mbzogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHVybCA9IEJBU0VfVVJMICsgJy9kcml2ZS92Mi9hYm91dD9maWVsZHM9dXNlcic7XG4gICAgICAvLyByZXF1ZXN0aW5nIHVzZXIgaW5mbyhtYWlubHkgZm9yIHVzZXJBZHJlc3MpXG4gICAgICByZXR1cm4gdGhpcy5fcmVxdWVzdCgnR0VUJywgdXJsLCB7fSkudGhlbihmdW5jdGlvbiAocmVzcCl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdmFyIGluZm8gPSBKU09OLnBhcnNlKHJlc3AucmVzcG9uc2VUZXh0KTtcbiAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGluZm8pO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGUpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9LFxuXG4gICAgX3VwZGF0ZUZpbGU6IGZ1bmN0aW9uIChpZCwgcGF0aCwgYm9keSwgY29udGVudFR5cGUsIG9wdGlvbnMpIHtcbiAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgIHZhciBtZXRhZGF0YSA9IHtcbiAgICAgICAgbWltZVR5cGU6IGNvbnRlbnRUeXBlXG4gICAgICB9O1xuICAgICAgdmFyIGhlYWRlcnMgPSB7XG4gICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbjsgY2hhcnNldD1VVEYtOCdcbiAgICAgIH07XG5cbiAgICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMuaWZNYXRjaCkge1xuICAgICAgICBoZWFkZXJzWydJZi1NYXRjaCddID0gJ1wiJyArIG9wdGlvbnMuaWZNYXRjaCArICdcIic7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzZWxmLl9yZXF1ZXN0KCdQVVQnLCBCQVNFX1VSTCArICcvdXBsb2FkL2RyaXZlL3YyL2ZpbGVzLycgKyBpZCArICc/dXBsb2FkVHlwZT1yZXN1bWFibGUnLCB7XG4gICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KG1ldGFkYXRhKSxcbiAgICAgICAgaGVhZGVyczogaGVhZGVyc1xuICAgICAgfSkudGhlbihmdW5jdGlvbiAocmVzcG9uc2UpIHtcbiAgICAgICAgaWYgKHJlc3BvbnNlLnN0YXR1cyA9PT0gNDEyKSB7XG4gICAgICAgICAgcmV0dXJuIChyZXNwb25zZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIHNlbGYuX3JlcXVlc3QoJ1BVVCcsIHJlc3BvbnNlLmdldFJlc3BvbnNlSGVhZGVyKCdMb2NhdGlvbicpLCB7XG4gICAgICAgICAgICBib2R5OiBjb250ZW50VHlwZS5tYXRjaCgvXmFwcGxpY2F0aW9uXFwvanNvbi8pID8gSlNPTi5zdHJpbmdpZnkoYm9keSkgOiBib2R5XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0sXG5cbiAgICBfY3JlYXRlRmlsZTogZnVuY3Rpb24gKHBhdGgsIGJvZHksIGNvbnRlbnRUeXBlLCBvcHRpb25zKSB7XG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICByZXR1cm4gc2VsZi5fZ2V0UGFyZW50SWQocGF0aCkudGhlbihmdW5jdGlvbiAocGFyZW50SWQpIHtcbiAgICAgICAgdmFyIGZpbGVOYW1lID0gYmFzZU5hbWUocGF0aCk7XG4gICAgICAgIHZhciBtZXRhZGF0YSA9IHtcbiAgICAgICAgICB0aXRsZTogbWV0YVRpdGxlRnJvbUZpbGVOYW1lKGZpbGVOYW1lKSxcbiAgICAgICAgICBtaW1lVHlwZTogY29udGVudFR5cGUsXG4gICAgICAgICAgcGFyZW50czogW3tcbiAgICAgICAgICAgIGtpbmQ6IFwiZHJpdmUjZmlsZUxpbmtcIixcbiAgICAgICAgICAgIGlkOiBwYXJlbnRJZFxuICAgICAgICAgIH1dXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBzZWxmLl9yZXF1ZXN0KCdQT1NUJywgQkFTRV9VUkwgKyAnL3VwbG9hZC9kcml2ZS92Mi9maWxlcz91cGxvYWRUeXBlPXJlc3VtYWJsZScsIHtcbiAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShtZXRhZGF0YSksXG4gICAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uOyBjaGFyc2V0PVVURi04J1xuICAgICAgICAgIH1cbiAgICAgICAgfSkudGhlbihmdW5jdGlvbiAocmVzcG9uc2UpIHtcbiAgICAgICAgICByZXR1cm4gc2VsZi5fcmVxdWVzdCgnUE9TVCcsIHJlc3BvbnNlLmdldFJlc3BvbnNlSGVhZGVyKCdMb2NhdGlvbicpLCB7XG4gICAgICAgICAgICBib2R5OiBjb250ZW50VHlwZS5tYXRjaCgvXmFwcGxpY2F0aW9uXFwvanNvbi8pID8gSlNPTi5zdHJpbmdpZnkoYm9keSkgOiBib2R5XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfSxcblxuICAgIF9nZXRGaWxlOiBmdW5jdGlvbiAocGF0aCwgb3B0aW9ucykge1xuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgcmV0dXJuIHNlbGYuX2dldEZpbGVJZChwYXRoKS50aGVuKGZ1bmN0aW9uIChpZCkge1xuICAgICAgICByZXR1cm4gc2VsZi5fZ2V0TWV0YShpZCkudGhlbihmdW5jdGlvbiAobWV0YSkge1xuICAgICAgICAgIHZhciBldGFnV2l0aG91dFF1b3RlcztcbiAgICAgICAgICBpZiAodHlwZW9mKG1ldGEpID09PSAnb2JqZWN0JyAmJiB0eXBlb2YobWV0YS5ldGFnKSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGV0YWdXaXRob3V0UXVvdGVzID0gbWV0YS5ldGFnLnN1YnN0cmluZygxLCBtZXRhLmV0YWcubGVuZ3RoLTEpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMuaWZOb25lTWF0Y2ggJiYgKGV0YWdXaXRob3V0UXVvdGVzID09PSBvcHRpb25zLmlmTm9uZU1hdGNoKSkge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh7c3RhdHVzQ29kZTogMzA0fSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIG9wdGlvbnMyID0ge307XG4gICAgICAgICAgaWYgKCFtZXRhLmRvd25sb2FkVXJsKSB7XG4gICAgICAgICAgICBpZiAobWV0YS5leHBvcnRMaW5rcyAmJiBtZXRhLmV4cG9ydExpbmtzWyd0ZXh0L2h0bWwnXSkge1xuICAgICAgICAgICAgICAvLyBEb2N1bWVudHMgdGhhdCB3ZXJlIGdlbmVyYXRlZCBpbnNpZGUgR29vZ2xlRG9jcyBoYXZlIG5vXG4gICAgICAgICAgICAgIC8vIGRvd25sb2FkVXJsLCBidXQgeW91IGNhbiBleHBvcnQgdGhlbSB0byB0ZXh0L2h0bWwgaW5zdGVhZDpcbiAgICAgICAgICAgICAgbWV0YS5taW1lVHlwZSArPSAnO2V4cG9ydD10ZXh0L2h0bWwnO1xuICAgICAgICAgICAgICBtZXRhLmRvd25sb2FkVXJsID0gbWV0YS5leHBvcnRMaW5rc1sndGV4dC9odG1sJ107XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAvLyBlbXB0eSBmaWxlXG4gICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoe3N0YXR1c0NvZGU6IDIwMCwgYm9keTogJycsIGNvbnRlbnRUeXBlOiBtZXRhLm1pbWVUeXBlLCByZXZpc2lvbjogZXRhZ1dpdGhvdXRRdW90ZXN9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAobWV0YS5taW1lVHlwZS5tYXRjaCgvY2hhcnNldD1iaW5hcnkvKSkge1xuICAgICAgICAgICAgb3B0aW9uczIucmVzcG9uc2VUeXBlID0gJ2Jsb2InO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gc2VsZi5fcmVxdWVzdCgnR0VUJywgbWV0YS5kb3dubG9hZFVybCwgb3B0aW9uczIpLnRoZW4oZnVuY3Rpb24gKHJlc3BvbnNlKSB7XG4gICAgICAgICAgICB2YXIgYm9keSA9IHJlc3BvbnNlLnJlc3BvbnNlO1xuICAgICAgICAgICAgaWYgKG1ldGEubWltZVR5cGUubWF0Y2goL15hcHBsaWNhdGlvblxcL2pzb24vKSkge1xuICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGJvZHkgPSBKU09OLnBhcnNlKGJvZHkpO1xuICAgICAgICAgICAgICB9IGNhdGNoKGUpIHt9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHtzdGF0dXNDb2RlOiAyMDAsIGJvZHk6IGJvZHksIGNvbnRlbnRUeXBlOiBtZXRhLm1pbWVUeXBlLCByZXZpc2lvbjogZXRhZ1dpdGhvdXRRdW90ZXN9KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9LFxuXG4gICAgX2dldEZvbGRlcjogZnVuY3Rpb24gKHBhdGgsIG9wdGlvbnMpIHtcbiAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgIHJldHVybiBzZWxmLl9nZXRGaWxlSWQocGF0aCkudGhlbihmdW5jdGlvbiAoaWQpIHtcbiAgICAgICAgdmFyIHF1ZXJ5LCBmaWVsZHMsIGRhdGEsIGV0YWdXaXRob3V0UXVvdGVzLCBpdGVtc01hcDtcbiAgICAgICAgaWYgKCEgaWQpIHtcbiAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHtzdGF0dXNDb2RlOiA0MDR9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHF1ZXJ5ID0gJ1xcJycgKyBpZCArICdcXCcgaW4gcGFyZW50cyc7XG4gICAgICAgIGZpZWxkcyA9ICdpdGVtcyhkb3dubG9hZFVybCxldGFnLGZpbGVTaXplLGlkLG1pbWVUeXBlLHRpdGxlKSc7XG4gICAgICAgIHJldHVybiBzZWxmLl9yZXF1ZXN0KCdHRVQnLCBCQVNFX1VSTCArICcvZHJpdmUvdjIvZmlsZXM/J1xuICAgICAgICAgICAgKyAncT0nICsgZW5jb2RlVVJJQ29tcG9uZW50KHF1ZXJ5KVxuICAgICAgICAgICAgKyAnJmZpZWxkcz0nICsgZW5jb2RlVVJJQ29tcG9uZW50KGZpZWxkcylcbiAgICAgICAgICAgICsgJyZtYXhSZXN1bHRzPTEwMDAnLFxuICAgICAgICAgICAge30pXG4gICAgICAgIC50aGVuKGZ1bmN0aW9uIChyZXNwb25zZSkge1xuICAgICAgICAgIGlmIChyZXNwb25zZS5zdGF0dXMgIT09IDIwMCkge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KCdyZXF1ZXN0IGZhaWxlZCBvciBzb21ldGhpbmc6ICcgKyByZXNwb25zZS5zdGF0dXMpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBkYXRhID0gSlNPTi5wYXJzZShyZXNwb25zZS5yZXNwb25zZVRleHQpO1xuICAgICAgICAgIH0gY2F0Y2goZSkge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KCdub24tSlNPTiByZXNwb25zZSBmcm9tIEdvb2dsZURyaXZlJyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaXRlbXNNYXAgPSB7fTtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gZGF0YS5pdGVtcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgZXRhZ1dpdGhvdXRRdW90ZXMgPSBkYXRhLml0ZW1zW2ldLmV0YWcuc3Vic3RyaW5nKDEsIGRhdGEuaXRlbXNbaV0uZXRhZy5sZW5ndGgtMSk7XG4gICAgICAgICAgICBpZiAoZGF0YS5pdGVtc1tpXS5taW1lVHlwZSA9PT0gR0RfRElSX01JTUVfVFlQRSkge1xuICAgICAgICAgICAgICBzZWxmLl9maWxlSWRDYWNoZS5zZXQocGF0aCArIGRhdGEuaXRlbXNbaV0udGl0bGUgKyAnLycsIGRhdGEuaXRlbXNbaV0uaWQpO1xuICAgICAgICAgICAgICBpdGVtc01hcFtkYXRhLml0ZW1zW2ldLnRpdGxlICsgJy8nXSA9IHtcbiAgICAgICAgICAgICAgICBFVGFnOiBldGFnV2l0aG91dFF1b3Rlc1xuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgc2VsZi5fZmlsZUlkQ2FjaGUuc2V0KHBhdGggKyBkYXRhLml0ZW1zW2ldLnRpdGxlLCBkYXRhLml0ZW1zW2ldLmlkKTtcbiAgICAgICAgICAgICAgaXRlbXNNYXBbZGF0YS5pdGVtc1tpXS50aXRsZV0gPSB7XG4gICAgICAgICAgICAgICAgRVRhZzogZXRhZ1dpdGhvdXRRdW90ZXMsXG4gICAgICAgICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6IGRhdGEuaXRlbXNbaV0ubWltZVR5cGUsXG4gICAgICAgICAgICAgICAgJ0NvbnRlbnQtTGVuZ3RoJzogZGF0YS5pdGVtc1tpXS5maWxlU2l6ZVxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBGSVhNRTogYWRkIHJldmlzaW9uIG9mIGZvbGRlciFcbiAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHtzdGF0dXNDb2RlOiAyMDAsIGJvZHk6IGl0ZW1zTWFwLCBjb250ZW50VHlwZTogUlNfRElSX01JTUVfVFlQRSwgcmV2aXNpb246IHVuZGVmaW5lZH0pO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH0sXG5cbiAgICBfZ2V0UGFyZW50SWQ6IGZ1bmN0aW9uIChwYXRoKSB7XG4gICAgICB2YXIgZm9sZGVybmFtZSA9IHBhcmVudFBhdGgocGF0aCk7XG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICByZXR1cm4gc2VsZi5fZ2V0RmlsZUlkKGZvbGRlcm5hbWUpLnRoZW4oZnVuY3Rpb24gKHBhcmVudElkKSB7XG4gICAgICAgIGlmIChwYXJlbnRJZCkge1xuICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUocGFyZW50SWQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBzZWxmLl9jcmVhdGVGb2xkZXIoZm9sZGVybmFtZSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0sXG5cbiAgICBfY3JlYXRlRm9sZGVyOiBmdW5jdGlvbiAocGF0aCkge1xuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgcmV0dXJuIHNlbGYuX2dldFBhcmVudElkKHBhdGgpLnRoZW4oZnVuY3Rpb24gKHBhcmVudElkKSB7XG4gICAgICAgIHJldHVybiBzZWxmLl9yZXF1ZXN0KCdQT1NUJywgQkFTRV9VUkwgKyAnL2RyaXZlL3YyL2ZpbGVzJywge1xuICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICAgIHRpdGxlOiBtZXRhVGl0bGVGcm9tRmlsZU5hbWUoYmFzZU5hbWUocGF0aCkpLFxuICAgICAgICAgICAgbWltZVR5cGU6IEdEX0RJUl9NSU1FX1RZUEUsXG4gICAgICAgICAgICBwYXJlbnRzOiBbe1xuICAgICAgICAgICAgICBpZDogcGFyZW50SWRcbiAgICAgICAgICAgIH1dXG4gICAgICAgICAgfSksXG4gICAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uOyBjaGFyc2V0PVVURi04J1xuICAgICAgICAgIH1cbiAgICAgICAgfSkudGhlbihmdW5jdGlvbiAocmVzcG9uc2UpIHtcbiAgICAgICAgICB2YXIgbWV0YSA9IEpTT04ucGFyc2UocmVzcG9uc2UucmVzcG9uc2VUZXh0KTtcbiAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKG1ldGEuaWQpO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH0sXG5cbiAgICBfZ2V0RmlsZUlkOiBmdW5jdGlvbiAocGF0aCkge1xuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgdmFyIGlkO1xuICAgICAgaWYgKHBhdGggPT09ICcvJykge1xuICAgICAgICAvLyBcInJvb3RcIiBpcyBhIHNwZWNpYWwgYWxpYXMgZm9yIHRoZSBmaWxlSWQgb2YgdGhlIHJvb3QgZm9sZGVyXG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoJ3Jvb3QnKTtcbiAgICAgIH0gZWxzZSBpZiAoKGlkID0gdGhpcy5fZmlsZUlkQ2FjaGUuZ2V0KHBhdGgpKSkge1xuICAgICAgICAvLyBpZCBpcyBjYWNoZWQuXG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoaWQpO1xuICAgICAgfVxuICAgICAgLy8gaWQgaXMgbm90IGNhY2hlZCAob3IgZmlsZSBkb2Vzbid0IGV4aXN0KS5cbiAgICAgIC8vIGxvYWQgcGFyZW50IGZvbGRlciBsaXN0aW5nIHRvIHByb3BhZ2F0ZSAvIHVwZGF0ZSBpZCBjYWNoZS5cbiAgICAgIHJldHVybiBzZWxmLl9nZXRGb2xkZXIocGFyZW50UGF0aChwYXRoKSkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlkID0gc2VsZi5fZmlsZUlkQ2FjaGUuZ2V0KHBhdGgpO1xuICAgICAgICBpZiAoIWlkKSB7XG4gICAgICAgICAgaWYgKHBhdGguc3Vic3RyKC0xKSA9PT0gJy8nKSB7XG4gICAgICAgICAgICByZXR1cm4gc2VsZi5fY3JlYXRlRm9sZGVyKHBhdGgpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICByZXR1cm4gc2VsZi5fZ2V0RmlsZUlkKHBhdGgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShpZCk7XG4gICAgICB9KTtcbiAgICB9LFxuXG4gICAgX2dldE1ldGE6IGZ1bmN0aW9uIChpZCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3JlcXVlc3QoJ0dFVCcsIEJBU0VfVVJMICsgJy9kcml2ZS92Mi9maWxlcy8nICsgaWQsIHt9KS50aGVuKGZ1bmN0aW9uIChyZXNwb25zZSkge1xuICAgICAgICBpZiAocmVzcG9uc2Uuc3RhdHVzID09PSAyMDApIHtcbiAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKEpTT04ucGFyc2UocmVzcG9uc2UucmVzcG9uc2VUZXh0KSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KFwicmVxdWVzdCAoZ2V0dGluZyBtZXRhZGF0YSBmb3IgXCIgKyBpZCArIFwiKSBmYWlsZWQgd2l0aCBzdGF0dXM6IFwiICsgcmVzcG9uc2Uuc3RhdHVzKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1ldGhvZDogaW5mb1xuICAgICAqXG4gICAgICogRmV0Y2hlcyB0aGUgdXNlcidzIGluZm8gZnJvbSBkcm9wYm94IGFuZCByZXR1cm5zIGEgcHJvbWlzZSBmb3IgaXQuXG4gICAgICpcbiAgICAgKiBSZXR1cm5zOlxuICAgICAqXG4gICAgICogICBBIHByb21pc2UgdG8gdGhlIHVzZXIncyBpbmZvXG4gICAgICovXG4gICAgaW5mbzogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHVybCA9IEJBU0VfVVJMICsgJy9kcml2ZS92Mi9hYm91dCc7XG4gICAgICAvLyByZXF1ZXN0aW5nIHVzZXIgaW5mbyhtYWlubHkgZm9yIHVzZXJBZHJlc3MpXG4gICAgICByZXR1cm4gdGhpcy5fcmVxdWVzdCgnR0VUJywgdXJsLCB7fSkudGhlbihmdW5jdGlvbiAocmVzcCl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdmFyIGluZm8gPSBKU09OLnBhcnNlKHJlc3AucmVzcG9uc2VUZXh0KTtcbiAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGluZm8pO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGUpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9LFxuXG5cbiAgICBfcmVxdWVzdDogZnVuY3Rpb24gKG1ldGhvZCwgdXJsLCBvcHRpb25zKSB7XG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAgIGlmICghIG9wdGlvbnMuaGVhZGVycykgeyBvcHRpb25zLmhlYWRlcnMgPSB7fTsgfVxuICAgICAgb3B0aW9ucy5oZWFkZXJzWydBdXRob3JpemF0aW9uJ10gPSAnQmVhcmVyICcgKyBzZWxmLnRva2VuO1xuXG4gICAgICB0aGlzLl9lbWl0KCd3aXJlLWJ1c3knLCB7XG4gICAgICAgIG1ldGhvZDogbWV0aG9kLFxuICAgICAgICBpc0ZvbGRlcjogaXNGb2xkZXIodXJsKVxuICAgICAgfSk7XG5cbiAgICAgIHJldHVybiBXaXJlQ2xpZW50LnJlcXVlc3QuY2FsbCh0aGlzLCBtZXRob2QsIHVybCwgb3B0aW9ucykudGhlbihmdW5jdGlvbih4aHIpIHtcbiAgICAgICAgLy8gR29vZ2xlIHRva2VucyBleHBpcmUgZnJvbSB0aW1lIHRvIHRpbWUuLi5cbiAgICAgICAgaWYgKHhociAmJiB4aHIuc3RhdHVzID09PSA0MDEpIHtcbiAgICAgICAgICBzZWxmLmNvbm5lY3QoKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKCFzZWxmLm9ubGluZSkge1xuICAgICAgICAgICAgc2VsZi5vbmxpbmUgPSB0cnVlO1xuICAgICAgICAgICAgc2VsZi5ycy5fZW1pdCgnbmV0d29yay1vbmxpbmUnKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgc2VsZi5fZW1pdCgnd2lyZS1kb25lJywge1xuICAgICAgICAgICAgbWV0aG9kOiBtZXRob2QsXG4gICAgICAgICAgICBpc0ZvbGRlcjogaXNGb2xkZXIodXJsKSxcbiAgICAgICAgICAgIHN1Y2Nlc3M6IHRydWVcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoeGhyKTtcbiAgICAgICAgfVxuICAgICAgfSwgZnVuY3Rpb24oZXJyb3IpIHtcbiAgICAgICAgaWYgKHNlbGYub25saW5lKSB7XG4gICAgICAgICAgc2VsZi5vbmxpbmUgPSBmYWxzZTtcbiAgICAgICAgICBzZWxmLnJzLl9lbWl0KCduZXR3b3JrLW9mZmxpbmUnKTtcbiAgICAgICAgfVxuICAgICAgICBzZWxmLl9lbWl0KCd3aXJlLWRvbmUnLCB7XG4gICAgICAgICAgbWV0aG9kOiBtZXRob2QsXG4gICAgICAgICAgaXNGb2xkZXI6IGlzRm9sZGVyKHVybCksXG4gICAgICAgICAgc3VjY2VzczogZmFsc2VcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGVycm9yKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcblxuICBHb29nbGVEcml2ZS5fcnNfaW5pdCA9IGZ1bmN0aW9uIChyZW1vdGVTdG9yYWdlKSB7XG4gICAgdmFyIGNvbmZpZyA9IHJlbW90ZVN0b3JhZ2UuYXBpS2V5cy5nb29nbGVkcml2ZTtcbiAgICBpZiAoY29uZmlnKSB7XG4gICAgICByZW1vdGVTdG9yYWdlLmdvb2dsZWRyaXZlID0gbmV3IEdvb2dsZURyaXZlKHJlbW90ZVN0b3JhZ2UsIGNvbmZpZy5jbGllbnRJZCk7XG4gICAgICBpZiAocmVtb3RlU3RvcmFnZS5iYWNrZW5kID09PSAnZ29vZ2xlZHJpdmUnKSB7XG4gICAgICAgIHJlbW90ZVN0b3JhZ2UuX29yaWdSZW1vdGUgPSByZW1vdGVTdG9yYWdlLnJlbW90ZTtcbiAgICAgICAgcmVtb3RlU3RvcmFnZS5yZW1vdGUgPSByZW1vdGVTdG9yYWdlLmdvb2dsZWRyaXZlO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBHb29nbGVEcml2ZS5fcnNfc3VwcG9ydGVkID0gZnVuY3Rpb24gKHJzKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH07XG5cbiAgR29vZ2xlRHJpdmUuX3JzX2NsZWFudXAgPSBmdW5jdGlvbiAocmVtb3RlU3RvcmFnZSkge1xuICAgIHJlbW90ZVN0b3JhZ2Uuc2V0QmFja2VuZCh1bmRlZmluZWQpO1xuICAgIGlmIChyZW1vdGVTdG9yYWdlLl9vcmlnUmVtb3RlKSB7XG4gICAgICByZW1vdGVTdG9yYWdlLnJlbW90ZSA9IHJlbW90ZVN0b3JhZ2UuX29yaWdSZW1vdGU7XG4gICAgICBkZWxldGUgcmVtb3RlU3RvcmFnZS5fb3JpZ1JlbW90ZTtcbiAgICB9XG4gIH07XG5cblxuICBtb2R1bGUuZXhwb3J0cyA9IEdvb2dsZURyaXZlO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2dvb2dsZWRyaXZlLmpzIl0sInNvdXJjZVJvb3QiOiIifQ==");
},function(module,exports,__webpack_require__){eval("'use strict';\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar hasLocalStorage;\n\nfunction emitUnauthorized(r) {\n  if (r.statusCode === 403 || r.statusCode === 401) {\n    this._emit('error', new Authorize.Unauthorized());\n  }\n  return Promise.resolve(r);\n}\n\nvar util = __webpack_require__(2);\nvar Dropbox = __webpack_require__(13);\nvar GoogleDrive = __webpack_require__(15);\nvar Discover = __webpack_require__(12);\nvar BaseClient = __webpack_require__(6);\nvar config = __webpack_require__(5);\nvar Authorize = __webpack_require__(4);\nvar Sync = __webpack_require__(8);\nvar _log = __webpack_require__(1);\nvar Features = __webpack_require__(17);\nvar globalContext = util.getGlobalContext();\nvar eventHandling = __webpack_require__(3);\n\n/**\n * Class: RemoteStorage\n *\n * TODO needs proper introduction and links to relevant classes etc\n *\n * Constructor for remoteStorage object.\n *\n * This class primarily contains feature detection code and convenience API.\n *\n * Depending on which features are built in, it contains different attributes and\n * functions. See the individual features for more information.\n *\n *  (start code)\n *  var remoteStorage = new RemoteStorage({\n *    logging: true,  // defaults to false\n *    cordovaRedirectUri: 'https://app.mygreatapp.com' // defaults to undefined\n *  });\n *  (end code)\n */\nvar RemoteStorage = function RemoteStorage(cfg) {\n  /**\n   * Event: ready\n   *\n   * Fired when ready\n   **/\n  /**\n   * Event: not-connected\n   *\n   * Fired when ready, but no storage connected (\"anonymous mode\")\n   **/\n  /**\n   * Event: connected\n   *\n   * Fired when a remote storage has been connected\n   **/\n  /**\n   * Event: disconnected\n   *\n   * Fired after disconnect\n   **/\n  /**\n   * Event: error\n   *\n   * Fired when an error occurs\n   *\n   * Arguments:\n   * the error\n   **/\n  /**\n   * Event: features-loaded\n   *\n   * Fired when all features are loaded\n   **/\n  /**\n   * Event: connecting\n   *\n   * Fired before webfinger lookup\n   **/\n  /**\n   * Event: authing\n   *\n   * Fired before redirecting to the authing server\n   **/\n  /**\n   * Event: wire-busy\n   *\n   * Fired when a wire request starts\n   **/\n  /**\n   * Event: wire-done\n   *\n   * Fired when a wire request completes\n   **/\n  /**\n   * Event: network-offline\n   *\n   * Fired once when a wire request fails for the first time, and\n   * `remote.online` is set to false\n   **/\n  /**\n   * Event: network-online\n   *\n   * Fired once when a wire request succeeds for the first time after a\n   * failed one, and `remote.online` is set back to true\n   **/\n\n  // Initial configuration property settings.\n  if ((typeof cfg === 'undefined' ? 'undefined' : _typeof(cfg)) === 'object') {\n    util.extend(config, cfg);\n  }\n\n  eventHandling(this, 'ready', 'connected', 'disconnected', 'not-connected', 'conflict', 'error', 'features-loaded', 'connecting', 'authing', 'sync-interval-change', 'wire-busy', 'wire-done', 'network-offline', 'network-online');\n\n  // pending get/put/delete calls.\n  this._pending = [];\n\n  this._setGPD({\n    get: this._pendingGPD('get'),\n    put: this._pendingGPD('put'),\n    delete: this._pendingGPD('delete')\n  });\n\n  this._cleanups = [];\n\n  this._pathHandlers = { change: {} };\n\n  this.apiKeys = {};\n\n  hasLocalStorage = util.localStorageAvailable();\n\n  if (hasLocalStorage) {\n    try {\n      this.apiKeys = JSON.parse(localStorage.getItem('remotestorage:api-keys')) || {};\n    } catch (exc) {\n      // ignored\n    }\n    this.setBackend(localStorage.getItem('remotestorage:backend') || 'remotestorage');\n  }\n\n  var origOn = this.on;\n\n  this.on = function (eventName, handler) {\n    if (eventName === 'ready' && this.remote && this.remote.connected && this._allLoaded) {\n      setTimeout(handler, 0);\n    } else if (eventName === 'features-loaded' && this._allLoaded) {\n      setTimeout(handler, 0);\n    }\n    return origOn.call(this, eventName, handler);\n  };\n\n  // load all features and emit `ready`\n  this._init();\n\n  this.fireInitial = function () {\n    if (this.local) {\n      setTimeout(this.local.fireInitial.bind(this.local), 0);\n    }\n  }.bind(this);\n\n  this.on('ready', this.fireInitial.bind(this));\n};\n\n// TOFIX: Instead of doing this, would be better to only \n// export setAuthURL / getAuthURL from RemoteStorage prototype\nRemoteStorage.Authorize = Authorize;\n\nRemoteStorage.SyncError = Sync.SyncError;\nRemoteStorage.Unauthorized = Authorize.Unauthorized;\nRemoteStorage.DiscoveryError = Discover.DiscoveryError;\n\nRemoteStorage.prototype = {\n  authorize: function authorize(authURL, cordovaRedirectUri) {\n    this.access.setStorageType(this.remote.storageType);\n    var scope = this.access.scopeParameter;\n\n    var redirectUri = globalContext.cordova ? cordovaRedirectUri : String(Authorize.getLocation());\n\n    var clientId = redirectUri.match(/^(https?:\\/\\/[^\\/]+)/)[0];\n\n    Authorize(this, authURL, scope, redirectUri, clientId);\n  },\n\n  impliedauth: function impliedauth(storageApi, redirectUri) {\n    storageApi = this.remote.storageApi;\n    redirectUri = String(document.location);\n\n    _log('ImpliedAuth proceeding due to absent authURL; storageApi = ' + storageApi + ' redirectUri = ' + redirectUri);\n    // Set a fixed access token, signalling to not send it as Bearer\n    this.remote.configure({\n      token: Authorize.IMPLIED_FAKE_TOKEN\n    });\n    document.location = redirectUri;\n  },\n  /**\n   * Property: remote\n   *\n   * Properties:\n   *\n   *   connected   - Boolean, whether or not a remote store is connected\n   *   online      - Boolean, whether last sync action was successful or not\n   *   userAddress - String, the user address of the connected user\n   *   properties  - String, the properties of the WebFinger link\n   */\n\n  /**\n   * Method: scope\n   *\n   * Returns a BaseClient with a certain scope (base path). Please use this method\n   * only for debugging, and always use defineModule instead, to get access to a\n   * BaseClient from a module in an app.\n   *\n   * Parameters:\n   *\n   *   scope - A string, with a leading and a trailing slash, specifying the\n   *           base path of the BaseClient that will be returned.\n   *\n   * Code example:\n   *\n   * (start code)\n   * remoteStorage.scope('/pictures/').getListing('');\n   * remoteStorage.scope('/public/pictures/').getListing('');\n   */\n\n  /**\n   * Method: startSync\n   *\n   * Start synchronization with remote storage, downloading and uploading any\n   * changes within the cached paths.\n   *\n   * Please consider: local changes will attempt sync immediately, and remote\n   * changes should also be synced timely when using library defaults. So\n   * this is mostly useful for letting users sync manually, when pressing a\n   * sync button for example. This might feel safer to them sometimes, esp.\n   * when shifting between offline and online a lot.\n   */\n  // (see src/sync.js for implementation)\n\n  /**\n   * Method: connect\n   *\n   * Connect to a remoteStorage server.\n   *\n   * Parameters:\n   *   userAddress        - The user address (user@host) to connect to.\n   *   token              - (optional) A bearer token acquired beforehand\n   *\n   * Discovers the WebFinger profile of the given user address and initiates\n   * the OAuth dance.\n   *\n   * This method must be called *after* all required access has been claimed.\n   * When using the connect widget, it will call this method itself.\n   *\n   * Special cases:\n   *\n   * 1. If a bearer token is supplied as second argument, the OAuth dance\n   *    will be skipped and the supplied token be used instead. This is\n   *    useful outside of browser environments, where the token has been\n   *    acquired in a different way.\n   *\n   * 2. If the Webfinger profile for the given user address doesn't contain\n   *    an auth URL, the library will assume that client and server have\n   *    established authorization among themselves, which will omit bearer\n   *    tokens in all requests later on. This is useful for example when using\n   *    Kerberos and similar protocols.\n   */\n  connect: function connect(userAddress, token) {\n    this.setBackend('remotestorage');\n    if (userAddress.indexOf('@') < 0) {\n      this._emit('error', new RemoteStorage.DiscoveryError(\"User address doesn't contain an @.\"));\n      return;\n    }\n\n    if (globalContext.cordova) {\n      if (typeof config.cordovaRedirectUri !== 'string') {\n        this._emit('error', new RemoteStorage.DiscoveryError(\"Please supply a custom HTTPS redirect URI for your Cordova app\"));\n        return;\n      }\n      if (!globalContext.cordova.InAppBrowser) {\n        this._emit('error', new RemoteStorage.DiscoveryError(\"Please include the InAppBrowser Cordova plugin to enable OAuth\"));\n        return;\n      }\n    }\n\n    this.remote.configure({\n      userAddress: userAddress\n    });\n    this._emit('connecting');\n\n    var discoveryTimeout = setTimeout(function () {\n      this._emit('error', new RemoteStorage.DiscoveryError(\"No storage information found for this user address.\"));\n    }.bind(this), config.discoveryTimeout);\n\n    Discover(userAddress).then(function (info) {\n      // Info contains fields: href, storageApi, authURL (optional), properties\n\n      clearTimeout(discoveryTimeout);\n      this._emit('authing');\n      info.userAddress = userAddress;\n      this.remote.configure(info);\n      if (!this.remote.connected) {\n        if (info.authURL) {\n          if (typeof token === 'undefined') {\n            // Normal authorization step; the default way to connect\n            this.authorize(info.authURL, config.cordovaRedirectUri);\n          } else if (typeof token === 'string') {\n            // Token supplied directly by app/developer/user\n            _log('Skipping authorization sequence and connecting with known token');\n            this.remote.configure({ token: token });\n          } else {\n            throw new Error(\"Supplied bearer token must be a string\");\n          }\n        } else {\n          // In lieu of an excplicit authURL, assume that the browser and\n          // server handle any authorization needs; for instance, TLS may\n          // trigger the browser to use a client certificate, or a 401 Not\n          // Authorized response may make the browser send a Kerberos ticket\n          // using the SPNEGO method.\n          this.impliedauth();\n        }\n      }\n    }.bind(this), function (err) {\n      clearTimeout(discoveryTimeout);\n      this._emit('error', new RemoteStorage.DiscoveryError(\"No storage information found for this user address.\"));\n    }.bind(this));\n  },\n\n  /**\n   * Method: disconnect\n   *\n   * \"Disconnect\" from remotestorage server to terminate current session.\n   * This method clears all stored settings and deletes the entire local\n   * cache.\n   */\n  disconnect: function disconnect() {\n    if (this.remote) {\n      this.remote.configure({\n        userAddress: null,\n        href: null,\n        storageApi: null,\n        token: null,\n        properties: null\n      });\n    }\n    this._setGPD({\n      get: this._pendingGPD('get'),\n      put: this._pendingGPD('put'),\n      delete: this._pendingGPD('delete')\n    });\n    var n = this._cleanups.length,\n        i = 0;\n\n    var oneDone = function () {\n      i++;\n      if (i >= n) {\n        this._init();\n        _log('Done cleaning up, emitting disconnected and disconnect events');\n        this._emit('disconnected');\n      }\n    }.bind(this);\n\n    if (n > 0) {\n      this._cleanups.forEach(function (cleanup) {\n        var cleanupResult = cleanup(this);\n        if ((typeof cleanupResult === 'undefined' ? 'undefined' : _typeof(cleanupResult)) === 'object' && typeof cleanupResult.then === 'function') {\n          cleanupResult.then(oneDone);\n        } else {\n          oneDone();\n        }\n      }.bind(this));\n    } else {\n      oneDone();\n    }\n  },\n\n  setBackend: function setBackend(what) {\n    this.backend = what;\n    if (hasLocalStorage) {\n      if (what) {\n        localStorage.setItem('remotestorage:backend', what);\n      } else {\n        localStorage.removeItem('remotestorage:backend');\n      }\n    }\n  },\n\n  /**\n   * Method: onChange\n   *\n   * Add a \"change\" event handler to the given path. Whenever a \"change\"\n   * happens (as determined by the backend, such as e.g.\n   * <RemoteStorage.IndexedDB>) and the affected path is equal to or below\n   * the given 'path', the given handler is called.\n   *\n   * You should usually not use this method directly, but instead use the\n   * \"change\" events provided by <RemoteStorage.BaseClient>.\n   *\n   * Parameters:\n   *   path    - Absolute path to attach handler to.\n   *   handler - Handler function.\n   */\n  onChange: function onChange(path, handler) {\n    if (!this._pathHandlers.change[path]) {\n      this._pathHandlers.change[path] = [];\n    }\n    this._pathHandlers.change[path].push(handler);\n  },\n\n  /**\n   * Method: enableLog\n   *\n   * Enable remoteStorage logging.\n   */\n  enableLog: function enableLog() {\n    config.logging = true;\n  },\n\n  /**\n   * Method: disableLog\n   *\n   * Disable remoteStorage logging\n   */\n  disableLog: function disableLog() {\n    config.logging = false;\n  },\n\n  /**\n   * Method: log\n   *\n   * The same as <RemoteStorage.log>.\n   */\n  log: function log() {\n    _log.apply(RemoteStorage, arguments);\n  },\n\n  /**\n   * Method: setApiKeys (experimental)\n   *\n   * Set API keys for (currently) GoogleDrive and/or Dropbox backend support.\n   * See also the 'backends' example in the starter-kit. Note that support for\n   * both these backends is still experimental.\n   *\n   * Parameters:\n   *   type - string, either 'googledrive' or 'dropbox'\n   *   keys - object, with one string field; 'clientId' for GoogleDrive, or\n   *          'appKey' for Dropbox.\n   *\n   */\n  setApiKeys: function setApiKeys(type, keys) {\n    if (keys) {\n      this.apiKeys[type] = keys;\n      if (type === 'dropbox' && (typeof this.dropbox === 'undefined' || this.dropbox.clientId !== keys.appKey)) {\n        Dropbox._rs_init(this);\n      } else if (type === 'googledrive' && (typeof this.googledrive === 'undefined' || this.googledrive.clientId !== keys.clientId)) {\n        GoogleDrive._rs_init(this);\n      }\n    } else {\n      delete this.apiKeys[type];\n    }\n    if (hasLocalStorage) {\n      localStorage.setItem('remotestorage:api-keys', JSON.stringify(this.apiKeys));\n    }\n  },\n\n  /**\n   * Method: setCordovaRedirectUri\n   *\n   * Set redirect URI to be used for the OAuth redirect within the\n   * in-app-browser window in Cordova apps.\n   *\n   * Parameters:\n   *   uri - string, valid HTTP(S) URI\n   */\n  setCordovaRedirectUri: function setCordovaRedirectUri(uri) {\n    if (typeof uri !== 'string' || !uri.match(/http(s)?\\:\\/\\//)) {\n      throw new Error(\"Cordova redirect URI must be a URI string\");\n    }\n    config.cordovaRedirectUri = uri;\n  },\n\n  /* FEATURES INITIALIZATION */\n  _init: Features.loadFeatures,\n  features: Features.features,\n  loadFeature: Features.loadFeature,\n  featureSupported: Features.featureSupported,\n  featureDone: Features.featureDone,\n  featuresDone: Features.featuresDone,\n  featuresLoaded: Features.featuresLoaded,\n  featureInitialized: Features.featureInitialized,\n  featureFailed: Features.featureFailed,\n  hasFeature: Features.hasFeature,\n  _setCachingModule: Features._setCachingModule,\n  _collectCleanupFunctions: Features._collectCleanupFunctions,\n  _fireReady: Features._fireReady,\n  initFeature: Features.initFeature,\n\n  /**\n   * TOFIX: needs some explanation on this -les\n   ** GET/PUT/DELETE INTERFACE HELPERS\n   **/\n\n  _setGPD: function _setGPD(impl, context) {\n    function wrap(func) {\n      return function () {\n        return func.apply(context, arguments).then(emitUnauthorized.bind(this));\n      };\n    }\n    this.get = wrap(impl.get);\n    this.put = wrap(impl.put);\n    this.delete = wrap(impl.delete);\n  },\n\n  _pendingGPD: function _pendingGPD(methodName) {\n    return function () {\n      var methodArguments = Array.prototype.slice.call(arguments);\n      return new Promise(function (resolve, reject) {\n        this._pending.push({\n          method: methodName,\n          args: methodArguments,\n          promise: {\n            resolve: resolve,\n            reject: reject\n          }\n        });\n      }.bind(this));\n    }.bind(this);\n  },\n\n  _processPending: function _processPending() {\n    this._pending.forEach(function (pending) {\n      try {\n        this[pending.method].apply(this, pending.args).then(pending.promise.resolve, pending.promise.reject);\n      } catch (e) {\n        pending.promise.reject(e);\n      }\n    }.bind(this));\n    this._pending = [];\n  },\n\n  /**\n   ** CHANGE EVENT HANDLING\n   **/\n  _bindChange: function _bindChange(object) {\n    object.on('change', this._dispatchEvent.bind(this, 'change'));\n  },\n\n  _dispatchEvent: function _dispatchEvent(eventName, event) {\n    var self = this;\n    Object.keys(this._pathHandlers[eventName]).forEach(function (path) {\n      var pl = path.length;\n      if (event.path.substr(0, pl) === path) {\n        self._pathHandlers[eventName][path].forEach(function (handler) {\n          var ev = {};\n          for (var key in event) {\n            ev[key] = event[key];\n          }\n          ev.relativePath = event.path.replace(new RegExp('^' + path), '');\n          try {\n            handler(ev);\n          } catch (e) {\n            console.error(\"'change' handler failed: \", e, e.stack);\n            self._emit('error', e);\n          }\n        });\n      }\n    });\n  },\n\n  scope: function scope(path) {\n    if (typeof path !== 'string') {\n      throw 'Argument \\'path\\' of baseClient.scope must be a string';\n    }\n\n    if (!this.access.checkPathPermission(path, 'r')) {\n      var escapedPath = path.replace(/(['\\\\])/g, '\\\\$1');\n      console.warn('WARNING: please call remoteStorage.access.claim(\\'' + escapedPath + '\\', \\'r\\') (read only) or remoteStorage.access.claim(\\'' + escapedPath + '\\', \\'rw\\') (read/write) first');\n    }\n    return new BaseClient(this, path);\n  },\n\n  /**\n   * Method: getSyncInterval\n   *\n   * Get the value of the sync interval when application is in the foreground\n   *\n   * Returns a number of milliseconds\n   *\n  //  */\n  getSyncInterval: function getSyncInterval() {\n    return config.syncInterval;\n  },\n\n  /**\n   * Method: setSyncInterval\n   *\n   * Set the value of the sync interval when application is in the foreground\n   *\n   * Parameters:\n   *   interval - sync interval in milliseconds\n   *\n   */\n  setSyncInterval: function setSyncInterval(interval) {\n    if (!isValidInterval(interval)) {\n      throw interval + \" is not a valid sync interval\";\n    }\n    var oldValue = config.syncInterval;\n    config.syncInterval = parseInt(interval, 10);\n    this._emit('sync-interval-change', { oldValue: oldValue, newValue: interval });\n  },\n\n  /**\n   * Method: getBackgroundSyncInterval\n   *\n   * Get the value of the sync interval when application is in the background\n   *\n   * Returns a number of milliseconds\n   *\n   */\n  getBackgroundSyncInterval: function getBackgroundSyncInterval() {\n    return config.backgroundSyncInterval;\n  },\n\n  /**\n   * Method: setBackgroundSyncInterval\n   *\n   * Set the value of the sync interval when the application is in the background\n   *\n   * Parameters:\n   *   interval - sync interval in milliseconds\n   *\n   */\n  setBackgroundSyncInterval: function setBackgroundSyncInterval(interval) {\n    if (!isValidInterval(interval)) {\n      throw interval + \" is not a valid sync interval\";\n    }\n    var oldValue = config.backgroundSyncInterval;\n    config.backgroundSyncInterval = parseInt(interval, 10);\n    this._emit('sync-interval-change', { oldValue: oldValue, newValue: interval });\n  },\n\n  /**\n   * Method: getCurrentSyncInterval\n   *\n   * Get the value of the current sync interval\n   *\n   * Returns a number of milliseconds\n   *\n   */\n  getCurrentSyncInterval: function getCurrentSyncInterval() {\n    return config.isBackground ? config.backgroundSyncInterval : config.syncInterval;\n  },\n\n  syncCycle: function syncCycle() {\n    if (this.sync.stopped) {\n      return;\n    }\n\n    this.sync.on('done', function () {\n      _log('[Sync] Sync done. Setting timer to', this.getCurrentSyncInterval());\n      if (!this.sync.stopped) {\n        if (this._syncTimer) {\n          clearTimeout(this._syncTimer);\n        }\n        this._syncTimer = setTimeout(this.sync.sync.bind(this.sync), this.getCurrentSyncInterval());\n      }\n    }.bind(this));\n\n    this.sync.sync();\n  },\n\n  stopSync: function stopSync() {\n    if (this.sync) {\n      _log('[Sync] Stopping sync');\n      this.sync.stopped = true;\n    } else {\n      // TODO When is this ever the case and what is syncStopped for then?\n      _log('[Sync] Will instantiate sync stopped');\n      this.syncStopped = true;\n    }\n  },\n\n  startSync: function startSync() {\n    if (!config.cache) {\n      return;\n    }\n    this.sync.stopped = false;\n    this.syncStopped = false;\n    this.sync.sync();\n  }\n\n};\n\n/**\n* Check if interval is valid: numeric and between 1000ms and 3600000ms\n*\n*/\nfunction isValidInterval(interval) {\n  return typeof interval === 'number' && interval > 1000 && interval < 3600000;\n}\n\nRemoteStorage.util = util;\n// RemoteStorage.defineModule = modules.defineModule;\n\n/**\n * Property: connected\n *\n * Boolean property indicating if remoteStorage is currently connected.\n */\nObject.defineProperty(RemoteStorage.prototype, 'connected', {\n  get: function get() {\n    return this.remote.connected;\n  }\n});\n\n/**\n * Property: access\n *\n * Tracking claimed access scopes. A <RemoteStorage.Access> instance.\n*/\nvar Access = __webpack_require__(10);\nObject.defineProperty(RemoteStorage.prototype, 'access', {\n  get: function get() {\n    var access = new Access();\n    Object.defineProperty(this, 'access', {\n      value: access\n    });\n    return access;\n  },\n  configurable: true\n});\n\n// TODO clean up/harmonize how modules are loaded and/or document this architecture properly\n//\n// At this point the remoteStorage object has not been created yet.\n// Only its prototype exists so far, so we define a self-constructing\n// property on there:\n/**\n *\n * Property: caching\n *\n * Caching settings. A <RemoteStorage.Caching> instance.\n *\n * Not available in no-cache builds.\n *\n */\n\n// TOFIX was in rs_init of Caching but don't want to require RemoteStorage from there.\nvar Caching = __webpack_require__(11);\nObject.defineProperty(RemoteStorage.prototype, 'caching', {\n  configurable: true,\n  get: function get() {\n    var caching = new Caching();\n    Object.defineProperty(this, 'caching', {\n      value: caching\n    });\n    return caching;\n  }\n});\n\n/*\n* Property: remote\n*\n* Access to the remote backend used. Usually a <RemoteStorage.WireClient>.\n*\n*\n* Property: local\n*\n* Access to the local caching backend used. Usually either a\n* <RemoteStorage.IndexedDB> or <RemoteStorage.LocalStorage> instance.\n*\n* Not available in no-cache builds.\n*/\n\nmodule.exports = RemoteStorage;\n__webpack_require__(21);\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvcmVtb3Rlc3RvcmFnZS5qcz9hMTc4Il0sIm5hbWVzIjpbImhhc0xvY2FsU3RvcmFnZSIsImVtaXRVbmF1dGhvcml6ZWQiLCJyIiwic3RhdHVzQ29kZSIsIl9lbWl0IiwiQXV0aG9yaXplIiwiVW5hdXRob3JpemVkIiwiUHJvbWlzZSIsInJlc29sdmUiLCJ1dGlsIiwicmVxdWlyZSIsIkRyb3Bib3giLCJHb29nbGVEcml2ZSIsIkRpc2NvdmVyIiwiQmFzZUNsaWVudCIsImNvbmZpZyIsIlN5bmMiLCJsb2ciLCJGZWF0dXJlcyIsImdsb2JhbENvbnRleHQiLCJnZXRHbG9iYWxDb250ZXh0IiwiZXZlbnRIYW5kbGluZyIsIlJlbW90ZVN0b3JhZ2UiLCJjZmciLCJleHRlbmQiLCJfcGVuZGluZyIsIl9zZXRHUEQiLCJnZXQiLCJfcGVuZGluZ0dQRCIsInB1dCIsImRlbGV0ZSIsIl9jbGVhbnVwcyIsIl9wYXRoSGFuZGxlcnMiLCJjaGFuZ2UiLCJhcGlLZXlzIiwibG9jYWxTdG9yYWdlQXZhaWxhYmxlIiwiSlNPTiIsInBhcnNlIiwibG9jYWxTdG9yYWdlIiwiZ2V0SXRlbSIsImV4YyIsInNldEJhY2tlbmQiLCJvcmlnT24iLCJvbiIsImV2ZW50TmFtZSIsImhhbmRsZXIiLCJyZW1vdGUiLCJjb25uZWN0ZWQiLCJfYWxsTG9hZGVkIiwic2V0VGltZW91dCIsImNhbGwiLCJfaW5pdCIsImZpcmVJbml0aWFsIiwibG9jYWwiLCJiaW5kIiwiU3luY0Vycm9yIiwiRGlzY292ZXJ5RXJyb3IiLCJwcm90b3R5cGUiLCJhdXRob3JpemUiLCJhdXRoVVJMIiwiY29yZG92YVJlZGlyZWN0VXJpIiwiYWNjZXNzIiwic2V0U3RvcmFnZVR5cGUiLCJzdG9yYWdlVHlwZSIsInNjb3BlIiwic2NvcGVQYXJhbWV0ZXIiLCJyZWRpcmVjdFVyaSIsImNvcmRvdmEiLCJTdHJpbmciLCJnZXRMb2NhdGlvbiIsImNsaWVudElkIiwibWF0Y2giLCJpbXBsaWVkYXV0aCIsInN0b3JhZ2VBcGkiLCJkb2N1bWVudCIsImxvY2F0aW9uIiwiY29uZmlndXJlIiwidG9rZW4iLCJJTVBMSUVEX0ZBS0VfVE9LRU4iLCJjb25uZWN0IiwidXNlckFkZHJlc3MiLCJpbmRleE9mIiwiSW5BcHBCcm93c2VyIiwiZGlzY292ZXJ5VGltZW91dCIsInRoZW4iLCJpbmZvIiwiY2xlYXJUaW1lb3V0IiwiRXJyb3IiLCJlcnIiLCJkaXNjb25uZWN0IiwiaHJlZiIsInByb3BlcnRpZXMiLCJuIiwibGVuZ3RoIiwiaSIsIm9uZURvbmUiLCJmb3JFYWNoIiwiY2xlYW51cCIsImNsZWFudXBSZXN1bHQiLCJ3aGF0IiwiYmFja2VuZCIsInNldEl0ZW0iLCJyZW1vdmVJdGVtIiwib25DaGFuZ2UiLCJwYXRoIiwicHVzaCIsImVuYWJsZUxvZyIsImxvZ2dpbmciLCJkaXNhYmxlTG9nIiwiYXBwbHkiLCJhcmd1bWVudHMiLCJzZXRBcGlLZXlzIiwidHlwZSIsImtleXMiLCJkcm9wYm94IiwiYXBwS2V5IiwiX3JzX2luaXQiLCJnb29nbGVkcml2ZSIsInN0cmluZ2lmeSIsInNldENvcmRvdmFSZWRpcmVjdFVyaSIsInVyaSIsImxvYWRGZWF0dXJlcyIsImZlYXR1cmVzIiwibG9hZEZlYXR1cmUiLCJmZWF0dXJlU3VwcG9ydGVkIiwiZmVhdHVyZURvbmUiLCJmZWF0dXJlc0RvbmUiLCJmZWF0dXJlc0xvYWRlZCIsImZlYXR1cmVJbml0aWFsaXplZCIsImZlYXR1cmVGYWlsZWQiLCJoYXNGZWF0dXJlIiwiX3NldENhY2hpbmdNb2R1bGUiLCJfY29sbGVjdENsZWFudXBGdW5jdGlvbnMiLCJfZmlyZVJlYWR5IiwiaW5pdEZlYXR1cmUiLCJpbXBsIiwiY29udGV4dCIsIndyYXAiLCJmdW5jIiwibWV0aG9kTmFtZSIsIm1ldGhvZEFyZ3VtZW50cyIsIkFycmF5Iiwic2xpY2UiLCJyZWplY3QiLCJtZXRob2QiLCJhcmdzIiwicHJvbWlzZSIsIl9wcm9jZXNzUGVuZGluZyIsInBlbmRpbmciLCJlIiwiX2JpbmRDaGFuZ2UiLCJvYmplY3QiLCJfZGlzcGF0Y2hFdmVudCIsImV2ZW50Iiwic2VsZiIsIk9iamVjdCIsInBsIiwic3Vic3RyIiwiZXYiLCJrZXkiLCJyZWxhdGl2ZVBhdGgiLCJyZXBsYWNlIiwiUmVnRXhwIiwiY29uc29sZSIsImVycm9yIiwic3RhY2siLCJjaGVja1BhdGhQZXJtaXNzaW9uIiwiZXNjYXBlZFBhdGgiLCJ3YXJuIiwiZ2V0U3luY0ludGVydmFsIiwic3luY0ludGVydmFsIiwic2V0U3luY0ludGVydmFsIiwiaW50ZXJ2YWwiLCJpc1ZhbGlkSW50ZXJ2YWwiLCJvbGRWYWx1ZSIsInBhcnNlSW50IiwibmV3VmFsdWUiLCJnZXRCYWNrZ3JvdW5kU3luY0ludGVydmFsIiwiYmFja2dyb3VuZFN5bmNJbnRlcnZhbCIsInNldEJhY2tncm91bmRTeW5jSW50ZXJ2YWwiLCJnZXRDdXJyZW50U3luY0ludGVydmFsIiwiaXNCYWNrZ3JvdW5kIiwic3luY0N5Y2xlIiwic3luYyIsInN0b3BwZWQiLCJfc3luY1RpbWVyIiwic3RvcFN5bmMiLCJzeW5jU3RvcHBlZCIsInN0YXJ0U3luYyIsImNhY2hlIiwiZGVmaW5lUHJvcGVydHkiLCJBY2Nlc3MiLCJ2YWx1ZSIsImNvbmZpZ3VyYWJsZSIsIkNhY2hpbmciLCJjYWNoaW5nIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7QUFDRSxJQUFJQSxlQUFKOztBQUVBLFNBQVNDLGdCQUFULENBQTBCQyxDQUExQixFQUE2QjtBQUMzQixNQUFJQSxFQUFFQyxVQUFGLEtBQWlCLEdBQWpCLElBQXlCRCxFQUFFQyxVQUFGLEtBQWlCLEdBQTlDLEVBQW1EO0FBQ2pELFNBQUtDLEtBQUwsQ0FBVyxPQUFYLEVBQW9CLElBQUlDLFVBQVVDLFlBQWQsRUFBcEI7QUFDRDtBQUNELFNBQU9DLFFBQVFDLE9BQVIsQ0FBZ0JOLENBQWhCLENBQVA7QUFDRDs7QUFFRCxJQUFNTyxPQUFPLG1CQUFBQyxDQUFRLENBQVIsQ0FBYjtBQUNBLElBQU1DLFVB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O0FBV0M7Ozs7Ozs7Ozs7Ozs7O0FBZUhDLE9BQU9DLE9BQVAsR0FBaUIvSyxhQUFqQjtBQUNBLG1CQUFBWixDQUFRLEVBQVIiLCJmaWxlIjoiMTYuanMiLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG4gIHZhciBoYXNMb2NhbFN0b3JhZ2U7XG5cbiAgZnVuY3Rpb24gZW1pdFVuYXV0aG9yaXplZChyKSB7XG4gICAgaWYgKHIuc3RhdHVzQ29kZSA9PT0gNDAzICB8fCByLnN0YXR1c0NvZGUgPT09IDQwMSkge1xuICAgICAgdGhpcy5fZW1pdCgnZXJyb3InLCBuZXcgQXV0aG9yaXplLlVuYXV0aG9yaXplZCgpKTtcbiAgICB9XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShyKTtcbiAgfVxuXG4gIGNvbnN0IHV0aWwgPSByZXF1aXJlKCcuL3V0aWwnKTtcbiAgY29uc3QgRHJvcGJveCA9IHJlcXVpcmUoJy4vZHJvcGJveCcpO1xuICBjb25zdCBHb29nbGVEcml2ZSA9IHJlcXVpcmUoJy4vZ29vZ2xlZHJpdmUnKTtcbiAgY29uc3QgRGlzY292ZXIgPSByZXF1aXJlKCcuL2Rpc2NvdmVyJyk7XG4gIGNvbnN0IEJhc2VDbGllbnQgPSByZXF1aXJlKCcuL2Jhc2VjbGllbnQnKTtcbiAgY29uc3QgY29uZmlnID0gcmVxdWlyZSgnLi9jb25maWcnKTtcbiAgY29uc3QgQXV0aG9yaXplID0gcmVxdWlyZSgnLi9hdXRob3JpemUnKTtcbiAgY29uc3QgU3luYyA9IHJlcXVpcmUoJy4vc3luYycpO1xuICBjb25zdCBsb2cgPSByZXF1aXJlKCcuL2xvZycpO1xuICBjb25zdCBGZWF0dXJlcyA9IHJlcXVpcmUoJy4vZmVhdHVyZXMnKTtcbiAgY29uc3QgZ2xvYmFsQ29udGV4dCA9IHV0aWwuZ2V0R2xvYmFsQ29udGV4dCgpO1xuICBjb25zdCBldmVudEhhbmRsaW5nID0gcmVxdWlyZSgnLi9ldmVudGhhbmRsaW5nJyk7XG5cblxuICAvKipcbiAgICogQ2xhc3M6IFJlbW90ZVN0b3JhZ2VcbiAgICpcbiAgICogVE9ETyBuZWVkcyBwcm9wZXIgaW50cm9kdWN0aW9uIGFuZCBsaW5rcyB0byByZWxldmFudCBjbGFzc2VzIGV0Y1xuICAgKlxuICAgKiBDb25zdHJ1Y3RvciBmb3IgcmVtb3RlU3RvcmFnZSBvYmplY3QuXG4gICAqXG4gICAqIFRoaXMgY2xhc3MgcHJpbWFyaWx5IGNvbnRhaW5zIGZlYXR1cmUgZGV0ZWN0aW9uIGNvZGUgYW5kIGNvbnZlbmllbmNlIEFQSS5cbiAgICpcbiAgICogRGVwZW5kaW5nIG9uIHdoaWNoIGZlYXR1cmVzIGFyZSBidWlsdCBpbiwgaXQgY29udGFpbnMgZGlmZmVyZW50IGF0dHJpYnV0ZXMgYW5kXG4gICAqIGZ1bmN0aW9ucy4gU2VlIHRoZSBpbmRpdmlkdWFsIGZlYXR1cmVzIGZvciBtb3JlIGluZm9ybWF0aW9uLlxuICAgKlxuICAgKiAgKHN0YXJ0IGNvZGUpXG4gICAqICB2YXIgcmVtb3RlU3RvcmFnZSA9IG5ldyBSZW1vdGVTdG9yYWdlKHtcbiAgICogICAgbG9nZ2luZzogdHJ1ZSwgIC8vIGRlZmF1bHRzIHRvIGZhbHNlXG4gICAqICAgIGNvcmRvdmFSZWRpcmVjdFVyaTogJ2h0dHBzOi8vYXBwLm15Z3JlYXRhcHAuY29tJyAvLyBkZWZhdWx0cyB0byB1bmRlZmluZWRcbiAgICogIH0pO1xuICAgKiAgKGVuZCBjb2RlKVxuICAgKi9cbiAgdmFyIFJlbW90ZVN0b3JhZ2UgPSBmdW5jdGlvbiAoY2ZnKSB7XG4gICAgLyoqXG4gICAgICogRXZlbnQ6IHJlYWR5XG4gICAgICpcbiAgICAgKiBGaXJlZCB3aGVuIHJlYWR5XG4gICAgICoqL1xuICAgIC8qKlxuICAgICAqIEV2ZW50OiBub3QtY29ubmVjdGVkXG4gICAgICpcbiAgICAgKiBGaXJlZCB3aGVuIHJlYWR5LCBidXQgbm8gc3RvcmFnZSBjb25uZWN0ZWQgKFwiYW5vbnltb3VzIG1vZGVcIilcbiAgICAgKiovXG4gICAgLyoqXG4gICAgICogRXZlbnQ6IGNvbm5lY3RlZFxuICAgICAqXG4gICAgICogRmlyZWQgd2hlbiBhIHJlbW90ZSBzdG9yYWdlIGhhcyBiZWVuIGNvbm5lY3RlZFxuICAgICAqKi9cbiAgICAvKipcbiAgICAgKiBFdmVudDogZGlzY29ubmVjdGVkXG4gICAgICpcbiAgICAgKiBGaXJlZCBhZnRlciBkaXNjb25uZWN0XG4gICAgICoqL1xuICAgIC8qKlxuICAgICAqIEV2ZW50OiBlcnJvclxuICAgICAqXG4gICAgICogRmlyZWQgd2hlbiBhbiBlcnJvciBvY2N1cnNcbiAgICAgKlxuICAgICAqIEFyZ3VtZW50czpcbiAgICAgKiB0aGUgZXJyb3JcbiAgICAgKiovXG4gICAgLyoqXG4gICAgICogRXZlbnQ6IGZlYXR1cmVzLWxvYWRlZFxuICAgICAqXG4gICAgICogRmlyZWQgd2hlbiBhbGwgZmVhdHVyZXMgYXJlIGxvYWRlZFxuICAgICAqKi9cbiAgICAvKipcbiAgICAgKiBFdmVudDogY29ubmVjdGluZ1xuICAgICAqXG4gICAgICogRmlyZWQgYmVmb3JlIHdlYmZpbmdlciBsb29rdXBcbiAgICAgKiovXG4gICAgLyoqXG4gICAgICogRXZlbnQ6IGF1dGhpbmdcbiAgICAgKlxuICAgICAqIEZpcmVkIGJlZm9yZSByZWRpcmVjdGluZyB0byB0aGUgYXV0aGluZyBzZXJ2ZXJcbiAgICAgKiovXG4gICAgLyoqXG4gICAgICogRXZlbnQ6IHdpcmUtYnVzeVxuICAgICAqXG4gICAgICogRmlyZWQgd2hlbiBhIHdpcmUgcmVxdWVzdCBzdGFydHNcbiAgICAgKiovXG4gICAgLyoqXG4gICAgICogRXZlbnQ6IHdpcmUtZG9uZVxuICAgICAqXG4gICAgICogRmlyZWQgd2hlbiBhIHdpcmUgcmVxdWVzdCBjb21wbGV0ZXNcbiAgICAgKiovXG4gICAgLyoqXG4gICAgICogRXZlbnQ6IG5ldHdvcmstb2ZmbGluZVxuICAgICAqXG4gICAgICogRmlyZWQgb25jZSB3aGVuIGEgd2lyZSByZXF1ZXN0IGZhaWxzIGZvciB0aGUgZmlyc3QgdGltZSwgYW5kXG4gICAgICogYHJlbW90ZS5vbmxpbmVgIGlzIHNldCB0byBmYWxzZVxuICAgICAqKi9cbiAgICAvKipcbiAgICAgKiBFdmVudDogbmV0d29yay1vbmxpbmVcbiAgICAgKlxuICAgICAqIEZpcmVkIG9uY2Ugd2hlbiBhIHdpcmUgcmVxdWVzdCBzdWNjZWVkcyBmb3IgdGhlIGZpcnN0IHRpbWUgYWZ0ZXIgYVxuICAgICAqIGZhaWxlZCBvbmUsIGFuZCBgcmVtb3RlLm9ubGluZWAgaXMgc2V0IGJhY2sgdG8gdHJ1ZVxuICAgICAqKi9cblxuICAgIC8vIEluaXRpYWwgY29uZmlndXJhdGlvbiBwcm9wZXJ0eSBzZXR0aW5ncy5cbiAgICBpZiAodHlwZW9mIGNmZyA9PT0gJ29iamVjdCcpIHtcbiAgICAgIHV0aWwuZXh0ZW5kKGNvbmZpZywgY2ZnKTtcbiAgICB9XG5cbiAgICBldmVudEhhbmRsaW5nKFxuICAgICAgdGhpcywgJ3JlYWR5JywgJ2Nvbm5lY3RlZCcsICdkaXNjb25uZWN0ZWQnLCAnbm90LWNvbm5lY3RlZCcsICdjb25mbGljdCcsXG4gICAgICAgICAgICAnZXJyb3InLCAnZmVhdHVyZXMtbG9hZGVkJywgJ2Nvbm5lY3RpbmcnLCAnYXV0aGluZycsXG4gICAgICAgICAgICAnc3luYy1pbnRlcnZhbC1jaGFuZ2UnLCAnd2lyZS1idXN5JywgJ3dpcmUtZG9uZScsXG4gICAgICAgICAgICAnbmV0d29yay1vZmZsaW5lJywgJ25ldHdvcmstb25saW5lJ1xuICAgICk7XG5cbiAgICAvLyBwZW5kaW5nIGdldC9wdXQvZGVsZXRlIGNhbGxzLlxuICAgIHRoaXMuX3BlbmRpbmcgPSBbXTtcblxuICAgIHRoaXMuX3NldEdQRCh7XG4gICAgICBnZXQ6IHRoaXMuX3BlbmRpbmdHUEQoJ2dldCcpLFxuICAgICAgcHV0OiB0aGlzLl9wZW5kaW5nR1BEKCdwdXQnKSxcbiAgICAgIGRlbGV0ZTogdGhpcy5fcGVuZGluZ0dQRCgnZGVsZXRlJylcbiAgICB9KTtcblxuICAgIHRoaXMuX2NsZWFudXBzID0gW107XG5cbiAgICB0aGlzLl9wYXRoSGFuZGxlcnMgPSB7IGNoYW5nZToge30gfTtcblxuICAgIHRoaXMuYXBpS2V5cyA9IHt9O1xuXG4gICAgaGFzTG9jYWxTdG9yYWdlID0gdXRpbC5sb2NhbFN0b3JhZ2VBdmFpbGFibGUoKTtcblxuICAgIGlmIChoYXNMb2NhbFN0b3JhZ2UpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHRoaXMuYXBpS2V5cyA9IEpTT04ucGFyc2UobG9jYWxTdG9yYWdlLmdldEl0ZW0oJ3JlbW90ZXN0b3JhZ2U6YXBpLWtleXMnKSkgfHwge307XG4gICAgICB9IGNhdGNoKGV4Yykge1xuICAgICAgICAvLyBpZ25vcmVkXG4gICAgICB9XG4gICAgICB0aGlzLnNldEJhY2tlbmQobG9jYWxTdG9yYWdlLmdldEl0ZW0oJ3JlbW90ZXN0b3JhZ2U6YmFja2VuZCcpIHx8ICdyZW1vdGVzdG9yYWdlJyk7XG4gICAgfVxuXG4gICAgdmFyIG9yaWdPbiA9IHRoaXMub247XG5cbiAgICB0aGlzLm9uID0gZnVuY3Rpb24gKGV2ZW50TmFtZSwgaGFuZGxlcikge1xuICAgICAgaWYgKGV2ZW50TmFtZSA9PT0gJ3JlYWR5JyAmJiB0aGlzLnJlbW90ZSAmJiB0aGlzLnJlbW90ZS5jb25uZWN0ZWQgJiYgdGhpcy5fYWxsTG9hZGVkKSB7XG4gICAgICAgIHNldFRpbWVvdXQoaGFuZGxlciwgMCk7XG4gICAgICB9IGVsc2UgaWYgKGV2ZW50TmFtZSA9PT0gJ2ZlYXR1cmVzLWxvYWRlZCcgJiYgdGhpcy5fYWxsTG9hZGVkKSB7XG4gICAgICAgIHNldFRpbWVvdXQoaGFuZGxlciwgMCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gb3JpZ09uLmNhbGwodGhpcywgZXZlbnROYW1lLCBoYW5kbGVyKTtcbiAgICB9O1xuXG4gICAgLy8gbG9hZCBhbGwgZmVhdHVyZXMgYW5kIGVtaXQgYHJlYWR5YFxuICAgIHRoaXMuX2luaXQoKTtcblxuICAgIHRoaXMuZmlyZUluaXRpYWwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAodGhpcy5sb2NhbCkge1xuICAgICAgICBzZXRUaW1lb3V0KHRoaXMubG9jYWwuZmlyZUluaXRpYWwuYmluZCh0aGlzLmxvY2FsKSwgMCk7XG4gICAgICB9XG4gICAgfS5iaW5kKHRoaXMpO1xuXG4gICAgdGhpcy5vbigncmVhZHknLCB0aGlzLmZpcmVJbml0aWFsLmJpbmQodGhpcykpO1xuICB9O1xuXG5cbiAgLy8gVE9GSVg6IEluc3RlYWQgb2YgZG9pbmcgdGhpcywgd291bGQgYmUgYmV0dGVyIHRvIG9ubHkgXG4gIC8vIGV4cG9ydCBzZXRBdXRoVVJMIC8gZ2V0QXV0aFVSTCBmcm9tIFJlbW90ZVN0b3JhZ2UgcHJvdG90eXBlXG4gIFJlbW90ZVN0b3JhZ2UuQXV0aG9yaXplID0gQXV0aG9yaXplO1xuXG4gIFJlbW90ZVN0b3JhZ2UuU3luY0Vycm9yID0gU3luYy5TeW5jRXJyb3I7XG4gIFJlbW90ZVN0b3JhZ2UuVW5hdXRob3JpemVkID0gQXV0aG9yaXplLlVuYXV0aG9yaXplZDtcbiAgUmVtb3RlU3RvcmFnZS5EaXNjb3ZlcnlFcnJvciA9IERpc2NvdmVyLkRpc2NvdmVyeUVycm9yO1xuXG4gXG4gIFJlbW90ZVN0b3JhZ2UucHJvdG90eXBlID0ge1xuICAgIGF1dGhvcml6ZTogZnVuY3Rpb24gYXV0aG9yaXplKGF1dGhVUkwsIGNvcmRvdmFSZWRpcmVjdFVyaSkge1xuICAgICAgdGhpcy5hY2Nlc3Muc2V0U3RvcmFnZVR5cGUodGhpcy5yZW1vdGUuc3RvcmFnZVR5cGUpO1xuICAgICAgdmFyIHNjb3BlID0gdGhpcy5hY2Nlc3Muc2NvcGVQYXJhbWV0ZXI7XG5cbiAgICAgIHZhciByZWRpcmVjdFVyaSA9IGdsb2JhbENvbnRleHQuY29yZG92YSA/XG4gICAgICAgIGNvcmRvdmFSZWRpcmVjdFVyaSA6XG4gICAgICAgIFN0cmluZyhBdXRob3JpemUuZ2V0TG9jYXRpb24oKSk7XG5cbiAgICAgIHZhciBjbGllbnRJZCA9IHJlZGlyZWN0VXJpLm1hdGNoKC9eKGh0dHBzPzpcXC9cXC9bXlxcL10rKS8pWzBdO1xuXG4gICAgICBBdXRob3JpemUodGhpcywgYXV0aFVSTCwgc2NvcGUsIHJlZGlyZWN0VXJpLCBjbGllbnRJZCk7XG4gICAgfSxcbiAgXG5cbiAgICBpbXBsaWVkYXV0aDogZnVuY3Rpb24gKHN0b3JhZ2VBcGksIHJlZGlyZWN0VXJpKSB7XG4gICAgICBzdG9yYWdlQXBpID0gdGhpcy5yZW1vdGUuc3RvcmFnZUFwaTtcbiAgICAgIHJlZGlyZWN0VXJpID0gIFN0cmluZyhkb2N1bWVudC5sb2NhdGlvbik7XG5cbiAgICAgIGxvZygnSW1wbGllZEF1dGggcHJvY2VlZGluZyBkdWUgdG8gYWJzZW50IGF1dGhVUkw7IHN0b3JhZ2VBcGkgPSAnICsgc3RvcmFnZUFwaSArICcgcmVkaXJlY3RVcmkgPSAnICsgcmVkaXJlY3RVcmkpO1xuICAgICAgLy8gU2V0IGEgZml4ZWQgYWNjZXNzIHRva2VuLCBzaWduYWxsaW5nIHRvIG5vdCBzZW5kIGl0IGFzIEJlYXJlclxuICAgICAgdGhpcy5yZW1vdGUuY29uZmlndXJlKHtcbiAgICAgICAgdG9rZW46IEF1dGhvcml6ZS5JTVBMSUVEX0ZBS0VfVE9LRU5cbiAgICAgIH0pO1xuICAgICAgZG9jdW1lbnQubG9jYXRpb24gPSByZWRpcmVjdFVyaTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFByb3BlcnR5OiByZW1vdGVcbiAgICAgKlxuICAgICAqIFByb3BlcnRpZXM6XG4gICAgICpcbiAgICAgKiAgIGNvbm5lY3RlZCAgIC0gQm9vbGVhbiwgd2hldGhlciBvciBub3QgYSByZW1vdGUgc3RvcmUgaXMgY29ubmVjdGVkXG4gICAgICogICBvbmxpbmUgICAgICAtIEJvb2xlYW4sIHdoZXRoZXIgbGFzdCBzeW5jIGFjdGlvbiB3YXMgc3VjY2Vzc2Z1bCBvciBub3RcbiAgICAgKiAgIHVzZXJBZGRyZXNzIC0gU3RyaW5nLCB0aGUgdXNlciBhZGRyZXNzIG9mIHRoZSBjb25uZWN0ZWQgdXNlclxuICAgICAqICAgcHJvcGVydGllcyAgLSBTdHJpbmcsIHRoZSBwcm9wZXJ0aWVzIG9mIHRoZSBXZWJGaW5nZXIgbGlua1xuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogTWV0aG9kOiBzY29wZVxuICAgICAqXG4gICAgICogUmV0dXJucyBhIEJhc2VDbGllbnQgd2l0aCBhIGNlcnRhaW4gc2NvcGUgKGJhc2UgcGF0aCkuIFBsZWFzZSB1c2UgdGhpcyBtZXRob2RcbiAgICAgKiBvbmx5IGZvciBkZWJ1Z2dpbmcsIGFuZCBhbHdheXMgdXNlIGRlZmluZU1vZHVsZSBpbnN0ZWFkLCB0byBnZXQgYWNjZXNzIHRvIGFcbiAgICAgKiBCYXNlQ2xpZW50IGZyb20gYSBtb2R1bGUgaW4gYW4gYXBwLlxuICAgICAqXG4gICAgICogUGFyYW1ldGVyczpcbiAgICAgKlxuICAgICAqICAgc2NvcGUgLSBBIHN0cmluZywgd2l0aCBhIGxlYWRpbmcgYW5kIGEgdHJhaWxpbmcgc2xhc2gsIHNwZWNpZnlpbmcgdGhlXG4gICAgICogICAgICAgICAgIGJhc2UgcGF0aCBvZiB0aGUgQmFzZUNsaWVudCB0aGF0IHdpbGwgYmUgcmV0dXJuZWQuXG4gICAgICpcbiAgICAgKiBDb2RlIGV4YW1wbGU6XG4gICAgICpcbiAgICAgKiAoc3RhcnQgY29kZSlcbiAgICAgKiByZW1vdGVTdG9yYWdlLnNjb3BlKCcvcGljdHVyZXMvJykuZ2V0TGlzdGluZygnJyk7XG4gICAgICogcmVtb3RlU3RvcmFnZS5zY29wZSgnL3B1YmxpYy9waWN0dXJlcy8nKS5nZXRMaXN0aW5nKCcnKTtcbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIE1ldGhvZDogc3RhcnRTeW5jXG4gICAgICpcbiAgICAgKiBTdGFydCBzeW5jaHJvbml6YXRpb24gd2l0aCByZW1vdGUgc3RvcmFnZSwgZG93bmxvYWRpbmcgYW5kIHVwbG9hZGluZyBhbnlcbiAgICAgKiBjaGFuZ2VzIHdpdGhpbiB0aGUgY2FjaGVkIHBhdGhzLlxuICAgICAqXG4gICAgICogUGxlYXNlIGNvbnNpZGVyOiBsb2NhbCBjaGFuZ2VzIHdpbGwgYXR0ZW1wdCBzeW5jIGltbWVkaWF0ZWx5LCBhbmQgcmVtb3RlXG4gICAgICogY2hhbmdlcyBzaG91bGQgYWxzbyBiZSBzeW5jZWQgdGltZWx5IHdoZW4gdXNpbmcgbGlicmFyeSBkZWZhdWx0cy4gU29cbiAgICAgKiB0aGlzIGlzIG1vc3RseSB1c2VmdWwgZm9yIGxldHRpbmcgdXNlcnMgc3luYyBtYW51YWxseSwgd2hlbiBwcmVzc2luZyBhXG4gICAgICogc3luYyBidXR0b24gZm9yIGV4YW1wbGUuIFRoaXMgbWlnaHQgZmVlbCBzYWZlciB0byB0aGVtIHNvbWV0aW1lcywgZXNwLlxuICAgICAqIHdoZW4gc2hpZnRpbmcgYmV0d2VlbiBvZmZsaW5lIGFuZCBvbmxpbmUgYSBsb3QuXG4gICAgICovXG4gICAgIC8vIChzZWUgc3JjL3N5bmMuanMgZm9yIGltcGxlbWVudGF0aW9uKVxuXG4gICAgLyoqXG4gICAgICogTWV0aG9kOiBjb25uZWN0XG4gICAgICpcbiAgICAgKiBDb25uZWN0IHRvIGEgcmVtb3RlU3RvcmFnZSBzZXJ2ZXIuXG4gICAgICpcbiAgICAgKiBQYXJhbWV0ZXJzOlxuICAgICAqICAgdXNlckFkZHJlc3MgICAgICAgIC0gVGhlIHVzZXIgYWRkcmVzcyAodXNlckBob3N0KSB0byBjb25uZWN0IHRvLlxuICAgICAqICAgdG9rZW4gICAgICAgICAgICAgIC0gKG9wdGlvbmFsKSBBIGJlYXJlciB0b2tlbiBhY3F1aXJlZCBiZWZvcmVoYW5kXG4gICAgICpcbiAgICAgKiBEaXNjb3ZlcnMgdGhlIFdlYkZpbmdlciBwcm9maWxlIG9mIHRoZSBnaXZlbiB1c2VyIGFkZHJlc3MgYW5kIGluaXRpYXRlc1xuICAgICAqIHRoZSBPQXV0aCBkYW5jZS5cbiAgICAgKlxuICAgICAqIFRoaXMgbWV0aG9kIG11c3QgYmUgY2FsbGVkICphZnRlciogYWxsIHJlcXVpcmVkIGFjY2VzcyBoYXMgYmVlbiBjbGFpbWVkLlxuICAgICAqIFdoZW4gdXNpbmcgdGhlIGNvbm5lY3Qgd2lkZ2V0LCBpdCB3aWxsIGNhbGwgdGhpcyBtZXRob2QgaXRzZWxmLlxuICAgICAqXG4gICAgICogU3BlY2lhbCBjYXNlczpcbiAgICAgKlxuICAgICAqIDEuIElmIGEgYmVhcmVyIHRva2VuIGlzIHN1cHBsaWVkIGFzIHNlY29uZCBhcmd1bWVudCwgdGhlIE9BdXRoIGRhbmNlXG4gICAgICogICAgd2lsbCBiZSBza2lwcGVkIGFuZCB0aGUgc3VwcGxpZWQgdG9rZW4gYmUgdXNlZCBpbnN0ZWFkLiBUaGlzIGlzXG4gICAgICogICAgdXNlZnVsIG91dHNpZGUgb2YgYnJvd3NlciBlbnZpcm9ubWVudHMsIHdoZXJlIHRoZSB0b2tlbiBoYXMgYmVlblxuICAgICAqICAgIGFjcXVpcmVkIGluIGEgZGlmZmVyZW50IHdheS5cbiAgICAgKlxuICAgICAqIDIuIElmIHRoZSBXZWJmaW5nZXIgcHJvZmlsZSBmb3IgdGhlIGdpdmVuIHVzZXIgYWRkcmVzcyBkb2Vzbid0IGNvbnRhaW5cbiAgICAgKiAgICBhbiBhdXRoIFVSTCwgdGhlIGxpYnJhcnkgd2lsbCBhc3N1bWUgdGhhdCBjbGllbnQgYW5kIHNlcnZlciBoYXZlXG4gICAgICogICAgZXN0YWJsaXNoZWQgYXV0aG9yaXphdGlvbiBhbW9uZyB0aGVtc2VsdmVzLCB3aGljaCB3aWxsIG9taXQgYmVhcmVyXG4gICAgICogICAgdG9rZW5zIGluIGFsbCByZXF1ZXN0cyBsYXRlciBvbi4gVGhpcyBpcyB1c2VmdWwgZm9yIGV4YW1wbGUgd2hlbiB1c2luZ1xuICAgICAqICAgIEtlcmJlcm9zIGFuZCBzaW1pbGFyIHByb3RvY29scy5cbiAgICAgKi9cbiAgICBjb25uZWN0OiBmdW5jdGlvbiAodXNlckFkZHJlc3MsIHRva2VuKSB7XG4gICAgICB0aGlzLnNldEJhY2tlbmQoJ3JlbW90ZXN0b3JhZ2UnKTtcbiAgICAgIGlmICh1c2VyQWRkcmVzcy5pbmRleE9mKCdAJykgPCAwKSB7XG4gICAgICAgIHRoaXMuX2VtaXQoJ2Vycm9yJywgbmV3IFJlbW90ZVN0b3JhZ2UuRGlzY292ZXJ5RXJyb3IoXCJVc2VyIGFkZHJlc3MgZG9lc24ndCBjb250YWluIGFuIEAuXCIpKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoZ2xvYmFsQ29udGV4dC5jb3Jkb3ZhKSB7XG4gICAgICAgIGlmICh0eXBlb2YgY29uZmlnLmNvcmRvdmFSZWRpcmVjdFVyaSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICB0aGlzLl9lbWl0KCdlcnJvcicsIG5ldyBSZW1vdGVTdG9yYWdlLkRpc2NvdmVyeUVycm9yKFwiUGxlYXNlIHN1cHBseSBhIGN1c3RvbSBIVFRQUyByZWRpcmVjdCBVUkkgZm9yIHlvdXIgQ29yZG92YSBhcHBcIikpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWdsb2JhbENvbnRleHQuY29yZG92YS5JbkFwcEJyb3dzZXIpIHtcbiAgICAgICAgICB0aGlzLl9lbWl0KCdlcnJvcicsIG5ldyBSZW1vdGVTdG9yYWdlLkRpc2NvdmVyeUVycm9yKFwiUGxlYXNlIGluY2x1ZGUgdGhlIEluQXBwQnJvd3NlciBDb3Jkb3ZhIHBsdWdpbiB0byBlbmFibGUgT0F1dGhcIikpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB0aGlzLnJlbW90ZS5jb25maWd1cmUoe1xuICAgICAgICB1c2VyQWRkcmVzczogdXNlckFkZHJlc3NcbiAgICAgIH0pO1xuICAgICAgdGhpcy5fZW1pdCgnY29ubmVjdGluZycpO1xuXG4gICAgICB2YXIgZGlzY292ZXJ5VGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9lbWl0KCdlcnJvcicsIG5ldyBSZW1vdGVTdG9yYWdlLkRpc2NvdmVyeUVycm9yKFwiTm8gc3RvcmFnZSBpbmZvcm1hdGlvbiBmb3VuZCBmb3IgdGhpcyB1c2VyIGFkZHJlc3MuXCIpKTtcbiAgICAgIH0uYmluZCh0aGlzKSwgY29uZmlnLmRpc2NvdmVyeVRpbWVvdXQpO1xuXG4gICAgICBEaXNjb3Zlcih1c2VyQWRkcmVzcykudGhlbihmdW5jdGlvbiAoaW5mbykge1xuICAgICAgICAvLyBJbmZvIGNvbnRhaW5zIGZpZWxkczogaHJlZiwgc3RvcmFnZUFwaSwgYXV0aFVSTCAob3B0aW9uYWwpLCBwcm9wZXJ0aWVzXG5cbiAgICAgICAgY2xlYXJUaW1lb3V0KGRpc2NvdmVyeVRpbWVvdXQpO1xuICAgICAgICB0aGlzLl9lbWl0KCdhdXRoaW5nJyk7XG4gICAgICAgIGluZm8udXNlckFkZHJlc3MgPSB1c2VyQWRkcmVzcztcbiAgICAgICAgdGhpcy5yZW1vdGUuY29uZmlndXJlKGluZm8pO1xuICAgICAgICBpZiAoISB0aGlzLnJlbW90ZS5jb25uZWN0ZWQpIHtcbiAgICAgICAgICBpZiAoaW5mby5hdXRoVVJMKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHRva2VuID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAvLyBOb3JtYWwgYXV0aG9yaXphdGlvbiBzdGVwOyB0aGUgZGVmYXVsdCB3YXkgdG8gY29ubmVjdFxuICAgICAgICAgICAgICB0aGlzLmF1dGhvcml6ZShpbmZvLmF1dGhVUkwsIGNvbmZpZy5jb3Jkb3ZhUmVkaXJlY3RVcmkpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdG9rZW4gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgIC8vIFRva2VuIHN1cHBsaWVkIGRpcmVjdGx5IGJ5IGFwcC9kZXZlbG9wZXIvdXNlclxuICAgICAgICAgICAgICBsb2coJ1NraXBwaW5nIGF1dGhvcml6YXRpb24gc2VxdWVuY2UgYW5kIGNvbm5lY3Rpbmcgd2l0aCBrbm93biB0b2tlbicpO1xuICAgICAgICAgICAgICB0aGlzLnJlbW90ZS5jb25maWd1cmUoeyB0b2tlbjogdG9rZW4gfSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJTdXBwbGllZCBiZWFyZXIgdG9rZW4gbXVzdCBiZSBhIHN0cmluZ1wiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gSW4gbGlldSBvZiBhbiBleGNwbGljaXQgYXV0aFVSTCwgYXNzdW1lIHRoYXQgdGhlIGJyb3dzZXIgYW5kXG4gICAgICAgICAgICAvLyBzZXJ2ZXIgaGFuZGxlIGFueSBhdXRob3JpemF0aW9uIG5lZWRzOyBmb3IgaW5zdGFuY2UsIFRMUyBtYXlcbiAgICAgICAgICAgIC8vIHRyaWdnZXIgdGhlIGJyb3dzZXIgdG8gdXNlIGEgY2xpZW50IGNlcnRpZmljYXRlLCBvciBhIDQwMSBOb3RcbiAgICAgICAgICAgIC8vIEF1dGhvcml6ZWQgcmVzcG9uc2UgbWF5IG1ha2UgdGhlIGJyb3dzZXIgc2VuZCBhIEtlcmJlcm9zIHRpY2tldFxuICAgICAgICAgICAgLy8gdXNpbmcgdGhlIFNQTkVHTyBtZXRob2QuXG4gICAgICAgICAgICB0aGlzLmltcGxpZWRhdXRoKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LmJpbmQodGhpcyksIGZ1bmN0aW9uKGVycikge1xuICAgICAgICBjbGVhclRpbWVvdXQoZGlzY292ZXJ5VGltZW91dCk7XG4gICAgICAgIHRoaXMuX2VtaXQoJ2Vycm9yJywgbmV3IFJlbW90ZVN0b3JhZ2UuRGlzY292ZXJ5RXJyb3IoXCJObyBzdG9yYWdlIGluZm9ybWF0aW9uIGZvdW5kIGZvciB0aGlzIHVzZXIgYWRkcmVzcy5cIikpO1xuICAgICAgfS5iaW5kKHRoaXMpKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTWV0aG9kOiBkaXNjb25uZWN0XG4gICAgICpcbiAgICAgKiBcIkRpc2Nvbm5lY3RcIiBmcm9tIHJlbW90ZXN0b3JhZ2Ugc2VydmVyIHRvIHRlcm1pbmF0ZSBjdXJyZW50IHNlc3Npb24uXG4gICAgICogVGhpcyBtZXRob2QgY2xlYXJzIGFsbCBzdG9yZWQgc2V0dGluZ3MgYW5kIGRlbGV0ZXMgdGhlIGVudGlyZSBsb2NhbFxuICAgICAqIGNhY2hlLlxuICAgICAqL1xuICAgIGRpc2Nvbm5lY3Q6IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICh0aGlzLnJlbW90ZSkge1xuICAgICAgICB0aGlzLnJlbW90ZS5jb25maWd1cmUoe1xuICAgICAgICAgIHVzZXJBZGRyZXNzOiBudWxsLFxuICAgICAgICAgIGhyZWY6IG51bGwsXG4gICAgICAgICAgc3RvcmFnZUFwaTogbnVsbCxcbiAgICAgICAgICB0b2tlbjogbnVsbCxcbiAgICAgICAgICBwcm9wZXJ0aWVzOiBudWxsXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgdGhpcy5fc2V0R1BEKHtcbiAgICAgICAgZ2V0OiB0aGlzLl9wZW5kaW5nR1BEKCdnZXQnKSxcbiAgICAgICAgcHV0OiB0aGlzLl9wZW5kaW5nR1BEKCdwdXQnKSxcbiAgICAgICAgZGVsZXRlOiB0aGlzLl9wZW5kaW5nR1BEKCdkZWxldGUnKVxuICAgICAgfSk7XG4gICAgICB2YXIgbiA9IHRoaXMuX2NsZWFudXBzLmxlbmd0aCwgaSA9IDA7XG5cbiAgICAgIHZhciBvbmVEb25lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpKys7XG4gICAgICAgIGlmIChpID49IG4pIHtcbiAgICAgICAgICB0aGlzLl9pbml0KCk7XG4gICAgICAgICAgbG9nKCdEb25lIGNsZWFuaW5nIHVwLCBlbWl0dGluZyBkaXNjb25uZWN0ZWQgYW5kIGRpc2Nvbm5lY3QgZXZlbnRzJyk7XG4gICAgICAgICAgdGhpcy5fZW1pdCgnZGlzY29ubmVjdGVkJyk7XG4gICAgICAgIH1cbiAgICAgIH0uYmluZCh0aGlzKTtcblxuICAgICAgaWYgKG4gPiAwKSB7XG4gICAgICAgIHRoaXMuX2NsZWFudXBzLmZvckVhY2goZnVuY3Rpb24gKGNsZWFudXApIHtcbiAgICAgICAgICB2YXIgY2xlYW51cFJlc3VsdCA9IGNsZWFudXAodGhpcyk7XG4gICAgICAgICAgaWYgKHR5cGVvZihjbGVhbnVwUmVzdWx0KSA9PT0gJ29iamVjdCcgJiYgdHlwZW9mKGNsZWFudXBSZXN1bHQudGhlbikgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNsZWFudXBSZXN1bHQudGhlbihvbmVEb25lKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgb25lRG9uZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfS5iaW5kKHRoaXMpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG9uZURvbmUoKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgc2V0QmFja2VuZDogZnVuY3Rpb24gKHdoYXQpIHtcbiAgICAgIHRoaXMuYmFja2VuZCA9IHdoYXQ7XG4gICAgICBpZiAoaGFzTG9jYWxTdG9yYWdlKSB7XG4gICAgICAgIGlmICh3aGF0KSB7XG4gICAgICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oJ3JlbW90ZXN0b3JhZ2U6YmFja2VuZCcsIHdoYXQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKCdyZW1vdGVzdG9yYWdlOmJhY2tlbmQnKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNZXRob2Q6IG9uQ2hhbmdlXG4gICAgICpcbiAgICAgKiBBZGQgYSBcImNoYW5nZVwiIGV2ZW50IGhhbmRsZXIgdG8gdGhlIGdpdmVuIHBhdGguIFdoZW5ldmVyIGEgXCJjaGFuZ2VcIlxuICAgICAqIGhhcHBlbnMgKGFzIGRldGVybWluZWQgYnkgdGhlIGJhY2tlbmQsIHN1Y2ggYXMgZS5nLlxuICAgICAqIDxSZW1vdGVTdG9yYWdlLkluZGV4ZWREQj4pIGFuZCB0aGUgYWZmZWN0ZWQgcGF0aCBpcyBlcXVhbCB0byBvciBiZWxvd1xuICAgICAqIHRoZSBnaXZlbiAncGF0aCcsIHRoZSBnaXZlbiBoYW5kbGVyIGlzIGNhbGxlZC5cbiAgICAgKlxuICAgICAqIFlvdSBzaG91bGQgdXN1YWxseSBub3QgdXNlIHRoaXMgbWV0aG9kIGRpcmVjdGx5LCBidXQgaW5zdGVhZCB1c2UgdGhlXG4gICAgICogXCJjaGFuZ2VcIiBldmVudHMgcHJvdmlkZWQgYnkgPFJlbW90ZVN0b3JhZ2UuQmFzZUNsaWVudD4uXG4gICAgICpcbiAgICAgKiBQYXJhbWV0ZXJzOlxuICAgICAqICAgcGF0aCAgICAtIEFic29sdXRlIHBhdGggdG8gYXR0YWNoIGhhbmRsZXIgdG8uXG4gICAgICogICBoYW5kbGVyIC0gSGFuZGxlciBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBvbkNoYW5nZTogZnVuY3Rpb24gKHBhdGgsIGhhbmRsZXIpIHtcbiAgICAgIGlmICghIHRoaXMuX3BhdGhIYW5kbGVycy5jaGFuZ2VbcGF0aF0pIHtcbiAgICAgICAgdGhpcy5fcGF0aEhhbmRsZXJzLmNoYW5nZVtwYXRoXSA9IFtdO1xuICAgICAgfVxuICAgICAgdGhpcy5fcGF0aEhhbmRsZXJzLmNoYW5nZVtwYXRoXS5wdXNoKGhhbmRsZXIpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNZXRob2Q6IGVuYWJsZUxvZ1xuICAgICAqXG4gICAgICogRW5hYmxlIHJlbW90ZVN0b3JhZ2UgbG9nZ2luZy5cbiAgICAgKi9cbiAgICBlbmFibGVMb2c6IGZ1bmN0aW9uICgpIHtcbiAgICAgIGNvbmZpZy5sb2dnaW5nID0gdHJ1ZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTWV0aG9kOiBkaXNhYmxlTG9nXG4gICAgICpcbiAgICAgKiBEaXNhYmxlIHJlbW90ZVN0b3JhZ2UgbG9nZ2luZ1xuICAgICAqL1xuICAgIGRpc2FibGVMb2c6IGZ1bmN0aW9uICgpIHtcbiAgICAgIGNvbmZpZy5sb2dnaW5nID0gZmFsc2U7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1ldGhvZDogbG9nXG4gICAgICpcbiAgICAgKiBUaGUgc2FtZSBhcyA8UmVtb3RlU3RvcmFnZS5sb2c+LlxuICAgICAqL1xuICAgIGxvZzogZnVuY3Rpb24gKCkge1xuICAgICAgbG9nLmFwcGx5KFJlbW90ZVN0b3JhZ2UsIGFyZ3VtZW50cyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1ldGhvZDogc2V0QXBpS2V5cyAoZXhwZXJpbWVudGFsKVxuICAgICAqXG4gICAgICogU2V0IEFQSSBrZXlzIGZvciAoY3VycmVudGx5KSBHb29nbGVEcml2ZSBhbmQvb3IgRHJvcGJveCBiYWNrZW5kIHN1cHBvcnQuXG4gICAgICogU2VlIGFsc28gdGhlICdiYWNrZW5kcycgZXhhbXBsZSBpbiB0aGUgc3RhcnRlci1raXQuIE5vdGUgdGhhdCBzdXBwb3J0IGZvclxuICAgICAqIGJvdGggdGhlc2UgYmFja2VuZHMgaXMgc3RpbGwgZXhwZXJpbWVudGFsLlxuICAgICAqXG4gICAgICogUGFyYW1ldGVyczpcbiAgICAgKiAgIHR5cGUgLSBzdHJpbmcsIGVpdGhlciAnZ29vZ2xlZHJpdmUnIG9yICdkcm9wYm94J1xuICAgICAqICAga2V5cyAtIG9iamVjdCwgd2l0aCBvbmUgc3RyaW5nIGZpZWxkOyAnY2xpZW50SWQnIGZvciBHb29nbGVEcml2ZSwgb3JcbiAgICAgKiAgICAgICAgICAnYXBwS2V5JyBmb3IgRHJvcGJveC5cbiAgICAgKlxuICAgICAqL1xuICAgIHNldEFwaUtleXM6IGZ1bmN0aW9uICh0eXBlLCBrZXlzKSB7XG4gICAgICBpZiAoa2V5cykge1xuICAgICAgICB0aGlzLmFwaUtleXNbdHlwZV0gPSBrZXlzO1xuICAgICAgICBpZiAodHlwZSA9PT0gJ2Ryb3Bib3gnICYmICh0eXBlb2YgdGhpcy5kcm9wYm94ID09PSAndW5kZWZpbmVkJyB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRyb3Bib3guY2xpZW50SWQgIT09IGtleXMuYXBwS2V5KSkge1xuICAgICAgICAgIERyb3Bib3guX3JzX2luaXQodGhpcyk7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ2dvb2dsZWRyaXZlJyAmJiAodHlwZW9mIHRoaXMuZ29vZ2xlZHJpdmUgPT09ICd1bmRlZmluZWQnIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5nb29nbGVkcml2ZS5jbGllbnRJZCAhPT0ga2V5cy5jbGllbnRJZCkpIHtcbiAgICAgICAgICBHb29nbGVEcml2ZS5fcnNfaW5pdCh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGVsZXRlIHRoaXMuYXBpS2V5c1t0eXBlXTtcbiAgICAgIH1cbiAgICAgIGlmIChoYXNMb2NhbFN0b3JhZ2UpIHtcbiAgICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oJ3JlbW90ZXN0b3JhZ2U6YXBpLWtleXMnLCBKU09OLnN0cmluZ2lmeSh0aGlzLmFwaUtleXMpKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTWV0aG9kOiBzZXRDb3Jkb3ZhUmVkaXJlY3RVcmlcbiAgICAgKlxuICAgICAqIFNldCByZWRpcmVjdCBVUkkgdG8gYmUgdXNlZCBmb3IgdGhlIE9BdXRoIHJlZGlyZWN0IHdpdGhpbiB0aGVcbiAgICAgKiBpbi1hcHAtYnJvd3NlciB3aW5kb3cgaW4gQ29yZG92YSBhcHBzLlxuICAgICAqXG4gICAgICogUGFyYW1ldGVyczpcbiAgICAgKiAgIHVyaSAtIHN0cmluZywgdmFsaWQgSFRUUChTKSBVUklcbiAgICAgKi9cbiAgICBzZXRDb3Jkb3ZhUmVkaXJlY3RVcmk6IGZ1bmN0aW9uICh1cmkpIHtcbiAgICAgIGlmICh0eXBlb2YgdXJpICE9PSAnc3RyaW5nJyB8fCAhdXJpLm1hdGNoKC9odHRwKHMpP1xcOlxcL1xcLy8pKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNvcmRvdmEgcmVkaXJlY3QgVVJJIG11c3QgYmUgYSBVUkkgc3RyaW5nXCIpO1xuICAgICAgfVxuICAgICAgY29uZmlnLmNvcmRvdmFSZWRpcmVjdFVyaSA9IHVyaTtcbiAgICB9LFxuXG5cbiAgICAvKiBGRUFUVVJFUyBJTklUSUFMSVpBVElPTiAqL1xuICAgIF9pbml0OiBGZWF0dXJlcy5sb2FkRmVhdHVyZXMsXG4gICAgZmVhdHVyZXM6IEZlYXR1cmVzLmZlYXR1cmVzLFxuICAgIGxvYWRGZWF0dXJlOiBGZWF0dXJlcy5sb2FkRmVhdHVyZSxcbiAgICBmZWF0dXJlU3VwcG9ydGVkOiBGZWF0dXJlcy5mZWF0dXJlU3VwcG9ydGVkLFxuICAgIGZlYXR1cmVEb25lOiBGZWF0dXJlcy5mZWF0dXJlRG9uZSxcbiAgICBmZWF0dXJlc0RvbmU6IEZlYXR1cmVzLmZlYXR1cmVzRG9uZSxcbiAgICBmZWF0dXJlc0xvYWRlZDogRmVhdHVyZXMuZmVhdHVyZXNMb2FkZWQsXG4gICAgZmVhdHVyZUluaXRpYWxpemVkOiBGZWF0dXJlcy5mZWF0dXJlSW5pdGlhbGl6ZWQsXG4gICAgZmVhdHVyZUZhaWxlZDogRmVhdHVyZXMuZmVhdHVyZUZhaWxlZCxcbiAgICBoYXNGZWF0dXJlOiBGZWF0dXJlcy5oYXNGZWF0dXJlLFxuICAgIF9zZXRDYWNoaW5nTW9kdWxlOiBGZWF0dXJlcy5fc2V0Q2FjaGluZ01vZHVsZSxcbiAgICBfY29sbGVjdENsZWFudXBGdW5jdGlvbnM6IEZlYXR1cmVzLl9jb2xsZWN0Q2xlYW51cEZ1bmN0aW9ucyxcbiAgICBfZmlyZVJlYWR5OiBGZWF0dXJlcy5fZmlyZVJlYWR5LFxuICAgIGluaXRGZWF0dXJlOiBGZWF0dXJlcy5pbml0RmVhdHVyZSxcblxuXG4gICAgLyoqXG4gICAgICogVE9GSVg6IG5lZWRzIHNvbWUgZXhwbGFuYXRpb24gb24gdGhpcyAtbGVzXG4gICAgICoqIEdFVC9QVVQvREVMRVRFIElOVEVSRkFDRSBIRUxQRVJTXG4gICAgICoqL1xuXG4gICAgX3NldEdQRDogZnVuY3Rpb24gKGltcGwsIGNvbnRleHQpIHtcbiAgICAgIGZ1bmN0aW9uIHdyYXAoZnVuYykge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBmdW5jLmFwcGx5KGNvbnRleHQsIGFyZ3VtZW50cylcbiAgICAgICAgICAgIC50aGVuKGVtaXRVbmF1dGhvcml6ZWQuYmluZCh0aGlzKSk7XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICB0aGlzLmdldCA9IHdyYXAoaW1wbC5nZXQpO1xuICAgICAgdGhpcy5wdXQgPSB3cmFwKGltcGwucHV0KTtcbiAgICAgIHRoaXMuZGVsZXRlID0gd3JhcChpbXBsLmRlbGV0ZSk7XG4gICAgfSxcblxuICAgIF9wZW5kaW5nR1BEOiBmdW5jdGlvbiAobWV0aG9kTmFtZSkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG1ldGhvZEFyZ3VtZW50cyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICB0aGlzLl9wZW5kaW5nLnB1c2goe1xuICAgICAgICAgICAgbWV0aG9kOiBtZXRob2ROYW1lLFxuICAgICAgICAgICAgYXJnczogbWV0aG9kQXJndW1lbnRzLFxuICAgICAgICAgICAgcHJvbWlzZToge1xuICAgICAgICAgICAgICByZXNvbHZlOiByZXNvbHZlLFxuICAgICAgICAgICAgICByZWplY3Q6IHJlamVjdFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9LmJpbmQodGhpcykpO1xuICAgICAgfS5iaW5kKHRoaXMpO1xuICAgIH0sXG5cbiAgICBfcHJvY2Vzc1BlbmRpbmc6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMuX3BlbmRpbmcuZm9yRWFjaChmdW5jdGlvbiAocGVuZGluZykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHRoaXNbcGVuZGluZy5tZXRob2RdLmFwcGx5KHRoaXMsIHBlbmRpbmcuYXJncykudGhlbihwZW5kaW5nLnByb21pc2UucmVzb2x2ZSwgcGVuZGluZy5wcm9taXNlLnJlamVjdCk7XG4gICAgICAgIH0gY2F0Y2goZSkge1xuICAgICAgICAgIHBlbmRpbmcucHJvbWlzZS5yZWplY3QoZSk7XG4gICAgICAgIH1cbiAgICAgIH0uYmluZCh0aGlzKSk7XG4gICAgICB0aGlzLl9wZW5kaW5nID0gW107XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqKiBDSEFOR0UgRVZFTlQgSEFORExJTkdcbiAgICAgKiovXG4gICAgX2JpbmRDaGFuZ2U6IGZ1bmN0aW9uIChvYmplY3QpIHtcbiAgICAgIG9iamVjdC5vbignY2hhbmdlJywgdGhpcy5fZGlzcGF0Y2hFdmVudC5iaW5kKHRoaXMsICdjaGFuZ2UnKSk7XG4gICAgfSxcblxuICAgIF9kaXNwYXRjaEV2ZW50OiBmdW5jdGlvbiAoZXZlbnROYW1lLCBldmVudCkge1xuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgT2JqZWN0LmtleXModGhpcy5fcGF0aEhhbmRsZXJzW2V2ZW50TmFtZV0pLmZvckVhY2goZnVuY3Rpb24gKHBhdGgpIHtcbiAgICAgICAgdmFyIHBsID0gcGF0aC5sZW5ndGg7XG4gICAgICAgIGlmIChldmVudC5wYXRoLnN1YnN0cigwLCBwbCkgPT09IHBhdGgpIHtcbiAgICAgICAgICBzZWxmLl9wYXRoSGFuZGxlcnNbZXZlbnROYW1lXVtwYXRoXS5mb3JFYWNoKGZ1bmN0aW9uIChoYW5kbGVyKSB7XG4gICAgICAgICAgICB2YXIgZXYgPSB7fTtcbiAgICAgICAgICAgIGZvciAodmFyIGtleSBpbiBldmVudCkgeyBldltrZXldID0gZXZlbnRba2V5XTsgfVxuICAgICAgICAgICAgZXYucmVsYXRpdmVQYXRoID0gZXZlbnQucGF0aC5yZXBsYWNlKG5ldyBSZWdFeHAoJ14nICsgcGF0aCksICcnKTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIGhhbmRsZXIoZXYpO1xuICAgICAgICAgICAgfSBjYXRjaChlKSB7XG4gICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCInY2hhbmdlJyBoYW5kbGVyIGZhaWxlZDogXCIsIGUsIGUuc3RhY2spO1xuICAgICAgICAgICAgICBzZWxmLl9lbWl0KCdlcnJvcicsIGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9LFxuXG5cbiAgICBzY29wZTogZnVuY3Rpb24gKHBhdGgpIHtcbiAgICAgIGlmICh0eXBlb2YocGF0aCkgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRocm93ICdBcmd1bWVudCBcXCdwYXRoXFwnIG9mIGJhc2VDbGllbnQuc2NvcGUgbXVzdCBiZSBhIHN0cmluZyc7XG4gICAgICB9XG5cbiAgICAgIGlmICghdGhpcy5hY2Nlc3MuY2hlY2tQYXRoUGVybWlzc2lvbihwYXRoLCAncicpKSB7XG4gICAgICAgIHZhciBlc2NhcGVkUGF0aCA9IHBhdGgucmVwbGFjZSgvKFsnXFxcXF0pL2csICdcXFxcJDEnKTtcbiAgICAgICAgY29uc29sZS53YXJuKCdXQVJOSU5HOiBwbGVhc2UgY2FsbCByZW1vdGVTdG9yYWdlLmFjY2Vzcy5jbGFpbShcXCcnICsgZXNjYXBlZFBhdGggKyAnXFwnLCBcXCdyXFwnKSAocmVhZCBvbmx5KSBvciByZW1vdGVTdG9yYWdlLmFjY2Vzcy5jbGFpbShcXCcnICsgZXNjYXBlZFBhdGggKyAnXFwnLCBcXCdyd1xcJykgKHJlYWQvd3JpdGUpIGZpcnN0Jyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbmV3IEJhc2VDbGllbnQodGhpcywgcGF0aCk7XG4gICAgfSxcblxuXG5cblxuICAgIC8qKlxuICAgICAqIE1ldGhvZDogZ2V0U3luY0ludGVydmFsXG4gICAgICpcbiAgICAgKiBHZXQgdGhlIHZhbHVlIG9mIHRoZSBzeW5jIGludGVydmFsIHdoZW4gYXBwbGljYXRpb24gaXMgaW4gdGhlIGZvcmVncm91bmRcbiAgICAgKlxuICAgICAqIFJldHVybnMgYSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzXG4gICAgICpcbiAgICAvLyAgKi9cbiAgICBnZXRTeW5jSW50ZXJ2YWw6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBjb25maWcuc3luY0ludGVydmFsO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNZXRob2Q6IHNldFN5bmNJbnRlcnZhbFxuICAgICAqXG4gICAgICogU2V0IHRoZSB2YWx1ZSBvZiB0aGUgc3luYyBpbnRlcnZhbCB3aGVuIGFwcGxpY2F0aW9uIGlzIGluIHRoZSBmb3JlZ3JvdW5kXG4gICAgICpcbiAgICAgKiBQYXJhbWV0ZXJzOlxuICAgICAqICAgaW50ZXJ2YWwgLSBzeW5jIGludGVydmFsIGluIG1pbGxpc2Vjb25kc1xuICAgICAqXG4gICAgICovXG4gICAgc2V0U3luY0ludGVydmFsOiBmdW5jdGlvbiAoaW50ZXJ2YWwpIHtcbiAgICAgIGlmICghaXNWYWxpZEludGVydmFsKGludGVydmFsKSkge1xuICAgICAgICB0aHJvdyBpbnRlcnZhbCArIFwiIGlzIG5vdCBhIHZhbGlkIHN5bmMgaW50ZXJ2YWxcIjtcbiAgICAgIH1cbiAgICAgIHZhciBvbGRWYWx1ZSA9IGNvbmZpZy5zeW5jSW50ZXJ2YWw7XG4gICAgICBjb25maWcuc3luY0ludGVydmFsID0gcGFyc2VJbnQoaW50ZXJ2YWwsIDEwKTtcbiAgICAgIHRoaXMuX2VtaXQoJ3N5bmMtaW50ZXJ2YWwtY2hhbmdlJywge29sZFZhbHVlOiBvbGRWYWx1ZSwgbmV3VmFsdWU6IGludGVydmFsfSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1ldGhvZDogZ2V0QmFja2dyb3VuZFN5bmNJbnRlcnZhbFxuICAgICAqXG4gICAgICogR2V0IHRoZSB2YWx1ZSBvZiB0aGUgc3luYyBpbnRlcnZhbCB3aGVuIGFwcGxpY2F0aW9uIGlzIGluIHRoZSBiYWNrZ3JvdW5kXG4gICAgICpcbiAgICAgKiBSZXR1cm5zIGEgbnVtYmVyIG9mIG1pbGxpc2Vjb25kc1xuICAgICAqXG4gICAgICovXG4gICAgZ2V0QmFja2dyb3VuZFN5bmNJbnRlcnZhbDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIGNvbmZpZy5iYWNrZ3JvdW5kU3luY0ludGVydmFsO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNZXRob2Q6IHNldEJhY2tncm91bmRTeW5jSW50ZXJ2YWxcbiAgICAgKlxuICAgICAqIFNldCB0aGUgdmFsdWUgb2YgdGhlIHN5bmMgaW50ZXJ2YWwgd2hlbiB0aGUgYXBwbGljYXRpb24gaXMgaW4gdGhlIGJhY2tncm91bmRcbiAgICAgKlxuICAgICAqIFBhcmFtZXRlcnM6XG4gICAgICogICBpbnRlcnZhbCAtIHN5bmMgaW50ZXJ2YWwgaW4gbWlsbGlzZWNvbmRzXG4gICAgICpcbiAgICAgKi9cbiAgICBzZXRCYWNrZ3JvdW5kU3luY0ludGVydmFsOiBmdW5jdGlvbiAoaW50ZXJ2YWwpIHtcbiAgICAgIGlmKCFpc1ZhbGlkSW50ZXJ2YWwoaW50ZXJ2YWwpKSB7XG4gICAgICAgIHRocm93IGludGVydmFsICsgXCIgaXMgbm90IGEgdmFsaWQgc3luYyBpbnRlcnZhbFwiO1xuICAgICAgfVxuICAgICAgdmFyIG9sZFZhbHVlID0gY29uZmlnLmJhY2tncm91bmRTeW5jSW50ZXJ2YWw7XG4gICAgICBjb25maWcuYmFja2dyb3VuZFN5bmNJbnRlcnZhbCA9IHBhcnNlSW50KGludGVydmFsLCAxMCk7XG4gICAgICB0aGlzLl9lbWl0KCdzeW5jLWludGVydmFsLWNoYW5nZScsIHtvbGRWYWx1ZTogb2xkVmFsdWUsIG5ld1ZhbHVlOiBpbnRlcnZhbH0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNZXRob2Q6IGdldEN1cnJlbnRTeW5jSW50ZXJ2YWxcbiAgICAgKlxuICAgICAqIEdldCB0aGUgdmFsdWUgb2YgdGhlIGN1cnJlbnQgc3luYyBpbnRlcnZhbFxuICAgICAqXG4gICAgICogUmV0dXJucyBhIG51bWJlciBvZiBtaWxsaXNlY29uZHNcbiAgICAgKlxuICAgICAqL1xuICAgIGdldEN1cnJlbnRTeW5jSW50ZXJ2YWw6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBjb25maWcuaXNCYWNrZ3JvdW5kID8gY29uZmlnLmJhY2tncm91bmRTeW5jSW50ZXJ2YWwgOiBjb25maWcuc3luY0ludGVydmFsO1xuICAgIH0sXG5cblxuXG4gICAgc3luY0N5Y2xlOiBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAodGhpcy5zeW5jLnN0b3BwZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnN5bmMub24oJ2RvbmUnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGxvZygnW1N5bmNdIFN5bmMgZG9uZS4gU2V0dGluZyB0aW1lciB0bycsIHRoaXMuZ2V0Q3VycmVudFN5bmNJbnRlcnZhbCgpKTtcbiAgICAgICAgaWYgKCF0aGlzLnN5bmMuc3RvcHBlZCkge1xuICAgICAgICAgIGlmICh0aGlzLl9zeW5jVGltZXIpIHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLl9zeW5jVGltZXIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLl9zeW5jVGltZXIgPSBzZXRUaW1lb3V0KHRoaXMuc3luYy5zeW5jLmJpbmQodGhpcy5zeW5jKSwgdGhpcy5nZXRDdXJyZW50U3luY0ludGVydmFsKCkpO1xuICAgICAgICB9XG4gICAgICB9LmJpbmQodGhpcykpO1xuXG4gICAgICB0aGlzLnN5bmMuc3luYygpO1xuICAgIH0sXG5cbiAgICBzdG9wU3luYzogZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKHRoaXMuc3luYykge1xuICAgICAgICBsb2coJ1tTeW5jXSBTdG9wcGluZyBzeW5jJyk7XG4gICAgICAgIHRoaXMuc3luYy5zdG9wcGVkID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFRPRE8gV2hlbiBpcyB0aGlzIGV2ZXIgdGhlIGNhc2UgYW5kIHdoYXQgaXMgc3luY1N0b3BwZWQgZm9yIHRoZW4/XG4gICAgICAgIGxvZygnW1N5bmNdIFdpbGwgaW5zdGFudGlhdGUgc3luYyBzdG9wcGVkJyk7XG4gICAgICAgIHRoaXMuc3luY1N0b3BwZWQgPSB0cnVlO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBzdGFydFN5bmM6IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICghY29uZmlnLmNhY2hlKSB7IHJldHVybjsgfVxuICAgICAgdGhpcy5zeW5jLnN0b3BwZWQgPSBmYWxzZTtcbiAgICAgIHRoaXMuc3luY1N0b3BwZWQgPSBmYWxzZTtcbiAgICAgIHRoaXMuc3luYy5zeW5jKCk7XG4gICAgfVxuXG4gIH07XG5cblxuICAgIC8qKlxuICAgKiBDaGVjayBpZiBpbnRlcnZhbCBpcyB2YWxpZDogbnVtZXJpYyBhbmQgYmV0d2VlbiAxMDAwbXMgYW5kIDM2MDAwMDBtc1xuICAgKlxuICAgKi9cbiAgZnVuY3Rpb24gaXNWYWxpZEludGVydmFsKGludGVydmFsKSB7XG4gICAgcmV0dXJuICh0eXBlb2YgaW50ZXJ2YWwgPT09ICdudW1iZXInICYmIGludGVydmFsID4gMTAwMCAmJiBpbnRlcnZhbCA8IDM2MDAwMDApO1xuICB9XG5cblxuICBSZW1vdGVTdG9yYWdlLnV0aWwgPSB1dGlsO1xuICAvLyBSZW1vdGVTdG9yYWdlLmRlZmluZU1vZHVsZSA9IG1vZHVsZXMuZGVmaW5lTW9kdWxlO1xuXG4gIC8qKlxuICAgKiBQcm9wZXJ0eTogY29ubmVjdGVkXG4gICAqXG4gICAqIEJvb2xlYW4gcHJvcGVydHkgaW5kaWNhdGluZyBpZiByZW1vdGVTdG9yYWdlIGlzIGN1cnJlbnRseSBjb25uZWN0ZWQuXG4gICAqL1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUmVtb3RlU3RvcmFnZS5wcm90b3R5cGUsICdjb25uZWN0ZWQnLCB7XG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5yZW1vdGUuY29ubmVjdGVkO1xuICAgIH1cbiAgfSk7XG5cbiAgLyoqXG4gICAqIFByb3BlcnR5OiBhY2Nlc3NcbiAgICpcbiAgICogVHJhY2tpbmcgY2xhaW1lZCBhY2Nlc3Mgc2NvcGVzLiBBIDxSZW1vdGVTdG9yYWdlLkFjY2Vzcz4gaW5zdGFuY2UuXG4gICovXG4gIHZhciBBY2Nlc3MgPSByZXF1aXJlKCcuL2FjY2VzcycpO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUmVtb3RlU3RvcmFnZS5wcm90b3R5cGUsICdhY2Nlc3MnLCB7XG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBhY2Nlc3MgPSBuZXcgQWNjZXNzKCk7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ2FjY2VzcycsIHtcbiAgICAgICAgdmFsdWU6IGFjY2Vzc1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gYWNjZXNzO1xuICAgIH0sXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xuXG5cblxuXG5cbiAgLy8gVE9ETyBjbGVhbiB1cC9oYXJtb25pemUgaG93IG1vZHVsZXMgYXJlIGxvYWRlZCBhbmQvb3IgZG9jdW1lbnQgdGhpcyBhcmNoaXRlY3R1cmUgcHJvcGVybHlcbiAgLy9cbiAgLy8gQXQgdGhpcyBwb2ludCB0aGUgcmVtb3RlU3RvcmFnZSBvYmplY3QgaGFzIG5vdCBiZWVuIGNyZWF0ZWQgeWV0LlxuICAvLyBPbmx5IGl0cyBwcm90b3R5cGUgZXhpc3RzIHNvIGZhciwgc28gd2UgZGVmaW5lIGEgc2VsZi1jb25zdHJ1Y3RpbmdcbiAgLy8gcHJvcGVydHkgb24gdGhlcmU6XG4gIC8qKlxuICAgKlxuICAgKiBQcm9wZXJ0eTogY2FjaGluZ1xuICAgKlxuICAgKiBDYWNoaW5nIHNldHRpbmdzLiBBIDxSZW1vdGVTdG9yYWdlLkNhY2hpbmc+IGluc3RhbmNlLlxuICAgKlxuICAgKiBOb3QgYXZhaWxhYmxlIGluIG5vLWNhY2hlIGJ1aWxkcy5cbiAgICpcbiAgICovXG5cbiAgLy8gVE9GSVggd2FzIGluIHJzX2luaXQgb2YgQ2FjaGluZyBidXQgZG9uJ3Qgd2FudCB0byByZXF1aXJlIFJlbW90ZVN0b3JhZ2UgZnJvbSB0aGVyZS5cbiAgdmFyIENhY2hpbmcgPSByZXF1aXJlKCcuL2NhY2hpbmcnKTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFJlbW90ZVN0b3JhZ2UucHJvdG90eXBlLCAnY2FjaGluZycsIHtcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgY2FjaGluZyA9IG5ldyBDYWNoaW5nKCk7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ2NhY2hpbmcnLCB7XG4gICAgICAgIHZhbHVlOiBjYWNoaW5nXG4gICAgICB9KTtcbiAgICAgIHJldHVybiBjYWNoaW5nO1xuICAgIH1cbiAgfSk7XG5cbiAgIC8qXG4gICAqIFByb3BlcnR5OiByZW1vdGVcbiAgICpcbiAgICogQWNjZXNzIHRvIHRoZSByZW1vdGUgYmFja2VuZCB1c2VkLiBVc3VhbGx5IGEgPFJlbW90ZVN0b3JhZ2UuV2lyZUNsaWVudD4uXG4gICAqXG4gICAqXG4gICAqIFByb3BlcnR5OiBsb2NhbFxuICAgKlxuICAgKiBBY2Nlc3MgdG8gdGhlIGxvY2FsIGNhY2hpbmcgYmFja2VuZCB1c2VkLiBVc3VhbGx5IGVpdGhlciBhXG4gICAqIDxSZW1vdGVTdG9yYWdlLkluZGV4ZWREQj4gb3IgPFJlbW90ZVN0b3JhZ2UuTG9jYWxTdG9yYWdlPiBpbnN0YW5jZS5cbiAgICpcbiAgICogTm90IGF2YWlsYWJsZSBpbiBuby1jYWNoZSBidWlsZHMuXG4gICAqL1xuXG5cbm1vZHVsZS5leHBvcnRzID0gUmVtb3RlU3RvcmFnZTtcbnJlcXVpcmUoJy4vbW9kdWxlcycpO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9yZW1vdGVzdG9yYWdlLmpzIl0sInNvdXJjZVJvb3QiOiIifQ==");
},function(module,exports,__webpack_require__){eval("'use strict';\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar util = __webpack_require__(2);\nvar log = __webpack_require__(1);\nvar SyncedGetPutDelete = __webpack_require__(22);\nvar config = __webpack_require__(5);\n\nvar Features = {\n  features: [],\n  featuresDone: 0,\n  readyFired: false,\n\n  loadFeatures: function loadFeatures() {\n    var _this = this;\n\n    this.features = [];\n    this.featuresDone = 0;\n    this.readyFired = false;\n\n    this.featureModules = {\n      'WireClient': __webpack_require__(9),\n      'Dropbox': __webpack_require__(13),\n      'GoogleDrive': __webpack_require__(15),\n      'Access': __webpack_require__(10),\n      'Discover': __webpack_require__(12),\n      'Authorize': __webpack_require__(4),\n      'BaseClient': __webpack_require__(6),\n      'Env': __webpack_require__(14)\n    };\n\n    // enable caching releate module if needed\n    if (config.cache) {\n      util.extend(this.featureModules, {\n        'Caching': __webpack_require__(11),\n        'IndexedDB': __webpack_require__(18),\n        'LocalStorage': __webpack_require__(20),\n        'InMemoryStorage': __webpack_require__(19),\n        'Sync': __webpack_require__(8)\n      });\n    }\n\n    // disable specified modules\n    config.disableFeatures.forEach(function (feature) {\n      if (_this.featureModules[feature]) {\n        // this.featureModules[feature] = undefined\n        delete _this.featureModules[feature];\n      }\n    });\n\n    this._allLoaded = false;\n\n    for (var featureName in this.featureModules) {\n      // TOFIX this has to push the promised return value into an\n      // array of promises and use Promise.all to emit `ready`\n      // instead of increment a counter of loaded features. -les\n      this.loadFeature(featureName);\n    }\n  },\n\n\n  /**\n   * Method: hasFeature\n   *\n   * Checks whether a feature is enabled or not within remoteStorage.\n   * Returns a boolean.\n   *\n   * Parameters:\n   *   name - Capitalized name of the feature. e.g. Authorize, or IndexedDB\n   *\n   * Example:\n   *   (start code)\n   *   if (remoteStorage.hasFeature('LocalStorage')) {\n   *     console.log('LocalStorage is enabled!');\n   *   }\n   *   (end code)\n   *\n   */\n  hasFeature: function hasFeature(feature) {\n    for (var i = this.features.length - 1; i >= 0; i--) {\n      if (this.features[i].name === feature) {\n        return this.features[i].supported;\n      }\n    }\n    return false;\n  },\n  loadFeature: function loadFeature(featureName) {\n    var _this2 = this;\n\n    var feature = this.featureModules[featureName];\n    var supported = !feature._rs_supported || feature._rs_supported();\n\n    log('[RemoteStorage] [FEATURE ' + featureName + '] initializing ...');\n\n    if ((typeof supported === 'undefined' ? 'undefined' : _typeof(supported)) === 'object') {\n      supported.then(function () {\n        _this2.featureSupported(featureName, true);\n        _this2.initFeature(featureName);\n      }, function () {\n        _this2.featureSupported(featureName, false);\n      });\n    } else if (typeof supported === 'boolean') {\n      this.featureSupported(featureName, supported);\n      if (supported) {\n        this.initFeature(featureName);\n      }\n    } else {\n      this.featureSupported(featureName, false);\n    }\n  },\n  initFeature: function initFeature(featureName) {\n    var _this3 = this;\n\n    var feature = this.featureModules[featureName];\n    var initResult = void 0;\n    try {\n      initResult = feature._rs_init(this);\n    } catch (e) {\n      this.featureFailed(featureName, e);\n      return;\n    }\n\n    if ((typeof initResult === 'undefined' ? 'undefined' : _typeof(initResult)) === 'object' && typeof initResult.then === 'function') {\n      initResult.then(function () {\n        _this3.featureInitialized(featureName);\n      }, function (err) {\n        _this3.featureFailed(featureName, err);\n      });\n    } else {\n      this.featureInitialized(featureName);\n    }\n  },\n  featureFailed: function featureFailed(featureName, err) {\n    log('[RemoteStorage] [FEATURE ' + featureName + '] initialization failed (' + err + ')');\n    this.featureDone();\n  },\n  featureSupported: function featureSupported(featureName, success) {\n    log('[RemoteStorage] [FEATURE ' + featureName + ']  ' + (success ? '' : ' not') + ' supported');\n    if (!success) {\n      this.featureDone();\n    }\n  },\n  featureInitialized: function featureInitialized(featureName) {\n    log('[RemoteStorage] [FEATURE ' + featureName + '] initialized.');\n    this.features.push({\n      name: featureName,\n      init: this.featureModules[featureName]._rs_init,\n      supported: true,\n      cleanup: this.featureModules[featureName]._rs_cleanup\n    });\n    this.featureDone();\n  },\n  featureDone: function featureDone() {\n    this.featuresDone++;\n    if (this.featuresDone === Object.keys(this.featureModules).length) {\n      setTimeout(this.featuresLoaded.bind(this), 0);\n    }\n  },\n  _setCachingModule: function _setCachingModule() {\n    var _this4 = this;\n\n    var cachingModules = ['IndexedDB', 'LocalStorage', 'InMemoryStorage'];\n\n    cachingModules.some(function (cachingLayer) {\n      if (_this4.features.some(function (feature) {\n        return feature.name === cachingLayer;\n      })) {\n        _this4.features.local = _this4.featureModules[cachingLayer];\n        return true;\n      }\n    });\n  },\n  _fireReady: function _fireReady() {\n    try {\n      if (!this.readyFired) {\n        this._emit('ready');\n        this.readyFired = true;\n      }\n    } catch (e) {\n      console.error(\"'ready' failed: \", e, e.stack);\n      this._emit('error', e);\n    }\n  },\n  featuresLoaded: function featuresLoaded() {\n    var _this5 = this;\n\n    log('[REMOTESTORAGE] All features loaded !');\n\n    this._setCachingModule();\n    this.local = config.cache && this.features.local && new this.features.local();\n\n    // this.remote set by WireClient._rs_init as lazy property on\n    // RS.prototype\n\n    if (this.local && this.remote) {\n      this._setGPD(SyncedGetPutDelete, this);\n      this._bindChange(this.local);\n    } else if (this.remote) {\n      this._setGPD(this.remote, this.remote);\n    }\n    if (this.remote) {\n      this.remote.on('connected', function () {\n        _this5._fireReady();\n        _this5._emit('connected');\n      });\n      this.remote.on('not-connected', function () {\n        _this5._fireReady();\n        _this5._emit('not-connected');\n      });\n      if (this.remote.connected) {\n        this._fireReady();\n        this._emit('connected');\n      }\n\n      if (!this.hasFeature('Authorize')) {\n        this.remote.stopWaitingForToken();\n      }\n    }\n\n    this._collectCleanupFunctions();\n\n    try {\n      this._allLoaded = true;\n      this._emit('features-loaded');\n    } catch (exc) {\n      util.logError(exc);\n      this._emit('error', exc);\n    }\n    this._processPending();\n  },\n  _collectCleanupFunctions: function _collectCleanupFunctions() {\n    this._cleanups = [];\n    for (var i = 0; i < this.features.length; i++) {\n      var cleanup = this.features[i].cleanup;\n      if (typeof cleanup === 'function') {\n        this._cleanups.push(cleanup);\n      }\n    }\n  }\n};\n\nmodule.exports = Features;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvZmVhdHVyZXMuanM/MmM1NSJdLCJuYW1lcyI6WyJ1dGlsIiwicmVxdWlyZSIsImxvZyIsIlN5bmNlZEdldFB1dERlbGV0ZSIsImNvbmZpZyIsIkZlYXR1cmVzIiwiZmVhdHVyZXMiLCJmZWF0dXJlc0RvbmUiLCJyZWFkeUZpcmVkIiwibG9hZEZlYXR1cmVzIiwiZmVhdHVyZU1vZHVsZXMiLCJjYWNoZSIsImV4dGVuZCIsImRpc2FibGVGZWF0dXJlcyIsImZvckVhY2giLCJmZWF0dXJlIiwiX2FsbExvYWRlZCIsImZlYXR1cmVOYW1lIiwibG9hZEZlYXR1cmUiLCJoYXNGZWF0dXJlIiwiaSIsImxlbmd0aCIsIm5hbWUiLCJzdXBwb3J0ZWQiLCJfcnNfc3VwcG9ydGVkIiwidGhlbiIsImZlYXR1cmVTdXBwb3J0ZWQiLCJpbml0RmVhdHVyZSIsImluaXRSZXN1bHQiLCJfcnNfaW5pdCIsImUiLCJmZWF0dXJlRmFpbGVkIiwiZmVhdHVyZUluaXRpYWxpemVkIiwiZXJyIiwiZmVhdHVyZURvbmUiLCJzdWNjZXNzIiwicHVzaCIsImluaXQiLCJjbGVhbnVwIiwiX3JzX2NsZWFudXAiLCJPYmplY3QiLCJrZXlzIiwic2V0VGltZW91dCIsImZlYXR1cmVzTG9hZGVkIiwiYmluZCIsIl9zZXRDYWNoaW5nTW9kdWxlIiwiY2FjaGluZ01vZHVsZXMiLCJzb21lIiwiY2FjaGluZ0xheWVyIiwibG9jYWwiLCJfZmlyZVJlYWR5IiwiX2VtaXQiLCJjb25zb2xlIiwiZXJyb3IiLCJzdGFjayIsInJlbW90ZSIsIl9zZXRHUEQiLCJfYmluZENoYW5nZSIsIm9uIiwiY29ubmVjdGVkIiwic3RvcFdhaXRpbmdGb3JUb2tlbiIsIl9jb2xsZWN0Q2xlYW51cEZ1bmN0aW9ucyIsImV4YyIsImxvZ0Vycm9yIiwiX3Byb2Nlc3NQZW5kaW5nIiwiX2NsZWFudXBzIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7QUFFQSxJQUFNQSxP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QyxZQUFNO0FBQ3BDLGVBQUtSLFVBQUw7QUFDQSxlQUFLQyxLQUFMLENBQVcsZUFBWDtBQUNELE9BSEQ7QUFJQSxVQUFJLEtBQUtJLE1BQUwsQ0FBWUksU0FBaEIsRUFBMkI7QUFDekIsYUFBS1QsVUFBTDtBQUNBLGFBQUtDLEtBQUwsQ0FBVyxXQUFYO0FBQ0Q7O0FBRUQsVUFBSSxDQUFDLEtBQUtoQyxVQUFMLENBQWdCLFdBQWhCLENBQUwsRUFBbUM7QUFDakMsYUFBS29DLE1BQUwsQ0FBWUssbUJBQVo7QUFDRDtBQUNGOztBQUVELFNBQUtDLHdCQUFMOztBQUVBLFFBQUk7QUFDRixXQUFLN0MsVUFBTCxHQUFrQixJQUFsQjtBQUNBLFdBQUttQyxLQUFMLENBQVcsaUJBQVg7QUFDRCxLQUhELENBR0UsT0FBTVcsR0FBTixFQUFXO0FBQ1g5RCxXQUFLK0QsUUFBTCxDQUFjRCxHQUFkO0FBQ0EsV0FBS1gsS0FBTCxDQUFXLE9BQVgsRUFBb0JXLEdBQXBCO0FBQ0Q7QUFDRCxTQUFLRSxlQUFMO0FBQ0QsR0E5TmM7QUFnT2ZILDBCQWhPZSxzQ0FnT2E7QUFDMUIsU0FBS0ksU0FBTCxHQUFpQixFQUFqQjtBQUNBLFNBQUssSUFBSTdDLElBQUUsQ0FBWCxFQUFjQSxJQUFJLEtBQUtkLFFBQUwsQ0FBY2UsTUFBaEMsRUFBd0NELEdBQXhDLEVBQTZDO0FBQzNDLFVBQUlrQixVQUFVLEtBQUtoQyxRQUFMLENBQWNjLENBQWQsRUFBaUJrQixPQUEvQjtBQUNBLFVBQUksT0FBT0EsT0FBUCxLQUFvQixVQUF4QixFQUFvQztBQUNsQyxhQUFLMkIsU0FBTCxDQUFlN0IsSUFBZixDQUFvQkUsT0FBcEI7QUFDRDtBQUNGO0FBQ0Y7QUF4T2MsQ0FBakI7O0FBNE9BNEIsT0FBT0MsT0FBUCxHQUFpQjlELFFBQWpCIiwiZmlsZSI6IjE3LmpzIiwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCB1dGlsID0gcmVxdWlyZSgnLi91dGlsJyk7XG5jb25zdCBsb2cgPSByZXF1aXJlKCcuL2xvZycpO1xuY29uc3QgU3luY2VkR2V0UHV0RGVsZXRlID0gcmVxdWlyZSgnLi9zeW5jZWRnZXRwdXRkZWxldGUnKTtcbmNvbnN0IGNvbmZpZyA9IHJlcXVpcmUoJy4vY29uZmlnJyk7XG5cbmNvbnN0IEZlYXR1cmVzID0ge1xuICBmZWF0dXJlczogW10sXG4gIGZlYXR1cmVzRG9uZTogMCxcbiAgcmVhZHlGaXJlZDogZmFsc2UsXG4gIFxuICBsb2FkRmVhdHVyZXMgKCkge1xuICAgIHRoaXMuZmVhdHVyZXMgPSBbXTtcbiAgICB0aGlzLmZlYXR1cmVzRG9uZSA9IDA7XG4gICAgdGhpcy5yZWFkeUZpcmVkID0gZmFsc2U7XG5cbiAgICB0aGlzLmZlYXR1cmVNb2R1bGVzID0ge1xuICAgICAgJ1dpcmVDbGllbnQnOiByZXF1aXJlKCcuL3dpcmVjbGllbnQnKSxcbiAgICAgICdEcm9wYm94JzogcmVxdWlyZSgnLi9kcm9wYm94JyksXG4gICAgICAnR29vZ2xlRHJpdmUnOiByZXF1aXJlKCcuL2dvb2dsZWRyaXZlJyksXG4gICAgICAnQWNjZXNzJzogcmVxdWlyZSgnLi9hY2Nlc3MnKSxcbiAgICAgICdEaXNjb3Zlcic6IHJlcXVpcmUoJy4vZGlzY292ZXInKSxcbiAgICAgICdBdXRob3JpemUnOiByZXF1aXJlKCcuL2F1dGhvcml6ZScpLFxuICAgICAgJ0Jhc2VDbGllbnQnOiByZXF1aXJlKCcuL2Jhc2VjbGllbnQnKSxcbiAgICAgICdFbnYnOiByZXF1aXJlKCcuL2VudicpXG4gICAgfTtcbiAgICBcbiAgICAvLyBlbmFibGUgY2FjaGluZyByZWxlYXRlIG1vZHVsZSBpZiBuZWVkZWRcbiAgICBpZiAoY29uZmlnLmNhY2hlKSB7XG4gICAgICB1dGlsLmV4dGVuZCggdGhpcy5mZWF0dXJlTW9kdWxlcywge1xuICAgICAgICAnQ2FjaGluZyc6IHJlcXVpcmUoJy4vY2FjaGluZycpLFxuICAgICAgICAnSW5kZXhlZERCJzogcmVxdWlyZSgnLi9pbmRleGVkZGInKSxcbiAgICAgICAgJ0xvY2FsU3RvcmFnZSc6IHJlcXVpcmUoJy4vbG9jYWxzdG9yYWdlJyksXG4gICAgICAgICdJbk1lbW9yeVN0b3JhZ2UnOiByZXF1aXJlKCcuL2lubWVtb3J5c3RvcmFnZScpLFxuICAgICAgICAnU3luYyc6IHJlcXVpcmUoJy4vc3luYycpXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBkaXNhYmxlIHNwZWNpZmllZCBtb2R1bGVzXG4gICAgY29uZmlnLmRpc2FibGVGZWF0dXJlcy5mb3JFYWNoKCBmZWF0dXJlID0+IHtcbiAgICAgIGlmICh0aGlzLmZlYXR1cmVNb2R1bGVzW2ZlYXR1cmVdKSB7XG4gICAgICAgIC8vIHRoaXMuZmVhdHVyZU1vZHVsZXNbZmVhdHVyZV0gPSB1bmRlZmluZWRcbiAgICAgICAgZGVsZXRlIHRoaXMuZmVhdHVyZU1vZHVsZXNbZmVhdHVyZV07XG4gICAgICB9XG5cbiAgICB9KTtcblxuICAgIHRoaXMuX2FsbExvYWRlZCA9IGZhbHNlO1xuXG4gICAgZm9yIChsZXQgZmVhdHVyZU5hbWUgaW4gdGhpcy5mZWF0dXJlTW9kdWxlcykge1xuICAgICAgLy8gVE9GSVggdGhpcyBoYXMgdG8gcHVzaCB0aGUgcHJvbWlzZWQgcmV0dXJuIHZhbHVlIGludG8gYW5cbiAgICAgIC8vIGFycmF5IG9mIHByb21pc2VzIGFuZCB1c2UgUHJvbWlzZS5hbGwgdG8gZW1pdCBgcmVhZHlgXG4gICAgICAvLyBpbnN0ZWFkIG9mIGluY3JlbWVudCBhIGNvdW50ZXIgb2YgbG9hZGVkIGZlYXR1cmVzLiAtbGVzXG4gICAgICB0aGlzLmxvYWRGZWF0dXJlKGZlYXR1cmVOYW1lKTtcbiAgICB9XG4gIH0sXG5cblxuXG4gIC8qKlxuICAgKiBNZXRob2Q6IGhhc0ZlYXR1cmVcbiAgICpcbiAgICogQ2hlY2tzIHdoZXRoZXIgYSBmZWF0dXJlIGlzIGVuYWJsZWQgb3Igbm90IHdpdGhpbiByZW1vdGVTdG9yYWdlLlxuICAgKiBSZXR1cm5zIGEgYm9vbGVhbi5cbiAgICpcbiAgICogUGFyYW1ldGVyczpcbiAgICogICBuYW1lIC0gQ2FwaXRhbGl6ZWQgbmFtZSBvZiB0aGUgZmVhdHVyZS4gZS5nLiBBdXRob3JpemUsIG9yIEluZGV4ZWREQlxuICAgKlxuICAgKiBFeGFtcGxlOlxuICAgKiAgIChzdGFydCBjb2RlKVxuICAgKiAgIGlmIChyZW1vdGVTdG9yYWdlLmhhc0ZlYXR1cmUoJ0xvY2FsU3RvcmFnZScpKSB7XG4gICAqICAgICBjb25zb2xlLmxvZygnTG9jYWxTdG9yYWdlIGlzIGVuYWJsZWQhJyk7XG4gICAqICAgfVxuICAgKiAgIChlbmQgY29kZSlcbiAgICpcbiAgICovXG4gIGhhc0ZlYXR1cmUgKGZlYXR1cmUpIHtcbiAgICBmb3IgKHZhciBpID0gdGhpcy5mZWF0dXJlcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgaWYgKHRoaXMuZmVhdHVyZXNbaV0ubmFtZSA9PT0gZmVhdHVyZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5mZWF0dXJlc1tpXS5zdXBwb3J0ZWQ7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfSxcblxuXG4gIGxvYWRGZWF0dXJlIChmZWF0dXJlTmFtZSkge1xuICAgIGNvbnN0IGZlYXR1cmUgPSB0aGlzLmZlYXR1cmVNb2R1bGVzW2ZlYXR1cmVOYW1lXTtcbiAgICBsZXQgc3VwcG9ydGVkID0gIWZlYXR1cmUuX3JzX3N1cHBvcnRlZCB8fCBmZWF0dXJlLl9yc19zdXBwb3J0ZWQoKTtcblxuICAgIGxvZyhgW1JlbW90ZVN0b3JhZ2VdIFtGRUFUVVJFICR7ZmVhdHVyZU5hbWV9XSBpbml0aWFsaXppbmcgLi4uYCk7XG5cbiAgICBpZiAodHlwZW9mIHN1cHBvcnRlZCA9PT0gJ29iamVjdCcpIHtcbiAgICAgIHN1cHBvcnRlZC50aGVuKCAoKSA9PiB7XG4gICAgICAgIHRoaXMuZmVhdHVyZVN1cHBvcnRlZChmZWF0dXJlTmFtZSwgdHJ1ZSk7XG4gICAgICAgIHRoaXMuaW5pdEZlYXR1cmUoZmVhdHVyZU5hbWUpO1xuICAgICAgfSwgKCkgPT4ge1xuICAgICAgICB0aGlzLmZlYXR1cmVTdXBwb3J0ZWQoZmVhdHVyZU5hbWUsIGZhbHNlKTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIHN1cHBvcnRlZCA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICB0aGlzLmZlYXR1cmVTdXBwb3J0ZWQoZmVhdHVyZU5hbWUsIHN1cHBvcnRlZCk7XG4gICAgICBpZiAoc3VwcG9ydGVkKSB7XG4gICAgICAgIHRoaXMuaW5pdEZlYXR1cmUoZmVhdHVyZU5hbWUpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmZlYXR1cmVTdXBwb3J0ZWQoZmVhdHVyZU5hbWUsIGZhbHNlKTtcbiAgICB9XG4gIH0sXG5cbiAgaW5pdEZlYXR1cmUgKGZlYXR1cmVOYW1lKSB7XG4gICAgY29uc3QgZmVhdHVyZSA9IHRoaXMuZmVhdHVyZU1vZHVsZXNbZmVhdHVyZU5hbWVdO1xuICAgIGxldCBpbml0UmVzdWx0O1xuICAgIHRyeSB7XG4gICAgICBpbml0UmVzdWx0ID0gZmVhdHVyZS5fcnNfaW5pdCh0aGlzKTtcbiAgICB9IGNhdGNoKGUpIHtcbiAgICAgIHRoaXMuZmVhdHVyZUZhaWxlZChmZWF0dXJlTmFtZSwgZSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZihpbml0UmVzdWx0KSA9PT0gJ29iamVjdCcgJiYgdHlwZW9mKGluaXRSZXN1bHQudGhlbikgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGluaXRSZXN1bHQudGhlbihcbiAgICAgICAgKCkgPT4geyB0aGlzLmZlYXR1cmVJbml0aWFsaXplZChmZWF0dXJlTmFtZSk7IH0sXG4gICAgICAgIChlcnIpID0+IHsgdGhpcy5mZWF0dXJlRmFpbGVkKGZlYXR1cmVOYW1lLCBlcnIpOyB9XG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmZlYXR1cmVJbml0aWFsaXplZChmZWF0dXJlTmFtZSk7XG4gICAgfVxuICB9LFxuXG4gIGZlYXR1cmVGYWlsZWQgKGZlYXR1cmVOYW1lLCBlcnIpIHtcbiAgICBsb2coYFtSZW1vdGVTdG9yYWdlXSBbRkVBVFVSRSAke2ZlYXR1cmVOYW1lfV0gaW5pdGlhbGl6YXRpb24gZmFpbGVkICgke2Vycn0pYCk7XG4gICAgdGhpcy5mZWF0dXJlRG9uZSgpO1xuICB9LFxuXG5cbiAgZmVhdHVyZVN1cHBvcnRlZCAoZmVhdHVyZU5hbWUsIHN1Y2Nlc3MpIHtcbiAgICBsb2coYFtSZW1vdGVTdG9yYWdlXSBbRkVBVFVSRSAke2ZlYXR1cmVOYW1lfV0gICR7c3VjY2VzcyA/ICcnIDogJyBub3QnfSBzdXBwb3J0ZWRgKTtcbiAgICBpZiAoIXN1Y2Nlc3MpIHtcbiAgICAgIHRoaXMuZmVhdHVyZURvbmUoKTtcbiAgICB9XG4gIH0sXG5cbiAgZmVhdHVyZUluaXRpYWxpemVkIChmZWF0dXJlTmFtZSkge1xuICAgIGxvZyhgW1JlbW90ZVN0b3JhZ2VdIFtGRUFUVVJFICR7ZmVhdHVyZU5hbWV9XSBpbml0aWFsaXplZC5gKTtcbiAgICB0aGlzLmZlYXR1cmVzLnB1c2goe1xuICAgICAgbmFtZSA6IGZlYXR1cmVOYW1lLFxuICAgICAgaW5pdCA6ICB0aGlzLmZlYXR1cmVNb2R1bGVzW2ZlYXR1cmVOYW1lXS5fcnNfaW5pdCxcbiAgICAgIHN1cHBvcnRlZCA6IHRydWUsXG4gICAgICBjbGVhbnVwIDogdGhpcy5mZWF0dXJlTW9kdWxlc1tmZWF0dXJlTmFtZV0uX3JzX2NsZWFudXBcbiAgICB9KTtcbiAgICB0aGlzLmZlYXR1cmVEb25lKCk7XG4gIH0sXG5cbiAgZmVhdHVyZURvbmUgKCkge1xuICAgIHRoaXMuZmVhdHVyZXNEb25lKys7XG4gICAgaWYgKHRoaXMuZmVhdHVyZXNEb25lID09PSBPYmplY3Qua2V5cyh0aGlzLmZlYXR1cmVNb2R1bGVzKS5sZW5ndGgpIHtcbiAgICAgIHNldFRpbWVvdXQodGhpcy5mZWF0dXJlc0xvYWRlZC5iaW5kKHRoaXMpLCAwKTtcbiAgICB9XG4gIH0sXG5cbiAgX3NldENhY2hpbmdNb2R1bGUgKCkge1xuICAgIGNvbnN0IGNhY2hpbmdNb2R1bGVzID0gWydJbmRleGVkREInLCAnTG9jYWxTdG9yYWdlJywgJ0luTWVtb3J5U3RvcmFnZSddO1xuXG4gICAgY2FjaGluZ01vZHVsZXMuc29tZSggY2FjaGluZ0xheWVyID0+IHtcbiAgICAgIGlmICh0aGlzLmZlYXR1cmVzLnNvbWUoZmVhdHVyZSA9PiBmZWF0dXJlLm5hbWUgPT09IGNhY2hpbmdMYXllcikpIHtcbiAgICAgICAgdGhpcy5mZWF0dXJlcy5sb2NhbCA9IHRoaXMuZmVhdHVyZU1vZHVsZXNbY2FjaGluZ0xheWVyXTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfSk7XG4gIH0sXG5cblxuICBfZmlyZVJlYWR5KCkge1xuICAgIHRyeSB7XG4gICAgICBpZiAoIXRoaXMucmVhZHlGaXJlZCkge1xuICAgICAgICB0aGlzLl9lbWl0KCdyZWFkeScpO1xuICAgICAgICB0aGlzLnJlYWR5RmlyZWQgPSB0cnVlO1xuICAgICAgfVxuICAgIH0gY2F0Y2goZSkge1xuICAgICAgY29uc29sZS5lcnJvcihcIidyZWFkeScgZmFpbGVkOiBcIiwgZSwgZS5zdGFjayk7XG4gICAgICB0aGlzLl9lbWl0KCdlcnJvcicsIGUpO1xuICAgIH1cbiAgfSxcblxuICBmZWF0dXJlc0xvYWRlZCAoKSB7XG4gICAgbG9nKGBbUkVNT1RFU1RPUkFHRV0gQWxsIGZlYXR1cmVzIGxvYWRlZCAhYCk7XG4gICAgXG4gICAgdGhpcy5fc2V0Q2FjaGluZ01vZHVsZSgpO1xuICAgIHRoaXMubG9jYWwgPSBjb25maWcuY2FjaGUgJiYgdGhpcy5mZWF0dXJlcy5sb2NhbCAmJiBuZXcgdGhpcy5mZWF0dXJlcy5sb2NhbCgpO1xuXG4gICAgLy8gdGhpcy5yZW1vdGUgc2V0IGJ5IFdpcmVDbGllbnQuX3JzX2luaXQgYXMgbGF6eSBwcm9wZXJ0eSBvblxuICAgIC8vIFJTLnByb3RvdHlwZVxuXG4gICAgaWYgKHRoaXMubG9jYWwgJiYgdGhpcy5yZW1vdGUpIHtcbiAgICAgIHRoaXMuX3NldEdQRChTeW5jZWRHZXRQdXREZWxldGUsIHRoaXMpO1xuICAgICAgdGhpcy5fYmluZENoYW5nZSh0aGlzLmxvY2FsKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMucmVtb3RlKSB7XG4gICAgICB0aGlzLl9zZXRHUEQodGhpcy5yZW1vdGUsIHRoaXMucmVtb3RlKTtcbiAgICB9XG4gICAgaWYgKHRoaXMucmVtb3RlKSB7XG4gICAgICB0aGlzLnJlbW90ZS5vbignY29ubmVjdGVkJywgKCkgPT4ge1xuICAgICAgICB0aGlzLl9maXJlUmVhZHkoKTtcbiAgICAgICAgdGhpcy5fZW1pdCgnY29ubmVjdGVkJyk7XG4gICAgICB9KTtcbiAgICAgIHRoaXMucmVtb3RlLm9uKCdub3QtY29ubmVjdGVkJywgKCkgPT4ge1xuICAgICAgICB0aGlzLl9maXJlUmVhZHkoKTtcbiAgICAgICAgdGhpcy5fZW1pdCgnbm90LWNvbm5lY3RlZCcpO1xuICAgICAgfSk7XG4gICAgICBpZiAodGhpcy5yZW1vdGUuY29ubmVjdGVkKSB7XG4gICAgICAgIHRoaXMuX2ZpcmVSZWFkeSgpO1xuICAgICAgICB0aGlzLl9lbWl0KCdjb25uZWN0ZWQnKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCF0aGlzLmhhc0ZlYXR1cmUoJ0F1dGhvcml6ZScpKSB7XG4gICAgICAgIHRoaXMucmVtb3RlLnN0b3BXYWl0aW5nRm9yVG9rZW4oKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLl9jb2xsZWN0Q2xlYW51cEZ1bmN0aW9ucygpO1xuXG4gICAgdHJ5IHtcbiAgICAgIHRoaXMuX2FsbExvYWRlZCA9IHRydWU7XG4gICAgICB0aGlzLl9lbWl0KCdmZWF0dXJlcy1sb2FkZWQnKTtcbiAgICB9IGNhdGNoKGV4Yykge1xuICAgICAgdXRpbC5sb2dFcnJvcihleGMpO1xuICAgICAgdGhpcy5fZW1pdCgnZXJyb3InLCBleGMpO1xuICAgIH1cbiAgICB0aGlzLl9wcm9jZXNzUGVuZGluZygpO1xuICB9LFxuXG4gIF9jb2xsZWN0Q2xlYW51cEZ1bmN0aW9ucyAoKSB7XG4gICAgdGhpcy5fY2xlYW51cHMgPSBbXTtcbiAgICBmb3IgKGxldCBpPTA7IGkgPCB0aGlzLmZlYXR1cmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBsZXQgY2xlYW51cCA9IHRoaXMuZmVhdHVyZXNbaV0uY2xlYW51cDtcbiAgICAgIGlmICh0eXBlb2YoY2xlYW51cCkgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhpcy5fY2xlYW51cHMucHVzaChjbGVhbnVwKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBGZWF0dXJlcztcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9mZWF0dXJlcy5qcyJdLCJzb3VyY2VSb290IjoiIn0=")},function(module,exports,__webpack_require__){eval("'use strict';\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\n/**\n * Class: IndexedDB\n *\n *\n * IndexedDB Interface\n * -------------------\n *\n * TODO rewrite, doesn't expose GPD anymore, it's in cachinglayer now\n *\n * This file exposes a get/put/delete interface, accessing data in an IndexedDB.\n *\n * There are multiple parts to this interface:\n *\n *   The RemoteStorage integration:\n *     - IndexedDB._rs_supported() determines if IndexedDB support\n *       is available. If it isn't, RemoteStorage won't initialize the feature.\n *     - IndexedDB._rs_init() initializes the feature. It returns\n *       a promise that is fulfilled as soon as the database has been opened and\n *       migrated.\n *\n *   The storage interface (IndexedDB object):\n *     - Usually this is accessible via \"remoteStorage.local\"\n *     - #get() takes a path and returns a promise.\n *     - #put() takes a path, body and contentType and also returns a promise.\n *     - #delete() takes a path and also returns a promise.\n *     - #on('change', ...) events, being fired whenever something changes in\n *       the storage. Change events roughly follow the StorageEvent pattern.\n *       They have \"oldValue\" and \"newValue\" properties, which can be used to\n *       distinguish create/update/delete operations and analyze changes in\n *       change handlers. In addition they carry a \"origin\" property, which\n *       is either \"window\", \"local\", or \"remote\". \"remote\" events are fired\n *       whenever a change comes in from Sync.\n *\n *   The sync interface (also on IndexedDB object):\n *     - #getNodes([paths]) returns the requested nodes in a promise.\n *     - #setNodes(map) stores all the nodes given in the (path -> node) map.\n *\n */\n\nvar log = __webpack_require__(1);\nvar cachingLayer = __webpack_require__(7);\nvar eventHandling = __webpack_require__(3);\nvar util = __webpack_require__(2);\n\nvar DB_VERSION = 2;\n\nvar DEFAULT_DB_NAME = 'remotestorage';\nvar DEFAULT_DB;\n\nvar IndexedDB = function IndexedDB(database) {\n  this.db = database || DEFAULT_DB;\n\n  if (!this.db) {\n    log(\"[IndexedDB] Failed to open DB\");\n    return undefined;\n  }\n\n  cachingLayer(this);\n  eventHandling(this, 'change', 'local-events-done');\n\n  this.getsRunning = 0;\n  this.putsRunning = 0;\n\n  /**\n   * Property: changesQueued\n   *\n   * Given a node for which uncommitted changes exist, this cache\n   * stores either the entire uncommitted node, or false for a deletion.\n   * The node's path is used as the key.\n   *\n   * changesQueued stores changes for which no IndexedDB transaction has\n   * been started yet.\n   */\n  this.changesQueued = {};\n\n  /**\n   * Property: changesRunning\n   *\n   * Given a node for which uncommitted changes exist, this cache\n   * stores either the entire uncommitted node, or false for a deletion.\n   * The node's path is used as the key.\n   *\n   * At any time there is at most one IndexedDB transaction running.\n   * changesRunning stores the changes that are included in that currently\n   * running IndexedDB transaction, or if none is running, of the last one\n   * that ran.\n   */\n  this.changesRunning = {};\n};\n\nIndexedDB.prototype = {\n  getNodes: function getNodes(paths) {\n    var misses = [],\n        fromCache = {};\n    for (var i = 0, len = paths.length; i < len; i++) {\n      if (this.changesQueued[paths[i]] !== undefined) {\n        fromCache[paths[i]] = util.deepClone(this.changesQueued[paths[i]] || undefined);\n      } else if (this.changesRunning[paths[i]] !== undefined) {\n        fromCache[paths[i]] = util.deepClone(this.changesRunning[paths[i]] || undefined);\n      } else {\n        misses.push(paths[i]);\n      }\n    }\n    if (misses.length > 0) {\n      return this.getNodesFromDb(misses).then(function (nodes) {\n        for (var i in fromCache) {\n          nodes[i] = fromCache[i];\n        }\n        return nodes;\n      });\n    } else {\n      return Promise.resolve(fromCache);\n    }\n  },\n\n  setNodes: function setNodes(nodes) {\n    for (var i in nodes) {\n      this.changesQueued[i] = nodes[i] || false;\n    }\n    this.maybeFlush();\n    return Promise.resolve();\n  },\n\n  maybeFlush: function maybeFlush() {\n    if (this.putsRunning === 0) {\n      this.flushChangesQueued();\n    } else {\n      if (!this.commitSlownessWarning) {\n        this.commitSlownessWarning = setInterval(function () {\n          console.log('WARNING: waited more than 10 seconds for previous commit to finish');\n        }, 10000);\n      }\n    }\n  },\n\n  flushChangesQueued: function flushChangesQueued() {\n    if (this.commitSlownessWarning) {\n      clearInterval(this.commitSlownessWarning);\n      this.commitSlownessWarning = null;\n    }\n    if (Object.keys(this.changesQueued).length > 0) {\n      this.changesRunning = this.changesQueued;\n      this.changesQueued = {};\n      this.setNodesInDb(this.changesRunning).then(this.flushChangesQueued.bind(this));\n    }\n  },\n\n  getNodesFromDb: function getNodesFromDb(paths) {\n    var _this = this;\n\n    return new Promise(function (resolve, reject) {\n\n      var transaction = _this.db.transaction(['nodes'], 'readonly');\n      var nodes = transaction.objectStore('nodes');\n      var retrievedNodes = {};\n\n      _this.getsRunning++;\n\n      paths.map(function (path, i) {\n        nodes.get(path).onsuccess = function (evt) {\n          retrievedNodes[path] = evt.target.result;\n        };\n      });\n\n      transaction.oncomplete = function () {\n        resolve(retrievedNodes);\n        this.getsRunning--;\n      }.bind(_this);\n\n      transaction.onerror = transaction.onabort = function () {\n        reject('get transaction error/abort');\n        this.getsRunning--;\n      }.bind(_this);\n    });\n  },\n\n  setNodesInDb: function setNodesInDb(nodes) {\n    var _this2 = this;\n\n    return new Promise(function (resolve, reject) {\n\n      var transaction = _this2.db.transaction(['nodes'], 'readwrite');\n      var nodesStore = transaction.objectStore('nodes');\n      var startTime = new Date().getTime();\n\n      _this2.putsRunning++;\n\n      log('[IndexedDB] Starting put', nodes, _this2.putsRunning);\n\n      for (var path in nodes) {\n        var node = nodes[path];\n        if ((typeof node === 'undefined' ? 'undefined' : _typeof(node)) === 'object') {\n          try {\n            nodesStore.put(node);\n          } catch (e) {\n            log('[IndexedDB] Error while putting', node, e);\n            throw e;\n          }\n        } else {\n          try {\n            nodesStore.delete(path);\n          } catch (e) {\n            log('[IndexedDB] Error while removing', nodesStore, node, e);\n            throw e;\n          }\n        }\n      }\n\n      transaction.oncomplete = function () {\n        this.putsRunning--;\n        log('[IndexedDB] Finished put', nodes, this.putsRunning, new Date().getTime() - startTime + 'ms');\n        resolve();\n      }.bind(_this2);\n\n      transaction.onerror = function () {\n        this.putsRunning--;\n        reject('transaction error');\n      }.bind(_this2);\n\n      transaction.onabort = function () {\n        reject('transaction abort');\n        this.putsRunning--;\n      }.bind(_this2);\n    });\n  },\n\n  reset: function reset(callback) {\n    var dbName = this.db.name;\n    var self = this;\n\n    this.db.close();\n\n    IndexedDB.clean(this.db.name, function () {\n      IndexedDB.open(dbName, function (err, other) {\n        if (err) {\n          log('[IndexedDB] Error while resetting local storage', err);\n        } else {\n          // hacky!\n          self.db = other;\n        }\n        if (typeof callback === 'function') {\n          callback(self);\n        }\n      });\n    });\n  },\n\n  forAllNodes: function forAllNodes(cb) {\n    var _this3 = this;\n\n    return new Promise(function (resolve, reject) {\n\n      var transaction = _this3.db.transaction(['nodes'], 'readonly');\n      var cursorReq = transaction.objectStore('nodes').openCursor();\n\n      cursorReq.onsuccess = function (evt) {\n        var cursor = evt.target.result;\n\n        if (cursor) {\n          cb(this.migrate(cursor.value));\n          cursor.continue();\n        } else {\n          resolve();\n        }\n      }.bind(_this3);\n    });\n  },\n\n  closeDB: function closeDB() {\n    this.db.close();\n  }\n\n};\n\nIndexedDB.open = function (name, callback) {\n  var timer = setTimeout(function () {\n    callback(\"timeout trying to open db\");\n  }, 10000);\n\n  try {\n    var req = indexedDB.open(name, DB_VERSION);\n\n    req.onerror = function () {\n      log('[IndexedDB] Opening DB failed', req);\n\n      clearTimeout(timer);\n      callback(req.error);\n    };\n\n    req.onupgradeneeded = function (event) {\n      var db = req.result;\n\n      log(\"[IndexedDB] Upgrade: from \", event.oldVersion, \" to \", event.newVersion);\n\n      if (event.oldVersion !== 1) {\n        log(\"[IndexedDB] Creating object store: nodes\");\n        db.createObjectStore('nodes', { keyPath: 'path' });\n      }\n\n      log(\"[IndexedDB] Creating object store: changes\");\n\n      db.createObjectStore('changes', { keyPath: 'path' });\n    };\n\n    req.onsuccess = function () {\n      clearTimeout(timer);\n\n      // check if all object stores exist\n      var db = req.result;\n      if (!db.objectStoreNames.contains('nodes') || !db.objectStoreNames.contains('changes')) {\n        log(\"[IndexedDB] Missing object store. Resetting the database.\");\n        IndexedDB.clean(name, function () {\n          IndexedDB.open(name, callback);\n        });\n        return;\n      }\n\n      callback(null, req.result);\n    };\n  } catch (error) {\n    log(\"[IndexedDB] Failed to open database: \" + error);\n    log(\"[IndexedDB] Resetting database and trying again.\");\n\n    clearTimeout(timer);\n\n    IndexedDB.clean(name, function () {\n      IndexedDB.open(name, callback);\n    });\n  }\n};\n\nIndexedDB.clean = function (databaseName, callback) {\n  var req = indexedDB.deleteDatabase(databaseName);\n\n  req.onsuccess = function () {\n    log('[IndexedDB] Done removing DB');\n    callback();\n  };\n\n  req.onerror = req.onabort = function (evt) {\n    console.error('Failed to remove database \"' + databaseName + '\"', evt);\n  };\n};\n\nIndexedDB._rs_init = function (remoteStorage) {\n\n  return new Promise(function (resolve, reject) {\n\n    IndexedDB.open(DEFAULT_DB_NAME, function (err, db) {\n      if (err) {\n        reject(err);\n      } else {\n        DEFAULT_DB = db;\n        db.onerror = function () {\n          remoteStorage._emit('error', err);\n        };\n        resolve();\n      }\n    });\n  });\n};\n\nIndexedDB._rs_supported = function () {\n  return new Promise(function (resolve, reject) {\n\n    var context = util.getGlobalContext();\n\n    // TOFIX this is causing an error in chrome\n    // context.indexedDB = context.indexedDB    || context.webkitIndexedDB ||\n    //                    context.mozIndexedDB || context.oIndexedDB      ||\n    //                    context.msIndexedDB;\n\n    // Detect browsers with known IndexedDb issues (e.g. Android pre-4.4)\n    var poorIndexedDbSupport = false;\n    if (typeof navigator !== 'undefined' && navigator.userAgent.match(/Android (2|3|4\\.[0-3])/)) {\n      // Chrome and Firefox support IndexedDB\n      if (!navigator.userAgent.match(/Chrome|Firefox/)) {\n        poorIndexedDbSupport = true;\n      }\n    }\n\n    if ('indexedDB' in context && !poorIndexedDbSupport) {\n      try {\n        var check = indexedDB.open(\"rs-check\");\n        check.onerror = function (event) {\n          reject();\n        };\n        check.onsuccess = function (event) {\n          check.result.close();\n          indexedDB.deleteDatabase(\"rs-check\");\n          resolve();\n        };\n      } catch (e) {\n        reject();\n      }\n    } else {\n      reject();\n    }\n  });\n};\n\nIndexedDB._rs_cleanup = function (remoteStorage) {\n  return new Promise(function (resolve, reject) {\n    if (remoteStorage.local) {\n      remoteStorage.local.closeDB();\n    }\n\n    IndexedDB.clean(DEFAULT_DB_NAME, resolve);\n  });\n};\n\nmodule.exports = IndexedDB;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvaW5kZXhlZGRiLmpzPzZhZGIiXSwibmFtZXMiOlsibG9nIiwicmVxdWlyZSIsImNhY2hpbmdMYXllciIsImV2ZW50SGFuZGxpbmciLCJ1dGlsIiwiREJfVkVSU0lPTiIsIkRFRkFVTFRfREJfTkFNRSIsIkRFRkFVTFRfREIiLCJJbmRleGVkREIiLCJkYXRhYmFzZSIsImRiIiwidW5kZWZpbmVkIiwiZ2V0c1J1bm5pbmciLCJwdXRzUnVubmluZyIsImNoYW5nZXNRdWV1ZWQiLCJjaGFuZ2VzUnVubmluZyIsInByb3RvdHlwZSIsImdldE5vZGVzIiwicGF0aHMiLCJtaXNzZXMiLCJmcm9tQ2FjaGUiLCJpIiwibGVuIiwibGVuZ3RoIiwiZGVlcENsb25lIiwicHVzaCIsImdldE5vZGVzRnJvbURiIiwidGhlbiIsIm5vZGVzIiwiUHJvbWlzZSIsInJlc29sdmUiLCJzZXROb2RlcyIsIm1heWJlRmx1c2giLCJmbHVzaENoYW5nZXNRdWV1ZWQiLCJjb21taXRTbG93bmVzc1dhcm5pbmciLCJzZXRJbnRlcnZhbCIsImNvbnNvbGUiLCJjbGVhckludGVydmFsIiwiT2JqZWN0Iiwia2V5cyIsInNldE5vZGVzSW5EYiIsImJpbmQiLCJyZWplY3QiLCJ0cmFuc2FjdGlvbiIsIm9iamVjdFN0b3JlIiwicmV0cmlldmVkTm9kZXMiLCJtYXAiLCJwYXRoIiwiZ2V0Iiwib25zdWNjZXNzIiwiZXZ0IiwidGFyZ2V0IiwicmVzdWx0Iiwib25jb21wbGV0ZSIsIm9uZXJyb3IiLCJvbmFib3J0Iiwibm9kZXNTdG9yZSIsInN0YXJ0VGltZSIsIkRhdGUiLCJnZXRUaW1lIiwibm9kZSIsInB1dCIsImUiLCJkZWxldGUiLCJyZXNldCIsImNhbGxiYWNrIiwiZGJOYW1lIiwibmFtZSIsInNlbGYiLCJjbG9zZSIsImNsZWFuIiwib3BlbiIsImVyciIsIm90aGVyIiwiZm9yQWxsTm9kZXMiLCJjYiIsImN1cnNvclJlcSIsIm9wZW5DdXJzb3IiLCJjdXJzb3IiLCJtaWdyYXRlIiwidmFsdWUiLCJjb250aW51ZSIsImNsb3NlREIiLCJ0aW1lciIsInNldFRpbWVvdXQiLCJyZXEiLCJpbmRleGVkREIiLCJjbGVhclRpbWVvdXQiLCJlcnJvciIsIm9udXBncmFkZW5lZWRlZCIsImV2ZW50Iiwib2xkVmVyc2lvbiIsIm5ld1ZlcnNpb24iLCJjcmVhdGVPYmplY3RTdG9yZSIsImtleVBhdGgiLCJvYmplY3RTdG9yZU5hbWVzIiwiY29udGFpbnMiLCJkYXRhYmFzZU5hbWUiLCJkZWxldGVEYXRhYmFzZSIsIl9yc19pbml0IiwicmVtb3RlU3RvcmFnZSIsIl9lbWl0IiwiX3JzX3N1cHBvcnRlZCIsImNvbnRleHQiLCJnZXRHbG9iYWxDb250ZXh0IiwicG9vckluZGV4ZWREYlN1cHBvcnQiLCJuYXZpZ2F0b3IiLCJ1c2VyQWdlbnQiLCJtYXRjaCIsImNoZWNrIiwiX3JzX2NsZWFudXAiLCJsb2NhbCIsIm1vZHVsZSIsImV4cG9ydHMiXSwibWFwcGluZ3MiOiI7Ozs7QUFDRTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBdUNBLElBQUlBLE1BQU0sbUJBQUFDLENBQVEsQ0FBUixDQUFWO0FBQ0EsSUFBSUMsZUFBZSxtQkFBQUQsQ0FBUSxDQUFSLENBQW5CO0FBQ0EsSUFBSUUsZ0JBQWdCLG1CQUFBRixDQUFRLENBQVIsQ0FBcEI7QUFDQSxJQUFJRyxPQUFPLG1CQUFBSCxDQUFRLENBQVIsQ0FBWDs7QUFFQSxJQUFJSSxhQUFhLENBQWpCOztBQUVBLElBQUlDLGtCQUFrQixlQUF0QjtBQUNBLElBQUlDLFVBQUo7O0FBRUEsSUFBSUMsWUFBWSxTQUFaQSxTQUFZLENBQVVDLFFBQVYsRUFBb0I7QUFDbEMsT0FBS0MsRUFBTCxHQUFVRCxZQUFZRixVQUF0Qjs7QUFFQSxNQUFJLENBQUMsS0FBS0csRUFBVixFQUFjO0FBQ1pWLFFBQUksK0JBQUo7QUFDQSxXQUFPVyxTQUFQO0FBQ0Q7O0FBRURULGVBQWEsSUFBYjtBQUNBQyxnQkFBYyxJQUFkLEVBQW9C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LElBQVYsQ0FBZSxVQUFmLENBQVo7QUFDQXNDLGNBQU12RCxPQUFOLEdBQWdCLFVBQVVvQyxLQUFWLEVBQWlCO0FBQy9CaEQ7QUFDRCxTQUZEO0FBR0FtRSxjQUFNNUQsU0FBTixHQUFrQixVQUFVeUMsS0FBVixFQUFpQjtBQUNqQ21CLGdCQUFNekQsTUFBTixDQUFhaUIsS0FBYjtBQUNBaUIsb0JBQVVZLGNBQVYsQ0FBeUIsVUFBekI7QUFDQXBFO0FBQ0QsU0FKRDtBQUtELE9BVkQsQ0FVRSxPQUFNZ0MsQ0FBTixFQUFTO0FBQ1RwQjtBQUNEO0FBQ0YsS0FkRCxNQWNPO0FBQ0xBO0FBQ0Q7QUFFRixHQXJDTSxDQUFQO0FBc0NELENBdkNEOztBQXlDQWxDLFVBQVVzRyxXQUFWLEdBQXdCLFVBQVVWLGFBQVYsRUFBeUI7QUFDL0MsU0FBTyxJQUFJdkUsT0FBSixDQUFZLFVBQUNDLE9BQUQsRUFBVVksTUFBVixFQUFxQjtBQUN0QyxRQUFJMEQsY0FBY1csS0FBbEIsRUFBeUI7QUFDdkJYLG9CQUFjVyxLQUFkLENBQW9CN0IsT0FBcEI7QUFDRDs7QUFFRDFFLGNBQVU4RCxLQUFWLENBQWdCaEUsZUFBaEIsRUFBaUN3QixPQUFqQztBQUVELEdBUE0sQ0FBUDtBQVFELENBVEQ7O0FBWUFrRixPQUFPQyxPQUFQLEdBQWlCekcsU0FBakIiLCJmaWxlIjoiMTguanMiLCJzb3VyY2VzQ29udGVudCI6WyJcbiAgLyoqXG4gICAqIENsYXNzOiBJbmRleGVkREJcbiAgICpcbiAgICpcbiAgICogSW5kZXhlZERCIEludGVyZmFjZVxuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAqXG4gICAqIFRPRE8gcmV3cml0ZSwgZG9lc24ndCBleHBvc2UgR1BEIGFueW1vcmUsIGl0J3MgaW4gY2FjaGluZ2xheWVyIG5vd1xuICAgKlxuICAgKiBUaGlzIGZpbGUgZXhwb3NlcyBhIGdldC9wdXQvZGVsZXRlIGludGVyZmFjZSwgYWNjZXNzaW5nIGRhdGEgaW4gYW4gSW5kZXhlZERCLlxuICAgKlxuICAgKiBUaGVyZSBhcmUgbXVsdGlwbGUgcGFydHMgdG8gdGhpcyBpbnRlcmZhY2U6XG4gICAqXG4gICAqICAgVGhlIFJlbW90ZVN0b3JhZ2UgaW50ZWdyYXRpb246XG4gICAqICAgICAtIEluZGV4ZWREQi5fcnNfc3VwcG9ydGVkKCkgZGV0ZXJtaW5lcyBpZiBJbmRleGVkREIgc3VwcG9ydFxuICAgKiAgICAgICBpcyBhdmFpbGFibGUuIElmIGl0IGlzbid0LCBSZW1vdGVTdG9yYWdlIHdvbid0IGluaXRpYWxpemUgdGhlIGZlYXR1cmUuXG4gICAqICAgICAtIEluZGV4ZWREQi5fcnNfaW5pdCgpIGluaXRpYWxpemVzIHRoZSBmZWF0dXJlLiBJdCByZXR1cm5zXG4gICAqICAgICAgIGEgcHJvbWlzZSB0aGF0IGlzIGZ1bGZpbGxlZCBhcyBzb29uIGFzIHRoZSBkYXRhYmFzZSBoYXMgYmVlbiBvcGVuZWQgYW5kXG4gICAqICAgICAgIG1pZ3JhdGVkLlxuICAgKlxuICAgKiAgIFRoZSBzdG9yYWdlIGludGVyZmFjZSAoSW5kZXhlZERCIG9iamVjdCk6XG4gICAqICAgICAtIFVzdWFsbHkgdGhpcyBpcyBhY2Nlc3NpYmxlIHZpYSBcInJlbW90ZVN0b3JhZ2UubG9jYWxcIlxuICAgKiAgICAgLSAjZ2V0KCkgdGFrZXMgYSBwYXRoIGFuZCByZXR1cm5zIGEgcHJvbWlzZS5cbiAgICogICAgIC0gI3B1dCgpIHRha2VzIGEgcGF0aCwgYm9keSBhbmQgY29udGVudFR5cGUgYW5kIGFsc28gcmV0dXJucyBhIHByb21pc2UuXG4gICAqICAgICAtICNkZWxldGUoKSB0YWtlcyBhIHBhdGggYW5kIGFsc28gcmV0dXJucyBhIHByb21pc2UuXG4gICAqICAgICAtICNvbignY2hhbmdlJywgLi4uKSBldmVudHMsIGJlaW5nIGZpcmVkIHdoZW5ldmVyIHNvbWV0aGluZyBjaGFuZ2VzIGluXG4gICAqICAgICAgIHRoZSBzdG9yYWdlLiBDaGFuZ2UgZXZlbnRzIHJvdWdobHkgZm9sbG93IHRoZSBTdG9yYWdlRXZlbnQgcGF0dGVybi5cbiAgICogICAgICAgVGhleSBoYXZlIFwib2xkVmFsdWVcIiBhbmQgXCJuZXdWYWx1ZVwiIHByb3BlcnRpZXMsIHdoaWNoIGNhbiBiZSB1c2VkIHRvXG4gICAqICAgICAgIGRpc3Rpbmd1aXNoIGNyZWF0ZS91cGRhdGUvZGVsZXRlIG9wZXJhdGlvbnMgYW5kIGFuYWx5emUgY2hhbmdlcyBpblxuICAgKiAgICAgICBjaGFuZ2UgaGFuZGxlcnMuIEluIGFkZGl0aW9uIHRoZXkgY2FycnkgYSBcIm9yaWdpblwiIHByb3BlcnR5LCB3aGljaFxuICAgKiAgICAgICBpcyBlaXRoZXIgXCJ3aW5kb3dcIiwgXCJsb2NhbFwiLCBvciBcInJlbW90ZVwiLiBcInJlbW90ZVwiIGV2ZW50cyBhcmUgZmlyZWRcbiAgICogICAgICAgd2hlbmV2ZXIgYSBjaGFuZ2UgY29tZXMgaW4gZnJvbSBTeW5jLlxuICAgKlxuICAgKiAgIFRoZSBzeW5jIGludGVyZmFjZSAoYWxzbyBvbiBJbmRleGVkREIgb2JqZWN0KTpcbiAgICogICAgIC0gI2dldE5vZGVzKFtwYXRoc10pIHJldHVybnMgdGhlIHJlcXVlc3RlZCBub2RlcyBpbiBhIHByb21pc2UuXG4gICAqICAgICAtICNzZXROb2RlcyhtYXApIHN0b3JlcyBhbGwgdGhlIG5vZGVzIGdpdmVuIGluIHRoZSAocGF0aCAtPiBub2RlKSBtYXAuXG4gICAqXG4gICAqL1xuXG4gIHZhciBsb2cgPSByZXF1aXJlKCcuL2xvZycpO1xuICB2YXIgY2FjaGluZ0xheWVyID0gcmVxdWlyZSgnLi9jYWNoaW5nbGF5ZXInKTtcbiAgdmFyIGV2ZW50SGFuZGxpbmcgPSByZXF1aXJlKCcuL2V2ZW50aGFuZGxpbmcnKTtcbiAgdmFyIHV0aWwgPSByZXF1aXJlKCcuL3V0aWwnKTtcblxuICB2YXIgREJfVkVSU0lPTiA9IDI7XG5cbiAgdmFyIERFRkFVTFRfREJfTkFNRSA9ICdyZW1vdGVzdG9yYWdlJztcbiAgdmFyIERFRkFVTFRfREI7XG5cbiAgdmFyIEluZGV4ZWREQiA9IGZ1bmN0aW9uIChkYXRhYmFzZSkge1xuICAgIHRoaXMuZGIgPSBkYXRhYmFzZSB8fCBERUZBVUxUX0RCO1xuXG4gICAgaWYgKCF0aGlzLmRiKSB7XG4gICAgICBsb2coXCJbSW5kZXhlZERCXSBGYWlsZWQgdG8gb3BlbiBEQlwiKTtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgY2FjaGluZ0xheWVyKHRoaXMpO1xuICAgIGV2ZW50SGFuZGxpbmcodGhpcywgJ2NoYW5nZScsICdsb2NhbC1ldmVudHMtZG9uZScpO1xuXG4gICAgdGhpcy5nZXRzUnVubmluZyA9IDA7XG4gICAgdGhpcy5wdXRzUnVubmluZyA9IDA7XG5cbiAgICAvKipcbiAgICAgKiBQcm9wZXJ0eTogY2hhbmdlc1F1ZXVlZFxuICAgICAqXG4gICAgICogR2l2ZW4gYSBub2RlIGZvciB3aGljaCB1bmNvbW1pdHRlZCBjaGFuZ2VzIGV4aXN0LCB0aGlzIGNhY2hlXG4gICAgICogc3RvcmVzIGVpdGhlciB0aGUgZW50aXJlIHVuY29tbWl0dGVkIG5vZGUsIG9yIGZhbHNlIGZvciBhIGRlbGV0aW9uLlxuICAgICAqIFRoZSBub2RlJ3MgcGF0aCBpcyB1c2VkIGFzIHRoZSBrZXkuXG4gICAgICpcbiAgICAgKiBjaGFuZ2VzUXVldWVkIHN0b3JlcyBjaGFuZ2VzIGZvciB3aGljaCBubyBJbmRleGVkREIgdHJhbnNhY3Rpb24gaGFzXG4gICAgICogYmVlbiBzdGFydGVkIHlldC5cbiAgICAgKi9cbiAgICB0aGlzLmNoYW5nZXNRdWV1ZWQgPSB7fTtcblxuICAgIC8qKlxuICAgICAqIFByb3BlcnR5OiBjaGFuZ2VzUnVubmluZ1xuICAgICAqXG4gICAgICogR2l2ZW4gYSBub2RlIGZvciB3aGljaCB1bmNvbW1pdHRlZCBjaGFuZ2VzIGV4aXN0LCB0aGlzIGNhY2hlXG4gICAgICogc3RvcmVzIGVpdGhlciB0aGUgZW50aXJlIHVuY29tbWl0dGVkIG5vZGUsIG9yIGZhbHNlIGZvciBhIGRlbGV0aW9uLlxuICAgICAqIFRoZSBub2RlJ3MgcGF0aCBpcyB1c2VkIGFzIHRoZSBrZXkuXG4gICAgICpcbiAgICAgKiBBdCBhbnkgdGltZSB0aGVyZSBpcyBhdCBtb3N0IG9uZSBJbmRleGVkREIgdHJhbnNhY3Rpb24gcnVubmluZy5cbiAgICAgKiBjaGFuZ2VzUnVubmluZyBzdG9yZXMgdGhlIGNoYW5nZXMgdGhhdCBhcmUgaW5jbHVkZWQgaW4gdGhhdCBjdXJyZW50bHlcbiAgICAgKiBydW5uaW5nIEluZGV4ZWREQiB0cmFuc2FjdGlvbiwgb3IgaWYgbm9uZSBpcyBydW5uaW5nLCBvZiB0aGUgbGFzdCBvbmVcbiAgICAgKiB0aGF0IHJhbi5cbiAgICAgKi9cbiAgICB0aGlzLmNoYW5nZXNSdW5uaW5nID0ge307XG4gIH07XG5cbiAgSW5kZXhlZERCLnByb3RvdHlwZSA9IHtcbiAgICBnZXROb2RlczogZnVuY3Rpb24gKHBhdGhzKSB7XG4gICAgICB2YXIgbWlzc2VzID0gW10sIGZyb21DYWNoZSA9IHt9O1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHBhdGhzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGlmICh0aGlzLmNoYW5nZXNRdWV1ZWRbcGF0aHNbaV1dICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBmcm9tQ2FjaGVbcGF0aHNbaV1dID0gdXRpbC5kZWVwQ2xvbmUodGhpcy5jaGFuZ2VzUXVldWVkW3BhdGhzW2ldXSB8fCB1bmRlZmluZWQpO1xuICAgICAgICB9IGVsc2UgaWYodGhpcy5jaGFuZ2VzUnVubmluZ1twYXRoc1tpXV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGZyb21DYWNoZVtwYXRoc1tpXV0gPSB1dGlsLmRlZXBDbG9uZSh0aGlzLmNoYW5nZXNSdW5uaW5nW3BhdGhzW2ldXSB8fCB1bmRlZmluZWQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG1pc3Nlcy5wdXNoKHBhdGhzW2ldKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKG1pc3Nlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldE5vZGVzRnJvbURiKG1pc3NlcykudGhlbihmdW5jdGlvbiAobm9kZXMpIHtcbiAgICAgICAgICBmb3IgKHZhciBpIGluIGZyb21DYWNoZSkge1xuICAgICAgICAgICAgbm9kZXNbaV0gPSBmcm9tQ2FjaGVbaV07XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBub2RlcztcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGZyb21DYWNoZSk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIHNldE5vZGVzOiBmdW5jdGlvbiAobm9kZXMpIHtcbiAgICAgIGZvciAodmFyIGkgaW4gbm9kZXMpIHtcbiAgICAgICAgdGhpcy5jaGFuZ2VzUXVldWVkW2ldID0gbm9kZXNbaV0gfHwgZmFsc2U7XG4gICAgICB9XG4gICAgICB0aGlzLm1heWJlRmx1c2goKTtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICB9LFxuXG4gICAgbWF5YmVGbHVzaDogZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKHRoaXMucHV0c1J1bm5pbmcgPT09IDApIHtcbiAgICAgICAgdGhpcy5mbHVzaENoYW5nZXNRdWV1ZWQoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICghdGhpcy5jb21taXRTbG93bmVzc1dhcm5pbmcpIHtcbiAgICAgICAgICB0aGlzLmNvbW1pdFNsb3duZXNzV2FybmluZyA9IHNldEludGVydmFsKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdXQVJOSU5HOiB3YWl0ZWQgbW9yZSB0aGFuIDEwIHNlY29uZHMgZm9yIHByZXZpb3VzIGNvbW1pdCB0byBmaW5pc2gnKTtcbiAgICAgICAgICB9LCAxMDAwMCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgZmx1c2hDaGFuZ2VzUXVldWVkOiBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAodGhpcy5jb21taXRTbG93bmVzc1dhcm5pbmcpIHtcbiAgICAgICAgY2xlYXJJbnRlcnZhbCh0aGlzLmNvbW1pdFNsb3duZXNzV2FybmluZyk7XG4gICAgICAgIHRoaXMuY29tbWl0U2xvd25lc3NXYXJuaW5nID0gbnVsbDtcbiAgICAgIH1cbiAgICAgIGlmIChPYmplY3Qua2V5cyh0aGlzLmNoYW5nZXNRdWV1ZWQpLmxlbmd0aCA+IDApIHtcbiAgICAgICAgdGhpcy5jaGFuZ2VzUnVubmluZyA9IHRoaXMuY2hhbmdlc1F1ZXVlZDtcbiAgICAgICAgdGhpcy5jaGFuZ2VzUXVldWVkID0ge307XG4gICAgICAgIHRoaXMuc2V0Tm9kZXNJbkRiKHRoaXMuY2hhbmdlc1J1bm5pbmcpLnRoZW4odGhpcy5mbHVzaENoYW5nZXNRdWV1ZWQuYmluZCh0aGlzKSk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIGdldE5vZGVzRnJvbURiOiBmdW5jdGlvbiAocGF0aHMpIHtcbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG5cbiAgICAgICAgdmFyIHRyYW5zYWN0aW9uID0gdGhpcy5kYi50cmFuc2FjdGlvbihbJ25vZGVzJ10sICdyZWFkb25seScpO1xuICAgICAgICB2YXIgbm9kZXMgPSB0cmFuc2FjdGlvbi5vYmplY3RTdG9yZSgnbm9kZXMnKTtcbiAgICAgICAgdmFyIHJldHJpZXZlZE5vZGVzID0ge307XG5cbiAgICAgICAgdGhpcy5nZXRzUnVubmluZysrO1xuXG4gICAgICAgIHBhdGhzLm1hcChmdW5jdGlvbiAocGF0aCwgaSkge1xuICAgICAgICAgIG5vZGVzLmdldChwYXRoKS5vbnN1Y2Nlc3MgPSBmdW5jdGlvbiAoZXZ0KSB7XG4gICAgICAgICAgICByZXRyaWV2ZWROb2Rlc1twYXRoXSA9IGV2dC50YXJnZXQucmVzdWx0O1xuICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRyYW5zYWN0aW9uLm9uY29tcGxldGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmVzb2x2ZShyZXRyaWV2ZWROb2Rlcyk7XG4gICAgICAgICAgdGhpcy5nZXRzUnVubmluZy0tO1xuICAgICAgICB9LmJpbmQodGhpcyk7XG5cbiAgICAgICAgdHJhbnNhY3Rpb24ub25lcnJvciA9IHRyYW5zYWN0aW9uLm9uYWJvcnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmVqZWN0KCdnZXQgdHJhbnNhY3Rpb24gZXJyb3IvYWJvcnQnKTtcbiAgICAgICAgICB0aGlzLmdldHNSdW5uaW5nLS07XG4gICAgICAgIH0uYmluZCh0aGlzKTtcblxuICAgICAgfSk7XG4gICAgfSxcblxuICAgIHNldE5vZGVzSW5EYjogZnVuY3Rpb24gKG5vZGVzKSB7XG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuXG4gICAgICAgIHZhciB0cmFuc2FjdGlvbiA9IHRoaXMuZGIudHJhbnNhY3Rpb24oWydub2RlcyddLCAncmVhZHdyaXRlJyk7XG4gICAgICAgIHZhciBub2Rlc1N0b3JlID0gdHJhbnNhY3Rpb24ub2JqZWN0U3RvcmUoJ25vZGVzJyk7XG4gICAgICAgIHZhciBzdGFydFRpbWUgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcblxuICAgICAgICB0aGlzLnB1dHNSdW5uaW5nKys7XG5cbiAgICAgICAgbG9nKCdbSW5kZXhlZERCXSBTdGFydGluZyBwdXQnLCBub2RlcywgdGhpcy5wdXRzUnVubmluZyk7XG5cbiAgICAgICAgZm9yICh2YXIgcGF0aCBpbiBub2Rlcykge1xuICAgICAgICAgIHZhciBub2RlID0gbm9kZXNbcGF0aF07XG4gICAgICAgICAgaWYodHlwZW9mKG5vZGUpID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgbm9kZXNTdG9yZS5wdXQobm9kZSk7XG4gICAgICAgICAgICB9IGNhdGNoKGUpIHtcbiAgICAgICAgICAgICAgbG9nKCdbSW5kZXhlZERCXSBFcnJvciB3aGlsZSBwdXR0aW5nJywgbm9kZSwgZSk7XG4gICAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIG5vZGVzU3RvcmUuZGVsZXRlKHBhdGgpO1xuICAgICAgICAgICAgfSBjYXRjaChlKSB7XG4gICAgICAgICAgICAgIGxvZygnW0luZGV4ZWREQl0gRXJyb3Igd2hpbGUgcmVtb3ZpbmcnLCBub2Rlc1N0b3JlLCBub2RlLCBlKTtcbiAgICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB0cmFuc2FjdGlvbi5vbmNvbXBsZXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHRoaXMucHV0c1J1bm5pbmctLTtcbiAgICAgICAgICBsb2coJ1tJbmRleGVkREJdIEZpbmlzaGVkIHB1dCcsIG5vZGVzLCB0aGlzLnB1dHNSdW5uaW5nLCAobmV3IERhdGUoKS5nZXRUaW1lKCkgLSBzdGFydFRpbWUpKydtcycpO1xuICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgfS5iaW5kKHRoaXMpO1xuXG4gICAgICAgIHRyYW5zYWN0aW9uLm9uZXJyb3IgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdGhpcy5wdXRzUnVubmluZy0tO1xuICAgICAgICAgIHJlamVjdCgndHJhbnNhY3Rpb24gZXJyb3InKTtcbiAgICAgICAgfS5iaW5kKHRoaXMpO1xuXG4gICAgICAgIHRyYW5zYWN0aW9uLm9uYWJvcnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmVqZWN0KCd0cmFuc2FjdGlvbiBhYm9ydCcpO1xuICAgICAgICAgIHRoaXMucHV0c1J1bm5pbmctLTtcbiAgICAgICAgfS5iaW5kKHRoaXMpO1xuXG4gICAgICB9KTtcbiAgICB9LFxuXG4gICAgcmVzZXQ6IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgICAgdmFyIGRiTmFtZSA9IHRoaXMuZGIubmFtZTtcbiAgICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgICAgdGhpcy5kYi5jbG9zZSgpO1xuXG4gICAgICBJbmRleGVkREIuY2xlYW4odGhpcy5kYi5uYW1lLCBmdW5jdGlvbigpIHtcbiAgICAgICAgSW5kZXhlZERCLm9wZW4oZGJOYW1lLCBmdW5jdGlvbiAoZXJyLCBvdGhlcikge1xuICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgIGxvZygnW0luZGV4ZWREQl0gRXJyb3Igd2hpbGUgcmVzZXR0aW5nIGxvY2FsIHN0b3JhZ2UnLCBlcnIpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBoYWNreSFcbiAgICAgICAgICAgIHNlbGYuZGIgPSBvdGhlcjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHR5cGVvZiBjYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJykgeyBjYWxsYmFjayhzZWxmKTsgfVxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH0sXG5cbiAgICBmb3JBbGxOb2RlczogZnVuY3Rpb24gKGNiKSB7XG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuXG4gICAgICAgIHZhciB0cmFuc2FjdGlvbiA9IHRoaXMuZGIudHJhbnNhY3Rpb24oWydub2RlcyddLCAncmVhZG9ubHknKTtcbiAgICAgICAgdmFyIGN1cnNvclJlcSA9IHRyYW5zYWN0aW9uLm9iamVjdFN0b3JlKCdub2RlcycpLm9wZW5DdXJzb3IoKTtcblxuICAgICAgICBjdXJzb3JSZXEub25zdWNjZXNzID0gZnVuY3Rpb24gKGV2dCkge1xuICAgICAgICAgIHZhciBjdXJzb3IgPSBldnQudGFyZ2V0LnJlc3VsdDtcblxuICAgICAgICAgIGlmIChjdXJzb3IpIHtcbiAgICAgICAgICAgIGNiKHRoaXMubWlncmF0ZShjdXJzb3IudmFsdWUpKTtcbiAgICAgICAgICAgIGN1cnNvci5jb250aW51ZSgpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9LmJpbmQodGhpcyk7XG5cbiAgICAgIH0pO1xuICAgIH0sXG5cbiAgICBjbG9zZURCOiBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLmRiLmNsb3NlKCk7XG4gICAgfVxuXG4gIH07XG5cbiAgSW5kZXhlZERCLm9wZW4gPSBmdW5jdGlvbiAobmFtZSwgY2FsbGJhY2spIHtcbiAgICB2YXIgdGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgIGNhbGxiYWNrKFwidGltZW91dCB0cnlpbmcgdG8gb3BlbiBkYlwiKTtcbiAgICB9LCAxMDAwMCk7XG5cbiAgICB0cnkge1xuICAgICAgdmFyIHJlcSA9IGluZGV4ZWREQi5vcGVuKG5hbWUsIERCX1ZFUlNJT04pO1xuXG4gICAgICByZXEub25lcnJvciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgbG9nKCdbSW5kZXhlZERCXSBPcGVuaW5nIERCIGZhaWxlZCcsIHJlcSk7XG5cbiAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVyKTtcbiAgICAgICAgY2FsbGJhY2socmVxLmVycm9yKTtcbiAgICAgIH07XG5cbiAgICAgIHJlcS5vbnVwZ3JhZGVuZWVkZWQgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgdmFyIGRiID0gcmVxLnJlc3VsdDtcblxuICAgICAgICBsb2coXCJbSW5kZXhlZERCXSBVcGdyYWRlOiBmcm9tIFwiLCBldmVudC5vbGRWZXJzaW9uLCBcIiB0byBcIiwgZXZlbnQubmV3VmVyc2lvbik7XG5cbiAgICAgICAgaWYgKGV2ZW50Lm9sZFZlcnNpb24gIT09IDEpIHtcbiAgICAgICAgICBsb2coXCJbSW5kZXhlZERCXSBDcmVhdGluZyBvYmplY3Qgc3RvcmU6IG5vZGVzXCIpO1xuICAgICAgICAgIGRiLmNyZWF0ZU9iamVjdFN0b3JlKCdub2RlcycsIHsga2V5UGF0aDogJ3BhdGgnIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgbG9nKFwiW0luZGV4ZWREQl0gQ3JlYXRpbmcgb2JqZWN0IHN0b3JlOiBjaGFuZ2VzXCIpO1xuXG4gICAgICAgIGRiLmNyZWF0ZU9iamVjdFN0b3JlKCdjaGFuZ2VzJywgeyBrZXlQYXRoOiAncGF0aCcgfSk7XG4gICAgICB9O1xuXG4gICAgICByZXEub25zdWNjZXNzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBjbGVhclRpbWVvdXQodGltZXIpO1xuXG4gICAgICAgIC8vIGNoZWNrIGlmIGFsbCBvYmplY3Qgc3RvcmVzIGV4aXN0XG4gICAgICAgIHZhciBkYiA9IHJlcS5yZXN1bHQ7XG4gICAgICAgIGlmKCFkYi5vYmplY3RTdG9yZU5hbWVzLmNvbnRhaW5zKCdub2RlcycpIHx8ICFkYi5vYmplY3RTdG9yZU5hbWVzLmNvbnRhaW5zKCdjaGFuZ2VzJykpIHtcbiAgICAgICAgICBsb2coXCJbSW5kZXhlZERCXSBNaXNzaW5nIG9iamVjdCBzdG9yZS4gUmVzZXR0aW5nIHRoZSBkYXRhYmFzZS5cIik7XG4gICAgICAgICAgSW5kZXhlZERCLmNsZWFuKG5hbWUsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgSW5kZXhlZERCLm9wZW4obmFtZSwgY2FsbGJhY2spO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNhbGxiYWNrKG51bGwsIHJlcS5yZXN1bHQpO1xuICAgICAgfTtcbiAgICB9IGNhdGNoKGVycm9yKSB7XG4gICAgICBsb2coXCJbSW5kZXhlZERCXSBGYWlsZWQgdG8gb3BlbiBkYXRhYmFzZTogXCIgKyBlcnJvcik7XG4gICAgICBsb2coXCJbSW5kZXhlZERCXSBSZXNldHRpbmcgZGF0YWJhc2UgYW5kIHRyeWluZyBhZ2Fpbi5cIik7XG5cbiAgICAgIGNsZWFyVGltZW91dCh0aW1lcik7XG5cbiAgICAgIEluZGV4ZWREQi5jbGVhbihuYW1lLCBmdW5jdGlvbigpIHtcbiAgICAgICAgSW5kZXhlZERCLm9wZW4obmFtZSwgY2FsbGJhY2spO1xuICAgICAgfSk7XG4gICAgfVxuICB9O1xuXG4gIEluZGV4ZWREQi5jbGVhbiA9IGZ1bmN0aW9uIChkYXRhYmFzZU5hbWUsIGNhbGxiYWNrKSB7XG4gICAgdmFyIHJlcSA9IGluZGV4ZWREQi5kZWxldGVEYXRhYmFzZShkYXRhYmFzZU5hbWUpO1xuXG4gICAgcmVxLm9uc3VjY2VzcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGxvZygnW0luZGV4ZWREQl0gRG9uZSByZW1vdmluZyBEQicpO1xuICAgICAgY2FsbGJhY2soKTtcbiAgICB9O1xuXG4gICAgcmVxLm9uZXJyb3IgPSByZXEub25hYm9ydCA9IGZ1bmN0aW9uIChldnQpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0ZhaWxlZCB0byByZW1vdmUgZGF0YWJhc2UgXCInICsgZGF0YWJhc2VOYW1lICsgJ1wiJywgZXZ0KTtcbiAgICB9O1xuICB9O1xuXG4gIEluZGV4ZWREQi5fcnNfaW5pdCA9IGZ1bmN0aW9uIChyZW1vdGVTdG9yYWdlKSB7XG5cbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuXG4gICAgICBJbmRleGVkREIub3BlbihERUZBVUxUX0RCX05BTUUsIGZ1bmN0aW9uIChlcnIsIGRiKSB7XG4gICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBERUZBVUxUX0RCID0gZGI7XG4gICAgICAgICAgZGIub25lcnJvciA9IGZ1bmN0aW9uICgpIHsgcmVtb3RlU3RvcmFnZS5fZW1pdCgnZXJyb3InLCBlcnIpOyB9O1xuICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICB9KTtcbiAgfTtcblxuICBJbmRleGVkREIuX3JzX3N1cHBvcnRlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuXG4gICAgICB2YXIgY29udGV4dCA9IHV0aWwuZ2V0R2xvYmFsQ29udGV4dCgpO1xuXG4gICAgICAvLyBUT0ZJWCB0aGlzIGlzIGNhdXNpbmcgYW4gZXJyb3IgaW4gY2hyb21lXG4gICAgICAvLyBjb250ZXh0LmluZGV4ZWREQiA9IGNvbnRleHQuaW5kZXhlZERCICAgIHx8IGNvbnRleHQud2Via2l0SW5kZXhlZERCIHx8XG4gICAgICAvLyAgICAgICAgICAgICAgICAgICAgY29udGV4dC5tb3pJbmRleGVkREIgfHwgY29udGV4dC5vSW5kZXhlZERCICAgICAgfHxcbiAgICAgIC8vICAgICAgICAgICAgICAgICAgICBjb250ZXh0Lm1zSW5kZXhlZERCO1xuXG4gICAgICAvLyBEZXRlY3QgYnJvd3NlcnMgd2l0aCBrbm93biBJbmRleGVkRGIgaXNzdWVzIChlLmcuIEFuZHJvaWQgcHJlLTQuNClcbiAgICAgIHZhciBwb29ySW5kZXhlZERiU3VwcG9ydCA9IGZhbHNlO1xuICAgICAgaWYgKHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICAgICAgbmF2aWdhdG9yLnVzZXJBZ2VudC5tYXRjaCgvQW5kcm9pZCAoMnwzfDRcXC5bMC0zXSkvKSkge1xuICAgICAgICAvLyBDaHJvbWUgYW5kIEZpcmVmb3ggc3VwcG9ydCBJbmRleGVkREJcbiAgICAgICAgaWYgKCFuYXZpZ2F0b3IudXNlckFnZW50Lm1hdGNoKC9DaHJvbWV8RmlyZWZveC8pKSB7XG4gICAgICAgICAgcG9vckluZGV4ZWREYlN1cHBvcnQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICgnaW5kZXhlZERCJyBpbiBjb250ZXh0ICYmICFwb29ySW5kZXhlZERiU3VwcG9ydCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHZhciBjaGVjayA9IGluZGV4ZWREQi5vcGVuKFwicnMtY2hlY2tcIik7XG4gICAgICAgICAgY2hlY2sub25lcnJvciA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgcmVqZWN0KCk7XG4gICAgICAgICAgfTtcbiAgICAgICAgICBjaGVjay5vbnN1Y2Nlc3MgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgIGNoZWNrLnJlc3VsdC5jbG9zZSgpO1xuICAgICAgICAgICAgaW5kZXhlZERCLmRlbGV0ZURhdGFiYXNlKFwicnMtY2hlY2tcIik7XG4gICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgfTtcbiAgICAgICAgfSBjYXRjaChlKSB7XG4gICAgICAgICAgcmVqZWN0KCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlamVjdCgpO1xuICAgICAgfVxuXG4gICAgfSk7XG4gIH07XG5cbiAgSW5kZXhlZERCLl9yc19jbGVhbnVwID0gZnVuY3Rpb24gKHJlbW90ZVN0b3JhZ2UpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgaWYgKHJlbW90ZVN0b3JhZ2UubG9jYWwpIHtcbiAgICAgICAgcmVtb3RlU3RvcmFnZS5sb2NhbC5jbG9zZURCKCk7XG4gICAgICB9XG5cbiAgICAgIEluZGV4ZWREQi5jbGVhbihERUZBVUxUX0RCX05BTUUsIHJlc29sdmUpO1xuXG4gICAgfSk7XG4gIH07XG5cblxuICBtb2R1bGUuZXhwb3J0cyA9IEluZGV4ZWREQjtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvaW5kZXhlZGRiLmpzIl0sInNvdXJjZVJvb3QiOiIifQ==");
},function(module,exports,__webpack_require__){eval("'use strict';\n\nvar eventHandling = __webpack_require__(3);\nvar log = __webpack_require__(1);\nvar cachingLayer = __webpack_require__(7);\n/**\n * Class: InMemoryStorage\n *\n * In-memory caching adapter. Used when no IndexedDB or localStorage\n * available.\n **/\n\nvar InMemoryStorage = function InMemoryStorage() {\n  cachingLayer(this);\n  log('[InMemoryStorage] Registering events');\n  eventHandling(this, 'change', 'local-events-done');\n\n  this._storage = {};\n};\n\nInMemoryStorage.prototype = {\n\n  getNodes: function getNodes(paths) {\n    var nodes = {};\n\n    for (var i = 0, len = paths.length; i < len; i++) {\n      nodes[paths[i]] = this._storage[paths[i]];\n    }\n\n    return Promise.resolve(nodes);\n  },\n\n  setNodes: function setNodes(nodes) {\n    for (var path in nodes) {\n      if (nodes[path] === undefined) {\n        delete this._storage[path];\n      } else {\n        this._storage[path] = nodes[path];\n      }\n    }\n\n    return Promise.resolve();\n  },\n\n  forAllNodes: function forAllNodes(cb) {\n    for (var path in this._storage) {\n      cb(this.migrate(this._storage[path]));\n    }\n    return Promise.resolve();\n  }\n\n};\n\nInMemoryStorage._rs_init = function () {};\n\nInMemoryStorage._rs_supported = function () {\n  // In-memory storage is always supported\n  return true;\n};\n\nInMemoryStorage._rs_cleanup = function () {};\n\nmodule.exports = InMemoryStorage;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvaW5tZW1vcnlzdG9yYWdlLmpzPzY1NDMiXSwibmFtZXMiOlsiZXZlbnRIYW5kbGluZyIsInJlcXVpcmUiLCJsb2ciLCJjYWNoaW5nTGF5ZXIiLCJJbk1lbW9yeVN0b3JhZ2UiLCJfc3RvcmFnZSIsInByb3RvdHlwZSIsImdldE5vZGVzIiwicGF0aHMiLCJub2RlcyIsImkiLCJsZW4iLCJsZW5ndGgiLCJQcm9taXNlIiwicmVzb2x2ZSIsInNldE5vZGVzIiwicGF0aCIsInVuZGVmaW5lZCIsImZvckFsbE5vZGVzIiwiY2IiLCJtaWdyYXRlIiwiX3JzX2luaXQiLCJfcnNfc3VwcG9ydGVkIiwiX3JzX2NsZWFudXAiLCJtb2R1bGUiLCJleHBvcnRzIl0sIm1hcHBpbmdzIjoiOztBQUFFLElBQUlBLGdCQUFnQixtQkFBQUMsQ0FBUSxDQUFSLENBQXBCO0FBQ0EsSUFBSUMsTUFBTSxtQkFBQUQsQ0FBUSxDQUFSLENBQVY7QUFDQSxJQUFJRSxlQUFlLG1CQUFBRixDQUFRLENBQVIsQ0FBbkI7QUFDQTs7Ozs7OztBQU9BLElBQUlHLGtCQUFrQixTQUFsQkEsZUFBa0IsR0FBWTtBQUNoQ0QsZUFBYSxJQUFiO0FBQ0FELE1BQUksc0NBQUo7QUFDQUYsZ0JBQWMsSUFBZCxFQUFvQixRQUFwQixFQUE4QixtQkFBOUI7O0FBRUEsT0FBS0ssUUFBTCxHQUFnQixFQUFoQjtBQUNELENBTkQ7O0FBUUFELGdCQUFnQkUsU0FBaEIsR0FBNEI7O0FBRTFCQyxZQUFVLGtCQUFVQyxLQUFWLEVBQWlCO0FBQ3pCLFFBQUlDLFFBQVEsRUFBWjs7QUFFQSxTQUFJLElBQUlDLElBQUksQ0FBUixFQUFXQyxNQUFNSCxNQUFNSSxNQUEzQixFQUFtQ0YsSUFBSUMsR0FBdkMsRUFBNENELEdBQTVDLEVBQWlEO0FBQy9DRCxZQUFNRCxNQUFNRSxDQUFOLENBQU4sSUFBa0IsS0FBS0wsUUFBTCxDQUFjRyxNQUFNRSxDQUFOLENBQWQsQ0FBbEI7QUFDRDs7QUFFRCxXQUFPRyxRQUFRQyxPQUFSLENBQWdCTCxLQUFoQixDQUFQO0FBQ0QsR0FWeUI7O0FBWTFCTSxZQUFVLGtCQUFVTixLQUFWLEVBQWlCO0FBQ3pCLFNBQUssSUFBSU8sSUFBVCxJQUFpQlAsS0FBakIsRUFBd0I7QUFDdEIsVUFBSUEsTUFBTU8sSUFBTixNQUFnQkMsU0FBcEIsRUFBK0I7QUFDN0IsZUFBTyxLQUFLWixRQUFMLENBQWNXLElBQWQsQ0FBUDtBQUNELE9BRkQsTUFFTztBQUNMLGFBQUtYLFFBQUwsQ0FBY1csSUFBZCxJQUFzQlAsTUFBTU8sSUFBTixDQUF0QjtBQUNEO0FBQ0Y7O0FBRUQsV0FBT0gsUUFBUUMsT0FBUixFQUFQO0FBQ0QsR0F0QnlCOztBQXdCMUJJLGVBQWEscUJBQVVDLEVBQVYsRUFBYztBQUN6QixTQUFLLElBQUlILElBQVQsSUFBaUIsS0FBS1gsUUFBdEIsRUFBZ0M7QUFDOUJjLFNBQUcsS0FBS0MsT0FBTCxDQUFhLEtBQUtmLFFBQUwsQ0FBY1csSUFBZCxDQUFiLENBQUg7QUFDRDtBQUNELFdBQU9ILFFBQVFDLE9BQVIsRUFBUDtBQUNEOztBQTdCeUIsQ0FBNUI7O0FBaUNBVixnQkFBZ0JpQixRQUFoQixHQUEyQixZQUFZLENBQUUsQ0FBekM7O0FBRUFqQixnQkFBZ0JrQixhQUFoQixHQUFnQyxZQUFZO0FBQzFDO0FBQ0EsU0FBTyxJQUFQO0FBQ0QsQ0FIRDs7QUFLQWxCLGdCQUFnQm1CLFdBQWhCLEdBQThCLFlBQVksQ0FBRSxDQUE1Qzs7QUFFQUMsT0FBT0MsT0FBUCxHQUFpQnJCLGVBQWpCIiwiZmlsZSI6IjE5LmpzIiwic291cmNlc0NvbnRlbnQiOlsiICB2YXIgZXZlbnRIYW5kbGluZyA9IHJlcXVpcmUoJy4vZXZlbnRoYW5kbGluZycpO1xuICB2YXIgbG9nID0gcmVxdWlyZSgnLi9sb2cnKTtcbiAgdmFyIGNhY2hpbmdMYXllciA9IHJlcXVpcmUoJy4vY2FjaGluZ2xheWVyJyk7XG4gIC8qKlxuICAgKiBDbGFzczogSW5NZW1vcnlTdG9yYWdlXG4gICAqXG4gICAqIEluLW1lbW9yeSBjYWNoaW5nIGFkYXB0ZXIuIFVzZWQgd2hlbiBubyBJbmRleGVkREIgb3IgbG9jYWxTdG9yYWdlXG4gICAqIGF2YWlsYWJsZS5cbiAgICoqL1xuXG4gIHZhciBJbk1lbW9yeVN0b3JhZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgY2FjaGluZ0xheWVyKHRoaXMpO1xuICAgIGxvZygnW0luTWVtb3J5U3RvcmFnZV0gUmVnaXN0ZXJpbmcgZXZlbnRzJyk7XG4gICAgZXZlbnRIYW5kbGluZyh0aGlzLCAnY2hhbmdlJywgJ2xvY2FsLWV2ZW50cy1kb25lJyk7XG5cbiAgICB0aGlzLl9zdG9yYWdlID0ge307XG4gIH07XG5cbiAgSW5NZW1vcnlTdG9yYWdlLnByb3RvdHlwZSA9IHtcblxuICAgIGdldE5vZGVzOiBmdW5jdGlvbiAocGF0aHMpIHtcbiAgICAgIHZhciBub2RlcyA9IHt9O1xuXG4gICAgICBmb3IodmFyIGkgPSAwLCBsZW4gPSBwYXRocy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBub2Rlc1twYXRoc1tpXV0gPSB0aGlzLl9zdG9yYWdlW3BhdGhzW2ldXTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShub2Rlcyk7XG4gICAgfSxcblxuICAgIHNldE5vZGVzOiBmdW5jdGlvbiAobm9kZXMpIHtcbiAgICAgIGZvciAodmFyIHBhdGggaW4gbm9kZXMpIHtcbiAgICAgICAgaWYgKG5vZGVzW3BhdGhdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBkZWxldGUgdGhpcy5fc3RvcmFnZVtwYXRoXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLl9zdG9yYWdlW3BhdGhdID0gbm9kZXNbcGF0aF07XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgIH0sXG5cbiAgICBmb3JBbGxOb2RlczogZnVuY3Rpb24gKGNiKSB7XG4gICAgICBmb3IgKHZhciBwYXRoIGluIHRoaXMuX3N0b3JhZ2UpIHtcbiAgICAgICAgY2IodGhpcy5taWdyYXRlKHRoaXMuX3N0b3JhZ2VbcGF0aF0pKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICB9XG5cbiAgfTtcblxuICBJbk1lbW9yeVN0b3JhZ2UuX3JzX2luaXQgPSBmdW5jdGlvbiAoKSB7fTtcblxuICBJbk1lbW9yeVN0b3JhZ2UuX3JzX3N1cHBvcnRlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAvLyBJbi1tZW1vcnkgc3RvcmFnZSBpcyBhbHdheXMgc3VwcG9ydGVkXG4gICAgcmV0dXJuIHRydWU7XG4gIH07XG5cbiAgSW5NZW1vcnlTdG9yYWdlLl9yc19jbGVhbnVwID0gZnVuY3Rpb24gKCkge307XG5cbiAgbW9kdWxlLmV4cG9ydHMgPSBJbk1lbW9yeVN0b3JhZ2U7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2lubWVtb3J5c3RvcmFnZS5qcyJdLCJzb3VyY2VSb290IjoiIn0=")},function(module,exports,__webpack_require__){eval("'use strict';\n\nvar cachingLayer = __webpack_require__(7);\nvar log = __webpack_require__(1);\nvar eventHandling = __webpack_require__(3);\nvar util = __webpack_require__(2);\n\n/**\n * Class: LocalStorage\n *\n * localStorage caching adapter. Used when no IndexedDB available.\n **/\n\nvar NODES_PREFIX = \"remotestorage:cache:nodes:\";\nvar CHANGES_PREFIX = \"remotestorage:cache:changes:\";\n\nvar LocalStorage = function LocalStorage() {\n  cachingLayer(this);\n  log('[LocalStorage] Registering events');\n  eventHandling(this, 'change', 'local-events-done');\n};\n\nfunction isRemoteStorageKey(key) {\n  return key.substr(0, NODES_PREFIX.length) === NODES_PREFIX || key.substr(0, CHANGES_PREFIX.length) === CHANGES_PREFIX;\n}\n\nfunction isNodeKey(key) {\n  return key.substr(0, NODES_PREFIX.length) === NODES_PREFIX;\n}\n\nLocalStorage.prototype = {\n\n  getNodes: function getNodes(paths) {\n    var nodes = {};\n\n    for (var i = 0, len = paths.length; i < len; i++) {\n      try {\n        nodes[paths[i]] = JSON.parse(localStorage[NODES_PREFIX + paths[i]]);\n      } catch (e) {\n        nodes[paths[i]] = undefined;\n      }\n    }\n\n    return Promise.resolve(nodes);\n  },\n\n  setNodes: function setNodes(nodes) {\n    for (var path in nodes) {\n      // TODO shouldn't we use getItem/setItem?\n      localStorage[NODES_PREFIX + path] = JSON.stringify(nodes[path]);\n    }\n\n    return Promise.resolve();\n  },\n\n  forAllNodes: function forAllNodes(cb) {\n    var node;\n\n    for (var i = 0, len = localStorage.length; i < len; i++) {\n      if (isNodeKey(localStorage.key(i))) {\n        try {\n          node = this.migrate(JSON.parse(localStorage[localStorage.key(i)]));\n        } catch (e) {\n          node = undefined;\n        }\n        if (node) {\n          cb(node);\n        }\n      }\n    }\n    return Promise.resolve();\n  }\n\n};\n\nLocalStorage._rs_init = function () {};\n\nLocalStorage._rs_supported = function () {\n  return util.localStorageAvailable();\n};\n\n// TODO tests missing!\nLocalStorage._rs_cleanup = function () {\n  var keys = [];\n\n  for (var i = 0, len = localStorage.length; i < len; i++) {\n    var key = localStorage.key(i);\n    if (isRemoteStorageKey(key)) {\n      keys.push(key);\n    }\n  }\n\n  keys.forEach(function (key) {\n    log('[LocalStorage] Removing', key);\n    delete localStorage[key];\n  });\n};\n\nmodule.exports = LocalStorage;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvbG9jYWxzdG9yYWdlLmpzPzlhYjYiXSwibmFtZXMiOlsiY2FjaGluZ0xheWVyIiwicmVxdWlyZSIsImxvZyIsImV2ZW50SGFuZGxpbmciLCJ1dGlsIiwiTk9ERVNfUFJFRklYIiwiQ0hBTkdFU19QUkVGSVgiLCJMb2NhbFN0b3JhZ2UiLCJpc1JlbW90ZVN0b3JhZ2VLZXkiLCJrZXkiLCJzdWJzdHIiLCJsZW5ndGgiLCJpc05vZGVLZXkiLCJwcm90b3R5cGUiLCJnZXROb2RlcyIsInBhdGhzIiwibm9kZXMiLCJpIiwibGVuIiwiSlNPTiIsInBhcnNlIiwibG9jYWxTdG9yYWdlIiwiZSIsInVuZGVmaW5lZCIsIlByb21pc2UiLCJyZXNvbHZlIiwic2V0Tm9kZXMiLCJwYXRoIiwic3RyaW5naWZ5IiwiZm9yQWxsTm9kZXMiLCJjYiIsIm5vZGUiLCJtaWdyYXRlIiwiX3JzX2luaXQiLCJfcnNfc3VwcG9ydGVkIiwibG9jYWxTdG9yYWdlQXZhaWxhYmxlIiwiX3JzX2NsZWFudXAiLCJrZXlzIiwicHVzaCIsImZvckVhY2giLCJtb2R1bGUiLCJleHBvcnRzIl0sIm1hcHBpbmdzIjoiOztBQUFFLElBQUlBLGVBQWUsbUJBQUFDLENBQVEsQ0FBUixDQUFuQjtBQUNBLElBQUlDLE1BQU0sbUJBQUFELENBQVEsQ0FBUixDQUFWO0FBQ0EsSUFBSUUsZ0JBQWdCLG1CQUFBRixDQUFRLENBQVIsQ0FBcEI7QUFDQSxJQUFJRyxPQUFPLG1CQUFBSCxDQUFRLENBQVIsQ0FBWDs7QUFFQTs7Ozs7O0FBTUEsSUFBSUksZUFBZSw0QkFBbkI7QUFDQSxJQUFJQyxpQkFBaUIsOEJBQXJCOztBQUVBLElBQUlDLGVBQWUsU0FBZkEsWUFBZSxHQUFZO0FBQzdCUCxlQUFhLElBQWI7QUFDQUUsTUFBSSxtQ0FBSjtBQUNBQyxnQkFBYyxJQUFkLEVBQW9CLFFBQXBCLEVBQThCLG1CQUE5QjtBQUNELENBSkQ7O0FBTUEsU0FBU0ssa0JBQVQsQ0FBNEJDLEdBQTVC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OztBQWdCQStCLE9BQU9DLE9BQVAsR0FBaUJsQyxZQUFqQiIsImZpbGUiOiIyMC5qcyIsInNvdXJjZXNDb250ZW50IjpbIiAgdmFyIGNhY2hpbmdMYXllciA9IHJlcXVpcmUoJy4vY2FjaGluZ2xheWVyJyk7XG4gIHZhciBsb2cgPSByZXF1aXJlKCcuL2xvZycpO1xuICB2YXIgZXZlbnRIYW5kbGluZyA9IHJlcXVpcmUoJy4vZXZlbnRoYW5kbGluZycpO1xuICB2YXIgdXRpbCA9IHJlcXVpcmUoJy4vdXRpbCcpO1xuXG4gIC8qKlxuICAgKiBDbGFzczogTG9jYWxTdG9yYWdlXG4gICAqXG4gICAqIGxvY2FsU3RvcmFnZSBjYWNoaW5nIGFkYXB0ZXIuIFVzZWQgd2hlbiBubyBJbmRleGVkREIgYXZhaWxhYmxlLlxuICAgKiovXG5cbiAgdmFyIE5PREVTX1BSRUZJWCA9IFwicmVtb3Rlc3RvcmFnZTpjYWNoZTpub2RlczpcIjtcbiAgdmFyIENIQU5HRVNfUFJFRklYID0gXCJyZW1vdGVzdG9yYWdlOmNhY2hlOmNoYW5nZXM6XCI7XG5cbiAgdmFyIExvY2FsU3RvcmFnZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBjYWNoaW5nTGF5ZXIodGhpcyk7XG4gICAgbG9nKCdbTG9jYWxTdG9yYWdlXSBSZWdpc3RlcmluZyBldmVudHMnKTtcbiAgICBldmVudEhhbmRsaW5nKHRoaXMsICdjaGFuZ2UnLCAnbG9jYWwtZXZlbnRzLWRvbmUnKTtcbiAgfTtcblxuICBmdW5jdGlvbiBpc1JlbW90ZVN0b3JhZ2VLZXkoa2V5KSB7XG4gICAgcmV0dXJuIGtleS5zdWJzdHIoMCwgTk9ERVNfUFJFRklYLmxlbmd0aCkgPT09IE5PREVTX1BSRUZJWCB8fFxuICAgICAgICAgICBrZXkuc3Vic3RyKDAsIENIQU5HRVNfUFJFRklYLmxlbmd0aCkgPT09IENIQU5HRVNfUFJFRklYO1xuICB9XG5cbiAgZnVuY3Rpb24gaXNOb2RlS2V5KGtleSkge1xuICAgIHJldHVybiBrZXkuc3Vic3RyKDAsIE5PREVTX1BSRUZJWC5sZW5ndGgpID09PSBOT0RFU19QUkVGSVg7XG4gIH1cblxuICBMb2NhbFN0b3JhZ2UucHJvdG90eXBlID0ge1xuXG4gICAgZ2V0Tm9kZXM6IGZ1bmN0aW9uIChwYXRocykge1xuICAgICAgdmFyIG5vZGVzID0ge307XG5cbiAgICAgIGZvcih2YXIgaSA9IDAsIGxlbiA9IHBhdGhzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgbm9kZXNbcGF0aHNbaV1dID0gSlNPTi5wYXJzZShsb2NhbFN0b3JhZ2VbTk9ERVNfUFJFRklYK3BhdGhzW2ldXSk7XG4gICAgICAgIH0gY2F0Y2goZSkge1xuICAgICAgICAgIG5vZGVzW3BhdGhzW2ldXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKG5vZGVzKTtcbiAgICB9LFxuXG4gICAgc2V0Tm9kZXM6IGZ1bmN0aW9uIChub2Rlcykge1xuICAgICAgZm9yICh2YXIgcGF0aCBpbiBub2Rlcykge1xuICAgICAgICAvLyBUT0RPIHNob3VsZG4ndCB3ZSB1c2UgZ2V0SXRlbS9zZXRJdGVtP1xuICAgICAgICBsb2NhbFN0b3JhZ2VbTk9ERVNfUFJFRklYK3BhdGhdID0gSlNPTi5zdHJpbmdpZnkobm9kZXNbcGF0aF0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgfSxcblxuICAgIGZvckFsbE5vZGVzOiBmdW5jdGlvbiAoY2IpIHtcbiAgICAgIHZhciBub2RlO1xuXG4gICAgICBmb3IodmFyIGkgPSAwLCBsZW4gPSBsb2NhbFN0b3JhZ2UubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgaWYgKGlzTm9kZUtleShsb2NhbFN0b3JhZ2Uua2V5KGkpKSkge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBub2RlID0gdGhpcy5taWdyYXRlKEpTT04ucGFyc2UobG9jYWxTdG9yYWdlW2xvY2FsU3RvcmFnZS5rZXkoaSldKSk7XG4gICAgICAgICAgfSBjYXRjaChlKSB7XG4gICAgICAgICAgICBub2RlID0gdW5kZWZpbmVkO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobm9kZSkge1xuICAgICAgICAgICAgY2Iobm9kZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgfVxuXG4gIH07XG5cbiAgTG9jYWxTdG9yYWdlLl9yc19pbml0ID0gZnVuY3Rpb24gKCkge307XG5cbiAgTG9jYWxTdG9yYWdlLl9yc19zdXBwb3J0ZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHV0aWwubG9jYWxTdG9yYWdlQXZhaWxhYmxlKCk7XG4gIH07XG5cbiAgLy8gVE9ETyB0ZXN0cyBtaXNzaW5nIVxuICBMb2NhbFN0b3JhZ2UuX3JzX2NsZWFudXAgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGtleXMgPSBbXTtcblxuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBsb2NhbFN0b3JhZ2UubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIHZhciBrZXkgPSBsb2NhbFN0b3JhZ2Uua2V5KGkpO1xuICAgICAgaWYgKGlzUmVtb3RlU3RvcmFnZUtleShrZXkpKSB7XG4gICAgICAgIGtleXMucHVzaChrZXkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGtleXMuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICBsb2coJ1tMb2NhbFN0b3JhZ2VdIFJlbW92aW5nJywga2V5KTtcbiAgICAgIGRlbGV0ZSBsb2NhbFN0b3JhZ2Vba2V5XTtcbiAgICB9KTtcbiAgfTtcblxuICBtb2R1bGUuZXhwb3J0cyA9IExvY2FsU3RvcmFnZTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9sb2NhbHN0b3JhZ2UuanMiXSwic291cmNlUm9vdCI6IiJ9")},function(module,exports,__webpack_require__){eval("'use strict';\n\nvar BaseClient = __webpack_require__(6);\nvar RemoteStorage = __webpack_require__(16);\n\nRemoteStorage.MODULES = {};\n\n/*\n * Method: RemoteStorage.defineModule\n *\n * Method for defining a new remoteStorage data module\n *\n * Parameters:\n *   moduleName - Name of the module\n *   builder    - Builder function defining the module\n *\n * The module builder function should return an object containing another\n * object called exports, which will be exported to any <RemoteStorage>\n * instance under the module's name. So when defining a locations module,\n * like in the example below, it would be accessible via\n * `remoteStorage.locations`, which would in turn have a `features` and a\n * `collections` property.\n *\n * The function receives a private and a public client, which are both\n * instances of <RemoteStorage.BaseClient>. In the following example, the\n * scope of privateClient is `/locations` and the scope of publicClient is\n * `/public/locations`.\n *\n * Example:\n *   (start code)\n *   RemoteStorage.defineModule('locations', function (privateClient, publicClient) {\n *     return {\n *       exports: {\n *         features: privateClient.scope('features/').defaultType('feature'),\n *         collections: privateClient.scope('collections/').defaultType('feature-collection')\n *       }\n *     };\n *   });\n * (end code)\n*/\n\nRemoteStorage.defineModule = function (moduleName, builder) {\n  RemoteStorage.MODULES[moduleName] = builder;\n\n  Object.defineProperty(RemoteStorage.prototype, moduleName, {\n    configurable: true,\n    get: function get() {\n      var instance = this._loadModule(moduleName);\n      Object.defineProperty(this, moduleName, {\n        value: instance\n      });\n      return instance;\n    }\n  });\n\n  if (moduleName.indexOf('-') !== -1) {\n    var camelizedName = moduleName.replace(/\\-[a-z]/g, function (s) {\n      return s[1].toUpperCase();\n    });\n    Object.defineProperty(RemoteStorage.prototype, camelizedName, {\n      get: function get() {\n        return this[moduleName];\n      }\n    });\n  }\n};\n\nRemoteStorage.prototype._loadModule = function (moduleName) {\n  var builder = RemoteStorage.MODULES[moduleName];\n  if (builder) {\n    var module = builder(new BaseClient(this, '/' + moduleName + '/'), new BaseClient(this, '/public/' + moduleName + '/'));\n    return module.exports;\n  } else {\n    throw \"Unknown module: \" + moduleName;\n  }\n};\n\nRemoteStorage.prototype.defineModule = function (moduleName) {\n  console.log(\"remoteStorage.defineModule is deprecated, use RemoteStorage.defineModule instead!\");\n  RemoteStorage.defineModule.apply(RemoteStorage, arguments);\n};\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvbW9kdWxlcy5qcz9jNzMyIl0sIm5hbWVzIjpbIkJhc2VDbGllbnQiLCJyZXF1aXJlIiwiUmVtb3RlU3RvcmFnZSIsIk1PRFVMRVMiLCJkZWZpbmVNb2R1bGUiLCJtb2R1bGVOYW1lIiwiYnVpbGRlciIsIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwicHJvdG90eXBlIiwiY29uZmlndXJhYmxlIiwiZ2V0IiwiaW5zdGFuY2UiLCJfbG9hZE1vZHVsZSIsInZhbHVlIiwiaW5kZXhPZiIsImNhbWVsaXplZE5hbWUiLCJyZXBsYWNlIiwicyIsInRvVXBwZXJDYXNlIiwibW9kdWxlIiwiZXhwb3J0cyIsImNvbnNvbGUiLCJsb2ciLCJhcHBseSIsImFyZ3VtZW50cyJdLCJtYXBwaW5ncyI6Ijs7QUFBRSxJQUFJQSxhQUFhLG1CQUFBQyxDQUFRLENBQVIsQ0FBakI7QUFDQSxJQUFJQyxnQkFBZ0IsbUJBQUFELENBQVEsRUFBUixDQUFwQjs7QUFFQUMsY0FBY0MsT0FBZCxHQUF3QixFQUF4Qjs7QUFFQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQWtDQUQsY0FBY0UsWUFBZCxHQUE2QixVQUFVQyxVQUFWLEVBQXNCQyxPQUF0QixFQUErQjtBQUMxREosZ0JBQWNDLE9BQWQsQ0FBc0JFLFVBQXRCLElBQW9DQyxPQUFwQzs7QUFFQUMsU0FBT0MsY0FBUCxDQUFzQk4sY0FBY08sU0FBcEMsRUFBK0NKLFVBQS9DLEVBQTJEO0FBQ3pESyxrQkFBYyxJQUQyQztBQUV6REMsU0FBSyxlQUFZO0FBQ2YsVUFBSUMsV0FBVyxLQUFLQyxXQUFMLENBQWlCUixVQUFqQixDQUFmO0FBQ0FFLGFBQU9DLGNBQVAsQ0FBc0IsSUFBdEIsRUFBNEJILFVBQTVCLEVBQXdDO0FBQ3RDUyxlQUFPRjtBQUQrQixPQUF4QztBQUdBLGFBQU9BLFFBQVA7QUFDRDtBQVJ3RCxHQUEzRDs7QUFXQSxNQUFJUCxXQUFXVSxPQUFYLENBQW1CLEdBQW5CLE1BQTRCLENBQUMsQ0FBakMsRUFBb0M7QUFDbEMsUUFBSUMsZ0JBQWdCWCxXQUFXWSxPQUFYLENBQW1CLFVBQW5CLEVBQStCLFVBQVVDLENBQVYsRUFBYTtBQUM5RCxhQUFPQSxFQUFFLENBQUYsRUFBS0MsV0FBTCxFQUFQO0FBQ0QsS0FGbUIsQ0FBcEI7QUFHQVosV0FBT0MsY0FBUCxDQUFzQk4sY0FBY08sU0FBcEMsRUFBK0NPLGFBQS9DLEVBQThEO0FBQzVETCxXQUFLLGVBQVk7QUFDZixlQUFPLEtBQUtOLFVBQUwsQ0FBUDtBQUNEO0FBSDJELEtBQTlEO0FBS0Q7QUFDRixDQXhCRDs7QUEwQkFILGNBQWNPLFNBQWQsQ0FBd0JJLFdBQXhCLEdBQXNDLFVBQVVSLFVBQVYsRUFBc0I7QUFDMUQsTUFBSUMsVUFBVUosY0FBY0MsT0FBZCxDQUFzQkUsVUFBdEIsQ0FBZDtBQUNBLE1BQUlDLE9BQUosRUFBYTtBQUNYLFFBQUljLFNBQVNkLFFBQVEsSUFBSU4sVUFBSixDQUFlLElBQWYsRUFBcUIsTUFBTUssVUFBTixHQUFtQixHQUF4QyxDQUFSLEVBQ1EsSUFBSUwsVUFBSixDQUFlLElBQWYsRUFBcUIsYUFBYUssVUFBYixHQUEwQixHQUEvQyxDQURSLENBQWI7QUFFQSxXQUFPZSxPQUFPQyxPQUFkO0FBQ0QsR0FKRCxNQUlPO0FBQ0wsVUFBTSxxQkFBcUJoQixVQUEzQjtBQUNEO0FBQ0YsQ0FURDs7QUFXQUgsY0FBY08sU0FBZCxDQUF3QkwsWUFBeEIsR0FBdUMsVUFBVUMsVUFBVixFQUFzQjtBQUMzRGlCLFVBQVFDLEdBQVIsQ0FBWSxtRkFBWjtBQUNBckIsZ0JBQWNFLFlBQWQsQ0FBMkJvQixLQUEzQixDQUFpQ3RCLGFBQWpDLEVBQWdEdUIsU0FBaEQ7QUFDRCxDQUhEIiwiZmlsZSI6IjIxLmpzIiwic291cmNlc0NvbnRlbnQiOlsiICB2YXIgQmFzZUNsaWVudCA9IHJlcXVpcmUoJy4vYmFzZWNsaWVudCcpO1xuICB2YXIgUmVtb3RlU3RvcmFnZSA9IHJlcXVpcmUoJy4vcmVtb3Rlc3RvcmFnZScpO1xuICBcbiAgUmVtb3RlU3RvcmFnZS5NT0RVTEVTID0ge307XG5cbiAgLypcbiAgICogTWV0aG9kOiBSZW1vdGVTdG9yYWdlLmRlZmluZU1vZHVsZVxuICAgKlxuICAgKiBNZXRob2QgZm9yIGRlZmluaW5nIGEgbmV3IHJlbW90ZVN0b3JhZ2UgZGF0YSBtb2R1bGVcbiAgICpcbiAgICogUGFyYW1ldGVyczpcbiAgICogICBtb2R1bGVOYW1lIC0gTmFtZSBvZiB0aGUgbW9kdWxlXG4gICAqICAgYnVpbGRlciAgICAtIEJ1aWxkZXIgZnVuY3Rpb24gZGVmaW5pbmcgdGhlIG1vZHVsZVxuICAgKlxuICAgKiBUaGUgbW9kdWxlIGJ1aWxkZXIgZnVuY3Rpb24gc2hvdWxkIHJldHVybiBhbiBvYmplY3QgY29udGFpbmluZyBhbm90aGVyXG4gICAqIG9iamVjdCBjYWxsZWQgZXhwb3J0cywgd2hpY2ggd2lsbCBiZSBleHBvcnRlZCB0byBhbnkgPFJlbW90ZVN0b3JhZ2U+XG4gICAqIGluc3RhbmNlIHVuZGVyIHRoZSBtb2R1bGUncyBuYW1lLiBTbyB3aGVuIGRlZmluaW5nIGEgbG9jYXRpb25zIG1vZHVsZSxcbiAgICogbGlrZSBpbiB0aGUgZXhhbXBsZSBiZWxvdywgaXQgd291bGQgYmUgYWNjZXNzaWJsZSB2aWFcbiAgICogYHJlbW90ZVN0b3JhZ2UubG9jYXRpb25zYCwgd2hpY2ggd291bGQgaW4gdHVybiBoYXZlIGEgYGZlYXR1cmVzYCBhbmQgYVxuICAgKiBgY29sbGVjdGlvbnNgIHByb3BlcnR5LlxuICAgKlxuICAgKiBUaGUgZnVuY3Rpb24gcmVjZWl2ZXMgYSBwcml2YXRlIGFuZCBhIHB1YmxpYyBjbGllbnQsIHdoaWNoIGFyZSBib3RoXG4gICAqIGluc3RhbmNlcyBvZiA8UmVtb3RlU3RvcmFnZS5CYXNlQ2xpZW50Pi4gSW4gdGhlIGZvbGxvd2luZyBleGFtcGxlLCB0aGVcbiAgICogc2NvcGUgb2YgcHJpdmF0ZUNsaWVudCBpcyBgL2xvY2F0aW9uc2AgYW5kIHRoZSBzY29wZSBvZiBwdWJsaWNDbGllbnQgaXNcbiAgICogYC9wdWJsaWMvbG9jYXRpb25zYC5cbiAgICpcbiAgICogRXhhbXBsZTpcbiAgICogICAoc3RhcnQgY29kZSlcbiAgICogICBSZW1vdGVTdG9yYWdlLmRlZmluZU1vZHVsZSgnbG9jYXRpb25zJywgZnVuY3Rpb24gKHByaXZhdGVDbGllbnQsIHB1YmxpY0NsaWVudCkge1xuICAgKiAgICAgcmV0dXJuIHtcbiAgICogICAgICAgZXhwb3J0czoge1xuICAgKiAgICAgICAgIGZlYXR1cmVzOiBwcml2YXRlQ2xpZW50LnNjb3BlKCdmZWF0dXJlcy8nKS5kZWZhdWx0VHlwZSgnZmVhdHVyZScpLFxuICAgKiAgICAgICAgIGNvbGxlY3Rpb25zOiBwcml2YXRlQ2xpZW50LnNjb3BlKCdjb2xsZWN0aW9ucy8nKS5kZWZhdWx0VHlwZSgnZmVhdHVyZS1jb2xsZWN0aW9uJylcbiAgICogICAgICAgfVxuICAgKiAgICAgfTtcbiAgICogICB9KTtcbiAgICogKGVuZCBjb2RlKVxuICAqL1xuXG4gIFJlbW90ZVN0b3JhZ2UuZGVmaW5lTW9kdWxlID0gZnVuY3Rpb24gKG1vZHVsZU5hbWUsIGJ1aWxkZXIpIHtcbiAgICBSZW1vdGVTdG9yYWdlLk1PRFVMRVNbbW9kdWxlTmFtZV0gPSBidWlsZGVyO1xuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFJlbW90ZVN0b3JhZ2UucHJvdG90eXBlLCBtb2R1bGVOYW1lLCB7XG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGluc3RhbmNlID0gdGhpcy5fbG9hZE1vZHVsZShtb2R1bGVOYW1lKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIG1vZHVsZU5hbWUsIHtcbiAgICAgICAgICB2YWx1ZTogaW5zdGFuY2VcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBpbnN0YW5jZTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGlmIChtb2R1bGVOYW1lLmluZGV4T2YoJy0nKSAhPT0gLTEpIHtcbiAgICAgIHZhciBjYW1lbGl6ZWROYW1lID0gbW9kdWxlTmFtZS5yZXBsYWNlKC9cXC1bYS16XS9nLCBmdW5jdGlvbiAocykge1xuICAgICAgICByZXR1cm4gc1sxXS50b1VwcGVyQ2FzZSgpO1xuICAgICAgfSk7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUmVtb3RlU3RvcmFnZS5wcm90b3R5cGUsIGNhbWVsaXplZE5hbWUsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXNbbW9kdWxlTmFtZV07XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcblxuICBSZW1vdGVTdG9yYWdlLnByb3RvdHlwZS5fbG9hZE1vZHVsZSA9IGZ1bmN0aW9uIChtb2R1bGVOYW1lKSB7XG4gICAgdmFyIGJ1aWxkZXIgPSBSZW1vdGVTdG9yYWdlLk1PRFVMRVNbbW9kdWxlTmFtZV07XG4gICAgaWYgKGJ1aWxkZXIpIHtcbiAgICAgIHZhciBtb2R1bGUgPSBidWlsZGVyKG5ldyBCYXNlQ2xpZW50KHRoaXMsICcvJyArIG1vZHVsZU5hbWUgKyAnLycpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3IEJhc2VDbGllbnQodGhpcywgJy9wdWJsaWMvJyArIG1vZHVsZU5hbWUgKyAnLycpKTtcbiAgICAgIHJldHVybiBtb2R1bGUuZXhwb3J0cztcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgXCJVbmtub3duIG1vZHVsZTogXCIgKyBtb2R1bGVOYW1lO1xuICAgIH1cbiAgfTtcblxuICBSZW1vdGVTdG9yYWdlLnByb3RvdHlwZS5kZWZpbmVNb2R1bGUgPSBmdW5jdGlvbiAobW9kdWxlTmFtZSkge1xuICAgIGNvbnNvbGUubG9nKFwicmVtb3RlU3RvcmFnZS5kZWZpbmVNb2R1bGUgaXMgZGVwcmVjYXRlZCwgdXNlIFJlbW90ZVN0b3JhZ2UuZGVmaW5lTW9kdWxlIGluc3RlYWQhXCIpO1xuICAgIFJlbW90ZVN0b3JhZ2UuZGVmaW5lTW9kdWxlLmFwcGx5KFJlbW90ZVN0b3JhZ2UsIGFyZ3VtZW50cyk7XG4gIH07XG5cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9tb2R1bGVzLmpzIl0sInNvdXJjZVJvb3QiOiIifQ==")},function(module,exports,__webpack_require__){eval("'use strict';\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar log = __webpack_require__(1);\n\nfunction shareFirst(path) {\n  return this.backend === 'dropbox' && path.match(/^\\/public\\/.*[^\\/]$/);\n}\n\nvar SyncedGetPutDelete = {\n  get: function get(path, maxAge) {\n    if (this.local) {\n      if (maxAge === undefined) {\n        if (_typeof(this.remote) === 'object' && this.remote.connected && this.remote.online) {\n          maxAge = 2 * this.getSyncInterval();\n        } else {\n          log('Not setting default maxAge, because remote is offline or not connected');\n          maxAge = false;\n        }\n      }\n      var maxAgeInvalid = function maxAgeInvalid(maxAge) {\n        return maxAge !== false && typeof maxAge !== 'number';\n      };\n\n      if (maxAgeInvalid(maxAge)) {\n        return Promise.reject('Argument \\'maxAge\\' must be false or a number');\n      }\n      return this.local.get(path, maxAge, this.sync.queueGetRequest.bind(this.sync));\n    } else {\n      return this.remote.get(path);\n    }\n  },\n\n  put: function put(path, body, contentType) {\n    if (shareFirst.bind(this)(path)) {\n      return SyncedGetPutDelete._wrapBusyDone.call(this, this.remote.put(path, body, contentType));\n    } else if (this.local) {\n      return this.local.put(path, body, contentType);\n    } else {\n      return SyncedGetPutDelete._wrapBusyDone.call(this, this.remote.put(path, body, contentType));\n    }\n  },\n\n  'delete': function _delete(path) {\n    if (this.local) {\n      return this.local.delete(path);\n    } else {\n      return SyncedGetPutDelete._wrapBusyDone.call(this, this.remote.delete(path));\n    }\n  },\n\n  _wrapBusyDone: function _wrapBusyDone(result) {\n    var self = this;\n    this._emit('wire-busy');\n    return result.then(function (r) {\n      self._emit('wire-done', { success: true });\n      return Promise.resolve(r);\n    }, function (err) {\n      self._emit('wire-done', { success: false });\n      return Promise.reject(err);\n    });\n  }\n};\n\nmodule.exports = SyncedGetPutDelete;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvc3luY2VkZ2V0cHV0ZGVsZXRlLmpzPzkyNjQiXSwibmFtZXMiOlsibG9nIiwicmVxdWlyZSIsInNoYXJlRmlyc3QiLCJwYXRoIiwiYmFja2VuZCIsIm1hdGNoIiwiU3luY2VkR2V0UHV0RGVsZXRlIiwiZ2V0IiwibWF4QWdlIiwibG9jYWwiLCJ1bmRlZmluZWQiLCJyZW1vdGUiLCJjb25uZWN0ZWQiLCJvbmxpbmUiLCJnZXRTeW5jSW50ZXJ2YWwiLCJtYXhBZ2VJbnZhbGlkIiwiUHJvbWlzZSIsInJlamVjdCIsInN5bmMiLCJxdWV1ZUdldFJlcXVlc3QiLCJiaW5kIiwicHV0IiwiYm9keSIsImNvbnRlbnRUeXBlIiwiX3dyYXBCdXN5RG9uZSIsImNhbGwiLCJkZWxldGUiLCJyZXN1bHQiLCJzZWxmIiwiX2VtaXQiLCJ0aGVuIiwiciIsInN1Y2Nlc3MiLCJyZXNvbHZlIiwiZXJyIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJtYXBwaW5ncyI6Ijs7OztBQUNBLElBQUlBLE1BQU0sbUJBQUFDLENBQVEsQ0FBUixDQUFWOztBQUVBLFNBQVNDLFVBQVQsQ0FBb0JDLElBQXBCLEVBQTBCO0FBQ3hCLFNBQVMsS0FBS0MsT0FBTCxLQUFpQixTQUFqQixJQUNBRCxLQUFLRSxLQUFMLENBQVcscUJBQVgsQ0FEVDtBQUVEOztBQUVELElBQUlDLHFCQUFxQjtBQUN2QkMsT0FBSyxhQUFVSixJQUFWLEVBQWdCSyxNQUFoQixFQUF3QjtBQUMzQixRQUFJLEtBQUtDLEtBQVQsRUFBZ0I7QUFDZCxVQUFJRCxXQUFXRSxTQUFmLEVBQTBCO0FBQ3hCLFlBQUssUUFBTyxLQUFLQyxNQUFaLE1BQXVCLFFBQXhCLElBQ0MsS0FBS0EsTUFBTCxDQUFZQyxTQURiLElBQzBCLEtBQUtELE1BQUwsQ0FBWUUsTUFEMUMsRUFDa0Q7QUFDaERMLG1CQUFTLElBQUUsS0FBS00sZUFBTCxFQUFYO0FBQ0QsU0FIRCxNQUdPO0FBQ0xkLGNBQUksd0VBQUo7QUFDQVEsbUJBQVMsS0FBVDtBQUNEO0FBQ0Y7QUFDRCxVQUFJTyxnQkFBZ0IsU0FBaEJBLGFBQWdCLENBQVVQLE1BQVYsRUFBa0I7QUFDcEMsZUFBT0EsV0FBVyxLQUFYLElBQW9CLE9BQU9BLE1BQVAsS0FBbUIsUUFBOUM7QUFDRCxPQUZEOztBQUlBLFVBQUlPLGNBQWNQLE1BQWQsQ0FBSixFQUEyQjtBQUN6QixlQUFPUSxRQUFRQyxNQUFSLENBQWUsK0NBQWYsQ0FBUDtBQUNEO0FBQ0QsYUFBTyxLQUFLUixLQUFMLENBQVdGLEdBQVgsQ0FBZUosSUFBZixFQUFxQkssTUFBckIsRUFBNkIsS0FBS1UsSUFBTCxDQUFVQyxlQUFWLENBQTBCQyxJQUExQixDQUErQixLQUFLRixJQUFwQyxDQUE3QixDQUFQO0FBQ0QsS0FsQkQsTUFrQk87QUFDTCxhQUFPLEtBQUtQLE1BQUwsQ0FBWUosR0FBWixDQUFnQkosSUFBaEIsQ0FBUDtBQUNEO0FBQ0YsR0F2QnNCOztBQXlCdkJrQixPQUFLLGFBQVVsQixJQUFWLEVBQWdCbUIsSUFBaEIsRUFBc0JDLFdBQXRCLEVBQW1DO0FBQ3RDLFFBQUlyQixXQUFXa0IsSUFBWCxDQUFnQixJQUFoQixFQUFzQmpCLElBQXRCLENBQUosRUFBaUM7QUFDL0IsYUFBT0csbUJBQW1Ca0IsYUFBbkIsQ0FBaUNDLElBQWpDLENBQXNDLElBQXRDLEVBQTRDLEtBQUtkLE1BQUwsQ0FBWVUsR0FBWixDQUFnQmxCLElBQWhCLEVBQXNCbUIsSUFBdEIsRUFBNEJDLFdBQTVCLENBQTVDLENBQVA7QUFDRCxLQUZELE1BR0ssSUFBSSxLQUFLZCxLQUFULEVBQWdCO0FBQ25CLGFBQU8sS0FBS0EsS0FBTCxDQUFXWSxHQUFYLENBQWVsQixJQUFmLEVBQXFCbUIsSUFBckIsRUFBMkJDLFdBQTNCLENBQVA7QUFDRCxLQUZJLE1BRUU7QUFDTCxhQUFPakIsbUJBQW1Ca0IsYUFBbkIsQ0FBaUNDLElBQWpDLENBQXNDLElBQXRDLEVBQTRDLEtBQUtkLE1BQUwsQ0FBWVUsR0FBWixDQUFnQmxCLElBQWhCLEVBQXNCbUIsSUFBdEIsRUFBNEJDLFdBQTVCLENBQTVDLENBQVA7QUFDRDtBQUNGLEdBbENzQjs7QUFvQ3ZCLFlBQVUsaUJBQVVwQixJQUFWLEVBQWdCO0FBQ3hCLFFBQUksS0FBS00sS0FBVCxFQUFnQjtBQUNkLGFBQU8sS0FBS0EsS0FBTCxDQUFXaUIsTUFBWCxDQUFrQnZCLElBQWxCLENBQVA7QUFDRCxLQUZELE1BRU87QUFDTCxhQUFPRyxtQkFBbUJrQixhQUFuQixDQUFpQ0MsSUFBakMsQ0FBc0MsSUFBdEMsRUFBNEMsS0FBS2QsTUFBTCxDQUFZZSxNQUFaLENBQW1CdkIsSUFBbkIsQ0FBNUMsQ0FBUDtBQUNEO0FBQ0YsR0ExQ3NCOztBQTRDdkJxQixpQkFBZSx1QkFBVUcsTUFBVixFQUFrQjtBQUMvQixRQUFJQyxPQUFPLElBQVg7QUFDQSxTQUFLQyxLQUFMLENBQVcsV0FBWDtBQUNBLFdBQU9GLE9BQU9HLElBQVAsQ0FBWSxVQUFVQyxDQUFWLEVBQWE7QUFDOUJILFdBQUtDLEtBQUwsQ0FBVyxXQUFYLEVBQXdCLEVBQUVHLFNBQVMsSUFBWCxFQUF4QjtBQUNBLGFBQU9oQixRQUFRaUIsT0FBUixDQUFnQkYsQ0FBaEIsQ0FBUDtBQUNELEtBSE0sRUFHSixVQUFVRyxHQUFWLEVBQWU7QUFDaEJOLFdBQUtDLEtBQUwsQ0FBVyxXQUFYLEVBQXdCLEVBQUVHLFNBQVMsS0FBWCxFQUF4QjtBQUNBLGFBQU9oQixRQUFRQyxNQUFSLENBQWVpQixHQUFmLENBQVA7QUFDRCxLQU5NLENBQVA7QUFPRDtBQXREc0IsQ0FBekI7O0FBeURBQyxPQUFPQyxPQUFQLEdBQWlCOUIsa0JBQWpCIiwiZmlsZSI6IjIyLmpzIiwic291cmNlc0NvbnRlbnQiOlsiXG52YXIgbG9nID0gcmVxdWlyZSgnLi9sb2cnKTtcblxuZnVuY3Rpb24gc2hhcmVGaXJzdChwYXRoKSB7XG4gIHJldHVybiAoIHRoaXMuYmFja2VuZCA9PT0gJ2Ryb3Bib3gnICYmXG4gICAgICAgICAgIHBhdGgubWF0Y2goL15cXC9wdWJsaWNcXC8uKlteXFwvXSQvKSApO1xufVxuXG52YXIgU3luY2VkR2V0UHV0RGVsZXRlID0ge1xuICBnZXQ6IGZ1bmN0aW9uIChwYXRoLCBtYXhBZ2UpIHtcbiAgICBpZiAodGhpcy5sb2NhbCkge1xuICAgICAgaWYgKG1heEFnZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmICgodHlwZW9mIHRoaXMucmVtb3RlID09PSAnb2JqZWN0JykgJiZcbiAgICAgICAgICAgICB0aGlzLnJlbW90ZS5jb25uZWN0ZWQgJiYgdGhpcy5yZW1vdGUub25saW5lKSB7XG4gICAgICAgICAgbWF4QWdlID0gMip0aGlzLmdldFN5bmNJbnRlcnZhbCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGxvZygnTm90IHNldHRpbmcgZGVmYXVsdCBtYXhBZ2UsIGJlY2F1c2UgcmVtb3RlIGlzIG9mZmxpbmUgb3Igbm90IGNvbm5lY3RlZCcpO1xuICAgICAgICAgIG1heEFnZSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB2YXIgbWF4QWdlSW52YWxpZCA9IGZ1bmN0aW9uIChtYXhBZ2UpIHtcbiAgICAgICAgcmV0dXJuIG1heEFnZSAhPT0gZmFsc2UgJiYgdHlwZW9mKG1heEFnZSkgIT09ICdudW1iZXInO1xuICAgICAgfTtcblxuICAgICAgaWYgKG1heEFnZUludmFsaWQobWF4QWdlKSkge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoJ0FyZ3VtZW50IFxcJ21heEFnZVxcJyBtdXN0IGJlIGZhbHNlIG9yIGEgbnVtYmVyJyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5sb2NhbC5nZXQocGF0aCwgbWF4QWdlLCB0aGlzLnN5bmMucXVldWVHZXRSZXF1ZXN0LmJpbmQodGhpcy5zeW5jKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLnJlbW90ZS5nZXQocGF0aCk7XG4gICAgfVxuICB9LFxuXG4gIHB1dDogZnVuY3Rpb24gKHBhdGgsIGJvZHksIGNvbnRlbnRUeXBlKSB7XG4gICAgaWYgKHNoYXJlRmlyc3QuYmluZCh0aGlzKShwYXRoKSkge1xuICAgICAgcmV0dXJuIFN5bmNlZEdldFB1dERlbGV0ZS5fd3JhcEJ1c3lEb25lLmNhbGwodGhpcywgdGhpcy5yZW1vdGUucHV0KHBhdGgsIGJvZHksIGNvbnRlbnRUeXBlKSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHRoaXMubG9jYWwpIHtcbiAgICAgIHJldHVybiB0aGlzLmxvY2FsLnB1dChwYXRoLCBib2R5LCBjb250ZW50VHlwZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBTeW5jZWRHZXRQdXREZWxldGUuX3dyYXBCdXN5RG9uZS5jYWxsKHRoaXMsIHRoaXMucmVtb3RlLnB1dChwYXRoLCBib2R5LCBjb250ZW50VHlwZSkpO1xuICAgIH1cbiAgfSxcblxuICAnZGVsZXRlJzogZnVuY3Rpb24gKHBhdGgpIHtcbiAgICBpZiAodGhpcy5sb2NhbCkge1xuICAgICAgcmV0dXJuIHRoaXMubG9jYWwuZGVsZXRlKHBhdGgpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gU3luY2VkR2V0UHV0RGVsZXRlLl93cmFwQnVzeURvbmUuY2FsbCh0aGlzLCB0aGlzLnJlbW90ZS5kZWxldGUocGF0aCkpO1xuICAgIH1cbiAgfSxcblxuICBfd3JhcEJ1c3lEb25lOiBmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHRoaXMuX2VtaXQoJ3dpcmUtYnVzeScpO1xuICAgIHJldHVybiByZXN1bHQudGhlbihmdW5jdGlvbiAocikge1xuICAgICAgc2VsZi5fZW1pdCgnd2lyZS1kb25lJywgeyBzdWNjZXNzOiB0cnVlIH0pO1xuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShyKTtcbiAgICB9LCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICBzZWxmLl9lbWl0KCd3aXJlLWRvbmUnLCB7IHN1Y2Nlc3M6IGZhbHNlIH0pO1xuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGVycik7XG4gICAgfSk7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gU3luY2VkR2V0UHV0RGVsZXRlO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL3N5bmNlZGdldHB1dGRlbGV0ZS5qcyJdLCJzb3VyY2VSb290IjoiIn0=");
},function(module,exports,__webpack_require__){eval('\'use strict\';\n\nvar tv4 = __webpack_require__(28);\nvar BaseClient = __webpack_require__(6);\n\n/**\n * Class: BaseClient.Types\n *\n * - Manages and validates types of remoteStorage objects, using JSON-LD and\n *   JSON Schema\n * - Adds schema declaration/validation methods to BaseClient instances.\n **/\nBaseClient.Types = {\n  // <alias> -> <uri>\n  uris: {},\n  // <uri> -> <schema>\n  schemas: {},\n  // <uri> -> <alias>\n  aliases: {},\n\n  declare: function declare(moduleName, alias, uri, schema) {\n    var fullAlias = moduleName + \'/\' + alias;\n\n    if (schema.extends) {\n      var extendedAlias;\n      var parts = schema.extends.split(\'/\');\n      if (parts.length === 1) {\n        extendedAlias = moduleName + \'/\' + parts.shift();\n      } else {\n        extendedAlias = parts.join(\'/\');\n      }\n      var extendedUri = this.uris[extendedAlias];\n      if (!extendedUri) {\n        throw "Type \'" + fullAlias + "\' tries to extend unknown schema \'" + extendedAlias + "\'";\n      }\n      schema.extends = this.schemas[extendedUri];\n    }\n\n    this.uris[fullAlias] = uri;\n    this.aliases[uri] = fullAlias;\n    this.schemas[uri] = schema;\n  },\n\n  resolveAlias: function resolveAlias(alias) {\n    return this.uris[alias];\n  },\n\n  getSchema: function getSchema(uri) {\n    return this.schemas[uri];\n  },\n\n  inScope: function inScope(moduleName) {\n    var ml = moduleName.length;\n    var schemas = {};\n    for (var alias in this.uris) {\n      if (alias.substr(0, ml + 1) === moduleName + \'/\') {\n        var uri = this.uris[alias];\n        schemas[uri] = this.schemas[uri];\n      }\n    }\n    return schemas;\n  }\n};\n\nvar SchemaNotFound = function SchemaNotFound(uri) {\n  var error = new Error("Schema not found: " + uri);\n  error.name = "SchemaNotFound";\n  return error;\n};\n\nSchemaNotFound.prototype = Error.prototype;\n\nBaseClient.Types.SchemaNotFound = SchemaNotFound;\n\n/**\n * Class: BaseClient\n **/\nBaseClient.prototype.extend({\n  /**\n   * Method: declareType\n   *\n   * Declare a remoteStorage object type using a JSON schema.\n   *\n   * Parameters:\n   *   alias  - A type alias/shortname\n   *   uri    - (optional) JSON-LD URI of the schema. Automatically generated if none given\n   *   schema - A JSON Schema object describing the object type\n   *\n   * Example:\n   *\n   * (start code)\n   * client.declareType(\'todo-item\', {\n   *   "type": "object",\n   *   "properties": {\n   *     "id": {\n   *       "type": "string"\n   *     },\n   *     "title": {\n   *       "type": "string"\n   *     },\n   *     "finished": {\n   *       "type": "boolean"\n   *       "default": false\n   *     },\n   *     "createdAt": {\n   *       "type": "date"\n   *     }\n   *   },\n   *   "required": ["id", "title"]\n   * })\n   * (end code)\n   *\n   * Visit <http://json-schema.org> for details on how to use JSON Schema.\n   **/\n  declareType: function declareType(alias, uri, schema) {\n    if (!schema) {\n      schema = uri;\n      uri = this._defaultTypeURI(alias);\n    }\n    BaseClient.Types.declare(this.moduleName, alias, uri, schema);\n  },\n\n  /**\n   * Method: validate\n   *\n   * Validate an object against the associated schema.\n   *\n   * Parameters:\n   *  object - Object to validate. Must have a @context property.\n   *\n   * Returns:\n   *   An object containing information about validation errors\n   **/\n  validate: function validate(object) {\n    var schema = BaseClient.Types.getSchema(object[\'@context\']);\n    if (schema) {\n      return tv4.validateResult(object, schema);\n    } else {\n      throw new SchemaNotFound(object[\'@context\']);\n    }\n  },\n\n  _defaultTypeURI: function _defaultTypeURI(alias) {\n    return \'http://remotestorage.io/spec/modules/\' + encodeURIComponent(this.moduleName) + \'/\' + encodeURIComponent(alias);\n  },\n\n  _attachType: function _attachType(object, alias) {\n    object[\'@context\'] = BaseClient.Types.resolveAlias(this.moduleName + \'/\' + alias) || this._defaultTypeURI(alias);\n  }\n});\n\n// Documented in baseclient.js\nObject.defineProperty(BaseClient.prototype, \'schemas\', {\n  configurable: true,\n  get: function get() {\n    return BaseClient.Types.inScope(this.moduleName);\n  }\n});\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvdHlwZXMuanM/ODlhOCJdLCJuYW1lcyI6WyJ0djQiLCJyZXF1aXJlIiwiQmFzZUNsaWVudCIsIlR5cGVzIiwidXJpcyIsInNjaGVtYXMiLCJhbGlhc2VzIiwiZGVjbGFyZSIsIm1vZHVsZU5hbWUiLCJhbGlhcyIsInVyaSIsInNjaGVtYSIsImZ1bGxBbGlhcyIsImV4dGVuZHMiLCJleHRlbmRlZEFsaWFzIiwicGFydHMiLCJzcGxpdCIsImxlbmd0aCIsInNoaWZ0Iiwiam9pbiIsImV4dGVuZGVkVXJpIiwicmVzb2x2ZUFsaWFzIiwiZ2V0U2NoZW1hIiwiaW5TY29wZSIsIm1sIiwic3Vic3RyIiwiU2NoZW1hTm90Rm91bmQiLCJlcnJvciIsIkVycm9yIiwibmFtZSIsInByb3RvdHlwZSIsImV4dGVuZCIsImRlY2xhcmVUeXBlIiwiX2RlZmF1bHRUeXBlVVJJIiwidmFsaWRhdGUiLCJvYmplY3QiLCJ2YWxpZGF0ZVJlc3VsdCIsImVuY29kZVVSSUNvbXBvbmVudCIsIl9hdHRhY2hUeXBlIiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJjb25maWd1cmFibGUiLCJnZXQiXSwibWFwcGluZ3MiOiI7O0FBQUUsSUFBSUEsTUFBTSxtQkFBQUMsQ0FBUSxFQUFSLENBQVY7QUFDQSxJQUFJQyxhQUFhLG1CQUFBRCxDQUFRLENBQVIsQ0FBakI7O0FBRUE7Ozs7Ozs7QUFPQUMsV0FBV0MsS0FBWCxHQUFtQjtBQUNqQjtBQUNBQyxRQUFNLEVBRlc7QUFHakI7QUFDQUMsV0FBUyxFQUpRO0FBS2pCO0FBQ0FDLFdBQVMsRUFOUTs7QUFRakJDLFdBQVMsaUJBQVNDLFVBQVQsRUFBcUJDLEtBQXJCLEVBQTRCQyxHQUE1QixFQUFpQ0MsTUFBakMsRUFBeUM7QUFDaEQsUUFBSUMsWUFBWUosYUFBYSxHQUFiLEdBQW1CQyxLQUFuQzs7QUFFQSxRQUFJRSxPQUFPRSxPQUFYLEVBQW9CO0FBQ2xCLFVBQUlDLGFBQUo7QUFDQSxVQUFJQyxRQUFRSixP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Q0QsS0FGRCxNQUVPO0FBQ0wsWUFBTSxJQUFJZSxjQUFKLENBQW1CUyxPQUFPLFVBQVAsQ0FBbkIsQ0FBTjtBQUNEO0FBQ0YsR0EvRHlCOztBQWlFMUJGLG1CQUFpQix5QkFBU3hCLEtBQVQsRUFBZ0I7QUFDL0IsV0FBTywwQ0FBMEM0QixtQkFBbUIsS0FBSzdCLFVBQXhCLENBQTFDLEdBQWdGLEdBQWhGLEdBQXNGNkIsbUJBQW1CNUIsS0FBbkIsQ0FBN0Y7QUFDRCxHQW5FeUI7O0FBcUUxQjZCLGVBQWEscUJBQVNILE1BQVQsRUFBaUIxQixLQUFqQixFQUF3QjtBQUNuQzBCLFdBQU8sVUFBUCxJQUFxQmpDLFdBQVdDLEtBQVgsQ0FBaUJrQixZQUFqQixDQUE4QixLQUFLYixVQUFMLEdBQWtCLEdBQWxCLEdBQXdCQyxLQUF0RCxLQUFnRSxLQUFLd0IsZUFBTCxDQUFxQnhCLEtBQXJCLENBQXJGO0FBQ0Q7QUF2RXlCLENBQTVCOztBQTBFQTtBQUNBOEIsT0FBT0MsY0FBUCxDQUFzQnRDLFdBQVc0QixTQUFqQyxFQUE0QyxTQUE1QyxFQUF1RDtBQUNyRFcsZ0JBQWMsSUFEdUM7QUFFckRDLE9BQUssZUFBVztBQUNkLFdBQU94QyxXQUFXQyxLQUFYLENBQWlCb0IsT0FBakIsQ0FBeUIsS0FBS2YsVUFBOUIsQ0FBUDtBQUNEO0FBSm9ELENBQXZEIiwiZmlsZSI6IjIzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiICB2YXIgdHY0ID0gcmVxdWlyZSgndHY0Jyk7XG4gIHZhciBCYXNlQ2xpZW50ID0gcmVxdWlyZSgnLi9iYXNlY2xpZW50Jyk7XG5cbiAgLyoqXG4gICAqIENsYXNzOiBCYXNlQ2xpZW50LlR5cGVzXG4gICAqXG4gICAqIC0gTWFuYWdlcyBhbmQgdmFsaWRhdGVzIHR5cGVzIG9mIHJlbW90ZVN0b3JhZ2Ugb2JqZWN0cywgdXNpbmcgSlNPTi1MRCBhbmRcbiAgICogICBKU09OIFNjaGVtYVxuICAgKiAtIEFkZHMgc2NoZW1hIGRlY2xhcmF0aW9uL3ZhbGlkYXRpb24gbWV0aG9kcyB0byBCYXNlQ2xpZW50IGluc3RhbmNlcy5cbiAgICoqL1xuICBCYXNlQ2xpZW50LlR5cGVzID0ge1xuICAgIC8vIDxhbGlhcz4gLT4gPHVyaT5cbiAgICB1cmlzOiB7fSxcbiAgICAvLyA8dXJpPiAtPiA8c2NoZW1hPlxuICAgIHNjaGVtYXM6IHt9LFxuICAgIC8vIDx1cmk+IC0+IDxhbGlhcz5cbiAgICBhbGlhc2VzOiB7fSxcblxuICAgIGRlY2xhcmU6IGZ1bmN0aW9uKG1vZHVsZU5hbWUsIGFsaWFzLCB1cmksIHNjaGVtYSkge1xuICAgICAgdmFyIGZ1bGxBbGlhcyA9IG1vZHVsZU5hbWUgKyAnLycgKyBhbGlhcztcblxuICAgICAgaWYgKHNjaGVtYS5leHRlbmRzKSB7XG4gICAgICAgIHZhciBleHRlbmRlZEFsaWFzO1xuICAgICAgICB2YXIgcGFydHMgPSBzY2hlbWEuZXh0ZW5kcy5zcGxpdCgnLycpO1xuICAgICAgICBpZiAocGFydHMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgZXh0ZW5kZWRBbGlhcyA9IG1vZHVsZU5hbWUgKyAnLycgKyBwYXJ0cy5zaGlmdCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGV4dGVuZGVkQWxpYXMgPSBwYXJ0cy5qb2luKCcvJyk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGV4dGVuZGVkVXJpID0gdGhpcy51cmlzW2V4dGVuZGVkQWxpYXNdO1xuICAgICAgICBpZiAoISBleHRlbmRlZFVyaSkge1xuICAgICAgICAgIHRocm93IFwiVHlwZSAnXCIgKyBmdWxsQWxpYXMgKyBcIicgdHJpZXMgdG8gZXh0ZW5kIHVua25vd24gc2NoZW1hICdcIiArIGV4dGVuZGVkQWxpYXMgKyBcIidcIjtcbiAgICAgICAgfVxuICAgICAgICBzY2hlbWEuZXh0ZW5kcyA9IHRoaXMuc2NoZW1hc1tleHRlbmRlZFVyaV07XG4gICAgICB9XG5cbiAgICAgIHRoaXMudXJpc1tmdWxsQWxpYXNdID0gdXJpO1xuICAgICAgdGhpcy5hbGlhc2VzW3VyaV0gPSBmdWxsQWxpYXM7XG4gICAgICB0aGlzLnNjaGVtYXNbdXJpXSA9IHNjaGVtYTtcbiAgICB9LFxuXG4gICAgcmVzb2x2ZUFsaWFzOiBmdW5jdGlvbihhbGlhcykge1xuICAgICAgcmV0dXJuIHRoaXMudXJpc1thbGlhc107XG4gICAgfSxcblxuICAgIGdldFNjaGVtYTogZnVuY3Rpb24odXJpKSB7XG4gICAgICByZXR1cm4gdGhpcy5zY2hlbWFzW3VyaV07XG4gICAgfSxcblxuICAgIGluU2NvcGU6IGZ1bmN0aW9uKG1vZHVsZU5hbWUpIHtcbiAgICAgIHZhciBtbCA9IG1vZHVsZU5hbWUubGVuZ3RoO1xuICAgICAgdmFyIHNjaGVtYXMgPSB7fTtcbiAgICAgIGZvciAodmFyIGFsaWFzIGluIHRoaXMudXJpcykge1xuICAgICAgICBpZiAoYWxpYXMuc3Vic3RyKDAsIG1sICsgMSkgPT09IG1vZHVsZU5hbWUgKyAnLycpIHtcbiAgICAgICAgICB2YXIgdXJpID0gdGhpcy51cmlzW2FsaWFzXTtcbiAgICAgICAgICBzY2hlbWFzW3VyaV0gPSB0aGlzLnNjaGVtYXNbdXJpXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHNjaGVtYXM7XG4gICAgfVxuICB9O1xuXG4gIHZhciBTY2hlbWFOb3RGb3VuZCA9IGZ1bmN0aW9uKHVyaSkge1xuICAgIHZhciBlcnJvciA9IG5ldyBFcnJvcihcIlNjaGVtYSBub3QgZm91bmQ6IFwiICsgdXJpKTtcbiAgICBlcnJvci5uYW1lID0gXCJTY2hlbWFOb3RGb3VuZFwiO1xuICAgIHJldHVybiBlcnJvcjtcbiAgfTtcblxuICBTY2hlbWFOb3RGb3VuZC5wcm90b3R5cGUgPSBFcnJvci5wcm90b3R5cGU7XG5cbiAgQmFzZUNsaWVudC5UeXBlcy5TY2hlbWFOb3RGb3VuZCA9IFNjaGVtYU5vdEZvdW5kO1xuXG4gIC8qKlxuICAgKiBDbGFzczogQmFzZUNsaWVudFxuICAgKiovXG4gIEJhc2VDbGllbnQucHJvdG90eXBlLmV4dGVuZCh7XG4gICAgLyoqXG4gICAgICogTWV0aG9kOiBkZWNsYXJlVHlwZVxuICAgICAqXG4gICAgICogRGVjbGFyZSBhIHJlbW90ZVN0b3JhZ2Ugb2JqZWN0IHR5cGUgdXNpbmcgYSBKU09OIHNjaGVtYS5cbiAgICAgKlxuICAgICAqIFBhcmFtZXRlcnM6XG4gICAgICogICBhbGlhcyAgLSBBIHR5cGUgYWxpYXMvc2hvcnRuYW1lXG4gICAgICogICB1cmkgICAgLSAob3B0aW9uYWwpIEpTT04tTEQgVVJJIG9mIHRoZSBzY2hlbWEuIEF1dG9tYXRpY2FsbHkgZ2VuZXJhdGVkIGlmIG5vbmUgZ2l2ZW5cbiAgICAgKiAgIHNjaGVtYSAtIEEgSlNPTiBTY2hlbWEgb2JqZWN0IGRlc2NyaWJpbmcgdGhlIG9iamVjdCB0eXBlXG4gICAgICpcbiAgICAgKiBFeGFtcGxlOlxuICAgICAqXG4gICAgICogKHN0YXJ0IGNvZGUpXG4gICAgICogY2xpZW50LmRlY2xhcmVUeXBlKCd0b2RvLWl0ZW0nLCB7XG4gICAgICogICBcInR5cGVcIjogXCJvYmplY3RcIixcbiAgICAgKiAgIFwicHJvcGVydGllc1wiOiB7XG4gICAgICogICAgIFwiaWRcIjoge1xuICAgICAqICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiXG4gICAgICogICAgIH0sXG4gICAgICogICAgIFwidGl0bGVcIjoge1xuICAgICAqICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiXG4gICAgICogICAgIH0sXG4gICAgICogICAgIFwiZmluaXNoZWRcIjoge1xuICAgICAqICAgICAgIFwidHlwZVwiOiBcImJvb2xlYW5cIlxuICAgICAqICAgICAgIFwiZGVmYXVsdFwiOiBmYWxzZVxuICAgICAqICAgICB9LFxuICAgICAqICAgICBcImNyZWF0ZWRBdFwiOiB7XG4gICAgICogICAgICAgXCJ0eXBlXCI6IFwiZGF0ZVwiXG4gICAgICogICAgIH1cbiAgICAgKiAgIH0sXG4gICAgICogICBcInJlcXVpcmVkXCI6IFtcImlkXCIsIFwidGl0bGVcIl1cbiAgICAgKiB9KVxuICAgICAqIChlbmQgY29kZSlcbiAgICAgKlxuICAgICAqIFZpc2l0IDxodHRwOi8vanNvbi1zY2hlbWEub3JnPiBmb3IgZGV0YWlscyBvbiBob3cgdG8gdXNlIEpTT04gU2NoZW1hLlxuICAgICAqKi9cbiAgICBkZWNsYXJlVHlwZTogZnVuY3Rpb24oYWxpYXMsIHVyaSwgc2NoZW1hKSB7XG4gICAgICBpZiAoISBzY2hlbWEpIHtcbiAgICAgICAgc2NoZW1hID0gdXJpO1xuICAgICAgICB1cmkgPSB0aGlzLl9kZWZhdWx0VHlwZVVSSShhbGlhcyk7XG4gICAgICB9XG4gICAgICBCYXNlQ2xpZW50LlR5cGVzLmRlY2xhcmUodGhpcy5tb2R1bGVOYW1lLCBhbGlhcywgdXJpLCBzY2hlbWEpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNZXRob2Q6IHZhbGlkYXRlXG4gICAgICpcbiAgICAgKiBWYWxpZGF0ZSBhbiBvYmplY3QgYWdhaW5zdCB0aGUgYXNzb2NpYXRlZCBzY2hlbWEuXG4gICAgICpcbiAgICAgKiBQYXJhbWV0ZXJzOlxuICAgICAqICBvYmplY3QgLSBPYmplY3QgdG8gdmFsaWRhdGUuIE11c3QgaGF2ZSBhIEBjb250ZXh0IHByb3BlcnR5LlxuICAgICAqXG4gICAgICogUmV0dXJuczpcbiAgICAgKiAgIEFuIG9iamVjdCBjb250YWluaW5nIGluZm9ybWF0aW9uIGFib3V0IHZhbGlkYXRpb24gZXJyb3JzXG4gICAgICoqL1xuICAgIHZhbGlkYXRlOiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICAgIHZhciBzY2hlbWEgPSBCYXNlQ2xpZW50LlR5cGVzLmdldFNjaGVtYShvYmplY3RbJ0Bjb250ZXh0J10pO1xuICAgICAgaWYgKHNjaGVtYSkge1xuICAgICAgICByZXR1cm4gdHY0LnZhbGlkYXRlUmVzdWx0KG9iamVjdCwgc2NoZW1hKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBTY2hlbWFOb3RGb3VuZChvYmplY3RbJ0Bjb250ZXh0J10pO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBfZGVmYXVsdFR5cGVVUkk6IGZ1bmN0aW9uKGFsaWFzKSB7XG4gICAgICByZXR1cm4gJ2h0dHA6Ly9yZW1vdGVzdG9yYWdlLmlvL3NwZWMvbW9kdWxlcy8nICsgZW5jb2RlVVJJQ29tcG9uZW50KHRoaXMubW9kdWxlTmFtZSkgKyAnLycgKyBlbmNvZGVVUklDb21wb25lbnQoYWxpYXMpO1xuICAgIH0sXG5cbiAgICBfYXR0YWNoVHlwZTogZnVuY3Rpb24ob2JqZWN0LCBhbGlhcykge1xuICAgICAgb2JqZWN0WydAY29udGV4dCddID0gQmFzZUNsaWVudC5UeXBlcy5yZXNvbHZlQWxpYXModGhpcy5tb2R1bGVOYW1lICsgJy8nICsgYWxpYXMpIHx8IHRoaXMuX2RlZmF1bHRUeXBlVVJJKGFsaWFzKTtcbiAgICB9XG4gIH0pO1xuXG4gIC8vIERvY3VtZW50ZWQgaW4gYmFzZWNsaWVudC5qc1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQmFzZUNsaWVudC5wcm90b3R5cGUsICdzY2hlbWFzJywge1xuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIEJhc2VDbGllbnQuVHlwZXMuaW5TY29wZSh0aGlzLm1vZHVsZU5hbWUpO1xuICAgIH1cbiAgfSk7XG5cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy90eXBlcy5qcyJdLCJzb3VyY2VSb290IjoiIn0=')},function(module,exports){eval("'use strict'\n\nexports.byteLength = byteLength\nexports.toByteArray = toByteArray\nexports.fromByteArray = fromByteArray\n\nvar lookup = []\nvar revLookup = []\nvar Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array\n\nvar code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\nfor (var i = 0, len = code.length; i < len; ++i) {\n  lookup[i] = code[i]\n  revLookup[code.charCodeAt(i)] = i\n}\n\nrevLookup['-'.charCodeAt(0)] = 62\nrevLookup['_'.charCodeAt(0)] = 63\n\nfunction placeHoldersCount (b64) {\n  var len = b64.length\n  if (len % 4 > 0) {\n    throw new Error('Invalid string. Length must be a multiple of 4')\n  }\n\n  // the number of equal signs (place holders)\n  // if there are two placeholders, than the two characters before it\n  // represent one byte\n  // if there is only one, then the three characters before it represent 2 bytes\n  // this is just a cheap hack to not do indexOf twice\n  return b64[len - 2] === '=' ? 2 : b64[len - 1] === '=' ? 1 : 0\n}\n\nfunction byteLength (b64) {\n  // base64 is 4/3 + up to two characters of the original data\n  return b64.length * 3 / 4 - placeHoldersCount(b64)\n}\n\nfunction toByteArray (b64) {\n  var i, j, l, tmp, placeHolders, arr\n  var len = b64.length\n  placeHolders = placeHoldersCount(b64)\n\n  arr = new Arr(len * 3 / 4 - placeHolders)\n\n  // if there are placeholders, only get up to the last complete 4 chars\n  l = placeHolders > 0 ? len - 4 : len\n\n  var L = 0\n\n  for (i = 0, j = 0; i < l; i += 4, j += 3) {\n    tmp = (revLookup[b64.charCodeAt(i)] << 18) | (revLookup[b64.charCodeAt(i + 1)] << 12) | (revLookup[b64.charCodeAt(i + 2)] << 6) | revLookup[b64.charCodeAt(i + 3)]\n    arr[L++] = (tmp >> 16) & 0xFF\n    arr[L++] = (tmp >> 8) & 0xFF\n    arr[L++] = tmp & 0xFF\n  }\n\n  if (placeHolders === 2) {\n    tmp = (revLookup[b64.charCodeAt(i)] << 2) | (revLookup[b64.charCodeAt(i + 1)] >> 4)\n    arr[L++] = tmp & 0xFF\n  } else if (placeHolders === 1) {\n    tmp = (revLookup[b64.charCodeAt(i)] << 10) | (revLookup[b64.charCodeAt(i + 1)] << 4) | (revLookup[b64.charCodeAt(i + 2)] >> 2)\n    arr[L++] = (tmp >> 8) & 0xFF\n    arr[L++] = tmp & 0xFF\n  }\n\n  return arr\n}\n\nfunction tripletToBase64 (num) {\n  return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F]\n}\n\nfunction encodeChunk (uint8, start, end) {\n  var tmp\n  var output = []\n  for (var i = start; i < end; i += 3) {\n    tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])\n    output.push(tripletToBase64(tmp))\n  }\n  return output.join('')\n}\n\nfunction fromByteArray (uint8) {\n  var tmp\n  var len = uint8.length\n  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes\n  var output = ''\n  var parts = []\n  var maxChunkLength = 16383 // must be multiple of 3\n\n  // go through the array every three bytes, we'll deal with trailing stuff later\n  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\n    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))\n  }\n\n  // pad the end with zeros, but make sure to not forget the extra bytes\n  if (extraBytes === 1) {\n    tmp = uint8[len - 1]\n    output += lookup[tmp >> 2]\n    output += lookup[(tmp << 4) & 0x3F]\n    output += '=='\n  } else if (extraBytes === 2) {\n    tmp = (uint8[len - 2] << 8) + (uint8[len - 1])\n    output += lookup[tmp >> 10]\n    output += lookup[(tmp >> 4) & 0x3F]\n    output += lookup[(tmp << 2) & 0x3F]\n    output += '='\n  }\n\n  parts.push(output)\n\n  return parts.join('')\n}\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2Jhc2U2NC1qcy9pbmRleC5qcz8yYWRkIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQ0FBa0MsU0FBUztBQUMzQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsb0JBQW9CLE9BQU87QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLFNBQVM7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDBDQUEwQyxVQUFVO0FBQ3BEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBIiwiZmlsZSI6IjI0LmpzIiwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbmV4cG9ydHMuYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGhcbmV4cG9ydHMudG9CeXRlQXJyYXkgPSB0b0J5dGVBcnJheVxuZXhwb3J0cy5mcm9tQnl0ZUFycmF5ID0gZnJvbUJ5dGVBcnJheVxuXG52YXIgbG9va3VwID0gW11cbnZhciByZXZMb29rdXAgPSBbXVxudmFyIEFyciA9IHR5cGVvZiBVaW50OEFycmF5ICE9PSAndW5kZWZpbmVkJyA/IFVpbnQ4QXJyYXkgOiBBcnJheVxuXG52YXIgY29kZSA9ICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvJ1xuZm9yICh2YXIgaSA9IDAsIGxlbiA9IGNvZGUubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgbG9va3VwW2ldID0gY29kZVtpXVxuICByZXZMb29rdXBbY29kZS5jaGFyQ29kZUF0KGkpXSA9IGlcbn1cblxucmV2TG9va3VwWyctJy5jaGFyQ29kZUF0KDApXSA9IDYyXG5yZXZMb29rdXBbJ18nLmNoYXJDb2RlQXQoMCldID0gNjNcblxuZnVuY3Rpb24gcGxhY2VIb2xkZXJzQ291bnQgKGI2NCkge1xuICB2YXIgbGVuID0gYjY0Lmxlbmd0aFxuICBpZiAobGVuICUgNCA+IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc3RyaW5nLiBMZW5ndGggbXVzdCBiZSBhIG11bHRpcGxlIG9mIDQnKVxuICB9XG5cbiAgLy8gdGhlIG51bWJlciBvZiBlcXVhbCBzaWducyAocGxhY2UgaG9sZGVycylcbiAgLy8gaWYgdGhlcmUgYXJlIHR3byBwbGFjZWhvbGRlcnMsIHRoYW4gdGhlIHR3byBjaGFyYWN0ZXJzIGJlZm9yZSBpdFxuICAvLyByZXByZXNlbnQgb25lIGJ5dGVcbiAgLy8gaWYgdGhlcmUgaXMgb25seSBvbmUsIHRoZW4gdGhlIHRocmVlIGNoYXJhY3RlcnMgYmVmb3JlIGl0IHJlcHJlc2VudCAyIGJ5dGVzXG4gIC8vIHRoaXMgaXMganVzdCBhIGNoZWFwIGhhY2sgdG8gbm90IGRvIGluZGV4T2YgdHdpY2VcbiAgcmV0dXJuIGI2NFtsZW4gLSAyXSA9PT0gJz0nID8gMiA6IGI2NFtsZW4gLSAxXSA9PT0gJz0nID8gMSA6IDBcbn1cblxuZnVuY3Rpb24gYnl0ZUxlbmd0aCAoYjY0KSB7XG4gIC8vIGJhc2U2NCBpcyA0LzMgKyB1cCB0byB0d28gY2hhcmFjdGVycyBvZiB0aGUgb3JpZ2luYWwgZGF0YVxuICByZXR1cm4gYjY0Lmxlbmd0aCAqIDMgLyA0IC0gcGxhY2VIb2xkZXJzQ291bnQoYjY0KVxufVxuXG5mdW5jdGlvbiB0b0J5dGVBcnJheSAoYjY0KSB7XG4gIHZhciBpLCBqLCBsLCB0bXAsIHBsYWNlSG9sZGVycywgYXJyXG4gIHZhciBsZW4gPSBiNjQubGVuZ3RoXG4gIHBsYWNlSG9sZGVycyA9IHBsYWNlSG9sZGVyc0NvdW50KGI2NClcblxuICBhcnIgPSBuZXcgQXJyKGxlbiAqIDMgLyA0IC0gcGxhY2VIb2xkZXJzKVxuXG4gIC8vIGlmIHRoZXJlIGFyZSBwbGFjZWhvbGRlcnMsIG9ubHkgZ2V0IHVwIHRvIHRoZSBsYXN0IGNvbXBsZXRlIDQgY2hhcnNcbiAgbCA9IHBsYWNlSG9sZGVycyA+IDAgPyBsZW4gLSA0IDogbGVuXG5cbiAgdmFyIEwgPSAwXG5cbiAgZm9yIChpID0gMCwgaiA9IDA7IGkgPCBsOyBpICs9IDQsIGogKz0gMykge1xuICAgIHRtcCA9IChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSldIDw8IDE4KSB8IChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDEpXSA8PCAxMikgfCAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAyKV0gPDwgNikgfCByZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDMpXVxuICAgIGFycltMKytdID0gKHRtcCA+PiAxNikgJiAweEZGXG4gICAgYXJyW0wrK10gPSAodG1wID4+IDgpICYgMHhGRlxuICAgIGFycltMKytdID0gdG1wICYgMHhGRlxuICB9XG5cbiAgaWYgKHBsYWNlSG9sZGVycyA9PT0gMikge1xuICAgIHRtcCA9IChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSldIDw8IDIpIHwgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMSldID4+IDQpXG4gICAgYXJyW0wrK10gPSB0bXAgJiAweEZGXG4gIH0gZWxzZSBpZiAocGxhY2VIb2xkZXJzID09PSAxKSB7XG4gICAgdG1wID0gKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpKV0gPDwgMTApIHwgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMSldIDw8IDQpIHwgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMildID4+IDIpXG4gICAgYXJyW0wrK10gPSAodG1wID4+IDgpICYgMHhGRlxuICAgIGFycltMKytdID0gdG1wICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIGFyclxufVxuXG5mdW5jdGlvbiB0cmlwbGV0VG9CYXNlNjQgKG51bSkge1xuICByZXR1cm4gbG9va3VwW251bSA+PiAxOCAmIDB4M0ZdICsgbG9va3VwW251bSA+PiAxMiAmIDB4M0ZdICsgbG9va3VwW251bSA+PiA2ICYgMHgzRl0gKyBsb29rdXBbbnVtICYgMHgzRl1cbn1cblxuZnVuY3Rpb24gZW5jb2RlQ2h1bmsgKHVpbnQ4LCBzdGFydCwgZW5kKSB7XG4gIHZhciB0bXBcbiAgdmFyIG91dHB1dCA9IFtdXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgaSArPSAzKSB7XG4gICAgdG1wID0gKHVpbnQ4W2ldIDw8IDE2KSArICh1aW50OFtpICsgMV0gPDwgOCkgKyAodWludDhbaSArIDJdKVxuICAgIG91dHB1dC5wdXNoKHRyaXBsZXRUb0Jhc2U2NCh0bXApKVxuICB9XG4gIHJldHVybiBvdXRwdXQuam9pbignJylcbn1cblxuZnVuY3Rpb24gZnJvbUJ5dGVBcnJheSAodWludDgpIHtcbiAgdmFyIHRtcFxuICB2YXIgbGVuID0gdWludDgubGVuZ3RoXG4gIHZhciBleHRyYUJ5dGVzID0gbGVuICUgMyAvLyBpZiB3ZSBoYXZlIDEgYnl0ZSBsZWZ0LCBwYWQgMiBieXRlc1xuICB2YXIgb3V0cHV0ID0gJydcbiAgdmFyIHBhcnRzID0gW11cbiAgdmFyIG1heENodW5rTGVuZ3RoID0gMTYzODMgLy8gbXVzdCBiZSBtdWx0aXBsZSBvZiAzXG5cbiAgLy8gZ28gdGhyb3VnaCB0aGUgYXJyYXkgZXZlcnkgdGhyZWUgYnl0ZXMsIHdlJ2xsIGRlYWwgd2l0aCB0cmFpbGluZyBzdHVmZiBsYXRlclxuICBmb3IgKHZhciBpID0gMCwgbGVuMiA9IGxlbiAtIGV4dHJhQnl0ZXM7IGkgPCBsZW4yOyBpICs9IG1heENodW5rTGVuZ3RoKSB7XG4gICAgcGFydHMucHVzaChlbmNvZGVDaHVuayh1aW50OCwgaSwgKGkgKyBtYXhDaHVua0xlbmd0aCkgPiBsZW4yID8gbGVuMiA6IChpICsgbWF4Q2h1bmtMZW5ndGgpKSlcbiAgfVxuXG4gIC8vIHBhZCB0aGUgZW5kIHdpdGggemVyb3MsIGJ1dCBtYWtlIHN1cmUgdG8gbm90IGZvcmdldCB0aGUgZXh0cmEgYnl0ZXNcbiAgaWYgKGV4dHJhQnl0ZXMgPT09IDEpIHtcbiAgICB0bXAgPSB1aW50OFtsZW4gLSAxXVxuICAgIG91dHB1dCArPSBsb29rdXBbdG1wID4+IDJdXG4gICAgb3V0cHV0ICs9IGxvb2t1cFsodG1wIDw8IDQpICYgMHgzRl1cbiAgICBvdXRwdXQgKz0gJz09J1xuICB9IGVsc2UgaWYgKGV4dHJhQnl0ZXMgPT09IDIpIHtcbiAgICB0bXAgPSAodWludDhbbGVuIC0gMl0gPDwgOCkgKyAodWludDhbbGVuIC0gMV0pXG4gICAgb3V0cHV0ICs9IGxvb2t1cFt0bXAgPj4gMTBdXG4gICAgb3V0cHV0ICs9IGxvb2t1cFsodG1wID4+IDQpICYgMHgzRl1cbiAgICBvdXRwdXQgKz0gbG9va3VwWyh0bXAgPDwgMikgJiAweDNGXVxuICAgIG91dHB1dCArPSAnPSdcbiAgfVxuXG4gIHBhcnRzLnB1c2gob3V0cHV0KVxuXG4gIHJldHVybiBwYXJ0cy5qb2luKCcnKVxufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2Jhc2U2NC1qcy9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gMjRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==")},function(module,exports,__webpack_require__){eval("/* WEBPACK VAR INJECTION */(function(global) {/*!\n * The buffer module from node.js, for the browser.\n *\n * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>\n * @license  MIT\n */\n/* eslint-disable no-proto */\n\n'use strict'\n\nvar base64 = __webpack_require__(24)\nvar ieee754 = __webpack_require__(26)\nvar isArray = __webpack_require__(27)\n\nexports.Buffer = Buffer\nexports.SlowBuffer = SlowBuffer\nexports.INSPECT_MAX_BYTES = 50\n\n/**\n * If `Buffer.TYPED_ARRAY_SUPPORT`:\n *   === true    Use Uint8Array implementation (fastest)\n *   === false   Use Object implementation (most compatible, even IE6)\n *\n * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,\n * Opera 11.6+, iOS 4.2+.\n *\n * Due to various browser bugs, sometimes the Object implementation will be used even\n * when the browser supports typed arrays.\n *\n * Note:\n *\n *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,\n *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.\n *\n *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.\n *\n *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of\n *     incorrect length in some situations.\n\n * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they\n * get the Object implementation, which is slower but behaves correctly.\n */\nBuffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined\n  ? global.TYPED_ARRAY_SUPPORT\n  : typedArraySupport()\n\n/*\n * Export kMaxLength after typed array support is determined.\n */\nexports.kMaxLength = kMaxLength()\n\nfunction typedArraySupport () {\n  try {\n    var arr = new Uint8Array(1)\n    arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}\n    return arr.foo() === 42 && // typed array instances can be augmented\n        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`\n        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`\n  } catch (e) {\n    return false\n  }\n}\n\nfunction kMaxLength () {\n  return Buffer.TYPED_ARRAY_SUPPORT\n    ? 0x7fffffff\n    : 0x3fffffff\n}\n\nfunction createBuffer (that, length) {\n  if (kMaxLength() < length) {\n    throw new RangeError('Invalid typed array length')\n  }\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    // Return an augmented `Uint8Array` instance, for best performance\n    that = new Uint8Array(length)\n    that.__proto__ = Buffer.prototype\n  } else {\n    // Fallback: Return an object instance of the Buffer class\n    if (that === null) {\n      that = new Buffer(length)\n    }\n    that.length = length\n  }\n\n  return that\n}\n\n/**\n * The Buffer constructor returns instances of `Uint8Array` that have their\n * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of\n * `Uint8Array`, so the returned instances will have all the node `Buffer` methods\n * and the `Uint8Array` methods. Square bracket notation works as expected -- it\n * returns a single octet.\n *\n * The `Uint8Array` prototype remains unmodified.\n */\n\nfunction Buffer (arg, encodingOrOffset, length) {\n  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {\n    return new Buffer(arg, encodingOrOffset, length)\n  }\n\n  // Common case.\n  if (typeof arg === 'number') {\n    if (typeof encodingOrOffset === 'string') {\n      throw new Error(\n        'If encoding is specified then the first argument must be a string'\n      )\n    }\n    return allocUnsafe(this, arg)\n  }\n  return from(this, arg, encodingOrOffset, length)\n}\n\nBuffer.poolSize = 8192 // not used by this implementation\n\n// TODO: Legacy, not needed anymore. Remove in next major version.\nBuffer._augment = function (arr) {\n  arr.__proto__ = Buffer.prototype\n  return arr\n}\n\nfunction from (that, value, encodingOrOffset, length) {\n  if (typeof value === 'number') {\n    throw new TypeError('\"value\" argument must not be a number')\n  }\n\n  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {\n    return fromArrayBuffer(that, value, encodingOrOffset, length)\n  }\n\n  if (typeof value === 'string') {\n    return fromString(that, value, encodingOrOffset)\n  }\n\n  return fromObject(that, value)\n}\n\n/**\n * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError\n * if value is a number.\n * Buffer.from(str[, encoding])\n * Buffer.from(array)\n * Buffer.from(buffer)\n * Buffer.from(arrayBuffer[, byteOffset[, length]])\n **/\nBuffer.from = function (value, encodingOrOffset, length) {\n  return from(null, value, encodingOrOffset, length)\n}\n\nif (Buffer.TYPED_ARRAY_SUPPORT) {\n  Buffer.prototype.__proto__ = Uint8Array.prototype\n  Buffer.__proto__ = Uint8Array\n  if (typeof Symbol !== 'undefined' && Symbol.species &&\n      Buffer[Symbol.species] === Buffer) {\n    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97\n    Object.defineProperty(Buffer, Symbol.species, {\n      value: null,\n      configurable: true\n    })\n  }\n}\n\nfunction assertSize (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('\"size\" argument must be a number')\n  } else if (size < 0) {\n    throw new RangeError('\"size\" argument must not be negative')\n  }\n}\n\nfunction alloc (that, size, fill, encoding) {\n  assertSize(size)\n  if (size <= 0) {\n    return createBuffer(that, size)\n  }\n  if (fill !== undefined) {\n    // Only pay attention to encoding if it's a string. This\n    // prevents accidentally sending in a number that would\n    // be interpretted as a start offset.\n    return typeof encoding === 'string'\n      ? createBuffer(that, size).fill(fill, encoding)\n      : createBuffer(that, size).fill(fill)\n  }\n  return createBuffer(that, size)\n}\n\n/**\n * Creates a new filled Buffer instance.\n * alloc(size[, fill[, encoding]])\n **/\nBuffer.alloc = function (size, fill, encoding) {\n  return alloc(null, size, fill, encoding)\n}\n\nfunction allocUnsafe (that, size) {\n  assertSize(size)\n  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) {\n    for (var i = 0; i < size; ++i) {\n      that[i] = 0\n    }\n  }\n  return that\n}\n\n/**\n * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.\n * */\nBuffer.allocUnsafe = function (size) {\n  return allocUnsafe(null, size)\n}\n/**\n * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.\n */\nBuffer.allocUnsafeSlow = function (size) {\n  return allocUnsafe(null, size)\n}\n\nfunction fromString (that, string, encoding) {\n  if (typeof encoding !== 'string' || encoding === '') {\n    encoding = 'utf8'\n  }\n\n  if (!Buffer.isEncoding(encoding)) {\n    throw new TypeError('\"encoding\" must be a valid string encoding')\n  }\n\n  var length = byteLength(string, encoding) | 0\n  that = createBuffer(that, length)\n\n  var actual = that.write(string, encoding)\n\n  if (actual !== length) {\n    // Writing a hex string, for example, that contains invalid characters will\n    // cause everything after the first invalid character to be ignored. (e.g.\n    // 'abxxcd' will be treated as 'ab')\n    that = that.slice(0, actual)\n  }\n\n  return that\n}\n\nfunction fromArrayLike (that, array) {\n  var length = array.length < 0 ? 0 : checked(array.length) | 0\n  that = createBuffer(that, length)\n  for (var i = 0; i < length; i += 1) {\n    that[i] = array[i] & 255\n  }\n  return that\n}\n\nfunction fromArrayBuffer (that, array, byteOffset, length) {\n  array.byteLength // this throws if `array` is not a valid ArrayBuffer\n\n  if (byteOffset < 0 || array.byteLength < byteOffset) {\n    throw new RangeError('\\'offset\\' is out of bounds')\n  }\n\n  if (array.byteLength < byteOffset + (length || 0)) {\n    throw new RangeError('\\'length\\' is out of bounds')\n  }\n\n  if (byteOffset === undefined && length === undefined) {\n    array = new Uint8Array(array)\n  } else if (length === undefined) {\n    array = new Uint8Array(array, byteOffset)\n  } else {\n    array = new Uint8Array(array, byteOffset, length)\n  }\n\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    // Return an augmented `Uint8Array` instance, for best performance\n    that = array\n    that.__proto__ = Buffer.prototype\n  } else {\n    // Fallback: Return an object instance of the Buffer class\n    that = fromArrayLike(that, array)\n  }\n  return that\n}\n\nfunction fromObject (that, obj) {\n  if (Buffer.isBuffer(obj)) {\n    var len = checked(obj.length) | 0\n    that = createBuffer(that, len)\n\n    if (that.length === 0) {\n      return that\n    }\n\n    obj.copy(that, 0, 0, len)\n    return that\n  }\n\n  if (obj) {\n    if ((typeof ArrayBuffer !== 'undefined' &&\n        obj.buffer instanceof ArrayBuffer) || 'length' in obj) {\n      if (typeof obj.length !== 'number' || isnan(obj.length)) {\n        return createBuffer(that, 0)\n      }\n      return fromArrayLike(that, obj)\n    }\n\n    if (obj.type === 'Buffer' && isArray(obj.data)) {\n      return fromArrayLike(that, obj.data)\n    }\n  }\n\n  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')\n}\n\nfunction checked (length) {\n  // Note: cannot use `length < kMaxLength()` here because that fails when\n  // length is NaN (which is otherwise coerced to zero.)\n  if (length >= kMaxLength()) {\n    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +\n                         'size: 0x' + kMaxLength().toString(16) + ' bytes')\n  }\n  return length | 0\n}\n\nfunction SlowBuffer (length) {\n  if (+length != length) { // eslint-disable-line eqeqeq\n    length = 0\n  }\n  return Buffer.alloc(+length)\n}\n\nBuffer.isBuffer = function isBuffer (b) {\n  return !!(b != null && b._isBuffer)\n}\n\nBuffer.compare = function compare (a, b) {\n  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {\n    throw new TypeError('Arguments must be Buffers')\n  }\n\n  if (a === b) return 0\n\n  var x = a.length\n  var y = b.length\n\n  for (var i = 0, len = Math.min(x, y); i < len; ++i) {\n    if (a[i] !== b[i]) {\n      x = a[i]\n      y = b[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\nBuffer.isEncoding = function isEncoding (encoding) {\n  switch (String(encoding).toLowerCase()) {\n    case 'hex':\n    case 'utf8':\n    case 'utf-8':\n    case 'ascii':\n    case 'latin1':\n    case 'binary':\n    case 'base64':\n    case 'ucs2':\n    case 'ucs-2':\n    case 'utf16le':\n    case 'utf-16le':\n      return true\n    default:\n      return false\n  }\n}\n\nBuffer.concat = function concat (list, length) {\n  if (!isArray(list)) {\n    throw new TypeError('\"list\" argument must be an Array of Buffers')\n  }\n\n  if (list.length === 0) {\n    return Buffer.alloc(0)\n  }\n\n  var i\n  if (length === undefined) {\n    length = 0\n    for (i = 0; i < list.length; ++i) {\n      length += list[i].length\n    }\n  }\n\n  var buffer = Buffer.allocUnsafe(length)\n  var pos = 0\n  for (i = 0; i < list.length; ++i) {\n    var buf = list[i]\n    if (!Buffer.isBuffer(buf)) {\n      throw new TypeError('\"list\" argument must be an Array of Buffers')\n    }\n    buf.copy(buffer, pos)\n    pos += buf.length\n  }\n  return buffer\n}\n\nfunction byteLength (string, encoding) {\n  if (Buffer.isBuffer(string)) {\n    return string.length\n  }\n  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&\n      (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {\n    return string.byteLength\n  }\n  if (typeof string !== 'string') {\n    string = '' + string\n  }\n\n  var len = string.length\n  if (len === 0) return 0\n\n  // Use a for loop to avoid recursion\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'ascii':\n      case 'latin1':\n      case 'binary':\n        return len\n      case 'utf8':\n      case 'utf-8':\n      case undefined:\n        return utf8ToBytes(string).length\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return len * 2\n      case 'hex':\n        return len >>> 1\n      case 'base64':\n        return base64ToBytes(string).length\n      default:\n        if (loweredCase) return utf8ToBytes(string).length // assume utf8\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\nBuffer.byteLength = byteLength\n\nfunction slowToString (encoding, start, end) {\n  var loweredCase = false\n\n  // No need to verify that \"this.length <= MAX_UINT32\" since it's a read-only\n  // property of a typed array.\n\n  // This behaves neither like String nor Uint8Array in that we set start/end\n  // to their upper/lower bounds if the value passed is out of range.\n  // undefined is handled specially as per ECMA-262 6th Edition,\n  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.\n  if (start === undefined || start < 0) {\n    start = 0\n  }\n  // Return early if start > this.length. Done here to prevent potential uint32\n  // coercion fail below.\n  if (start > this.length) {\n    return ''\n  }\n\n  if (end === undefined || end > this.length) {\n    end = this.length\n  }\n\n  if (end <= 0) {\n    return ''\n  }\n\n  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.\n  end >>>= 0\n  start >>>= 0\n\n  if (end <= start) {\n    return ''\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  while (true) {\n    switch (encoding) {\n      case 'hex':\n        return hexSlice(this, start, end)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Slice(this, start, end)\n\n      case 'ascii':\n        return asciiSlice(this, start, end)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Slice(this, start, end)\n\n      case 'base64':\n        return base64Slice(this, start, end)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return utf16leSlice(this, start, end)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = (encoding + '').toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\n// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect\n// Buffer instances.\nBuffer.prototype._isBuffer = true\n\nfunction swap (b, n, m) {\n  var i = b[n]\n  b[n] = b[m]\n  b[m] = i\n}\n\nBuffer.prototype.swap16 = function swap16 () {\n  var len = this.length\n  if (len % 2 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 16-bits')\n  }\n  for (var i = 0; i < len; i += 2) {\n    swap(this, i, i + 1)\n  }\n  return this\n}\n\nBuffer.prototype.swap32 = function swap32 () {\n  var len = this.length\n  if (len % 4 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 32-bits')\n  }\n  for (var i = 0; i < len; i += 4) {\n    swap(this, i, i + 3)\n    swap(this, i + 1, i + 2)\n  }\n  return this\n}\n\nBuffer.prototype.swap64 = function swap64 () {\n  var len = this.length\n  if (len % 8 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 64-bits')\n  }\n  for (var i = 0; i < len; i += 8) {\n    swap(this, i, i + 7)\n    swap(this, i + 1, i + 6)\n    swap(this, i + 2, i + 5)\n    swap(this, i + 3, i + 4)\n  }\n  return this\n}\n\nBuffer.prototype.toString = function toString () {\n  var length = this.length | 0\n  if (length === 0) return ''\n  if (arguments.length === 0) return utf8Slice(this, 0, length)\n  return slowToString.apply(this, arguments)\n}\n\nBuffer.prototype.equals = function equals (b) {\n  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')\n  if (this === b) return true\n  return Buffer.compare(this, b) === 0\n}\n\nBuffer.prototype.inspect = function inspect () {\n  var str = ''\n  var max = exports.INSPECT_MAX_BYTES\n  if (this.length > 0) {\n    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')\n    if (this.length > max) str += ' ... '\n  }\n  return '<Buffer ' + str + '>'\n}\n\nBuffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {\n  if (!Buffer.isBuffer(target)) {\n    throw new TypeError('Argument must be a Buffer')\n  }\n\n  if (start === undefined) {\n    start = 0\n  }\n  if (end === undefined) {\n    end = target ? target.length : 0\n  }\n  if (thisStart === undefined) {\n    thisStart = 0\n  }\n  if (thisEnd === undefined) {\n    thisEnd = this.length\n  }\n\n  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {\n    throw new RangeError('out of range index')\n  }\n\n  if (thisStart >= thisEnd && start >= end) {\n    return 0\n  }\n  if (thisStart >= thisEnd) {\n    return -1\n  }\n  if (start >= end) {\n    return 1\n  }\n\n  start >>>= 0\n  end >>>= 0\n  thisStart >>>= 0\n  thisEnd >>>= 0\n\n  if (this === target) return 0\n\n  var x = thisEnd - thisStart\n  var y = end - start\n  var len = Math.min(x, y)\n\n  var thisCopy = this.slice(thisStart, thisEnd)\n  var targetCopy = target.slice(start, end)\n\n  for (var i = 0; i < len; ++i) {\n    if (thisCopy[i] !== targetCopy[i]) {\n      x = thisCopy[i]\n      y = targetCopy[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\n// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,\n// OR the last index of `val` in `buffer` at offset <= `byteOffset`.\n//\n// Arguments:\n// - buffer - a Buffer to search\n// - val - a string, Buffer, or number\n// - byteOffset - an index into `buffer`; will be clamped to an int32\n// - encoding - an optional encoding, relevant is val is a string\n// - dir - true for indexOf, false for lastIndexOf\nfunction bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {\n  // Empty buffer means no match\n  if (buffer.length === 0) return -1\n\n  // Normalize byteOffset\n  if (typeof byteOffset === 'string') {\n    encoding = byteOffset\n    byteOffset = 0\n  } else if (byteOffset > 0x7fffffff) {\n    byteOffset = 0x7fffffff\n  } else if (byteOffset < -0x80000000) {\n    byteOffset = -0x80000000\n  }\n  byteOffset = +byteOffset  // Coerce to Number.\n  if (isNaN(byteOffset)) {\n    // byteOffset: it it's undefined, null, NaN, \"foo\", etc, search whole buffer\n    byteOffset = dir ? 0 : (buffer.length - 1)\n  }\n\n  // Normalize byteOffset: negative offsets start from the end of the buffer\n  if (byteOffset < 0) byteOffset = buffer.length + byteOffset\n  if (byteOffset >= buffer.length) {\n    if (dir) return -1\n    else byteOffset = buffer.length - 1\n  } else if (byteOffset < 0) {\n    if (dir) byteOffset = 0\n    else return -1\n  }\n\n  // Normalize val\n  if (typeof val === 'string') {\n    val = Buffer.from(val, encoding)\n  }\n\n  // Finally, search either indexOf (if dir is true) or lastIndexOf\n  if (Buffer.isBuffer(val)) {\n    // Special case: looking for empty string/buffer always fails\n    if (val.length === 0) {\n      return -1\n    }\n    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)\n  } else if (typeof val === 'number') {\n    val = val & 0xFF // Search for a byte value [0-255]\n    if (Buffer.TYPED_ARRAY_SUPPORT &&\n        typeof Uint8Array.prototype.indexOf === 'function') {\n      if (dir) {\n        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)\n      } else {\n        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)\n      }\n    }\n    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)\n  }\n\n  throw new TypeError('val must be string, number or Buffer')\n}\n\nfunction arrayIndexOf (arr, val, byteOffset, encoding, dir) {\n  var indexSize = 1\n  var arrLength = arr.length\n  var valLength = val.length\n\n  if (encoding !== undefined) {\n    encoding = String(encoding).toLowerCase()\n    if (encoding === 'ucs2' || encoding === 'ucs-2' ||\n        encoding === 'utf16le' || encoding === 'utf-16le') {\n      if (arr.length < 2 || val.length < 2) {\n        return -1\n      }\n      indexSize = 2\n      arrLength /= 2\n      valLength /= 2\n      byteOffset /= 2\n    }\n  }\n\n  function read (buf, i) {\n    if (indexSize === 1) {\n      return buf[i]\n    } else {\n      return buf.readUInt16BE(i * indexSize)\n    }\n  }\n\n  var i\n  if (dir) {\n    var foundIndex = -1\n    for (i = byteOffset; i < arrLength; i++) {\n      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {\n        if (foundIndex === -1) foundIndex = i\n        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize\n      } else {\n        if (foundIndex !== -1) i -= i - foundIndex\n        foundIndex = -1\n      }\n    }\n  } else {\n    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength\n    for (i = byteOffset; i >= 0; i--) {\n      var found = true\n      for (var j = 0; j < valLength; j++) {\n        if (read(arr, i + j) !== read(val, j)) {\n          found = false\n          break\n        }\n      }\n      if (found) return i\n    }\n  }\n\n  return -1\n}\n\nBuffer.prototype.includes = function includes (val, byteOffset, encoding) {\n  return this.indexOf(val, byteOffset, encoding) !== -1\n}\n\nBuffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)\n}\n\nBuffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)\n}\n\nfunction hexWrite (buf, string, offset, length) {\n  offset = Number(offset) || 0\n  var remaining = buf.length - offset\n  if (!length) {\n    length = remaining\n  } else {\n    length = Number(length)\n    if (length > remaining) {\n      length = remaining\n    }\n  }\n\n  // must be an even number of digits\n  var strLen = string.length\n  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')\n\n  if (length > strLen / 2) {\n    length = strLen / 2\n  }\n  for (var i = 0; i < length; ++i) {\n    var parsed = parseInt(string.substr(i * 2, 2), 16)\n    if (isNaN(parsed)) return i\n    buf[offset + i] = parsed\n  }\n  return i\n}\n\nfunction utf8Write (buf, string, offset, length) {\n  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nfunction asciiWrite (buf, string, offset, length) {\n  return blitBuffer(asciiToBytes(string), buf, offset, length)\n}\n\nfunction latin1Write (buf, string, offset, length) {\n  return asciiWrite(buf, string, offset, length)\n}\n\nfunction base64Write (buf, string, offset, length) {\n  return blitBuffer(base64ToBytes(string), buf, offset, length)\n}\n\nfunction ucs2Write (buf, string, offset, length) {\n  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nBuffer.prototype.write = function write (string, offset, length, encoding) {\n  // Buffer#write(string)\n  if (offset === undefined) {\n    encoding = 'utf8'\n    length = this.length\n    offset = 0\n  // Buffer#write(string, encoding)\n  } else if (length === undefined && typeof offset === 'string') {\n    encoding = offset\n    length = this.length\n    offset = 0\n  // Buffer#write(string, offset[, length][, encoding])\n  } else if (isFinite(offset)) {\n    offset = offset | 0\n    if (isFinite(length)) {\n      length = length | 0\n      if (encoding === undefined) encoding = 'utf8'\n    } else {\n      encoding = length\n      length = undefined\n    }\n  // legacy write(string, encoding, offset, length) - remove in v0.13\n  } else {\n    throw new Error(\n      'Buffer.write(string, encoding, offset[, length]) is no longer supported'\n    )\n  }\n\n  var remaining = this.length - offset\n  if (length === undefined || length > remaining) length = remaining\n\n  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {\n    throw new RangeError('Attempt to write outside buffer bounds')\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'hex':\n        return hexWrite(this, string, offset, length)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Write(this, string, offset, length)\n\n      case 'ascii':\n        return asciiWrite(this, string, offset, length)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Write(this, string, offset, length)\n\n      case 'base64':\n        // Warning: maxLength not taken into account in base64Write\n        return base64Write(this, string, offset, length)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return ucs2Write(this, string, offset, length)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\nBuffer.prototype.toJSON = function toJSON () {\n  return {\n    type: 'Buffer',\n    data: Array.prototype.slice.call(this._arr || this, 0)\n  }\n}\n\nfunction base64Slice (buf, start, end) {\n  if (start === 0 && end === buf.length) {\n    return base64.fromByteArray(buf)\n  } else {\n    return base64.fromByteArray(buf.slice(start, end))\n  }\n}\n\nfunction utf8Slice (buf, start, end) {\n  end = Math.min(buf.length, end)\n  var res = []\n\n  var i = start\n  while (i < end) {\n    var firstByte = buf[i]\n    var codePoint = null\n    var bytesPerSequence = (firstByte > 0xEF) ? 4\n      : (firstByte > 0xDF) ? 3\n      : (firstByte > 0xBF) ? 2\n      : 1\n\n    if (i + bytesPerSequence <= end) {\n      var secondByte, thirdByte, fourthByte, tempCodePoint\n\n      switch (bytesPerSequence) {\n        case 1:\n          if (firstByte < 0x80) {\n            codePoint = firstByte\n          }\n          break\n        case 2:\n          secondByte = buf[i + 1]\n          if ((secondByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)\n            if (tempCodePoint > 0x7F) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 3:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)\n            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 4:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          fourthByte = buf[i + 3]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)\n            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {\n              codePoint = tempCodePoint\n            }\n          }\n      }\n    }\n\n    if (codePoint === null) {\n      // we did not generate a valid codePoint so insert a\n      // replacement char (U+FFFD) and advance only 1 byte\n      codePoint = 0xFFFD\n      bytesPerSequence = 1\n    } else if (codePoint > 0xFFFF) {\n      // encode to utf16 (surrogate pair dance)\n      codePoint -= 0x10000\n      res.push(codePoint >>> 10 & 0x3FF | 0xD800)\n      codePoint = 0xDC00 | codePoint & 0x3FF\n    }\n\n    res.push(codePoint)\n    i += bytesPerSequence\n  }\n\n  return decodeCodePointsArray(res)\n}\n\n// Based on http://stackoverflow.com/a/22747272/680742, the browser with\n// the lowest limit is Chrome, with 0x10000 args.\n// We go 1 magnitude less, for safety\nvar MAX_ARGUMENTS_LENGTH = 0x1000\n\nfunction decodeCodePointsArray (codePoints) {\n  var len = codePoints.length\n  if (len <= MAX_ARGUMENTS_LENGTH) {\n    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()\n  }\n\n  // Decode in chunks to avoid \"call stack size exceeded\".\n  var res = ''\n  var i = 0\n  while (i < len) {\n    res += String.fromCharCode.apply(\n      String,\n      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)\n    )\n  }\n  return res\n}\n\nfunction asciiSlice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i] & 0x7F)\n  }\n  return ret\n}\n\nfunction latin1Slice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i])\n  }\n  return ret\n}\n\nfunction hexSlice (buf, start, end) {\n  var len = buf.length\n\n  if (!start || start < 0) start = 0\n  if (!end || end < 0 || end > len) end = len\n\n  var out = ''\n  for (var i = start; i < end; ++i) {\n    out += toHex(buf[i])\n  }\n  return out\n}\n\nfunction utf16leSlice (buf, start, end) {\n  var bytes = buf.slice(start, end)\n  var res = ''\n  for (var i = 0; i < bytes.length; i += 2) {\n    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)\n  }\n  return res\n}\n\nBuffer.prototype.slice = function slice (start, end) {\n  var len = this.length\n  start = ~~start\n  end = end === undefined ? len : ~~end\n\n  if (start < 0) {\n    start += len\n    if (start < 0) start = 0\n  } else if (start > len) {\n    start = len\n  }\n\n  if (end < 0) {\n    end += len\n    if (end < 0) end = 0\n  } else if (end > len) {\n    end = len\n  }\n\n  if (end < start) end = start\n\n  var newBuf\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    newBuf = this.subarray(start, end)\n    newBuf.__proto__ = Buffer.prototype\n  } else {\n    var sliceLen = end - start\n    newBuf = new Buffer(sliceLen, undefined)\n    for (var i = 0; i < sliceLen; ++i) {\n      newBuf[i] = this[i + start]\n    }\n  }\n\n  return newBuf\n}\n\n/*\n * Need to make sure that buffer isn't trying to write out of bounds.\n */\nfunction checkOffset (offset, ext, length) {\n  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')\n  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')\n}\n\nBuffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    checkOffset(offset, byteLength, this.length)\n  }\n\n  var val = this[offset + --byteLength]\n  var mul = 1\n  while (byteLength > 0 && (mul *= 0x100)) {\n    val += this[offset + --byteLength] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  return this[offset]\n}\n\nBuffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return this[offset] | (this[offset + 1] << 8)\n}\n\nBuffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return (this[offset] << 8) | this[offset + 1]\n}\n\nBuffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return ((this[offset]) |\n      (this[offset + 1] << 8) |\n      (this[offset + 2] << 16)) +\n      (this[offset + 3] * 0x1000000)\n}\n\nBuffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] * 0x1000000) +\n    ((this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    this[offset + 3])\n}\n\nBuffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var i = byteLength\n  var mul = 1\n  var val = this[offset + --i]\n  while (i > 0 && (mul *= 0x100)) {\n    val += this[offset + --i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readInt8 = function readInt8 (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  if (!(this[offset] & 0x80)) return (this[offset])\n  return ((0xff - this[offset] + 1) * -1)\n}\n\nBuffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset] | (this[offset + 1] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset + 1] | (this[offset] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset]) |\n    (this[offset + 1] << 8) |\n    (this[offset + 2] << 16) |\n    (this[offset + 3] << 24)\n}\n\nBuffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] << 24) |\n    (this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    (this[offset + 3])\n}\n\nBuffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, true, 23, 4)\n}\n\nBuffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, false, 23, 4)\n}\n\nBuffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, true, 52, 8)\n}\n\nBuffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, false, 52, 8)\n}\n\nfunction checkInt (buf, value, offset, ext, max, min) {\n  if (!Buffer.isBuffer(buf)) throw new TypeError('\"buffer\" argument must be a Buffer instance')\n  if (value > max || value < min) throw new RangeError('\"value\" argument is out of bounds')\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n}\n\nBuffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  var mul = 1\n  var i = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  var i = byteLength - 1\n  var mul = 1\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nfunction objectWriteUInt16 (buf, value, offset, littleEndian) {\n  if (value < 0) value = 0xffff + value + 1\n  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {\n    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>\n      (littleEndian ? i : 1 - i) * 8\n  }\n}\n\nBuffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n  } else {\n    objectWriteUInt16(this, value, offset, true)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 8)\n    this[offset + 1] = (value & 0xff)\n  } else {\n    objectWriteUInt16(this, value, offset, false)\n  }\n  return offset + 2\n}\n\nfunction objectWriteUInt32 (buf, value, offset, littleEndian) {\n  if (value < 0) value = 0xffffffff + value + 1\n  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {\n    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff\n  }\n}\n\nBuffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset + 3] = (value >>> 24)\n    this[offset + 2] = (value >>> 16)\n    this[offset + 1] = (value >>> 8)\n    this[offset] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, true)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 24)\n    this[offset + 1] = (value >>> 16)\n    this[offset + 2] = (value >>> 8)\n    this[offset + 3] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, false)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) {\n    var limit = Math.pow(2, 8 * byteLength - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = 0\n  var mul = 1\n  var sub = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) {\n    var limit = Math.pow(2, 8 * byteLength - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = byteLength - 1\n  var mul = 1\n  var sub = 0\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)\n  if (value < 0) value = 0xff + value + 1\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nBuffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n  } else {\n    objectWriteUInt16(this, value, offset, true)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 8)\n    this[offset + 1] = (value & 0xff)\n  } else {\n    objectWriteUInt16(this, value, offset, false)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n    this[offset + 2] = (value >>> 16)\n    this[offset + 3] = (value >>> 24)\n  } else {\n    objectWriteUInt32(this, value, offset, true)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (value < 0) value = 0xffffffff + value + 1\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 24)\n    this[offset + 1] = (value >>> 16)\n    this[offset + 2] = (value >>> 8)\n    this[offset + 3] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, false)\n  }\n  return offset + 4\n}\n\nfunction checkIEEE754 (buf, value, offset, ext, max, min) {\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n  if (offset < 0) throw new RangeError('Index out of range')\n}\n\nfunction writeFloat (buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 23, 4)\n  return offset + 4\n}\n\nBuffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, false, noAssert)\n}\n\nfunction writeDouble (buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 52, 8)\n  return offset + 8\n}\n\nBuffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, false, noAssert)\n}\n\n// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\nBuffer.prototype.copy = function copy (target, targetStart, start, end) {\n  if (!start) start = 0\n  if (!end && end !== 0) end = this.length\n  if (targetStart >= target.length) targetStart = target.length\n  if (!targetStart) targetStart = 0\n  if (end > 0 && end < start) end = start\n\n  // Copy 0 bytes; we're done\n  if (end === start) return 0\n  if (target.length === 0 || this.length === 0) return 0\n\n  // Fatal error conditions\n  if (targetStart < 0) {\n    throw new RangeError('targetStart out of bounds')\n  }\n  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')\n  if (end < 0) throw new RangeError('sourceEnd out of bounds')\n\n  // Are we oob?\n  if (end > this.length) end = this.length\n  if (target.length - targetStart < end - start) {\n    end = target.length - targetStart + start\n  }\n\n  var len = end - start\n  var i\n\n  if (this === target && start < targetStart && targetStart < end) {\n    // descending copy from end\n    for (i = len - 1; i >= 0; --i) {\n      target[i + targetStart] = this[i + start]\n    }\n  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {\n    // ascending copy from start\n    for (i = 0; i < len; ++i) {\n      target[i + targetStart] = this[i + start]\n    }\n  } else {\n    Uint8Array.prototype.set.call(\n      target,\n      this.subarray(start, start + len),\n      targetStart\n    )\n  }\n\n  return len\n}\n\n// Usage:\n//    buffer.fill(number[, offset[, end]])\n//    buffer.fill(buffer[, offset[, end]])\n//    buffer.fill(string[, offset[, end]][, encoding])\nBuffer.prototype.fill = function fill (val, start, end, encoding) {\n  // Handle string cases:\n  if (typeof val === 'string') {\n    if (typeof start === 'string') {\n      encoding = start\n      start = 0\n      end = this.length\n    } else if (typeof end === 'string') {\n      encoding = end\n      end = this.length\n    }\n    if (val.length === 1) {\n      var code = val.charCodeAt(0)\n      if (code < 256) {\n        val = code\n      }\n    }\n    if (encoding !== undefined && typeof encoding !== 'string') {\n      throw new TypeError('encoding must be a string')\n    }\n    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {\n      throw new TypeError('Unknown encoding: ' + encoding)\n    }\n  } else if (typeof val === 'number') {\n    val = val & 255\n  }\n\n  // Invalid ranges are not set to a default, so can range check early.\n  if (start < 0 || this.length < start || this.length < end) {\n    throw new RangeError('Out of range index')\n  }\n\n  if (end <= start) {\n    return this\n  }\n\n  start = start >>> 0\n  end = end === undefined ? this.length : end >>> 0\n\n  if (!val) val = 0\n\n  var i\n  if (typeof val === 'number') {\n    for (i = start; i < end; ++i) {\n      this[i] = val\n    }\n  } else {\n    var bytes = Buffer.isBuffer(val)\n      ? val\n      : utf8ToBytes(new Buffer(val, encoding).toString())\n    var len = bytes.length\n    for (i = 0; i < end - start; ++i) {\n      this[i + start] = bytes[i % len]\n    }\n  }\n\n  return this\n}\n\n// HELPER FUNCTIONS\n// ================\n\nvar INVALID_BASE64_RE = /[^+\\/0-9A-Za-z-_]/g\n\nfunction base64clean (str) {\n  // Node strips out invalid characters like \\n and \\t from the string, base64-js does not\n  str = stringtrim(str).replace(INVALID_BASE64_RE, '')\n  // Node converts strings with length < 2 to ''\n  if (str.length < 2) return ''\n  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not\n  while (str.length % 4 !== 0) {\n    str = str + '='\n  }\n  return str\n}\n\nfunction stringtrim (str) {\n  if (str.trim) return str.trim()\n  return str.replace(/^\\s+|\\s+$/g, '')\n}\n\nfunction toHex (n) {\n  if (n < 16) return '0' + n.toString(16)\n  return n.toString(16)\n}\n\nfunction utf8ToBytes (string, units) {\n  units = units || Infinity\n  var codePoint\n  var length = string.length\n  var leadSurrogate = null\n  var bytes = []\n\n  for (var i = 0; i < length; ++i) {\n    codePoint = string.charCodeAt(i)\n\n    // is surrogate component\n    if (codePoint > 0xD7FF && codePoint < 0xE000) {\n      // last char was a lead\n      if (!leadSurrogate) {\n        // no lead yet\n        if (codePoint > 0xDBFF) {\n          // unexpected trail\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        } else if (i + 1 === length) {\n          // unpaired lead\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        }\n\n        // valid lead\n        leadSurrogate = codePoint\n\n        continue\n      }\n\n      // 2 leads in a row\n      if (codePoint < 0xDC00) {\n        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n        leadSurrogate = codePoint\n        continue\n      }\n\n      // valid surrogate pair\n      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000\n    } else if (leadSurrogate) {\n      // valid bmp char, but last char was a lead\n      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n    }\n\n    leadSurrogate = null\n\n    // encode utf8\n    if (codePoint < 0x80) {\n      if ((units -= 1) < 0) break\n      bytes.push(codePoint)\n    } else if (codePoint < 0x800) {\n      if ((units -= 2) < 0) break\n      bytes.push(\n        codePoint >> 0x6 | 0xC0,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x10000) {\n      if ((units -= 3) < 0) break\n      bytes.push(\n        codePoint >> 0xC | 0xE0,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x110000) {\n      if ((units -= 4) < 0) break\n      bytes.push(\n        codePoint >> 0x12 | 0xF0,\n        codePoint >> 0xC & 0x3F | 0x80,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else {\n      throw new Error('Invalid code point')\n    }\n  }\n\n  return bytes\n}\n\nfunction asciiToBytes (str) {\n  var byteArray = []\n  for (var i = 0; i < str.length; ++i) {\n    // Node's code seems to be doing this and not & 0x7F..\n    byteArray.push(str.charCodeAt(i) & 0xFF)\n  }\n  return byteArray\n}\n\nfunction utf16leToBytes (str, units) {\n  var c, hi, lo\n  var byteArray = []\n  for (var i = 0; i < str.length; ++i) {\n    if ((units -= 2) < 0) break\n\n    c = str.charCodeAt(i)\n    hi = c >> 8\n    lo = c % 256\n    byteArray.push(lo)\n    byteArray.push(hi)\n  }\n\n  return byteArray\n}\n\nfunction base64ToBytes (str) {\n  return base64.toByteArray(base64clean(str))\n}\n\nfunction blitBuffer (src, dst, offset, length) {\n  for (var i = 0; i < length; ++i) {\n    if ((i + offset >= dst.length) || (i >= src.length)) break\n    dst[i + offset] = src[i]\n  }\n  return i\n}\n\nfunction isnan (val) {\n  return val !== val // eslint-disable-line no-self-compare\n}\n\n/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2J1ZmZlci9pbmRleC5qcz8xYTU1Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLG1EQUFtRDtBQUN4RTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFVBQVU7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFlBQVk7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSx1Q0FBdUMsU0FBUztBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGlCQUFpQjtBQUNoQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsaUJBQWlCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsU0FBUztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsU0FBUztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxFQUFFO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixlQUFlO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLHdCQUF3QixRQUFRO0FBQ2hDO0FBQ0EscUJBQXFCLGVBQWU7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFlBQVk7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHFCQUFxQixTQUFTO0FBQzlCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxxQkFBcUIsU0FBUztBQUM5QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxxQkFBcUIsU0FBUztBQUM5QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsa0JBQWtCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxtQkFBbUIsY0FBYztBQUNqQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsdURBQXVELE9BQU87QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHVEQUF1RCxPQUFPO0FBQzlEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGtCQUFrQjtBQUNsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHFCQUFxQixRQUFRO0FBQzdCO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxlQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxtQkFBbUIsU0FBUztBQUM1QjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxpQkFBaUI7QUFDaEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpQkFBaUIsWUFBWTtBQUM3Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUJBQWlCLGdCQUFnQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixnQkFBZ0I7QUFDakM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCLFlBQVk7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EiLCJmaWxlIjoiMjUuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIFRoZSBidWZmZXIgbW9kdWxlIGZyb20gbm9kZS5qcywgZm9yIHRoZSBicm93c2VyLlxuICpcbiAqIEBhdXRob3IgICBGZXJvc3MgQWJvdWtoYWRpamVoIDxmZXJvc3NAZmVyb3NzLm9yZz4gPGh0dHA6Ly9mZXJvc3Mub3JnPlxuICogQGxpY2Vuc2UgIE1JVFxuICovXG4vKiBlc2xpbnQtZGlzYWJsZSBuby1wcm90byAqL1xuXG4ndXNlIHN0cmljdCdcblxudmFyIGJhc2U2NCA9IHJlcXVpcmUoJ2Jhc2U2NC1qcycpXG52YXIgaWVlZTc1NCA9IHJlcXVpcmUoJ2llZWU3NTQnKVxudmFyIGlzQXJyYXkgPSByZXF1aXJlKCdpc2FycmF5JylcblxuZXhwb3J0cy5CdWZmZXIgPSBCdWZmZXJcbmV4cG9ydHMuU2xvd0J1ZmZlciA9IFNsb3dCdWZmZXJcbmV4cG9ydHMuSU5TUEVDVF9NQVhfQllURVMgPSA1MFxuXG4vKipcbiAqIElmIGBCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVGA6XG4gKiAgID09PSB0cnVlICAgIFVzZSBVaW50OEFycmF5IGltcGxlbWVudGF0aW9uIChmYXN0ZXN0KVxuICogICA9PT0gZmFsc2UgICBVc2UgT2JqZWN0IGltcGxlbWVudGF0aW9uIChtb3N0IGNvbXBhdGlibGUsIGV2ZW4gSUU2KVxuICpcbiAqIEJyb3dzZXJzIHRoYXQgc3VwcG9ydCB0eXBlZCBhcnJheXMgYXJlIElFIDEwKywgRmlyZWZveCA0KywgQ2hyb21lIDcrLCBTYWZhcmkgNS4xKyxcbiAqIE9wZXJhIDExLjYrLCBpT1MgNC4yKy5cbiAqXG4gKiBEdWUgdG8gdmFyaW91cyBicm93c2VyIGJ1Z3MsIHNvbWV0aW1lcyB0aGUgT2JqZWN0IGltcGxlbWVudGF0aW9uIHdpbGwgYmUgdXNlZCBldmVuXG4gKiB3aGVuIHRoZSBicm93c2VyIHN1cHBvcnRzIHR5cGVkIGFycmF5cy5cbiAqXG4gKiBOb3RlOlxuICpcbiAqICAgLSBGaXJlZm94IDQtMjkgbGFja3Mgc3VwcG9ydCBmb3IgYWRkaW5nIG5ldyBwcm9wZXJ0aWVzIHRvIGBVaW50OEFycmF5YCBpbnN0YW5jZXMsXG4gKiAgICAgU2VlOiBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD02OTU0MzguXG4gKlxuICogICAtIENocm9tZSA5LTEwIGlzIG1pc3NpbmcgdGhlIGBUeXBlZEFycmF5LnByb3RvdHlwZS5zdWJhcnJheWAgZnVuY3Rpb24uXG4gKlxuICogICAtIElFMTAgaGFzIGEgYnJva2VuIGBUeXBlZEFycmF5LnByb3RvdHlwZS5zdWJhcnJheWAgZnVuY3Rpb24gd2hpY2ggcmV0dXJucyBhcnJheXMgb2ZcbiAqICAgICBpbmNvcnJlY3QgbGVuZ3RoIGluIHNvbWUgc2l0dWF0aW9ucy5cblxuICogV2UgZGV0ZWN0IHRoZXNlIGJ1Z2d5IGJyb3dzZXJzIGFuZCBzZXQgYEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUYCB0byBgZmFsc2VgIHNvIHRoZXlcbiAqIGdldCB0aGUgT2JqZWN0IGltcGxlbWVudGF0aW9uLCB3aGljaCBpcyBzbG93ZXIgYnV0IGJlaGF2ZXMgY29ycmVjdGx5LlxuICovXG5CdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCA9IGdsb2JhbC5UWVBFRF9BUlJBWV9TVVBQT1JUICE9PSB1bmRlZmluZWRcbiAgPyBnbG9iYWwuVFlQRURfQVJSQVlfU1VQUE9SVFxuICA6IHR5cGVkQXJyYXlTdXBwb3J0KClcblxuLypcbiAqIEV4cG9ydCBrTWF4TGVuZ3RoIGFmdGVyIHR5cGVkIGFycmF5IHN1cHBvcnQgaXMgZGV0ZXJtaW5lZC5cbiAqL1xuZXhwb3J0cy5rTWF4TGVuZ3RoID0ga01heExlbmd0aCgpXG5cbmZ1bmN0aW9uIHR5cGVkQXJyYXlTdXBwb3J0ICgpIHtcbiAgdHJ5IHtcbiAgICB2YXIgYXJyID0gbmV3IFVpbnQ4QXJyYXkoMSlcbiAgICBhcnIuX19wcm90b19fID0ge19fcHJvdG9fXzogVWludDhBcnJheS5wcm90b3R5cGUsIGZvbzogZnVuY3Rpb24gKCkgeyByZXR1cm4gNDIgfX1cbiAgICByZXR1cm4gYXJyLmZvbygpID09PSA0MiAmJiAvLyB0eXBlZCBhcnJheSBpbnN0YW5jZXMgY2FuIGJlIGF1Z21lbnRlZFxuICAgICAgICB0eXBlb2YgYXJyLnN1YmFycmF5ID09PSAnZnVuY3Rpb24nICYmIC8vIGNocm9tZSA5LTEwIGxhY2sgYHN1YmFycmF5YFxuICAgICAgICBhcnIuc3ViYXJyYXkoMSwgMSkuYnl0ZUxlbmd0aCA9PT0gMCAvLyBpZTEwIGhhcyBicm9rZW4gYHN1YmFycmF5YFxuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbn1cblxuZnVuY3Rpb24ga01heExlbmd0aCAoKSB7XG4gIHJldHVybiBCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVFxuICAgID8gMHg3ZmZmZmZmZlxuICAgIDogMHgzZmZmZmZmZlxufVxuXG5mdW5jdGlvbiBjcmVhdGVCdWZmZXIgKHRoYXQsIGxlbmd0aCkge1xuICBpZiAoa01heExlbmd0aCgpIDwgbGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0ludmFsaWQgdHlwZWQgYXJyYXkgbGVuZ3RoJylcbiAgfVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICAvLyBSZXR1cm4gYW4gYXVnbWVudGVkIGBVaW50OEFycmF5YCBpbnN0YW5jZSwgZm9yIGJlc3QgcGVyZm9ybWFuY2VcbiAgICB0aGF0ID0gbmV3IFVpbnQ4QXJyYXkobGVuZ3RoKVxuICAgIHRoYXQuX19wcm90b19fID0gQnVmZmVyLnByb3RvdHlwZVxuICB9IGVsc2Uge1xuICAgIC8vIEZhbGxiYWNrOiBSZXR1cm4gYW4gb2JqZWN0IGluc3RhbmNlIG9mIHRoZSBCdWZmZXIgY2xhc3NcbiAgICBpZiAodGhhdCA9PT0gbnVsbCkge1xuICAgICAgdGhhdCA9IG5ldyBCdWZmZXIobGVuZ3RoKVxuICAgIH1cbiAgICB0aGF0Lmxlbmd0aCA9IGxlbmd0aFxuICB9XG5cbiAgcmV0dXJuIHRoYXRcbn1cblxuLyoqXG4gKiBUaGUgQnVmZmVyIGNvbnN0cnVjdG9yIHJldHVybnMgaW5zdGFuY2VzIG9mIGBVaW50OEFycmF5YCB0aGF0IGhhdmUgdGhlaXJcbiAqIHByb3RvdHlwZSBjaGFuZ2VkIHRvIGBCdWZmZXIucHJvdG90eXBlYC4gRnVydGhlcm1vcmUsIGBCdWZmZXJgIGlzIGEgc3ViY2xhc3Mgb2ZcbiAqIGBVaW50OEFycmF5YCwgc28gdGhlIHJldHVybmVkIGluc3RhbmNlcyB3aWxsIGhhdmUgYWxsIHRoZSBub2RlIGBCdWZmZXJgIG1ldGhvZHNcbiAqIGFuZCB0aGUgYFVpbnQ4QXJyYXlgIG1ldGhvZHMuIFNxdWFyZSBicmFja2V0IG5vdGF0aW9uIHdvcmtzIGFzIGV4cGVjdGVkIC0tIGl0XG4gKiByZXR1cm5zIGEgc2luZ2xlIG9jdGV0LlxuICpcbiAqIFRoZSBgVWludDhBcnJheWAgcHJvdG90eXBlIHJlbWFpbnMgdW5tb2RpZmllZC5cbiAqL1xuXG5mdW5jdGlvbiBCdWZmZXIgKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIGlmICghQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQgJiYgISh0aGlzIGluc3RhbmNlb2YgQnVmZmVyKSkge1xuICAgIHJldHVybiBuZXcgQnVmZmVyKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxuICB9XG5cbiAgLy8gQ29tbW9uIGNhc2UuXG4gIGlmICh0eXBlb2YgYXJnID09PSAnbnVtYmVyJykge1xuICAgIGlmICh0eXBlb2YgZW5jb2RpbmdPck9mZnNldCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ0lmIGVuY29kaW5nIGlzIHNwZWNpZmllZCB0aGVuIHRoZSBmaXJzdCBhcmd1bWVudCBtdXN0IGJlIGEgc3RyaW5nJ1xuICAgICAgKVxuICAgIH1cbiAgICByZXR1cm4gYWxsb2NVbnNhZmUodGhpcywgYXJnKVxuICB9XG4gIHJldHVybiBmcm9tKHRoaXMsIGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxufVxuXG5CdWZmZXIucG9vbFNpemUgPSA4MTkyIC8vIG5vdCB1c2VkIGJ5IHRoaXMgaW1wbGVtZW50YXRpb25cblxuLy8gVE9ETzogTGVnYWN5LCBub3QgbmVlZGVkIGFueW1vcmUuIFJlbW92ZSBpbiBuZXh0IG1ham9yIHZlcnNpb24uXG5CdWZmZXIuX2F1Z21lbnQgPSBmdW5jdGlvbiAoYXJyKSB7XG4gIGFyci5fX3Byb3RvX18gPSBCdWZmZXIucHJvdG90eXBlXG4gIHJldHVybiBhcnJcbn1cblxuZnVuY3Rpb24gZnJvbSAodGhhdCwgdmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1widmFsdWVcIiBhcmd1bWVudCBtdXN0IG5vdCBiZSBhIG51bWJlcicpXG4gIH1cblxuICBpZiAodHlwZW9mIEFycmF5QnVmZmVyICE9PSAndW5kZWZpbmVkJyAmJiB2YWx1ZSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG4gICAgcmV0dXJuIGZyb21BcnJheUJ1ZmZlcih0aGF0LCB2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxuICB9XG5cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gZnJvbVN0cmluZyh0aGF0LCB2YWx1ZSwgZW5jb2RpbmdPck9mZnNldClcbiAgfVxuXG4gIHJldHVybiBmcm9tT2JqZWN0KHRoYXQsIHZhbHVlKVxufVxuXG4vKipcbiAqIEZ1bmN0aW9uYWxseSBlcXVpdmFsZW50IHRvIEJ1ZmZlcihhcmcsIGVuY29kaW5nKSBidXQgdGhyb3dzIGEgVHlwZUVycm9yXG4gKiBpZiB2YWx1ZSBpcyBhIG51bWJlci5cbiAqIEJ1ZmZlci5mcm9tKHN0clssIGVuY29kaW5nXSlcbiAqIEJ1ZmZlci5mcm9tKGFycmF5KVxuICogQnVmZmVyLmZyb20oYnVmZmVyKVxuICogQnVmZmVyLmZyb20oYXJyYXlCdWZmZXJbLCBieXRlT2Zmc2V0WywgbGVuZ3RoXV0pXG4gKiovXG5CdWZmZXIuZnJvbSA9IGZ1bmN0aW9uICh2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBmcm9tKG51bGwsIHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG59XG5cbmlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICBCdWZmZXIucHJvdG90eXBlLl9fcHJvdG9fXyA9IFVpbnQ4QXJyYXkucHJvdG90eXBlXG4gIEJ1ZmZlci5fX3Byb3RvX18gPSBVaW50OEFycmF5XG4gIGlmICh0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wuc3BlY2llcyAmJlxuICAgICAgQnVmZmVyW1N5bWJvbC5zcGVjaWVzXSA9PT0gQnVmZmVyKSB7XG4gICAgLy8gRml4IHN1YmFycmF5KCkgaW4gRVMyMDE2LiBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvYnVmZmVyL3B1bGwvOTdcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQnVmZmVyLCBTeW1ib2wuc3BlY2llcywge1xuICAgICAgdmFsdWU6IG51bGwsXG4gICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KVxuICB9XG59XG5cbmZ1bmN0aW9uIGFzc2VydFNpemUgKHNpemUpIHtcbiAgaWYgKHR5cGVvZiBzaXplICE9PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wic2l6ZVwiIGFyZ3VtZW50IG11c3QgYmUgYSBudW1iZXInKVxuICB9IGVsc2UgaWYgKHNpemUgPCAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1wic2l6ZVwiIGFyZ3VtZW50IG11c3Qgbm90IGJlIG5lZ2F0aXZlJylcbiAgfVxufVxuXG5mdW5jdGlvbiBhbGxvYyAodGhhdCwgc2l6ZSwgZmlsbCwgZW5jb2RpbmcpIHtcbiAgYXNzZXJ0U2l6ZShzaXplKVxuICBpZiAoc2l6ZSA8PSAwKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUJ1ZmZlcih0aGF0LCBzaXplKVxuICB9XG4gIGlmIChmaWxsICE9PSB1bmRlZmluZWQpIHtcbiAgICAvLyBPbmx5IHBheSBhdHRlbnRpb24gdG8gZW5jb2RpbmcgaWYgaXQncyBhIHN0cmluZy4gVGhpc1xuICAgIC8vIHByZXZlbnRzIGFjY2lkZW50YWxseSBzZW5kaW5nIGluIGEgbnVtYmVyIHRoYXQgd291bGRcbiAgICAvLyBiZSBpbnRlcnByZXR0ZWQgYXMgYSBzdGFydCBvZmZzZXQuXG4gICAgcmV0dXJuIHR5cGVvZiBlbmNvZGluZyA9PT0gJ3N0cmluZydcbiAgICAgID8gY3JlYXRlQnVmZmVyKHRoYXQsIHNpemUpLmZpbGwoZmlsbCwgZW5jb2RpbmcpXG4gICAgICA6IGNyZWF0ZUJ1ZmZlcih0aGF0LCBzaXplKS5maWxsKGZpbGwpXG4gIH1cbiAgcmV0dXJuIGNyZWF0ZUJ1ZmZlcih0aGF0LCBzaXplKVxufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgZmlsbGVkIEJ1ZmZlciBpbnN0YW5jZS5cbiAqIGFsbG9jKHNpemVbLCBmaWxsWywgZW5jb2RpbmddXSlcbiAqKi9cbkJ1ZmZlci5hbGxvYyA9IGZ1bmN0aW9uIChzaXplLCBmaWxsLCBlbmNvZGluZykge1xuICByZXR1cm4gYWxsb2MobnVsbCwgc2l6ZSwgZmlsbCwgZW5jb2RpbmcpXG59XG5cbmZ1bmN0aW9uIGFsbG9jVW5zYWZlICh0aGF0LCBzaXplKSB7XG4gIGFzc2VydFNpemUoc2l6ZSlcbiAgdGhhdCA9IGNyZWF0ZUJ1ZmZlcih0aGF0LCBzaXplIDwgMCA/IDAgOiBjaGVja2VkKHNpemUpIHwgMClcbiAgaWYgKCFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2l6ZTsgKytpKSB7XG4gICAgICB0aGF0W2ldID0gMFxuICAgIH1cbiAgfVxuICByZXR1cm4gdGhhdFxufVxuXG4vKipcbiAqIEVxdWl2YWxlbnQgdG8gQnVmZmVyKG51bSksIGJ5IGRlZmF1bHQgY3JlYXRlcyBhIG5vbi16ZXJvLWZpbGxlZCBCdWZmZXIgaW5zdGFuY2UuXG4gKiAqL1xuQnVmZmVyLmFsbG9jVW5zYWZlID0gZnVuY3Rpb24gKHNpemUpIHtcbiAgcmV0dXJuIGFsbG9jVW5zYWZlKG51bGwsIHNpemUpXG59XG4vKipcbiAqIEVxdWl2YWxlbnQgdG8gU2xvd0J1ZmZlcihudW0pLCBieSBkZWZhdWx0IGNyZWF0ZXMgYSBub24temVyby1maWxsZWQgQnVmZmVyIGluc3RhbmNlLlxuICovXG5CdWZmZXIuYWxsb2NVbnNhZmVTbG93ID0gZnVuY3Rpb24gKHNpemUpIHtcbiAgcmV0dXJuIGFsbG9jVW5zYWZlKG51bGwsIHNpemUpXG59XG5cbmZ1bmN0aW9uIGZyb21TdHJpbmcgKHRoYXQsIHN0cmluZywgZW5jb2RpbmcpIHtcbiAgaWYgKHR5cGVvZiBlbmNvZGluZyAhPT0gJ3N0cmluZycgfHwgZW5jb2RpbmcgPT09ICcnKSB7XG4gICAgZW5jb2RpbmcgPSAndXRmOCdcbiAgfVxuXG4gIGlmICghQnVmZmVyLmlzRW5jb2RpbmcoZW5jb2RpbmcpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJlbmNvZGluZ1wiIG11c3QgYmUgYSB2YWxpZCBzdHJpbmcgZW5jb2RpbmcnKVxuICB9XG5cbiAgdmFyIGxlbmd0aCA9IGJ5dGVMZW5ndGgoc3RyaW5nLCBlbmNvZGluZykgfCAwXG4gIHRoYXQgPSBjcmVhdGVCdWZmZXIodGhhdCwgbGVuZ3RoKVxuXG4gIHZhciBhY3R1YWwgPSB0aGF0LndyaXRlKHN0cmluZywgZW5jb2RpbmcpXG5cbiAgaWYgKGFjdHVhbCAhPT0gbGVuZ3RoKSB7XG4gICAgLy8gV3JpdGluZyBhIGhleCBzdHJpbmcsIGZvciBleGFtcGxlLCB0aGF0IGNvbnRhaW5zIGludmFsaWQgY2hhcmFjdGVycyB3aWxsXG4gICAgLy8gY2F1c2UgZXZlcnl0aGluZyBhZnRlciB0aGUgZmlyc3QgaW52YWxpZCBjaGFyYWN0ZXIgdG8gYmUgaWdub3JlZC4gKGUuZy5cbiAgICAvLyAnYWJ4eGNkJyB3aWxsIGJlIHRyZWF0ZWQgYXMgJ2FiJylcbiAgICB0aGF0ID0gdGhhdC5zbGljZSgwLCBhY3R1YWwpXG4gIH1cblxuICByZXR1cm4gdGhhdFxufVxuXG5mdW5jdGlvbiBmcm9tQXJyYXlMaWtlICh0aGF0LCBhcnJheSkge1xuICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoIDwgMCA/IDAgOiBjaGVja2VkKGFycmF5Lmxlbmd0aCkgfCAwXG4gIHRoYXQgPSBjcmVhdGVCdWZmZXIodGhhdCwgbGVuZ3RoKVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSArPSAxKSB7XG4gICAgdGhhdFtpXSA9IGFycmF5W2ldICYgMjU1XG4gIH1cbiAgcmV0dXJuIHRoYXRcbn1cblxuZnVuY3Rpb24gZnJvbUFycmF5QnVmZmVyICh0aGF0LCBhcnJheSwgYnl0ZU9mZnNldCwgbGVuZ3RoKSB7XG4gIGFycmF5LmJ5dGVMZW5ndGggLy8gdGhpcyB0aHJvd3MgaWYgYGFycmF5YCBpcyBub3QgYSB2YWxpZCBBcnJheUJ1ZmZlclxuXG4gIGlmIChieXRlT2Zmc2V0IDwgMCB8fCBhcnJheS5ieXRlTGVuZ3RoIDwgYnl0ZU9mZnNldCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdcXCdvZmZzZXRcXCcgaXMgb3V0IG9mIGJvdW5kcycpXG4gIH1cblxuICBpZiAoYXJyYXkuYnl0ZUxlbmd0aCA8IGJ5dGVPZmZzZXQgKyAobGVuZ3RoIHx8IDApKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1xcJ2xlbmd0aFxcJyBpcyBvdXQgb2YgYm91bmRzJylcbiAgfVxuXG4gIGlmIChieXRlT2Zmc2V0ID09PSB1bmRlZmluZWQgJiYgbGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICBhcnJheSA9IG5ldyBVaW50OEFycmF5KGFycmF5KVxuICB9IGVsc2UgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgYXJyYXkgPSBuZXcgVWludDhBcnJheShhcnJheSwgYnl0ZU9mZnNldClcbiAgfSBlbHNlIHtcbiAgICBhcnJheSA9IG5ldyBVaW50OEFycmF5KGFycmF5LCBieXRlT2Zmc2V0LCBsZW5ndGgpXG4gIH1cblxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICAvLyBSZXR1cm4gYW4gYXVnbWVudGVkIGBVaW50OEFycmF5YCBpbnN0YW5jZSwgZm9yIGJlc3QgcGVyZm9ybWFuY2VcbiAgICB0aGF0ID0gYXJyYXlcbiAgICB0aGF0Ll9fcHJvdG9fXyA9IEJ1ZmZlci5wcm90b3R5cGVcbiAgfSBlbHNlIHtcbiAgICAvLyBGYWxsYmFjazogUmV0dXJuIGFuIG9iamVjdCBpbnN0YW5jZSBvZiB0aGUgQnVmZmVyIGNsYXNzXG4gICAgdGhhdCA9IGZyb21BcnJheUxpa2UodGhhdCwgYXJyYXkpXG4gIH1cbiAgcmV0dXJuIHRoYXRcbn1cblxuZnVuY3Rpb24gZnJvbU9iamVjdCAodGhhdCwgb2JqKSB7XG4gIGlmIChCdWZmZXIuaXNCdWZmZXIob2JqKSkge1xuICAgIHZhciBsZW4gPSBjaGVja2VkKG9iai5sZW5ndGgpIHwgMFxuICAgIHRoYXQgPSBjcmVhdGVCdWZmZXIodGhhdCwgbGVuKVxuXG4gICAgaWYgKHRoYXQubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gdGhhdFxuICAgIH1cblxuICAgIG9iai5jb3B5KHRoYXQsIDAsIDAsIGxlbilcbiAgICByZXR1cm4gdGhhdFxuICB9XG5cbiAgaWYgKG9iaikge1xuICAgIGlmICgodHlwZW9mIEFycmF5QnVmZmVyICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgICBvYmouYnVmZmVyIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHx8ICdsZW5ndGgnIGluIG9iaikge1xuICAgICAgaWYgKHR5cGVvZiBvYmoubGVuZ3RoICE9PSAnbnVtYmVyJyB8fCBpc25hbihvYmoubGVuZ3RoKSkge1xuICAgICAgICByZXR1cm4gY3JlYXRlQnVmZmVyKHRoYXQsIDApXG4gICAgICB9XG4gICAgICByZXR1cm4gZnJvbUFycmF5TGlrZSh0aGF0LCBvYmopXG4gICAgfVxuXG4gICAgaWYgKG9iai50eXBlID09PSAnQnVmZmVyJyAmJiBpc0FycmF5KG9iai5kYXRhKSkge1xuICAgICAgcmV0dXJuIGZyb21BcnJheUxpa2UodGhhdCwgb2JqLmRhdGEpXG4gICAgfVxuICB9XG5cbiAgdGhyb3cgbmV3IFR5cGVFcnJvcignRmlyc3QgYXJndW1lbnQgbXVzdCBiZSBhIHN0cmluZywgQnVmZmVyLCBBcnJheUJ1ZmZlciwgQXJyYXksIG9yIGFycmF5LWxpa2Ugb2JqZWN0LicpXG59XG5cbmZ1bmN0aW9uIGNoZWNrZWQgKGxlbmd0aCkge1xuICAvLyBOb3RlOiBjYW5ub3QgdXNlIGBsZW5ndGggPCBrTWF4TGVuZ3RoKClgIGhlcmUgYmVjYXVzZSB0aGF0IGZhaWxzIHdoZW5cbiAgLy8gbGVuZ3RoIGlzIE5hTiAod2hpY2ggaXMgb3RoZXJ3aXNlIGNvZXJjZWQgdG8gemVyby4pXG4gIGlmIChsZW5ndGggPj0ga01heExlbmd0aCgpKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0F0dGVtcHQgdG8gYWxsb2NhdGUgQnVmZmVyIGxhcmdlciB0aGFuIG1heGltdW0gJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgJ3NpemU6IDB4JyArIGtNYXhMZW5ndGgoKS50b1N0cmluZygxNikgKyAnIGJ5dGVzJylcbiAgfVxuICByZXR1cm4gbGVuZ3RoIHwgMFxufVxuXG5mdW5jdGlvbiBTbG93QnVmZmVyIChsZW5ndGgpIHtcbiAgaWYgKCtsZW5ndGggIT0gbGVuZ3RoKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgZXFlcWVxXG4gICAgbGVuZ3RoID0gMFxuICB9XG4gIHJldHVybiBCdWZmZXIuYWxsb2MoK2xlbmd0aClcbn1cblxuQnVmZmVyLmlzQnVmZmVyID0gZnVuY3Rpb24gaXNCdWZmZXIgKGIpIHtcbiAgcmV0dXJuICEhKGIgIT0gbnVsbCAmJiBiLl9pc0J1ZmZlcilcbn1cblxuQnVmZmVyLmNvbXBhcmUgPSBmdW5jdGlvbiBjb21wYXJlIChhLCBiKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGEpIHx8ICFCdWZmZXIuaXNCdWZmZXIoYikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudHMgbXVzdCBiZSBCdWZmZXJzJylcbiAgfVxuXG4gIGlmIChhID09PSBiKSByZXR1cm4gMFxuXG4gIHZhciB4ID0gYS5sZW5ndGhcbiAgdmFyIHkgPSBiLmxlbmd0aFxuXG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSBNYXRoLm1pbih4LCB5KTsgaSA8IGxlbjsgKytpKSB7XG4gICAgaWYgKGFbaV0gIT09IGJbaV0pIHtcbiAgICAgIHggPSBhW2ldXG4gICAgICB5ID0gYltpXVxuICAgICAgYnJlYWtcbiAgICB9XG4gIH1cblxuICBpZiAoeCA8IHkpIHJldHVybiAtMVxuICBpZiAoeSA8IHgpIHJldHVybiAxXG4gIHJldHVybiAwXG59XG5cbkJ1ZmZlci5pc0VuY29kaW5nID0gZnVuY3Rpb24gaXNFbmNvZGluZyAoZW5jb2RpbmcpIHtcbiAgc3dpdGNoIChTdHJpbmcoZW5jb2RpbmcpLnRvTG93ZXJDYXNlKCkpIHtcbiAgICBjYXNlICdoZXgnOlxuICAgIGNhc2UgJ3V0ZjgnOlxuICAgIGNhc2UgJ3V0Zi04JzpcbiAgICBjYXNlICdhc2NpaSc6XG4gICAgY2FzZSAnbGF0aW4xJzpcbiAgICBjYXNlICdiaW5hcnknOlxuICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgY2FzZSAndWNzMic6XG4gICAgY2FzZSAndWNzLTInOlxuICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgIHJldHVybiB0cnVlXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBmYWxzZVxuICB9XG59XG5cbkJ1ZmZlci5jb25jYXQgPSBmdW5jdGlvbiBjb25jYXQgKGxpc3QsIGxlbmd0aCkge1xuICBpZiAoIWlzQXJyYXkobGlzdCkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImxpc3RcIiBhcmd1bWVudCBtdXN0IGJlIGFuIEFycmF5IG9mIEJ1ZmZlcnMnKVxuICB9XG5cbiAgaWYgKGxpc3QubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIEJ1ZmZlci5hbGxvYygwKVxuICB9XG5cbiAgdmFyIGlcbiAgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgbGVuZ3RoID0gMFxuICAgIGZvciAoaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgKytpKSB7XG4gICAgICBsZW5ndGggKz0gbGlzdFtpXS5sZW5ndGhcbiAgICB9XG4gIH1cblxuICB2YXIgYnVmZmVyID0gQnVmZmVyLmFsbG9jVW5zYWZlKGxlbmd0aClcbiAgdmFyIHBvcyA9IDBcbiAgZm9yIChpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyArK2kpIHtcbiAgICB2YXIgYnVmID0gbGlzdFtpXVxuICAgIGlmICghQnVmZmVyLmlzQnVmZmVyKGJ1ZikpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wibGlzdFwiIGFyZ3VtZW50IG11c3QgYmUgYW4gQXJyYXkgb2YgQnVmZmVycycpXG4gICAgfVxuICAgIGJ1Zi5jb3B5KGJ1ZmZlciwgcG9zKVxuICAgIHBvcyArPSBidWYubGVuZ3RoXG4gIH1cbiAgcmV0dXJuIGJ1ZmZlclxufVxuXG5mdW5jdGlvbiBieXRlTGVuZ3RoIChzdHJpbmcsIGVuY29kaW5nKSB7XG4gIGlmIChCdWZmZXIuaXNCdWZmZXIoc3RyaW5nKSkge1xuICAgIHJldHVybiBzdHJpbmcubGVuZ3RoXG4gIH1cbiAgaWYgKHR5cGVvZiBBcnJheUJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIEFycmF5QnVmZmVyLmlzVmlldyA9PT0gJ2Z1bmN0aW9uJyAmJlxuICAgICAgKEFycmF5QnVmZmVyLmlzVmlldyhzdHJpbmcpIHx8IHN0cmluZyBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSkge1xuICAgIHJldHVybiBzdHJpbmcuYnl0ZUxlbmd0aFxuICB9XG4gIGlmICh0eXBlb2Ygc3RyaW5nICE9PSAnc3RyaW5nJykge1xuICAgIHN0cmluZyA9ICcnICsgc3RyaW5nXG4gIH1cblxuICB2YXIgbGVuID0gc3RyaW5nLmxlbmd0aFxuICBpZiAobGVuID09PSAwKSByZXR1cm4gMFxuXG4gIC8vIFVzZSBhIGZvciBsb29wIHRvIGF2b2lkIHJlY3Vyc2lvblxuICB2YXIgbG93ZXJlZENhc2UgPSBmYWxzZVxuICBmb3IgKDs7KSB7XG4gICAgc3dpdGNoIChlbmNvZGluZykge1xuICAgICAgY2FzZSAnYXNjaWknOlxuICAgICAgY2FzZSAnbGF0aW4xJzpcbiAgICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICAgIHJldHVybiBsZW5cbiAgICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgY2FzZSAndXRmLTgnOlxuICAgICAgY2FzZSB1bmRlZmluZWQ6XG4gICAgICAgIHJldHVybiB1dGY4VG9CeXRlcyhzdHJpbmcpLmxlbmd0aFxuICAgICAgY2FzZSAndWNzMic6XG4gICAgICBjYXNlICd1Y3MtMic6XG4gICAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgICAgcmV0dXJuIGxlbiAqIDJcbiAgICAgIGNhc2UgJ2hleCc6XG4gICAgICAgIHJldHVybiBsZW4gPj4+IDFcbiAgICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICAgIHJldHVybiBiYXNlNjRUb0J5dGVzKHN0cmluZykubGVuZ3RoXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAobG93ZXJlZENhc2UpIHJldHVybiB1dGY4VG9CeXRlcyhzdHJpbmcpLmxlbmd0aCAvLyBhc3N1bWUgdXRmOFxuICAgICAgICBlbmNvZGluZyA9ICgnJyArIGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpXG4gICAgICAgIGxvd2VyZWRDYXNlID0gdHJ1ZVxuICAgIH1cbiAgfVxufVxuQnVmZmVyLmJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoXG5cbmZ1bmN0aW9uIHNsb3dUb1N0cmluZyAoZW5jb2RpbmcsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGxvd2VyZWRDYXNlID0gZmFsc2VcblxuICAvLyBObyBuZWVkIHRvIHZlcmlmeSB0aGF0IFwidGhpcy5sZW5ndGggPD0gTUFYX1VJTlQzMlwiIHNpbmNlIGl0J3MgYSByZWFkLW9ubHlcbiAgLy8gcHJvcGVydHkgb2YgYSB0eXBlZCBhcnJheS5cblxuICAvLyBUaGlzIGJlaGF2ZXMgbmVpdGhlciBsaWtlIFN0cmluZyBub3IgVWludDhBcnJheSBpbiB0aGF0IHdlIHNldCBzdGFydC9lbmRcbiAgLy8gdG8gdGhlaXIgdXBwZXIvbG93ZXIgYm91bmRzIGlmIHRoZSB2YWx1ZSBwYXNzZWQgaXMgb3V0IG9mIHJhbmdlLlxuICAvLyB1bmRlZmluZWQgaXMgaGFuZGxlZCBzcGVjaWFsbHkgYXMgcGVyIEVDTUEtMjYyIDZ0aCBFZGl0aW9uLFxuICAvLyBTZWN0aW9uIDEzLjMuMy43IFJ1bnRpbWUgU2VtYW50aWNzOiBLZXllZEJpbmRpbmdJbml0aWFsaXphdGlvbi5cbiAgaWYgKHN0YXJ0ID09PSB1bmRlZmluZWQgfHwgc3RhcnQgPCAwKSB7XG4gICAgc3RhcnQgPSAwXG4gIH1cbiAgLy8gUmV0dXJuIGVhcmx5IGlmIHN0YXJ0ID4gdGhpcy5sZW5ndGguIERvbmUgaGVyZSB0byBwcmV2ZW50IHBvdGVudGlhbCB1aW50MzJcbiAgLy8gY29lcmNpb24gZmFpbCBiZWxvdy5cbiAgaWYgKHN0YXJ0ID4gdGhpcy5sZW5ndGgpIHtcbiAgICByZXR1cm4gJydcbiAgfVxuXG4gIGlmIChlbmQgPT09IHVuZGVmaW5lZCB8fCBlbmQgPiB0aGlzLmxlbmd0aCkge1xuICAgIGVuZCA9IHRoaXMubGVuZ3RoXG4gIH1cblxuICBpZiAoZW5kIDw9IDApIHtcbiAgICByZXR1cm4gJydcbiAgfVxuXG4gIC8vIEZvcmNlIGNvZXJzaW9uIHRvIHVpbnQzMi4gVGhpcyB3aWxsIGFsc28gY29lcmNlIGZhbHNleS9OYU4gdmFsdWVzIHRvIDAuXG4gIGVuZCA+Pj49IDBcbiAgc3RhcnQgPj4+PSAwXG5cbiAgaWYgKGVuZCA8PSBzdGFydCkge1xuICAgIHJldHVybiAnJ1xuICB9XG5cbiAgaWYgKCFlbmNvZGluZykgZW5jb2RpbmcgPSAndXRmOCdcblxuICB3aGlsZSAodHJ1ZSkge1xuICAgIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICAgIGNhc2UgJ2hleCc6XG4gICAgICAgIHJldHVybiBoZXhTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICd1dGY4JzpcbiAgICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgICAgcmV0dXJuIHV0ZjhTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICdhc2NpaSc6XG4gICAgICAgIHJldHVybiBhc2NpaVNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgICBjYXNlICdiaW5hcnknOlxuICAgICAgICByZXR1cm4gbGF0aW4xU2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgICAgcmV0dXJuIGJhc2U2NFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ3VjczInOlxuICAgICAgY2FzZSAndWNzLTInOlxuICAgICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICAgIHJldHVybiB1dGYxNmxlU2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKGxvd2VyZWRDYXNlKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gICAgICAgIGVuY29kaW5nID0gKGVuY29kaW5nICsgJycpLnRvTG93ZXJDYXNlKClcbiAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlXG4gICAgfVxuICB9XG59XG5cbi8vIFRoZSBwcm9wZXJ0eSBpcyB1c2VkIGJ5IGBCdWZmZXIuaXNCdWZmZXJgIGFuZCBgaXMtYnVmZmVyYCAoaW4gU2FmYXJpIDUtNykgdG8gZGV0ZWN0XG4vLyBCdWZmZXIgaW5zdGFuY2VzLlxuQnVmZmVyLnByb3RvdHlwZS5faXNCdWZmZXIgPSB0cnVlXG5cbmZ1bmN0aW9uIHN3YXAgKGIsIG4sIG0pIHtcbiAgdmFyIGkgPSBiW25dXG4gIGJbbl0gPSBiW21dXG4gIGJbbV0gPSBpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc3dhcDE2ID0gZnVuY3Rpb24gc3dhcDE2ICgpIHtcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoXG4gIGlmIChsZW4gJSAyICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0J1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiAxNi1iaXRzJylcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSArPSAyKSB7XG4gICAgc3dhcCh0aGlzLCBpLCBpICsgMSlcbiAgfVxuICByZXR1cm4gdGhpc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnN3YXAzMiA9IGZ1bmN0aW9uIHN3YXAzMiAoKSB7XG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aFxuICBpZiAobGVuICUgNCAhPT0gMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgMzItYml0cycpXG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkgKz0gNCkge1xuICAgIHN3YXAodGhpcywgaSwgaSArIDMpXG4gICAgc3dhcCh0aGlzLCBpICsgMSwgaSArIDIpXG4gIH1cbiAgcmV0dXJuIHRoaXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zd2FwNjQgPSBmdW5jdGlvbiBzd2FwNjQgKCkge1xuICB2YXIgbGVuID0gdGhpcy5sZW5ndGhcbiAgaWYgKGxlbiAlIDggIT09IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQnVmZmVyIHNpemUgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDY0LWJpdHMnKVxuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpICs9IDgpIHtcbiAgICBzd2FwKHRoaXMsIGksIGkgKyA3KVxuICAgIHN3YXAodGhpcywgaSArIDEsIGkgKyA2KVxuICAgIHN3YXAodGhpcywgaSArIDIsIGkgKyA1KVxuICAgIHN3YXAodGhpcywgaSArIDMsIGkgKyA0KVxuICB9XG4gIHJldHVybiB0aGlzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZyAoKSB7XG4gIHZhciBsZW5ndGggPSB0aGlzLmxlbmd0aCB8IDBcbiAgaWYgKGxlbmd0aCA9PT0gMCkgcmV0dXJuICcnXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSByZXR1cm4gdXRmOFNsaWNlKHRoaXMsIDAsIGxlbmd0aClcbiAgcmV0dXJuIHNsb3dUb1N0cmluZy5hcHBseSh0aGlzLCBhcmd1bWVudHMpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuZXF1YWxzID0gZnVuY3Rpb24gZXF1YWxzIChiKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGIpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyJylcbiAgaWYgKHRoaXMgPT09IGIpIHJldHVybiB0cnVlXG4gIHJldHVybiBCdWZmZXIuY29tcGFyZSh0aGlzLCBiKSA9PT0gMFxufVxuXG5CdWZmZXIucHJvdG90eXBlLmluc3BlY3QgPSBmdW5jdGlvbiBpbnNwZWN0ICgpIHtcbiAgdmFyIHN0ciA9ICcnXG4gIHZhciBtYXggPSBleHBvcnRzLklOU1BFQ1RfTUFYX0JZVEVTXG4gIGlmICh0aGlzLmxlbmd0aCA+IDApIHtcbiAgICBzdHIgPSB0aGlzLnRvU3RyaW5nKCdoZXgnLCAwLCBtYXgpLm1hdGNoKC8uezJ9L2cpLmpvaW4oJyAnKVxuICAgIGlmICh0aGlzLmxlbmd0aCA+IG1heCkgc3RyICs9ICcgLi4uICdcbiAgfVxuICByZXR1cm4gJzxCdWZmZXIgJyArIHN0ciArICc+J1xufVxuXG5CdWZmZXIucHJvdG90eXBlLmNvbXBhcmUgPSBmdW5jdGlvbiBjb21wYXJlICh0YXJnZXQsIHN0YXJ0LCBlbmQsIHRoaXNTdGFydCwgdGhpc0VuZCkge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcih0YXJnZXQpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBiZSBhIEJ1ZmZlcicpXG4gIH1cblxuICBpZiAoc3RhcnQgPT09IHVuZGVmaW5lZCkge1xuICAgIHN0YXJ0ID0gMFxuICB9XG4gIGlmIChlbmQgPT09IHVuZGVmaW5lZCkge1xuICAgIGVuZCA9IHRhcmdldCA/IHRhcmdldC5sZW5ndGggOiAwXG4gIH1cbiAgaWYgKHRoaXNTdGFydCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdGhpc1N0YXJ0ID0gMFxuICB9XG4gIGlmICh0aGlzRW5kID09PSB1bmRlZmluZWQpIHtcbiAgICB0aGlzRW5kID0gdGhpcy5sZW5ndGhcbiAgfVxuXG4gIGlmIChzdGFydCA8IDAgfHwgZW5kID4gdGFyZ2V0Lmxlbmd0aCB8fCB0aGlzU3RhcnQgPCAwIHx8IHRoaXNFbmQgPiB0aGlzLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdvdXQgb2YgcmFuZ2UgaW5kZXgnKVxuICB9XG5cbiAgaWYgKHRoaXNTdGFydCA+PSB0aGlzRW5kICYmIHN0YXJ0ID49IGVuZCkge1xuICAgIHJldHVybiAwXG4gIH1cbiAgaWYgKHRoaXNTdGFydCA+PSB0aGlzRW5kKSB7XG4gICAgcmV0dXJuIC0xXG4gIH1cbiAgaWYgKHN0YXJ0ID49IGVuZCkge1xuICAgIHJldHVybiAxXG4gIH1cblxuICBzdGFydCA+Pj49IDBcbiAgZW5kID4+Pj0gMFxuICB0aGlzU3RhcnQgPj4+PSAwXG4gIHRoaXNFbmQgPj4+PSAwXG5cbiAgaWYgKHRoaXMgPT09IHRhcmdldCkgcmV0dXJuIDBcblxuICB2YXIgeCA9IHRoaXNFbmQgLSB0aGlzU3RhcnRcbiAgdmFyIHkgPSBlbmQgLSBzdGFydFxuICB2YXIgbGVuID0gTWF0aC5taW4oeCwgeSlcblxuICB2YXIgdGhpc0NvcHkgPSB0aGlzLnNsaWNlKHRoaXNTdGFydCwgdGhpc0VuZClcbiAgdmFyIHRhcmdldENvcHkgPSB0YXJnZXQuc2xpY2Uoc3RhcnQsIGVuZClcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgaWYgKHRoaXNDb3B5W2ldICE9PSB0YXJnZXRDb3B5W2ldKSB7XG4gICAgICB4ID0gdGhpc0NvcHlbaV1cbiAgICAgIHkgPSB0YXJnZXRDb3B5W2ldXG4gICAgICBicmVha1xuICAgIH1cbiAgfVxuXG4gIGlmICh4IDwgeSkgcmV0dXJuIC0xXG4gIGlmICh5IDwgeCkgcmV0dXJuIDFcbiAgcmV0dXJuIDBcbn1cblxuLy8gRmluZHMgZWl0aGVyIHRoZSBmaXJzdCBpbmRleCBvZiBgdmFsYCBpbiBgYnVmZmVyYCBhdCBvZmZzZXQgPj0gYGJ5dGVPZmZzZXRgLFxuLy8gT1IgdGhlIGxhc3QgaW5kZXggb2YgYHZhbGAgaW4gYGJ1ZmZlcmAgYXQgb2Zmc2V0IDw9IGBieXRlT2Zmc2V0YC5cbi8vXG4vLyBBcmd1bWVudHM6XG4vLyAtIGJ1ZmZlciAtIGEgQnVmZmVyIHRvIHNlYXJjaFxuLy8gLSB2YWwgLSBhIHN0cmluZywgQnVmZmVyLCBvciBudW1iZXJcbi8vIC0gYnl0ZU9mZnNldCAtIGFuIGluZGV4IGludG8gYGJ1ZmZlcmA7IHdpbGwgYmUgY2xhbXBlZCB0byBhbiBpbnQzMlxuLy8gLSBlbmNvZGluZyAtIGFuIG9wdGlvbmFsIGVuY29kaW5nLCByZWxldmFudCBpcyB2YWwgaXMgYSBzdHJpbmdcbi8vIC0gZGlyIC0gdHJ1ZSBmb3IgaW5kZXhPZiwgZmFsc2UgZm9yIGxhc3RJbmRleE9mXG5mdW5jdGlvbiBiaWRpcmVjdGlvbmFsSW5kZXhPZiAoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpIHtcbiAgLy8gRW1wdHkgYnVmZmVyIG1lYW5zIG5vIG1hdGNoXG4gIGlmIChidWZmZXIubGVuZ3RoID09PSAwKSByZXR1cm4gLTFcblxuICAvLyBOb3JtYWxpemUgYnl0ZU9mZnNldFxuICBpZiAodHlwZW9mIGJ5dGVPZmZzZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgZW5jb2RpbmcgPSBieXRlT2Zmc2V0XG4gICAgYnl0ZU9mZnNldCA9IDBcbiAgfSBlbHNlIGlmIChieXRlT2Zmc2V0ID4gMHg3ZmZmZmZmZikge1xuICAgIGJ5dGVPZmZzZXQgPSAweDdmZmZmZmZmXG4gIH0gZWxzZSBpZiAoYnl0ZU9mZnNldCA8IC0weDgwMDAwMDAwKSB7XG4gICAgYnl0ZU9mZnNldCA9IC0weDgwMDAwMDAwXG4gIH1cbiAgYnl0ZU9mZnNldCA9ICtieXRlT2Zmc2V0ICAvLyBDb2VyY2UgdG8gTnVtYmVyLlxuICBpZiAoaXNOYU4oYnl0ZU9mZnNldCkpIHtcbiAgICAvLyBieXRlT2Zmc2V0OiBpdCBpdCdzIHVuZGVmaW5lZCwgbnVsbCwgTmFOLCBcImZvb1wiLCBldGMsIHNlYXJjaCB3aG9sZSBidWZmZXJcbiAgICBieXRlT2Zmc2V0ID0gZGlyID8gMCA6IChidWZmZXIubGVuZ3RoIC0gMSlcbiAgfVxuXG4gIC8vIE5vcm1hbGl6ZSBieXRlT2Zmc2V0OiBuZWdhdGl2ZSBvZmZzZXRzIHN0YXJ0IGZyb20gdGhlIGVuZCBvZiB0aGUgYnVmZmVyXG4gIGlmIChieXRlT2Zmc2V0IDwgMCkgYnl0ZU9mZnNldCA9IGJ1ZmZlci5sZW5ndGggKyBieXRlT2Zmc2V0XG4gIGlmIChieXRlT2Zmc2V0ID49IGJ1ZmZlci5sZW5ndGgpIHtcbiAgICBpZiAoZGlyKSByZXR1cm4gLTFcbiAgICBlbHNlIGJ5dGVPZmZzZXQgPSBidWZmZXIubGVuZ3RoIC0gMVxuICB9IGVsc2UgaWYgKGJ5dGVPZmZzZXQgPCAwKSB7XG4gICAgaWYgKGRpcikgYnl0ZU9mZnNldCA9IDBcbiAgICBlbHNlIHJldHVybiAtMVxuICB9XG5cbiAgLy8gTm9ybWFsaXplIHZhbFxuICBpZiAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpIHtcbiAgICB2YWwgPSBCdWZmZXIuZnJvbSh2YWwsIGVuY29kaW5nKVxuICB9XG5cbiAgLy8gRmluYWxseSwgc2VhcmNoIGVpdGhlciBpbmRleE9mIChpZiBkaXIgaXMgdHJ1ZSkgb3IgbGFzdEluZGV4T2ZcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcih2YWwpKSB7XG4gICAgLy8gU3BlY2lhbCBjYXNlOiBsb29raW5nIGZvciBlbXB0eSBzdHJpbmcvYnVmZmVyIGFsd2F5cyBmYWlsc1xuICAgIGlmICh2YWwubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gLTFcbiAgICB9XG4gICAgcmV0dXJuIGFycmF5SW5kZXhPZihidWZmZXIsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcilcbiAgfSBlbHNlIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xuICAgIHZhbCA9IHZhbCAmIDB4RkYgLy8gU2VhcmNoIGZvciBhIGJ5dGUgdmFsdWUgWzAtMjU1XVxuICAgIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCAmJlxuICAgICAgICB0eXBlb2YgVWludDhBcnJheS5wcm90b3R5cGUuaW5kZXhPZiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgaWYgKGRpcikge1xuICAgICAgICByZXR1cm4gVWludDhBcnJheS5wcm90b3R5cGUuaW5kZXhPZi5jYWxsKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0KVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIFVpbnQ4QXJyYXkucHJvdG90eXBlLmxhc3RJbmRleE9mLmNhbGwoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQpXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBhcnJheUluZGV4T2YoYnVmZmVyLCBbIHZhbCBdLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKVxuICB9XG5cbiAgdGhyb3cgbmV3IFR5cGVFcnJvcigndmFsIG11c3QgYmUgc3RyaW5nLCBudW1iZXIgb3IgQnVmZmVyJylcbn1cblxuZnVuY3Rpb24gYXJyYXlJbmRleE9mIChhcnIsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcikge1xuICB2YXIgaW5kZXhTaXplID0gMVxuICB2YXIgYXJyTGVuZ3RoID0gYXJyLmxlbmd0aFxuICB2YXIgdmFsTGVuZ3RoID0gdmFsLmxlbmd0aFxuXG4gIGlmIChlbmNvZGluZyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgZW5jb2RpbmcgPSBTdHJpbmcoZW5jb2RpbmcpLnRvTG93ZXJDYXNlKClcbiAgICBpZiAoZW5jb2RpbmcgPT09ICd1Y3MyJyB8fCBlbmNvZGluZyA9PT0gJ3Vjcy0yJyB8fFxuICAgICAgICBlbmNvZGluZyA9PT0gJ3V0ZjE2bGUnIHx8IGVuY29kaW5nID09PSAndXRmLTE2bGUnKSB7XG4gICAgICBpZiAoYXJyLmxlbmd0aCA8IDIgfHwgdmFsLmxlbmd0aCA8IDIpIHtcbiAgICAgICAgcmV0dXJuIC0xXG4gICAgICB9XG4gICAgICBpbmRleFNpemUgPSAyXG4gICAgICBhcnJMZW5ndGggLz0gMlxuICAgICAgdmFsTGVuZ3RoIC89IDJcbiAgICAgIGJ5dGVPZmZzZXQgLz0gMlxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlYWQgKGJ1ZiwgaSkge1xuICAgIGlmIChpbmRleFNpemUgPT09IDEpIHtcbiAgICAgIHJldHVybiBidWZbaV1cbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGJ1Zi5yZWFkVUludDE2QkUoaSAqIGluZGV4U2l6ZSlcbiAgICB9XG4gIH1cblxuICB2YXIgaVxuICBpZiAoZGlyKSB7XG4gICAgdmFyIGZvdW5kSW5kZXggPSAtMVxuICAgIGZvciAoaSA9IGJ5dGVPZmZzZXQ7IGkgPCBhcnJMZW5ndGg7IGkrKykge1xuICAgICAgaWYgKHJlYWQoYXJyLCBpKSA9PT0gcmVhZCh2YWwsIGZvdW5kSW5kZXggPT09IC0xID8gMCA6IGkgLSBmb3VuZEluZGV4KSkge1xuICAgICAgICBpZiAoZm91bmRJbmRleCA9PT0gLTEpIGZvdW5kSW5kZXggPSBpXG4gICAgICAgIGlmIChpIC0gZm91bmRJbmRleCArIDEgPT09IHZhbExlbmd0aCkgcmV0dXJuIGZvdW5kSW5kZXggKiBpbmRleFNpemVcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChmb3VuZEluZGV4ICE9PSAtMSkgaSAtPSBpIC0gZm91bmRJbmRleFxuICAgICAgICBmb3VuZEluZGV4ID0gLTFcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKGJ5dGVPZmZzZXQgKyB2YWxMZW5ndGggPiBhcnJMZW5ndGgpIGJ5dGVPZmZzZXQgPSBhcnJMZW5ndGggLSB2YWxMZW5ndGhcbiAgICBmb3IgKGkgPSBieXRlT2Zmc2V0OyBpID49IDA7IGktLSkge1xuICAgICAgdmFyIGZvdW5kID0gdHJ1ZVxuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCB2YWxMZW5ndGg7IGorKykge1xuICAgICAgICBpZiAocmVhZChhcnIsIGkgKyBqKSAhPT0gcmVhZCh2YWwsIGopKSB7XG4gICAgICAgICAgZm91bmQgPSBmYWxzZVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChmb3VuZCkgcmV0dXJuIGlcbiAgICB9XG4gIH1cblxuICByZXR1cm4gLTFcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5pbmNsdWRlcyA9IGZ1bmN0aW9uIGluY2x1ZGVzICh2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSB7XG4gIHJldHVybiB0aGlzLmluZGV4T2YodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykgIT09IC0xXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuaW5kZXhPZiA9IGZ1bmN0aW9uIGluZGV4T2YgKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIGJpZGlyZWN0aW9uYWxJbmRleE9mKHRoaXMsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIHRydWUpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUubGFzdEluZGV4T2YgPSBmdW5jdGlvbiBsYXN0SW5kZXhPZiAodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykge1xuICByZXR1cm4gYmlkaXJlY3Rpb25hbEluZGV4T2YodGhpcywgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZmFsc2UpXG59XG5cbmZ1bmN0aW9uIGhleFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgb2Zmc2V0ID0gTnVtYmVyKG9mZnNldCkgfHwgMFxuICB2YXIgcmVtYWluaW5nID0gYnVmLmxlbmd0aCAtIG9mZnNldFxuICBpZiAoIWxlbmd0aCkge1xuICAgIGxlbmd0aCA9IHJlbWFpbmluZ1xuICB9IGVsc2Uge1xuICAgIGxlbmd0aCA9IE51bWJlcihsZW5ndGgpXG4gICAgaWYgKGxlbmd0aCA+IHJlbWFpbmluZykge1xuICAgICAgbGVuZ3RoID0gcmVtYWluaW5nXG4gICAgfVxuICB9XG5cbiAgLy8gbXVzdCBiZSBhbiBldmVuIG51bWJlciBvZiBkaWdpdHNcbiAgdmFyIHN0ckxlbiA9IHN0cmluZy5sZW5ndGhcbiAgaWYgKHN0ckxlbiAlIDIgIT09IDApIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgaGV4IHN0cmluZycpXG5cbiAgaWYgKGxlbmd0aCA+IHN0ckxlbiAvIDIpIHtcbiAgICBsZW5ndGggPSBzdHJMZW4gLyAyXG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgIHZhciBwYXJzZWQgPSBwYXJzZUludChzdHJpbmcuc3Vic3RyKGkgKiAyLCAyKSwgMTYpXG4gICAgaWYgKGlzTmFOKHBhcnNlZCkpIHJldHVybiBpXG4gICAgYnVmW29mZnNldCArIGldID0gcGFyc2VkXG4gIH1cbiAgcmV0dXJuIGlcbn1cblxuZnVuY3Rpb24gdXRmOFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIodXRmOFRvQnl0ZXMoc3RyaW5nLCBidWYubGVuZ3RoIC0gb2Zmc2V0KSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gYXNjaWlXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKGFzY2lpVG9CeXRlcyhzdHJpbmcpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiBsYXRpbjFXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBhc2NpaVdyaXRlKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gYmFzZTY0V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcihiYXNlNjRUb0J5dGVzKHN0cmluZyksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIHVjczJXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKHV0ZjE2bGVUb0J5dGVzKHN0cmluZywgYnVmLmxlbmd0aCAtIG9mZnNldCksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbiB3cml0ZSAoc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCwgZW5jb2RpbmcpIHtcbiAgLy8gQnVmZmVyI3dyaXRlKHN0cmluZylcbiAgaWYgKG9mZnNldCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZW5jb2RpbmcgPSAndXRmOCdcbiAgICBsZW5ndGggPSB0aGlzLmxlbmd0aFxuICAgIG9mZnNldCA9IDBcbiAgLy8gQnVmZmVyI3dyaXRlKHN0cmluZywgZW5jb2RpbmcpXG4gIH0gZWxzZSBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQgJiYgdHlwZW9mIG9mZnNldCA9PT0gJ3N0cmluZycpIHtcbiAgICBlbmNvZGluZyA9IG9mZnNldFxuICAgIGxlbmd0aCA9IHRoaXMubGVuZ3RoXG4gICAgb2Zmc2V0ID0gMFxuICAvLyBCdWZmZXIjd3JpdGUoc3RyaW5nLCBvZmZzZXRbLCBsZW5ndGhdWywgZW5jb2RpbmddKVxuICB9IGVsc2UgaWYgKGlzRmluaXRlKG9mZnNldCkpIHtcbiAgICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gICAgaWYgKGlzRmluaXRlKGxlbmd0aCkpIHtcbiAgICAgIGxlbmd0aCA9IGxlbmd0aCB8IDBcbiAgICAgIGlmIChlbmNvZGluZyA9PT0gdW5kZWZpbmVkKSBlbmNvZGluZyA9ICd1dGY4J1xuICAgIH0gZWxzZSB7XG4gICAgICBlbmNvZGluZyA9IGxlbmd0aFxuICAgICAgbGVuZ3RoID0gdW5kZWZpbmVkXG4gICAgfVxuICAvLyBsZWdhY3kgd3JpdGUoc3RyaW5nLCBlbmNvZGluZywgb2Zmc2V0LCBsZW5ndGgpIC0gcmVtb3ZlIGluIHYwLjEzXG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgJ0J1ZmZlci53cml0ZShzdHJpbmcsIGVuY29kaW5nLCBvZmZzZXRbLCBsZW5ndGhdKSBpcyBubyBsb25nZXIgc3VwcG9ydGVkJ1xuICAgIClcbiAgfVxuXG4gIHZhciByZW1haW5pbmcgPSB0aGlzLmxlbmd0aCAtIG9mZnNldFxuICBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQgfHwgbGVuZ3RoID4gcmVtYWluaW5nKSBsZW5ndGggPSByZW1haW5pbmdcblxuICBpZiAoKHN0cmluZy5sZW5ndGggPiAwICYmIChsZW5ndGggPCAwIHx8IG9mZnNldCA8IDApKSB8fCBvZmZzZXQgPiB0aGlzLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdBdHRlbXB0IHRvIHdyaXRlIG91dHNpZGUgYnVmZmVyIGJvdW5kcycpXG4gIH1cblxuICBpZiAoIWVuY29kaW5nKSBlbmNvZGluZyA9ICd1dGY4J1xuXG4gIHZhciBsb3dlcmVkQ2FzZSA9IGZhbHNlXG4gIGZvciAoOzspIHtcbiAgICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgICBjYXNlICdoZXgnOlxuICAgICAgICByZXR1cm4gaGV4V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAndXRmOCc6XG4gICAgICBjYXNlICd1dGYtOCc6XG4gICAgICAgIHJldHVybiB1dGY4V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAnYXNjaWknOlxuICAgICAgICByZXR1cm4gYXNjaWlXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICdsYXRpbjEnOlxuICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgICAgcmV0dXJuIGxhdGluMVdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICAgIC8vIFdhcm5pbmc6IG1heExlbmd0aCBub3QgdGFrZW4gaW50byBhY2NvdW50IGluIGJhc2U2NFdyaXRlXG4gICAgICAgIHJldHVybiBiYXNlNjRXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICd1Y3MyJzpcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgICByZXR1cm4gdWNzMldyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChsb3dlcmVkQ2FzZSkgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKVxuICAgICAgICBlbmNvZGluZyA9ICgnJyArIGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpXG4gICAgICAgIGxvd2VyZWRDYXNlID0gdHJ1ZVxuICAgIH1cbiAgfVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uIHRvSlNPTiAoKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogJ0J1ZmZlcicsXG4gICAgZGF0YTogQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwodGhpcy5fYXJyIHx8IHRoaXMsIDApXG4gIH1cbn1cblxuZnVuY3Rpb24gYmFzZTY0U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICBpZiAoc3RhcnQgPT09IDAgJiYgZW5kID09PSBidWYubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGJhc2U2NC5mcm9tQnl0ZUFycmF5KGJ1ZilcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gYmFzZTY0LmZyb21CeXRlQXJyYXkoYnVmLnNsaWNlKHN0YXJ0LCBlbmQpKVxuICB9XG59XG5cbmZ1bmN0aW9uIHV0ZjhTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZClcbiAgdmFyIHJlcyA9IFtdXG5cbiAgdmFyIGkgPSBzdGFydFxuICB3aGlsZSAoaSA8IGVuZCkge1xuICAgIHZhciBmaXJzdEJ5dGUgPSBidWZbaV1cbiAgICB2YXIgY29kZVBvaW50ID0gbnVsbFxuICAgIHZhciBieXRlc1BlclNlcXVlbmNlID0gKGZpcnN0Qnl0ZSA+IDB4RUYpID8gNFxuICAgICAgOiAoZmlyc3RCeXRlID4gMHhERikgPyAzXG4gICAgICA6IChmaXJzdEJ5dGUgPiAweEJGKSA/IDJcbiAgICAgIDogMVxuXG4gICAgaWYgKGkgKyBieXRlc1BlclNlcXVlbmNlIDw9IGVuZCkge1xuICAgICAgdmFyIHNlY29uZEJ5dGUsIHRoaXJkQnl0ZSwgZm91cnRoQnl0ZSwgdGVtcENvZGVQb2ludFxuXG4gICAgICBzd2l0Y2ggKGJ5dGVzUGVyU2VxdWVuY2UpIHtcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIGlmIChmaXJzdEJ5dGUgPCAweDgwKSB7XG4gICAgICAgICAgICBjb2RlUG9pbnQgPSBmaXJzdEJ5dGVcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgIHNlY29uZEJ5dGUgPSBidWZbaSArIDFdXG4gICAgICAgICAgaWYgKChzZWNvbmRCeXRlICYgMHhDMCkgPT09IDB4ODApIHtcbiAgICAgICAgICAgIHRlbXBDb2RlUG9pbnQgPSAoZmlyc3RCeXRlICYgMHgxRikgPDwgMHg2IHwgKHNlY29uZEJ5dGUgJiAweDNGKVxuICAgICAgICAgICAgaWYgKHRlbXBDb2RlUG9pbnQgPiAweDdGKSB7XG4gICAgICAgICAgICAgIGNvZGVQb2ludCA9IHRlbXBDb2RlUG9pbnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgIHNlY29uZEJ5dGUgPSBidWZbaSArIDFdXG4gICAgICAgICAgdGhpcmRCeXRlID0gYnVmW2kgKyAyXVxuICAgICAgICAgIGlmICgoc2Vjb25kQnl0ZSAmIDB4QzApID09PSAweDgwICYmICh0aGlyZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCkge1xuICAgICAgICAgICAgdGVtcENvZGVQb2ludCA9IChmaXJzdEJ5dGUgJiAweEYpIDw8IDB4QyB8IChzZWNvbmRCeXRlICYgMHgzRikgPDwgMHg2IHwgKHRoaXJkQnl0ZSAmIDB4M0YpXG4gICAgICAgICAgICBpZiAodGVtcENvZGVQb2ludCA+IDB4N0ZGICYmICh0ZW1wQ29kZVBvaW50IDwgMHhEODAwIHx8IHRlbXBDb2RlUG9pbnQgPiAweERGRkYpKSB7XG4gICAgICAgICAgICAgIGNvZGVQb2ludCA9IHRlbXBDb2RlUG9pbnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSA0OlxuICAgICAgICAgIHNlY29uZEJ5dGUgPSBidWZbaSArIDFdXG4gICAgICAgICAgdGhpcmRCeXRlID0gYnVmW2kgKyAyXVxuICAgICAgICAgIGZvdXJ0aEJ5dGUgPSBidWZbaSArIDNdXG4gICAgICAgICAgaWYgKChzZWNvbmRCeXRlICYgMHhDMCkgPT09IDB4ODAgJiYgKHRoaXJkQnl0ZSAmIDB4QzApID09PSAweDgwICYmIChmb3VydGhCeXRlICYgMHhDMCkgPT09IDB4ODApIHtcbiAgICAgICAgICAgIHRlbXBDb2RlUG9pbnQgPSAoZmlyc3RCeXRlICYgMHhGKSA8PCAweDEyIHwgKHNlY29uZEJ5dGUgJiAweDNGKSA8PCAweEMgfCAodGhpcmRCeXRlICYgMHgzRikgPDwgMHg2IHwgKGZvdXJ0aEJ5dGUgJiAweDNGKVxuICAgICAgICAgICAgaWYgKHRlbXBDb2RlUG9pbnQgPiAweEZGRkYgJiYgdGVtcENvZGVQb2ludCA8IDB4MTEwMDAwKSB7XG4gICAgICAgICAgICAgIGNvZGVQb2ludCA9IHRlbXBDb2RlUG9pbnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGNvZGVQb2ludCA9PT0gbnVsbCkge1xuICAgICAgLy8gd2UgZGlkIG5vdCBnZW5lcmF0ZSBhIHZhbGlkIGNvZGVQb2ludCBzbyBpbnNlcnQgYVxuICAgICAgLy8gcmVwbGFjZW1lbnQgY2hhciAoVStGRkZEKSBhbmQgYWR2YW5jZSBvbmx5IDEgYnl0ZVxuICAgICAgY29kZVBvaW50ID0gMHhGRkZEXG4gICAgICBieXRlc1BlclNlcXVlbmNlID0gMVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50ID4gMHhGRkZGKSB7XG4gICAgICAvLyBlbmNvZGUgdG8gdXRmMTYgKHN1cnJvZ2F0ZSBwYWlyIGRhbmNlKVxuICAgICAgY29kZVBvaW50IC09IDB4MTAwMDBcbiAgICAgIHJlcy5wdXNoKGNvZGVQb2ludCA+Pj4gMTAgJiAweDNGRiB8IDB4RDgwMClcbiAgICAgIGNvZGVQb2ludCA9IDB4REMwMCB8IGNvZGVQb2ludCAmIDB4M0ZGXG4gICAgfVxuXG4gICAgcmVzLnB1c2goY29kZVBvaW50KVxuICAgIGkgKz0gYnl0ZXNQZXJTZXF1ZW5jZVxuICB9XG5cbiAgcmV0dXJuIGRlY29kZUNvZGVQb2ludHNBcnJheShyZXMpXG59XG5cbi8vIEJhc2VkIG9uIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzIyNzQ3MjcyLzY4MDc0MiwgdGhlIGJyb3dzZXIgd2l0aFxuLy8gdGhlIGxvd2VzdCBsaW1pdCBpcyBDaHJvbWUsIHdpdGggMHgxMDAwMCBhcmdzLlxuLy8gV2UgZ28gMSBtYWduaXR1ZGUgbGVzcywgZm9yIHNhZmV0eVxudmFyIE1BWF9BUkdVTUVOVFNfTEVOR1RIID0gMHgxMDAwXG5cbmZ1bmN0aW9uIGRlY29kZUNvZGVQb2ludHNBcnJheSAoY29kZVBvaW50cykge1xuICB2YXIgbGVuID0gY29kZVBvaW50cy5sZW5ndGhcbiAgaWYgKGxlbiA8PSBNQVhfQVJHVU1FTlRTX0xFTkdUSCkge1xuICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFN0cmluZywgY29kZVBvaW50cykgLy8gYXZvaWQgZXh0cmEgc2xpY2UoKVxuICB9XG5cbiAgLy8gRGVjb2RlIGluIGNodW5rcyB0byBhdm9pZCBcImNhbGwgc3RhY2sgc2l6ZSBleGNlZWRlZFwiLlxuICB2YXIgcmVzID0gJydcbiAgdmFyIGkgPSAwXG4gIHdoaWxlIChpIDwgbGVuKSB7XG4gICAgcmVzICs9IFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoXG4gICAgICBTdHJpbmcsXG4gICAgICBjb2RlUG9pbnRzLnNsaWNlKGksIGkgKz0gTUFYX0FSR1VNRU5UU19MRU5HVEgpXG4gICAgKVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuZnVuY3Rpb24gYXNjaWlTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciByZXQgPSAnJ1xuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpXG5cbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICByZXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShidWZbaV0gJiAweDdGKVxuICB9XG4gIHJldHVybiByZXRcbn1cblxuZnVuY3Rpb24gbGF0aW4xU2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgcmV0ID0gJydcbiAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKVxuXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgcmV0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnVmW2ldKVxuICB9XG4gIHJldHVybiByZXRcbn1cblxuZnVuY3Rpb24gaGV4U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgbGVuID0gYnVmLmxlbmd0aFxuXG4gIGlmICghc3RhcnQgfHwgc3RhcnQgPCAwKSBzdGFydCA9IDBcbiAgaWYgKCFlbmQgfHwgZW5kIDwgMCB8fCBlbmQgPiBsZW4pIGVuZCA9IGxlblxuXG4gIHZhciBvdXQgPSAnJ1xuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgIG91dCArPSB0b0hleChidWZbaV0pXG4gIH1cbiAgcmV0dXJuIG91dFxufVxuXG5mdW5jdGlvbiB1dGYxNmxlU2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgYnl0ZXMgPSBidWYuc2xpY2Uoc3RhcnQsIGVuZClcbiAgdmFyIHJlcyA9ICcnXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICByZXMgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShieXRlc1tpXSArIGJ5dGVzW2kgKyAxXSAqIDI1NilcbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc2xpY2UgPSBmdW5jdGlvbiBzbGljZSAoc3RhcnQsIGVuZCkge1xuICB2YXIgbGVuID0gdGhpcy5sZW5ndGhcbiAgc3RhcnQgPSB+fnN0YXJ0XG4gIGVuZCA9IGVuZCA9PT0gdW5kZWZpbmVkID8gbGVuIDogfn5lbmRcblxuICBpZiAoc3RhcnQgPCAwKSB7XG4gICAgc3RhcnQgKz0gbGVuXG4gICAgaWYgKHN0YXJ0IDwgMCkgc3RhcnQgPSAwXG4gIH0gZWxzZSBpZiAoc3RhcnQgPiBsZW4pIHtcbiAgICBzdGFydCA9IGxlblxuICB9XG5cbiAgaWYgKGVuZCA8IDApIHtcbiAgICBlbmQgKz0gbGVuXG4gICAgaWYgKGVuZCA8IDApIGVuZCA9IDBcbiAgfSBlbHNlIGlmIChlbmQgPiBsZW4pIHtcbiAgICBlbmQgPSBsZW5cbiAgfVxuXG4gIGlmIChlbmQgPCBzdGFydCkgZW5kID0gc3RhcnRcblxuICB2YXIgbmV3QnVmXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIG5ld0J1ZiA9IHRoaXMuc3ViYXJyYXkoc3RhcnQsIGVuZClcbiAgICBuZXdCdWYuX19wcm90b19fID0gQnVmZmVyLnByb3RvdHlwZVxuICB9IGVsc2Uge1xuICAgIHZhciBzbGljZUxlbiA9IGVuZCAtIHN0YXJ0XG4gICAgbmV3QnVmID0gbmV3IEJ1ZmZlcihzbGljZUxlbiwgdW5kZWZpbmVkKVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2xpY2VMZW47ICsraSkge1xuICAgICAgbmV3QnVmW2ldID0gdGhpc1tpICsgc3RhcnRdXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5ld0J1ZlxufVxuXG4vKlxuICogTmVlZCB0byBtYWtlIHN1cmUgdGhhdCBidWZmZXIgaXNuJ3QgdHJ5aW5nIHRvIHdyaXRlIG91dCBvZiBib3VuZHMuXG4gKi9cbmZ1bmN0aW9uIGNoZWNrT2Zmc2V0IChvZmZzZXQsIGV4dCwgbGVuZ3RoKSB7XG4gIGlmICgob2Zmc2V0ICUgMSkgIT09IDAgfHwgb2Zmc2V0IDwgMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ29mZnNldCBpcyBub3QgdWludCcpXG4gIGlmIChvZmZzZXQgKyBleHQgPiBsZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdUcnlpbmcgdG8gYWNjZXNzIGJleW9uZCBidWZmZXIgbGVuZ3RoJylcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludExFID0gZnVuY3Rpb24gcmVhZFVJbnRMRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldF1cbiAgdmFyIG11bCA9IDFcbiAgdmFyIGkgPSAwXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgaV0gKiBtdWxcbiAgfVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludEJFID0gZnVuY3Rpb24gcmVhZFVJbnRCRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcbiAgfVxuXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldCArIC0tYnl0ZUxlbmd0aF1cbiAgdmFyIG11bCA9IDFcbiAgd2hpbGUgKGJ5dGVMZW5ndGggPiAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgLS1ieXRlTGVuZ3RoXSAqIG11bFxuICB9XG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50OCA9IGZ1bmN0aW9uIHJlYWRVSW50OCAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDEsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gdGhpc1tvZmZzZXRdXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQxNkxFID0gZnVuY3Rpb24gcmVhZFVJbnQxNkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiB0aGlzW29mZnNldF0gfCAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MTZCRSA9IGZ1bmN0aW9uIHJlYWRVSW50MTZCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSA8PCA4KSB8IHRoaXNbb2Zmc2V0ICsgMV1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDMyTEUgPSBmdW5jdGlvbiByZWFkVUludDMyTEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKCh0aGlzW29mZnNldF0pIHxcbiAgICAgICh0aGlzW29mZnNldCArIDFdIDw8IDgpIHxcbiAgICAgICh0aGlzW29mZnNldCArIDJdIDw8IDE2KSkgK1xuICAgICAgKHRoaXNbb2Zmc2V0ICsgM10gKiAweDEwMDAwMDApXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQzMkJFID0gZnVuY3Rpb24gcmVhZFVJbnQzMkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICh0aGlzW29mZnNldF0gKiAweDEwMDAwMDApICtcbiAgICAoKHRoaXNbb2Zmc2V0ICsgMV0gPDwgMTYpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCA4KSB8XG4gICAgdGhpc1tvZmZzZXQgKyAzXSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50TEUgPSBmdW5jdGlvbiByZWFkSW50TEUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcblxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXRdXG4gIHZhciBtdWwgPSAxXG4gIHZhciBpID0gMFxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIGldICogbXVsXG4gIH1cbiAgbXVsICo9IDB4ODBcblxuICBpZiAodmFsID49IG11bCkgdmFsIC09IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50QkUgPSBmdW5jdGlvbiByZWFkSW50QkUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcblxuICB2YXIgaSA9IGJ5dGVMZW5ndGhcbiAgdmFyIG11bCA9IDFcbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0ICsgLS1pXVxuICB3aGlsZSAoaSA+IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyAtLWldICogbXVsXG4gIH1cbiAgbXVsICo9IDB4ODBcblxuICBpZiAodmFsID49IG11bCkgdmFsIC09IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50OCA9IGZ1bmN0aW9uIHJlYWRJbnQ4IChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMSwgdGhpcy5sZW5ndGgpXG4gIGlmICghKHRoaXNbb2Zmc2V0XSAmIDB4ODApKSByZXR1cm4gKHRoaXNbb2Zmc2V0XSlcbiAgcmV0dXJuICgoMHhmZiAtIHRoaXNbb2Zmc2V0XSArIDEpICogLTEpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDE2TEUgPSBmdW5jdGlvbiByZWFkSW50MTZMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXRdIHwgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOClcbiAgcmV0dXJuICh2YWwgJiAweDgwMDApID8gdmFsIHwgMHhGRkZGMDAwMCA6IHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQxNkJFID0gZnVuY3Rpb24gcmVhZEludDE2QkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0ICsgMV0gfCAodGhpc1tvZmZzZXRdIDw8IDgpXG4gIHJldHVybiAodmFsICYgMHg4MDAwKSA/IHZhbCB8IDB4RkZGRjAwMDAgOiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MzJMRSA9IGZ1bmN0aW9uIHJlYWRJbnQzMkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICh0aGlzW29mZnNldF0pIHxcbiAgICAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgMTYpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAzXSA8PCAyNClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MzJCRSA9IGZ1bmN0aW9uIHJlYWRJbnQzMkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICh0aGlzW29mZnNldF0gPDwgMjQpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAxXSA8PCAxNikgfFxuICAgICh0aGlzW29mZnNldCArIDJdIDw8IDgpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAzXSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRmxvYXRMRSA9IGZ1bmN0aW9uIHJlYWRGbG9hdExFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCB0cnVlLCAyMywgNClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRmxvYXRCRSA9IGZ1bmN0aW9uIHJlYWRGbG9hdEJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCBmYWxzZSwgMjMsIDQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZERvdWJsZUxFID0gZnVuY3Rpb24gcmVhZERvdWJsZUxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgOCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCB0cnVlLCA1MiwgOClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRG91YmxlQkUgPSBmdW5jdGlvbiByZWFkRG91YmxlQkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA4LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIGZhbHNlLCA1MiwgOClcbn1cblxuZnVuY3Rpb24gY2hlY2tJbnQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgZXh0LCBtYXgsIG1pbikge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihidWYpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImJ1ZmZlclwiIGFyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXIgaW5zdGFuY2UnKVxuICBpZiAodmFsdWUgPiBtYXggfHwgdmFsdWUgPCBtaW4pIHRocm93IG5ldyBSYW5nZUVycm9yKCdcInZhbHVlXCIgYXJndW1lbnQgaXMgb3V0IG9mIGJvdW5kcycpXG4gIGlmIChvZmZzZXQgKyBleHQgPiBidWYubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJylcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnRMRSA9IGZ1bmN0aW9uIHdyaXRlVUludExFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgdmFyIG1heEJ5dGVzID0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpIC0gMVxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG1heEJ5dGVzLCAwKVxuICB9XG5cbiAgdmFyIG11bCA9IDFcbiAgdmFyIGkgPSAwXG4gIHRoaXNbb2Zmc2V0XSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAodmFsdWUgLyBtdWwpICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnRCRSA9IGZ1bmN0aW9uIHdyaXRlVUludEJFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgdmFyIG1heEJ5dGVzID0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpIC0gMVxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG1heEJ5dGVzLCAwKVxuICB9XG5cbiAgdmFyIGkgPSBieXRlTGVuZ3RoIC0gMVxuICB2YXIgbXVsID0gMVxuICB0aGlzW29mZnNldCArIGldID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgtLWkgPj0gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAodmFsdWUgLyBtdWwpICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQ4ID0gZnVuY3Rpb24gd3JpdGVVSW50OCAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAxLCAweGZmLCAwKVxuICBpZiAoIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB2YWx1ZSA9IE1hdGguZmxvb3IodmFsdWUpXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyAxXG59XG5cbmZ1bmN0aW9uIG9iamVjdFdyaXRlVUludDE2IChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbikge1xuICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmZmZiArIHZhbHVlICsgMVxuICBmb3IgKHZhciBpID0gMCwgaiA9IE1hdGgubWluKGJ1Zi5sZW5ndGggLSBvZmZzZXQsIDIpOyBpIDwgajsgKytpKSB7XG4gICAgYnVmW29mZnNldCArIGldID0gKHZhbHVlICYgKDB4ZmYgPDwgKDggKiAobGl0dGxlRW5kaWFuID8gaSA6IDEgLSBpKSkpKSA+Pj5cbiAgICAgIChsaXR0bGVFbmRpYW4gPyBpIDogMSAtIGkpICogOFxuICB9XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MTZMRSA9IGZ1bmN0aW9uIHdyaXRlVUludDE2TEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHhmZmZmLCAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDE2QkUgPSBmdW5jdGlvbiB3cml0ZVVJbnQxNkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4ZmZmZiwgMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgJiAweGZmKVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDE2KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbmZ1bmN0aW9uIG9iamVjdFdyaXRlVUludDMyIChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbikge1xuICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmZmZmZmZmYgKyB2YWx1ZSArIDFcbiAgZm9yICh2YXIgaSA9IDAsIGogPSBNYXRoLm1pbihidWYubGVuZ3RoIC0gb2Zmc2V0LCA0KTsgaSA8IGo7ICsraSkge1xuICAgIGJ1ZltvZmZzZXQgKyBpXSA9ICh2YWx1ZSA+Pj4gKGxpdHRsZUVuZGlhbiA/IGkgOiAzIC0gaSkgKiA4KSAmIDB4ZmZcbiAgfVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDMyTEUgPSBmdW5jdGlvbiB3cml0ZVVJbnQzMkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4ZmZmZmZmZmYsIDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgPj4+IDI0KVxuICAgIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDE2KVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MzJCRSA9IGZ1bmN0aW9uIHdyaXRlVUludDMyQkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHhmZmZmZmZmZiwgMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiAyNClcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiAxNilcbiAgICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgJiAweGZmKVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDMyKHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnRMRSA9IGZ1bmN0aW9uIHdyaXRlSW50TEUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIHZhciBsaW1pdCA9IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoIC0gMSlcblxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIGxpbWl0IC0gMSwgLWxpbWl0KVxuICB9XG5cbiAgdmFyIGkgPSAwXG4gIHZhciBtdWwgPSAxXG4gIHZhciBzdWIgPSAwXG4gIHRoaXNbb2Zmc2V0XSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIGlmICh2YWx1ZSA8IDAgJiYgc3ViID09PSAwICYmIHRoaXNbb2Zmc2V0ICsgaSAtIDFdICE9PSAwKSB7XG4gICAgICBzdWIgPSAxXG4gICAgfVxuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAoKHZhbHVlIC8gbXVsKSA+PiAwKSAtIHN1YiAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnRCRSA9IGZ1bmN0aW9uIHdyaXRlSW50QkUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIHZhciBsaW1pdCA9IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoIC0gMSlcblxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIGxpbWl0IC0gMSwgLWxpbWl0KVxuICB9XG5cbiAgdmFyIGkgPSBieXRlTGVuZ3RoIC0gMVxuICB2YXIgbXVsID0gMVxuICB2YXIgc3ViID0gMFxuICB0aGlzW29mZnNldCArIGldID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgtLWkgPj0gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIGlmICh2YWx1ZSA8IDAgJiYgc3ViID09PSAwICYmIHRoaXNbb2Zmc2V0ICsgaSArIDFdICE9PSAwKSB7XG4gICAgICBzdWIgPSAxXG4gICAgfVxuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAoKHZhbHVlIC8gbXVsKSA+PiAwKSAtIHN1YiAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQ4ID0gZnVuY3Rpb24gd3JpdGVJbnQ4ICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDEsIDB4N2YsIC0weDgwKVxuICBpZiAoIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB2YWx1ZSA9IE1hdGguZmxvb3IodmFsdWUpXG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZiArIHZhbHVlICsgMVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgMVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MTZMRSA9IGZ1bmN0aW9uIHdyaXRlSW50MTZMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweDdmZmYsIC0weDgwMDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQxNkJFID0gZnVuY3Rpb24gd3JpdGVJbnQxNkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4N2ZmZiwgLTB4ODAwMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgJiAweGZmKVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDE2KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQzMkxFID0gZnVuY3Rpb24gd3JpdGVJbnQzMkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4N2ZmZmZmZmYsIC0weDgwMDAwMDAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gICAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gICAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSA+Pj4gMjQpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MzJCRSA9IGZ1bmN0aW9uIHdyaXRlSW50MzJCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweDdmZmZmZmZmLCAtMHg4MDAwMDAwMClcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmZmZmZmZmICsgdmFsdWUgKyAxXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gMjQpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gICAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlICYgMHhmZilcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5mdW5jdGlvbiBjaGVja0lFRUU3NTQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgZXh0LCBtYXgsIG1pbikge1xuICBpZiAob2Zmc2V0ICsgZXh0ID4gYnVmLmxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZScpXG4gIGlmIChvZmZzZXQgPCAwKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJylcbn1cblxuZnVuY3Rpb24gd3JpdGVGbG9hdCAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBjaGVja0lFRUU3NTQoYnVmLCB2YWx1ZSwgb2Zmc2V0LCA0LCAzLjQwMjgyMzQ2NjM4NTI4ODZlKzM4LCAtMy40MDI4MjM0NjYzODUyODg2ZSszOClcbiAgfVxuICBpZWVlNzU0LndyaXRlKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCAyMywgNClcbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUZsb2F0TEUgPSBmdW5jdGlvbiB3cml0ZUZsb2F0TEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZUZsb2F0KHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRmxvYXRCRSA9IGZ1bmN0aW9uIHdyaXRlRmxvYXRCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRmxvYXQodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG5mdW5jdGlvbiB3cml0ZURvdWJsZSAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBjaGVja0lFRUU3NTQoYnVmLCB2YWx1ZSwgb2Zmc2V0LCA4LCAxLjc5NzY5MzEzNDg2MjMxNTdFKzMwOCwgLTEuNzk3NjkzMTM0ODYyMzE1N0UrMzA4KVxuICB9XG4gIGllZWU3NTQud3JpdGUoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIDUyLCA4KVxuICByZXR1cm4gb2Zmc2V0ICsgOFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRG91YmxlTEUgPSBmdW5jdGlvbiB3cml0ZURvdWJsZUxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVEb3VibGUodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVEb3VibGVCRSA9IGZ1bmN0aW9uIHdyaXRlRG91YmxlQkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZURvdWJsZSh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXG59XG5cbi8vIGNvcHkodGFyZ2V0QnVmZmVyLCB0YXJnZXRTdGFydD0wLCBzb3VyY2VTdGFydD0wLCBzb3VyY2VFbmQ9YnVmZmVyLmxlbmd0aClcbkJ1ZmZlci5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uIGNvcHkgKHRhcmdldCwgdGFyZ2V0U3RhcnQsIHN0YXJ0LCBlbmQpIHtcbiAgaWYgKCFzdGFydCkgc3RhcnQgPSAwXG4gIGlmICghZW5kICYmIGVuZCAhPT0gMCkgZW5kID0gdGhpcy5sZW5ndGhcbiAgaWYgKHRhcmdldFN0YXJ0ID49IHRhcmdldC5sZW5ndGgpIHRhcmdldFN0YXJ0ID0gdGFyZ2V0Lmxlbmd0aFxuICBpZiAoIXRhcmdldFN0YXJ0KSB0YXJnZXRTdGFydCA9IDBcbiAgaWYgKGVuZCA+IDAgJiYgZW5kIDwgc3RhcnQpIGVuZCA9IHN0YXJ0XG5cbiAgLy8gQ29weSAwIGJ5dGVzOyB3ZSdyZSBkb25lXG4gIGlmIChlbmQgPT09IHN0YXJ0KSByZXR1cm4gMFxuICBpZiAodGFyZ2V0Lmxlbmd0aCA9PT0gMCB8fCB0aGlzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIDBcblxuICAvLyBGYXRhbCBlcnJvciBjb25kaXRpb25zXG4gIGlmICh0YXJnZXRTdGFydCA8IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcigndGFyZ2V0U3RhcnQgb3V0IG9mIGJvdW5kcycpXG4gIH1cbiAgaWYgKHN0YXJ0IDwgMCB8fCBzdGFydCA+PSB0aGlzLmxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3NvdXJjZVN0YXJ0IG91dCBvZiBib3VuZHMnKVxuICBpZiAoZW5kIDwgMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3NvdXJjZUVuZCBvdXQgb2YgYm91bmRzJylcblxuICAvLyBBcmUgd2Ugb29iP1xuICBpZiAoZW5kID4gdGhpcy5sZW5ndGgpIGVuZCA9IHRoaXMubGVuZ3RoXG4gIGlmICh0YXJnZXQubGVuZ3RoIC0gdGFyZ2V0U3RhcnQgPCBlbmQgLSBzdGFydCkge1xuICAgIGVuZCA9IHRhcmdldC5sZW5ndGggLSB0YXJnZXRTdGFydCArIHN0YXJ0XG4gIH1cblxuICB2YXIgbGVuID0gZW5kIC0gc3RhcnRcbiAgdmFyIGlcblxuICBpZiAodGhpcyA9PT0gdGFyZ2V0ICYmIHN0YXJ0IDwgdGFyZ2V0U3RhcnQgJiYgdGFyZ2V0U3RhcnQgPCBlbmQpIHtcbiAgICAvLyBkZXNjZW5kaW5nIGNvcHkgZnJvbSBlbmRcbiAgICBmb3IgKGkgPSBsZW4gLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgdGFyZ2V0W2kgKyB0YXJnZXRTdGFydF0gPSB0aGlzW2kgKyBzdGFydF1cbiAgICB9XG4gIH0gZWxzZSBpZiAobGVuIDwgMTAwMCB8fCAhQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICAvLyBhc2NlbmRpbmcgY29weSBmcm9tIHN0YXJ0XG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICB0YXJnZXRbaSArIHRhcmdldFN0YXJ0XSA9IHRoaXNbaSArIHN0YXJ0XVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBVaW50OEFycmF5LnByb3RvdHlwZS5zZXQuY2FsbChcbiAgICAgIHRhcmdldCxcbiAgICAgIHRoaXMuc3ViYXJyYXkoc3RhcnQsIHN0YXJ0ICsgbGVuKSxcbiAgICAgIHRhcmdldFN0YXJ0XG4gICAgKVxuICB9XG5cbiAgcmV0dXJuIGxlblxufVxuXG4vLyBVc2FnZTpcbi8vICAgIGJ1ZmZlci5maWxsKG51bWJlclssIG9mZnNldFssIGVuZF1dKVxuLy8gICAgYnVmZmVyLmZpbGwoYnVmZmVyWywgb2Zmc2V0WywgZW5kXV0pXG4vLyAgICBidWZmZXIuZmlsbChzdHJpbmdbLCBvZmZzZXRbLCBlbmRdXVssIGVuY29kaW5nXSlcbkJ1ZmZlci5wcm90b3R5cGUuZmlsbCA9IGZ1bmN0aW9uIGZpbGwgKHZhbCwgc3RhcnQsIGVuZCwgZW5jb2RpbmcpIHtcbiAgLy8gSGFuZGxlIHN0cmluZyBjYXNlczpcbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKSB7XG4gICAgaWYgKHR5cGVvZiBzdGFydCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGVuY29kaW5nID0gc3RhcnRcbiAgICAgIHN0YXJ0ID0gMFxuICAgICAgZW5kID0gdGhpcy5sZW5ndGhcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBlbmQgPT09ICdzdHJpbmcnKSB7XG4gICAgICBlbmNvZGluZyA9IGVuZFxuICAgICAgZW5kID0gdGhpcy5sZW5ndGhcbiAgICB9XG4gICAgaWYgKHZhbC5sZW5ndGggPT09IDEpIHtcbiAgICAgIHZhciBjb2RlID0gdmFsLmNoYXJDb2RlQXQoMClcbiAgICAgIGlmIChjb2RlIDwgMjU2KSB7XG4gICAgICAgIHZhbCA9IGNvZGVcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGVuY29kaW5nICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIGVuY29kaW5nICE9PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignZW5jb2RpbmcgbXVzdCBiZSBhIHN0cmluZycpXG4gICAgfVxuICAgIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09ICdzdHJpbmcnICYmICFCdWZmZXIuaXNFbmNvZGluZyhlbmNvZGluZykpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZylcbiAgICB9XG4gIH0gZWxzZSBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICB2YWwgPSB2YWwgJiAyNTVcbiAgfVxuXG4gIC8vIEludmFsaWQgcmFuZ2VzIGFyZSBub3Qgc2V0IHRvIGEgZGVmYXVsdCwgc28gY2FuIHJhbmdlIGNoZWNrIGVhcmx5LlxuICBpZiAoc3RhcnQgPCAwIHx8IHRoaXMubGVuZ3RoIDwgc3RhcnQgfHwgdGhpcy5sZW5ndGggPCBlbmQpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignT3V0IG9mIHJhbmdlIGluZGV4JylcbiAgfVxuXG4gIGlmIChlbmQgPD0gc3RhcnQpIHtcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgc3RhcnQgPSBzdGFydCA+Pj4gMFxuICBlbmQgPSBlbmQgPT09IHVuZGVmaW5lZCA/IHRoaXMubGVuZ3RoIDogZW5kID4+PiAwXG5cbiAgaWYgKCF2YWwpIHZhbCA9IDBcblxuICB2YXIgaVxuICBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICBmb3IgKGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgICB0aGlzW2ldID0gdmFsXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhciBieXRlcyA9IEJ1ZmZlci5pc0J1ZmZlcih2YWwpXG4gICAgICA/IHZhbFxuICAgICAgOiB1dGY4VG9CeXRlcyhuZXcgQnVmZmVyKHZhbCwgZW5jb2RpbmcpLnRvU3RyaW5nKCkpXG4gICAgdmFyIGxlbiA9IGJ5dGVzLmxlbmd0aFxuICAgIGZvciAoaSA9IDA7IGkgPCBlbmQgLSBzdGFydDsgKytpKSB7XG4gICAgICB0aGlzW2kgKyBzdGFydF0gPSBieXRlc1tpICUgbGVuXVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0aGlzXG59XG5cbi8vIEhFTFBFUiBGVU5DVElPTlNcbi8vID09PT09PT09PT09PT09PT1cblxudmFyIElOVkFMSURfQkFTRTY0X1JFID0gL1teK1xcLzAtOUEtWmEtei1fXS9nXG5cbmZ1bmN0aW9uIGJhc2U2NGNsZWFuIChzdHIpIHtcbiAgLy8gTm9kZSBzdHJpcHMgb3V0IGludmFsaWQgY2hhcmFjdGVycyBsaWtlIFxcbiBhbmQgXFx0IGZyb20gdGhlIHN0cmluZywgYmFzZTY0LWpzIGRvZXMgbm90XG4gIHN0ciA9IHN0cmluZ3RyaW0oc3RyKS5yZXBsYWNlKElOVkFMSURfQkFTRTY0X1JFLCAnJylcbiAgLy8gTm9kZSBjb252ZXJ0cyBzdHJpbmdzIHdpdGggbGVuZ3RoIDwgMiB0byAnJ1xuICBpZiAoc3RyLmxlbmd0aCA8IDIpIHJldHVybiAnJ1xuICAvLyBOb2RlIGFsbG93cyBmb3Igbm9uLXBhZGRlZCBiYXNlNjQgc3RyaW5ncyAobWlzc2luZyB0cmFpbGluZyA9PT0pLCBiYXNlNjQtanMgZG9lcyBub3RcbiAgd2hpbGUgKHN0ci5sZW5ndGggJSA0ICE9PSAwKSB7XG4gICAgc3RyID0gc3RyICsgJz0nXG4gIH1cbiAgcmV0dXJuIHN0clxufVxuXG5mdW5jdGlvbiBzdHJpbmd0cmltIChzdHIpIHtcbiAgaWYgKHN0ci50cmltKSByZXR1cm4gc3RyLnRyaW0oKVxuICByZXR1cm4gc3RyLnJlcGxhY2UoL15cXHMrfFxccyskL2csICcnKVxufVxuXG5mdW5jdGlvbiB0b0hleCAobikge1xuICBpZiAobiA8IDE2KSByZXR1cm4gJzAnICsgbi50b1N0cmluZygxNilcbiAgcmV0dXJuIG4udG9TdHJpbmcoMTYpXG59XG5cbmZ1bmN0aW9uIHV0ZjhUb0J5dGVzIChzdHJpbmcsIHVuaXRzKSB7XG4gIHVuaXRzID0gdW5pdHMgfHwgSW5maW5pdHlcbiAgdmFyIGNvZGVQb2ludFxuICB2YXIgbGVuZ3RoID0gc3RyaW5nLmxlbmd0aFxuICB2YXIgbGVhZFN1cnJvZ2F0ZSA9IG51bGxcbiAgdmFyIGJ5dGVzID0gW11cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgY29kZVBvaW50ID0gc3RyaW5nLmNoYXJDb2RlQXQoaSlcblxuICAgIC8vIGlzIHN1cnJvZ2F0ZSBjb21wb25lbnRcbiAgICBpZiAoY29kZVBvaW50ID4gMHhEN0ZGICYmIGNvZGVQb2ludCA8IDB4RTAwMCkge1xuICAgICAgLy8gbGFzdCBjaGFyIHdhcyBhIGxlYWRcbiAgICAgIGlmICghbGVhZFN1cnJvZ2F0ZSkge1xuICAgICAgICAvLyBubyBsZWFkIHlldFxuICAgICAgICBpZiAoY29kZVBvaW50ID4gMHhEQkZGKSB7XG4gICAgICAgICAgLy8gdW5leHBlY3RlZCB0cmFpbFxuICAgICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH0gZWxzZSBpZiAoaSArIDEgPT09IGxlbmd0aCkge1xuICAgICAgICAgIC8vIHVucGFpcmVkIGxlYWRcbiAgICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gdmFsaWQgbGVhZFxuICAgICAgICBsZWFkU3Vycm9nYXRlID0gY29kZVBvaW50XG5cbiAgICAgICAgY29udGludWVcbiAgICAgIH1cblxuICAgICAgLy8gMiBsZWFkcyBpbiBhIHJvd1xuICAgICAgaWYgKGNvZGVQb2ludCA8IDB4REMwMCkge1xuICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICAgICAgbGVhZFN1cnJvZ2F0ZSA9IGNvZGVQb2ludFxuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuXG4gICAgICAvLyB2YWxpZCBzdXJyb2dhdGUgcGFpclxuICAgICAgY29kZVBvaW50ID0gKGxlYWRTdXJyb2dhdGUgLSAweEQ4MDAgPDwgMTAgfCBjb2RlUG9pbnQgLSAweERDMDApICsgMHgxMDAwMFxuICAgIH0gZWxzZSBpZiAobGVhZFN1cnJvZ2F0ZSkge1xuICAgICAgLy8gdmFsaWQgYm1wIGNoYXIsIGJ1dCBsYXN0IGNoYXIgd2FzIGEgbGVhZFxuICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgfVxuXG4gICAgbGVhZFN1cnJvZ2F0ZSA9IG51bGxcblxuICAgIC8vIGVuY29kZSB1dGY4XG4gICAgaWYgKGNvZGVQb2ludCA8IDB4ODApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gMSkgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChjb2RlUG9pbnQpXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCAweDgwMCkge1xuICAgICAgaWYgKCh1bml0cyAtPSAyKSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHg2IHwgMHhDMCxcbiAgICAgICAgY29kZVBvaW50ICYgMHgzRiB8IDB4ODBcbiAgICAgIClcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA8IDB4MTAwMDApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gMykgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChcbiAgICAgICAgY29kZVBvaW50ID4+IDB4QyB8IDB4RTAsXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDYgJiAweDNGIHwgMHg4MCxcbiAgICAgICAgY29kZVBvaW50ICYgMHgzRiB8IDB4ODBcbiAgICAgIClcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA8IDB4MTEwMDAwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDQpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDEyIHwgMHhGMCxcbiAgICAgICAgY29kZVBvaW50ID4+IDB4QyAmIDB4M0YgfCAweDgwLFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHg2ICYgMHgzRiB8IDB4ODAsXG4gICAgICAgIGNvZGVQb2ludCAmIDB4M0YgfCAweDgwXG4gICAgICApXG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBjb2RlIHBvaW50JylcbiAgICB9XG4gIH1cblxuICByZXR1cm4gYnl0ZXNcbn1cblxuZnVuY3Rpb24gYXNjaWlUb0J5dGVzIChzdHIpIHtcbiAgdmFyIGJ5dGVBcnJheSA9IFtdXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgKytpKSB7XG4gICAgLy8gTm9kZSdzIGNvZGUgc2VlbXMgdG8gYmUgZG9pbmcgdGhpcyBhbmQgbm90ICYgMHg3Ri4uXG4gICAgYnl0ZUFycmF5LnB1c2goc3RyLmNoYXJDb2RlQXQoaSkgJiAweEZGKVxuICB9XG4gIHJldHVybiBieXRlQXJyYXlcbn1cblxuZnVuY3Rpb24gdXRmMTZsZVRvQnl0ZXMgKHN0ciwgdW5pdHMpIHtcbiAgdmFyIGMsIGhpLCBsb1xuICB2YXIgYnl0ZUFycmF5ID0gW11cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyArK2kpIHtcbiAgICBpZiAoKHVuaXRzIC09IDIpIDwgMCkgYnJlYWtcblxuICAgIGMgPSBzdHIuY2hhckNvZGVBdChpKVxuICAgIGhpID0gYyA+PiA4XG4gICAgbG8gPSBjICUgMjU2XG4gICAgYnl0ZUFycmF5LnB1c2gobG8pXG4gICAgYnl0ZUFycmF5LnB1c2goaGkpXG4gIH1cblxuICByZXR1cm4gYnl0ZUFycmF5XG59XG5cbmZ1bmN0aW9uIGJhc2U2NFRvQnl0ZXMgKHN0cikge1xuICByZXR1cm4gYmFzZTY0LnRvQnl0ZUFycmF5KGJhc2U2NGNsZWFuKHN0cikpXG59XG5cbmZ1bmN0aW9uIGJsaXRCdWZmZXIgKHNyYywgZHN0LCBvZmZzZXQsIGxlbmd0aCkge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgaWYgKChpICsgb2Zmc2V0ID49IGRzdC5sZW5ndGgpIHx8IChpID49IHNyYy5sZW5ndGgpKSBicmVha1xuICAgIGRzdFtpICsgb2Zmc2V0XSA9IHNyY1tpXVxuICB9XG4gIHJldHVybiBpXG59XG5cbmZ1bmN0aW9uIGlzbmFuICh2YWwpIHtcbiAgcmV0dXJuIHZhbCAhPT0gdmFsIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tc2VsZi1jb21wYXJlXG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vYnVmZmVyL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSAyNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9");
},function(module,exports){eval("exports.read = function (buffer, offset, isLE, mLen, nBytes) {\n  var e, m\n  var eLen = nBytes * 8 - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var nBits = -7\n  var i = isLE ? (nBytes - 1) : 0\n  var d = isLE ? -1 : 1\n  var s = buffer[offset + i]\n\n  i += d\n\n  e = s & ((1 << (-nBits)) - 1)\n  s >>= (-nBits)\n  nBits += eLen\n  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}\n\n  m = e & ((1 << (-nBits)) - 1)\n  e >>= (-nBits)\n  nBits += mLen\n  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}\n\n  if (e === 0) {\n    e = 1 - eBias\n  } else if (e === eMax) {\n    return m ? NaN : ((s ? -1 : 1) * Infinity)\n  } else {\n    m = m + Math.pow(2, mLen)\n    e = e - eBias\n  }\n  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)\n}\n\nexports.write = function (buffer, value, offset, isLE, mLen, nBytes) {\n  var e, m, c\n  var eLen = nBytes * 8 - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)\n  var i = isLE ? 0 : (nBytes - 1)\n  var d = isLE ? 1 : -1\n  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0\n\n  value = Math.abs(value)\n\n  if (isNaN(value) || value === Infinity) {\n    m = isNaN(value) ? 1 : 0\n    e = eMax\n  } else {\n    e = Math.floor(Math.log(value) / Math.LN2)\n    if (value * (c = Math.pow(2, -e)) < 1) {\n      e--\n      c *= 2\n    }\n    if (e + eBias >= 1) {\n      value += rt / c\n    } else {\n      value += rt * Math.pow(2, 1 - eBias)\n    }\n    if (value * c >= 2) {\n      e++\n      c /= 2\n    }\n\n    if (e + eBias >= eMax) {\n      m = 0\n      e = eMax\n    } else if (e + eBias >= 1) {\n      m = (value * c - 1) * Math.pow(2, mLen)\n      e = e + eBias\n    } else {\n      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)\n      e = 0\n    }\n  }\n\n  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}\n\n  e = (e << mLen) | m\n  eLen += mLen\n  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}\n\n  buffer[offset + i - d] |= s * 128\n}\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2llZWU3NTQvaW5kZXguanM/NzBmZSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUSxXQUFXOztBQUVuQjtBQUNBO0FBQ0E7QUFDQSxRQUFRLFdBQVc7O0FBRW5CO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxRQUFRLFdBQVc7O0FBRW5CO0FBQ0E7QUFDQSxRQUFRLFVBQVU7O0FBRWxCO0FBQ0EiLCJmaWxlIjoiMjYuanMiLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnRzLnJlYWQgPSBmdW5jdGlvbiAoYnVmZmVyLCBvZmZzZXQsIGlzTEUsIG1MZW4sIG5CeXRlcykge1xuICB2YXIgZSwgbVxuICB2YXIgZUxlbiA9IG5CeXRlcyAqIDggLSBtTGVuIC0gMVxuICB2YXIgZU1heCA9ICgxIDw8IGVMZW4pIC0gMVxuICB2YXIgZUJpYXMgPSBlTWF4ID4+IDFcbiAgdmFyIG5CaXRzID0gLTdcbiAgdmFyIGkgPSBpc0xFID8gKG5CeXRlcyAtIDEpIDogMFxuICB2YXIgZCA9IGlzTEUgPyAtMSA6IDFcbiAgdmFyIHMgPSBidWZmZXJbb2Zmc2V0ICsgaV1cblxuICBpICs9IGRcblxuICBlID0gcyAmICgoMSA8PCAoLW5CaXRzKSkgLSAxKVxuICBzID4+PSAoLW5CaXRzKVxuICBuQml0cyArPSBlTGVuXG4gIGZvciAoOyBuQml0cyA+IDA7IGUgPSBlICogMjU2ICsgYnVmZmVyW29mZnNldCArIGldLCBpICs9IGQsIG5CaXRzIC09IDgpIHt9XG5cbiAgbSA9IGUgJiAoKDEgPDwgKC1uQml0cykpIC0gMSlcbiAgZSA+Pj0gKC1uQml0cylcbiAgbkJpdHMgKz0gbUxlblxuICBmb3IgKDsgbkJpdHMgPiAwOyBtID0gbSAqIDI1NiArIGJ1ZmZlcltvZmZzZXQgKyBpXSwgaSArPSBkLCBuQml0cyAtPSA4KSB7fVxuXG4gIGlmIChlID09PSAwKSB7XG4gICAgZSA9IDEgLSBlQmlhc1xuICB9IGVsc2UgaWYgKGUgPT09IGVNYXgpIHtcbiAgICByZXR1cm4gbSA/IE5hTiA6ICgocyA/IC0xIDogMSkgKiBJbmZpbml0eSlcbiAgfSBlbHNlIHtcbiAgICBtID0gbSArIE1hdGgucG93KDIsIG1MZW4pXG4gICAgZSA9IGUgLSBlQmlhc1xuICB9XG4gIHJldHVybiAocyA/IC0xIDogMSkgKiBtICogTWF0aC5wb3coMiwgZSAtIG1MZW4pXG59XG5cbmV4cG9ydHMud3JpdGUgPSBmdW5jdGlvbiAoYnVmZmVyLCB2YWx1ZSwgb2Zmc2V0LCBpc0xFLCBtTGVuLCBuQnl0ZXMpIHtcbiAgdmFyIGUsIG0sIGNcbiAgdmFyIGVMZW4gPSBuQnl0ZXMgKiA4IC0gbUxlbiAtIDFcbiAgdmFyIGVNYXggPSAoMSA8PCBlTGVuKSAtIDFcbiAgdmFyIGVCaWFzID0gZU1heCA+PiAxXG4gIHZhciBydCA9IChtTGVuID09PSAyMyA/IE1hdGgucG93KDIsIC0yNCkgLSBNYXRoLnBvdygyLCAtNzcpIDogMClcbiAgdmFyIGkgPSBpc0xFID8gMCA6IChuQnl0ZXMgLSAxKVxuICB2YXIgZCA9IGlzTEUgPyAxIDogLTFcbiAgdmFyIHMgPSB2YWx1ZSA8IDAgfHwgKHZhbHVlID09PSAwICYmIDEgLyB2YWx1ZSA8IDApID8gMSA6IDBcblxuICB2YWx1ZSA9IE1hdGguYWJzKHZhbHVlKVxuXG4gIGlmIChpc05hTih2YWx1ZSkgfHwgdmFsdWUgPT09IEluZmluaXR5KSB7XG4gICAgbSA9IGlzTmFOKHZhbHVlKSA/IDEgOiAwXG4gICAgZSA9IGVNYXhcbiAgfSBlbHNlIHtcbiAgICBlID0gTWF0aC5mbG9vcihNYXRoLmxvZyh2YWx1ZSkgLyBNYXRoLkxOMilcbiAgICBpZiAodmFsdWUgKiAoYyA9IE1hdGgucG93KDIsIC1lKSkgPCAxKSB7XG4gICAgICBlLS1cbiAgICAgIGMgKj0gMlxuICAgIH1cbiAgICBpZiAoZSArIGVCaWFzID49IDEpIHtcbiAgICAgIHZhbHVlICs9IHJ0IC8gY1xuICAgIH0gZWxzZSB7XG4gICAgICB2YWx1ZSArPSBydCAqIE1hdGgucG93KDIsIDEgLSBlQmlhcylcbiAgICB9XG4gICAgaWYgKHZhbHVlICogYyA+PSAyKSB7XG4gICAgICBlKytcbiAgICAgIGMgLz0gMlxuICAgIH1cblxuICAgIGlmIChlICsgZUJpYXMgPj0gZU1heCkge1xuICAgICAgbSA9IDBcbiAgICAgIGUgPSBlTWF4XG4gICAgfSBlbHNlIGlmIChlICsgZUJpYXMgPj0gMSkge1xuICAgICAgbSA9ICh2YWx1ZSAqIGMgLSAxKSAqIE1hdGgucG93KDIsIG1MZW4pXG4gICAgICBlID0gZSArIGVCaWFzXG4gICAgfSBlbHNlIHtcbiAgICAgIG0gPSB2YWx1ZSAqIE1hdGgucG93KDIsIGVCaWFzIC0gMSkgKiBNYXRoLnBvdygyLCBtTGVuKVxuICAgICAgZSA9IDBcbiAgICB9XG4gIH1cblxuICBmb3IgKDsgbUxlbiA+PSA4OyBidWZmZXJbb2Zmc2V0ICsgaV0gPSBtICYgMHhmZiwgaSArPSBkLCBtIC89IDI1NiwgbUxlbiAtPSA4KSB7fVxuXG4gIGUgPSAoZSA8PCBtTGVuKSB8IG1cbiAgZUxlbiArPSBtTGVuXG4gIGZvciAoOyBlTGVuID4gMDsgYnVmZmVyW29mZnNldCArIGldID0gZSAmIDB4ZmYsIGkgKz0gZCwgZSAvPSAyNTYsIGVMZW4gLT0gOCkge31cblxuICBidWZmZXJbb2Zmc2V0ICsgaSAtIGRdIHw9IHMgKiAxMjhcbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9pZWVlNzU0L2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSAyNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9")},function(module,exports){eval("var toString = {}.toString;\n\nmodule.exports = Array.isArray || function (arr) {\n  return toString.call(arr) == '[object Array]';\n};\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2lzYXJyYXkvaW5kZXguanM/ZWFiYyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxpQkFBaUI7O0FBRWpCO0FBQ0E7QUFDQSIsImZpbGUiOiIyNy5qcyIsInNvdXJjZXNDb250ZW50IjpbInZhciB0b1N0cmluZyA9IHt9LnRvU3RyaW5nO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gKGFycikge1xuICByZXR1cm4gdG9TdHJpbmcuY2FsbChhcnIpID09ICdbb2JqZWN0IEFycmF5XSc7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2lzYXJyYXkvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDI3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=")},function(module,exports,__webpack_require__){eval('var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*\nAuthor: Geraint Luff and others\nYear: 2013\n\nThis code is released into the "public domain" by its author(s).  Anybody may use, alter and distribute the code without restriction.  The author makes no guarantees, and takes no liability of any kind for use of this code.\n\nIf you find a bug or make an improvement, it would be courteous to let the author know, but it is not compulsory.\n*/\n(function (global, factory) {\n  if (true) {\n    // AMD. Register as an anonymous module.\n    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === \'function\' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  } else if (typeof module !== \'undefined\' && module.exports){\n    // CommonJS. Define export.\n    module.exports = factory();\n  } else {\n    // Browser globals\n    global.tv4 = factory();\n  }\n}(this, function () {\n\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/keys?redirectlocale=en-US&redirectslug=JavaScript%2FReference%2FGlobal_Objects%2FObject%2Fkeys\nif (!Object.keys) {\n\tObject.keys = (function () {\n\t\tvar hasOwnProperty = Object.prototype.hasOwnProperty,\n\t\t\thasDontEnumBug = !({toString: null}).propertyIsEnumerable(\'toString\'),\n\t\t\tdontEnums = [\n\t\t\t\t\'toString\',\n\t\t\t\t\'toLocaleString\',\n\t\t\t\t\'valueOf\',\n\t\t\t\t\'hasOwnProperty\',\n\t\t\t\t\'isPrototypeOf\',\n\t\t\t\t\'propertyIsEnumerable\',\n\t\t\t\t\'constructor\'\n\t\t\t],\n\t\t\tdontEnumsLength = dontEnums.length;\n\n\t\treturn function (obj) {\n\t\t\tif (typeof obj !== \'object\' && typeof obj !== \'function\' || obj === null) {\n\t\t\t\tthrow new TypeError(\'Object.keys called on non-object\');\n\t\t\t}\n\n\t\t\tvar result = [];\n\n\t\t\tfor (var prop in obj) {\n\t\t\t\tif (hasOwnProperty.call(obj, prop)) {\n\t\t\t\t\tresult.push(prop);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (hasDontEnumBug) {\n\t\t\t\tfor (var i=0; i < dontEnumsLength; i++) {\n\t\t\t\t\tif (hasOwnProperty.call(obj, dontEnums[i])) {\n\t\t\t\t\t\tresult.push(dontEnums[i]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn result;\n\t\t};\n\t})();\n}\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/create\nif (!Object.create) {\n\tObject.create = (function(){\n\t\tfunction F(){}\n\n\t\treturn function(o){\n\t\t\tif (arguments.length !== 1) {\n\t\t\t\tthrow new Error(\'Object.create implementation only accepts one parameter.\');\n\t\t\t}\n\t\t\tF.prototype = o;\n\t\t\treturn new F();\n\t\t};\n\t})();\n}\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/isArray?redirectlocale=en-US&redirectslug=JavaScript%2FReference%2FGlobal_Objects%2FArray%2FisArray\nif(!Array.isArray) {\n\tArray.isArray = function (vArg) {\n\t\treturn Object.prototype.toString.call(vArg) === "[object Array]";\n\t};\n}\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/indexOf?redirectlocale=en-US&redirectslug=JavaScript%2FReference%2FGlobal_Objects%2FArray%2FindexOf\nif (!Array.prototype.indexOf) {\n\tArray.prototype.indexOf = function (searchElement /*, fromIndex */ ) {\n\t\tif (this === null) {\n\t\t\tthrow new TypeError();\n\t\t}\n\t\tvar t = Object(this);\n\t\tvar len = t.length >>> 0;\n\n\t\tif (len === 0) {\n\t\t\treturn -1;\n\t\t}\n\t\tvar n = 0;\n\t\tif (arguments.length > 1) {\n\t\t\tn = Number(arguments[1]);\n\t\t\tif (n !== n) { // shortcut for verifying if it\'s NaN\n\t\t\t\tn = 0;\n\t\t\t} else if (n !== 0 && n !== Infinity && n !== -Infinity) {\n\t\t\t\tn = (n > 0 || -1) * Math.floor(Math.abs(n));\n\t\t\t}\n\t\t}\n\t\tif (n >= len) {\n\t\t\treturn -1;\n\t\t}\n\t\tvar k = n >= 0 ? n : Math.max(len - Math.abs(n), 0);\n\t\tfor (; k < len; k++) {\n\t\t\tif (k in t && t[k] === searchElement) {\n\t\t\t\treturn k;\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t};\n}\n\n// Grungey Object.isFrozen hack\nif (!Object.isFrozen) {\n\tObject.isFrozen = function (obj) {\n\t\tvar key = "tv4_test_frozen_key";\n\t\twhile (obj.hasOwnProperty(key)) {\n\t\t\tkey += Math.random();\n\t\t}\n\t\ttry {\n\t\t\tobj[key] = true;\n\t\t\tdelete obj[key];\n\t\t\treturn false;\n\t\t} catch (e) {\n\t\t\treturn true;\n\t\t}\n\t};\n}\n// Based on: https://github.com/geraintluff/uri-templates, but with all the de-substitution stuff removed\n\nvar uriTemplateGlobalModifiers = {\n\t"+": true,\n\t"#": true,\n\t".": true,\n\t"/": true,\n\t";": true,\n\t"?": true,\n\t"&": true\n};\nvar uriTemplateSuffices = {\n\t"*": true\n};\n\nfunction notReallyPercentEncode(string) {\n\treturn encodeURI(string).replace(/%25[0-9][0-9]/g, function (doubleEncoded) {\n\t\treturn "%" + doubleEncoded.substring(3);\n\t});\n}\n\nfunction uriTemplateSubstitution(spec) {\n\tvar modifier = "";\n\tif (uriTemplateGlobalModifiers[spec.charAt(0)]) {\n\t\tmodifier = spec.charAt(0);\n\t\tspec = spec.substring(1);\n\t}\n\tvar separator = "";\n\tvar prefix = "";\n\tvar shouldEscape = true;\n\tvar showVariables = false;\n\tvar trimEmptyString = false;\n\tif (modifier === \'+\') {\n\t\tshouldEscape = false;\n\t} else if (modifier === ".") {\n\t\tprefix = ".";\n\t\tseparator = ".";\n\t} else if (modifier === "/") {\n\t\tprefix = "/";\n\t\tseparator = "/";\n\t} else if (modifier === \'#\') {\n\t\tprefix = "#";\n\t\tshouldEscape = false;\n\t} else if (modifier === \';\') {\n\t\tprefix = ";";\n\t\tseparator = ";";\n\t\tshowVariables = true;\n\t\ttrimEmptyString = true;\n\t} else if (modifier === \'?\') {\n\t\tprefix = "?";\n\t\tseparator = "&";\n\t\tshowVariables = true;\n\t} else if (modifier === \'&\') {\n\t\tprefix = "&";\n\t\tseparator = "&";\n\t\tshowVariables = true;\n\t}\n\n\tvar varNames = [];\n\tvar varList = spec.split(",");\n\tvar varSpecs = [];\n\tvar varSpecMap = {};\n\tfor (var i = 0; i < varList.length; i++) {\n\t\tvar varName = varList[i];\n\t\tvar truncate = null;\n\t\tif (varName.indexOf(":") !== -1) {\n\t\t\tvar parts = varName.split(":");\n\t\t\tvarName = parts[0];\n\t\t\ttruncate = parseInt(parts[1], 10);\n\t\t}\n\t\tvar suffices = {};\n\t\twhile (uriTemplateSuffices[varName.charAt(varName.length - 1)]) {\n\t\t\tsuffices[varName.charAt(varName.length - 1)] = true;\n\t\t\tvarName = varName.substring(0, varName.length - 1);\n\t\t}\n\t\tvar varSpec = {\n\t\t\ttruncate: truncate,\n\t\t\tname: varName,\n\t\t\tsuffices: suffices\n\t\t};\n\t\tvarSpecs.push(varSpec);\n\t\tvarSpecMap[varName] = varSpec;\n\t\tvarNames.push(varName);\n\t}\n\tvar subFunction = function (valueFunction) {\n\t\tvar result = "";\n\t\tvar startIndex = 0;\n\t\tfor (var i = 0; i < varSpecs.length; i++) {\n\t\t\tvar varSpec = varSpecs[i];\n\t\t\tvar value = valueFunction(varSpec.name);\n\t\t\tif (value === null || value === undefined || (Array.isArray(value) && value.length === 0) || (typeof value === \'object\' && Object.keys(value).length === 0)) {\n\t\t\t\tstartIndex++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (i === startIndex) {\n\t\t\t\tresult += prefix;\n\t\t\t} else {\n\t\t\t\tresult += (separator || ",");\n\t\t\t}\n\t\t\tif (Array.isArray(value)) {\n\t\t\t\tif (showVariables) {\n\t\t\t\t\tresult += varSpec.name + "=";\n\t\t\t\t}\n\t\t\t\tfor (var j = 0; j < value.length; j++) {\n\t\t\t\t\tif (j > 0) {\n\t\t\t\t\t\tresult += varSpec.suffices[\'*\'] ? (separator || ",") : ",";\n\t\t\t\t\t\tif (varSpec.suffices[\'*\'] && showVariables) {\n\t\t\t\t\t\t\tresult += varSpec.name + "=";\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tresult += shouldEscape ? encodeURIComponent(value[j]).replace(/!/g, "%21") : notReallyPercentEncode(value[j]);\n\t\t\t\t}\n\t\t\t} else if (typeof value === "object") {\n\t\t\t\tif (showVariables && !varSpec.suffices[\'*\']) {\n\t\t\t\t\tresult += varSpec.name + "=";\n\t\t\t\t}\n\t\t\t\tvar first = true;\n\t\t\t\tfor (var key in value) {\n\t\t\t\t\tif (!first) {\n\t\t\t\t\t\tresult += varSpec.suffices[\'*\'] ? (separator || ",") : ",";\n\t\t\t\t\t}\n\t\t\t\t\tfirst = false;\n\t\t\t\t\tresult += shouldEscape ? encodeURIComponent(key).replace(/!/g, "%21") : notReallyPercentEncode(key);\n\t\t\t\t\tresult += varSpec.suffices[\'*\'] ? \'=\' : ",";\n\t\t\t\t\tresult += shouldEscape ? encodeURIComponent(value[key]).replace(/!/g, "%21") : notReallyPercentEncode(value[key]);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (showVariables) {\n\t\t\t\t\tresult += varSpec.name;\n\t\t\t\t\tif (!trimEmptyString || value !== "") {\n\t\t\t\t\t\tresult += "=";\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (varSpec.truncate != null) {\n\t\t\t\t\tvalue = value.substring(0, varSpec.truncate);\n\t\t\t\t}\n\t\t\t\tresult += shouldEscape ? encodeURIComponent(value).replace(/!/g, "%21"): notReallyPercentEncode(value);\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t};\n\tsubFunction.varNames = varNames;\n\treturn {\n\t\tprefix: prefix,\n\t\tsubstitution: subFunction\n\t};\n}\n\nfunction UriTemplate(template) {\n\tif (!(this instanceof UriTemplate)) {\n\t\treturn new UriTemplate(template);\n\t}\n\tvar parts = template.split("{");\n\tvar textParts = [parts.shift()];\n\tvar prefixes = [];\n\tvar substitutions = [];\n\tvar varNames = [];\n\twhile (parts.length > 0) {\n\t\tvar part = parts.shift();\n\t\tvar spec = part.split("}")[0];\n\t\tvar remainder = part.substring(spec.length + 1);\n\t\tvar funcs = uriTemplateSubstitution(spec);\n\t\tsubstitutions.push(funcs.substitution);\n\t\tprefixes.push(funcs.prefix);\n\t\ttextParts.push(remainder);\n\t\tvarNames = varNames.concat(funcs.substitution.varNames);\n\t}\n\tthis.fill = function (valueFunction) {\n\t\tvar result = textParts[0];\n\t\tfor (var i = 0; i < substitutions.length; i++) {\n\t\t\tvar substitution = substitutions[i];\n\t\t\tresult += substitution(valueFunction);\n\t\t\tresult += textParts[i + 1];\n\t\t}\n\t\treturn result;\n\t};\n\tthis.varNames = varNames;\n\tthis.template = template;\n}\nUriTemplate.prototype = {\n\ttoString: function () {\n\t\treturn this.template;\n\t},\n\tfillFromObject: function (obj) {\n\t\treturn this.fill(function (varName) {\n\t\t\treturn obj[varName];\n\t\t});\n\t}\n};\nvar ValidatorContext = function ValidatorContext(parent, collectMultiple, errorReporter, checkRecursive, trackUnknownProperties) {\n\tthis.missing = [];\n\tthis.missingMap = {};\n\tthis.formatValidators = parent ? Object.create(parent.formatValidators) : {};\n\tthis.schemas = parent ? Object.create(parent.schemas) : {};\n\tthis.collectMultiple = collectMultiple;\n\tthis.errors = [];\n\tthis.handleError = collectMultiple ? this.collectError : this.returnError;\n\tif (checkRecursive) {\n\t\tthis.checkRecursive = true;\n\t\tthis.scanned = [];\n\t\tthis.scannedFrozen = [];\n\t\tthis.scannedFrozenSchemas = [];\n\t\tthis.scannedFrozenValidationErrors = [];\n\t\tthis.validatedSchemasKey = \'tv4_validation_id\';\n\t\tthis.validationErrorsKey = \'tv4_validation_errors_id\';\n\t}\n\tif (trackUnknownProperties) {\n\t\tthis.trackUnknownProperties = true;\n\t\tthis.knownPropertyPaths = {};\n\t\tthis.unknownPropertyPaths = {};\n\t}\n\tthis.errorReporter = errorReporter || defaultErrorReporter(\'en\');\n\tif (typeof this.errorReporter === \'string\') {\n\t\tthrow new Error(\'debug\');\n\t}\n\tthis.definedKeywords = {};\n\tif (parent) {\n\t\tfor (var key in parent.definedKeywords) {\n\t\t\tthis.definedKeywords[key] = parent.definedKeywords[key].slice(0);\n\t\t}\n\t}\n};\nValidatorContext.prototype.defineKeyword = function (keyword, keywordFunction) {\n\tthis.definedKeywords[keyword] = this.definedKeywords[keyword] || [];\n\tthis.definedKeywords[keyword].push(keywordFunction);\n};\nValidatorContext.prototype.createError = function (code, messageParams, dataPath, schemaPath, subErrors, data, schema) {\n\tvar error = new ValidationError(code, messageParams, dataPath, schemaPath, subErrors);\n\terror.message = this.errorReporter(error, data, schema);\n\treturn error;\n};\nValidatorContext.prototype.returnError = function (error) {\n\treturn error;\n};\nValidatorContext.prototype.collectError = function (error) {\n\tif (error) {\n\t\tthis.errors.push(error);\n\t}\n\treturn null;\n};\nValidatorContext.prototype.prefixErrors = function (startIndex, dataPath, schemaPath) {\n\tfor (var i = startIndex; i < this.errors.length; i++) {\n\t\tthis.errors[i] = this.errors[i].prefixWith(dataPath, schemaPath);\n\t}\n\treturn this;\n};\nValidatorContext.prototype.banUnknownProperties = function (data, schema) {\n\tfor (var unknownPath in this.unknownPropertyPaths) {\n\t\tvar error = this.createError(ErrorCodes.UNKNOWN_PROPERTY, {path: unknownPath}, unknownPath, "", null, data, schema);\n\t\tvar result = this.handleError(error);\n\t\tif (result) {\n\t\t\treturn result;\n\t\t}\n\t}\n\treturn null;\n};\n\nValidatorContext.prototype.addFormat = function (format, validator) {\n\tif (typeof format === \'object\') {\n\t\tfor (var key in format) {\n\t\t\tthis.addFormat(key, format[key]);\n\t\t}\n\t\treturn this;\n\t}\n\tthis.formatValidators[format] = validator;\n};\nValidatorContext.prototype.resolveRefs = function (schema, urlHistory) {\n\tif (schema[\'$ref\'] !== undefined) {\n\t\turlHistory = urlHistory || {};\n\t\tif (urlHistory[schema[\'$ref\']]) {\n\t\t\treturn this.createError(ErrorCodes.CIRCULAR_REFERENCE, {urls: Object.keys(urlHistory).join(\', \')}, \'\', \'\', null, undefined, schema);\n\t\t}\n\t\turlHistory[schema[\'$ref\']] = true;\n\t\tschema = this.getSchema(schema[\'$ref\'], urlHistory);\n\t}\n\treturn schema;\n};\nValidatorContext.prototype.getSchema = function (url, urlHistory) {\n\tvar schema;\n\tif (this.schemas[url] !== undefined) {\n\t\tschema = this.schemas[url];\n\t\treturn this.resolveRefs(schema, urlHistory);\n\t}\n\tvar baseUrl = url;\n\tvar fragment = "";\n\tif (url.indexOf(\'#\') !== -1) {\n\t\tfragment = url.substring(url.indexOf("#") + 1);\n\t\tbaseUrl = url.substring(0, url.indexOf("#"));\n\t}\n\tif (typeof this.schemas[baseUrl] === \'object\') {\n\t\tschema = this.schemas[baseUrl];\n\t\tvar pointerPath = decodeURIComponent(fragment);\n\t\tif (pointerPath === "") {\n\t\t\treturn this.resolveRefs(schema, urlHistory);\n\t\t} else if (pointerPath.charAt(0) !== "/") {\n\t\t\treturn undefined;\n\t\t}\n\t\tvar parts = pointerPath.split("/").slice(1);\n\t\tfor (var i = 0; i < parts.length; i++) {\n\t\t\tvar component = parts[i].replace(/~1/g, "/").replace(/~0/g, "~");\n\t\t\tif (schema[component] === undefined) {\n\t\t\t\tschema = undefined;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tschema = schema[component];\n\t\t}\n\t\tif (schema !== undefined) {\n\t\t\treturn this.resolveRefs(schema, urlHistory);\n\t\t}\n\t}\n\tif (this.missing[baseUrl] === undefined) {\n\t\tthis.missing.push(baseUrl);\n\t\tthis.missing[baseUrl] = baseUrl;\n\t\tthis.missingMap[baseUrl] = baseUrl;\n\t}\n};\nValidatorContext.prototype.searchSchemas = function (schema, url) {\n\tif (Array.isArray(schema)) {\n\t\tfor (var i = 0; i < schema.length; i++) {\n\t\t\tthis.searchSchemas(schema[i], url);\n\t\t}\n\t} else if (schema && typeof schema === "object") {\n\t\tif (typeof schema.id === "string") {\n\t\t\tif (isTrustedUrl(url, schema.id)) {\n\t\t\t\tif (this.schemas[schema.id] === undefined) {\n\t\t\t\t\tthis.schemas[schema.id] = schema;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (var key in schema) {\n\t\t\tif (key !== "enum") {\n\t\t\t\tif (typeof schema[key] === "object") {\n\t\t\t\t\tthis.searchSchemas(schema[key], url);\n\t\t\t\t} else if (key === "$ref") {\n\t\t\t\t\tvar uri = getDocumentUri(schema[key]);\n\t\t\t\t\tif (uri && this.schemas[uri] === undefined && this.missingMap[uri] === undefined) {\n\t\t\t\t\t\tthis.missingMap[uri] = uri;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n};\nValidatorContext.prototype.addSchema = function (url, schema) {\n\t//overload\n\tif (typeof url !== \'string\' || typeof schema === \'undefined\') {\n\t\tif (typeof url === \'object\' && typeof url.id === \'string\') {\n\t\t\tschema = url;\n\t\t\turl = schema.id;\n\t\t}\n\t\telse {\n\t\t\treturn;\n\t\t}\n\t}\n\tif (url === getDocumentUri(url) + "#") {\n\t\t// Remove empty fragment\n\t\turl = getDocumentUri(url);\n\t}\n\tthis.schemas[url] = schema;\n\tdelete this.missingMap[url];\n\tnormSchema(schema, url);\n\tthis.searchSchemas(schema, url);\n};\n\nValidatorContext.prototype.getSchemaMap = function () {\n\tvar map = {};\n\tfor (var key in this.schemas) {\n\t\tmap[key] = this.schemas[key];\n\t}\n\treturn map;\n};\n\nValidatorContext.prototype.getSchemaUris = function (filterRegExp) {\n\tvar list = [];\n\tfor (var key in this.schemas) {\n\t\tif (!filterRegExp || filterRegExp.test(key)) {\n\t\t\tlist.push(key);\n\t\t}\n\t}\n\treturn list;\n};\n\nValidatorContext.prototype.getMissingUris = function (filterRegExp) {\n\tvar list = [];\n\tfor (var key in this.missingMap) {\n\t\tif (!filterRegExp || filterRegExp.test(key)) {\n\t\t\tlist.push(key);\n\t\t}\n\t}\n\treturn list;\n};\n\nValidatorContext.prototype.dropSchemas = function () {\n\tthis.schemas = {};\n\tthis.reset();\n};\nValidatorContext.prototype.reset = function () {\n\tthis.missing = [];\n\tthis.missingMap = {};\n\tthis.errors = [];\n};\n\nValidatorContext.prototype.validateAll = function (data, schema, dataPathParts, schemaPathParts, dataPointerPath) {\n\tvar topLevel;\n\tschema = this.resolveRefs(schema);\n\tif (!schema) {\n\t\treturn null;\n\t} else if (schema instanceof ValidationError) {\n\t\tthis.errors.push(schema);\n\t\treturn schema;\n\t}\n\n\tvar startErrorCount = this.errors.length;\n\tvar frozenIndex, scannedFrozenSchemaIndex = null, scannedSchemasIndex = null;\n\tif (this.checkRecursive && data && typeof data === \'object\') {\n\t\ttopLevel = !this.scanned.length;\n\t\tif (data[this.validatedSchemasKey]) {\n\t\t\tvar schemaIndex = data[this.validatedSchemasKey].indexOf(schema);\n\t\t\tif (schemaIndex !== -1) {\n\t\t\t\tthis.errors = this.errors.concat(data[this.validationErrorsKey][schemaIndex]);\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t\tif (Object.isFrozen(data)) {\n\t\t\tfrozenIndex = this.scannedFrozen.indexOf(data);\n\t\t\tif (frozenIndex !== -1) {\n\t\t\t\tvar frozenSchemaIndex = this.scannedFrozenSchemas[frozenIndex].indexOf(schema);\n\t\t\t\tif (frozenSchemaIndex !== -1) {\n\t\t\t\t\tthis.errors = this.errors.concat(this.scannedFrozenValidationErrors[frozenIndex][frozenSchemaIndex]);\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tthis.scanned.push(data);\n\t\tif (Object.isFrozen(data)) {\n\t\t\tif (frozenIndex === -1) {\n\t\t\t\tfrozenIndex = this.scannedFrozen.length;\n\t\t\t\tthis.scannedFrozen.push(data);\n\t\t\t\tthis.scannedFrozenSchemas.push([]);\n\t\t\t}\n\t\t\tscannedFrozenSchemaIndex = this.scannedFrozenSchemas[frozenIndex].length;\n\t\t\tthis.scannedFrozenSchemas[frozenIndex][scannedFrozenSchemaIndex] = schema;\n\t\t\tthis.scannedFrozenValidationErrors[frozenIndex][scannedFrozenSchemaIndex] = [];\n\t\t} else {\n\t\t\tif (!data[this.validatedSchemasKey]) {\n\t\t\t\ttry {\n\t\t\t\t\tObject.defineProperty(data, this.validatedSchemasKey, {\n\t\t\t\t\t\tvalue: [],\n\t\t\t\t\t\tconfigurable: true\n\t\t\t\t\t});\n\t\t\t\t\tObject.defineProperty(data, this.validationErrorsKey, {\n\t\t\t\t\t\tvalue: [],\n\t\t\t\t\t\tconfigurable: true\n\t\t\t\t\t});\n\t\t\t\t} catch (e) {\n\t\t\t\t\t//IE 7/8 workaround\n\t\t\t\t\tdata[this.validatedSchemasKey] = [];\n\t\t\t\t\tdata[this.validationErrorsKey] = [];\n\t\t\t\t}\n\t\t\t}\n\t\t\tscannedSchemasIndex = data[this.validatedSchemasKey].length;\n\t\t\tdata[this.validatedSchemasKey][scannedSchemasIndex] = schema;\n\t\t\tdata[this.validationErrorsKey][scannedSchemasIndex] = [];\n\t\t}\n\t}\n\n\tvar errorCount = this.errors.length;\n\tvar error = this.validateBasic(data, schema, dataPointerPath)\n\t\t|| this.validateNumeric(data, schema, dataPointerPath)\n\t\t|| this.validateString(data, schema, dataPointerPath)\n\t\t|| this.validateArray(data, schema, dataPointerPath)\n\t\t|| this.validateObject(data, schema, dataPointerPath)\n\t\t|| this.validateCombinations(data, schema, dataPointerPath)\n\t\t|| this.validateHypermedia(data, schema, dataPointerPath)\n\t\t|| this.validateFormat(data, schema, dataPointerPath)\n\t\t|| this.validateDefinedKeywords(data, schema, dataPointerPath)\n\t\t|| null;\n\n\tif (topLevel) {\n\t\twhile (this.scanned.length) {\n\t\t\tvar item = this.scanned.pop();\n\t\t\tdelete item[this.validatedSchemasKey];\n\t\t}\n\t\tthis.scannedFrozen = [];\n\t\tthis.scannedFrozenSchemas = [];\n\t}\n\n\tif (error || errorCount !== this.errors.length) {\n\t\twhile ((dataPathParts && dataPathParts.length) || (schemaPathParts && schemaPathParts.length)) {\n\t\t\tvar dataPart = (dataPathParts && dataPathParts.length) ? "" + dataPathParts.pop() : null;\n\t\t\tvar schemaPart = (schemaPathParts && schemaPathParts.length) ? "" + schemaPathParts.pop() : null;\n\t\t\tif (error) {\n\t\t\t\terror = error.prefixWith(dataPart, schemaPart);\n\t\t\t}\n\t\t\tthis.prefixErrors(errorCount, dataPart, schemaPart);\n\t\t}\n\t}\n\n\tif (scannedFrozenSchemaIndex !== null) {\n\t\tthis.scannedFrozenValidationErrors[frozenIndex][scannedFrozenSchemaIndex] = this.errors.slice(startErrorCount);\n\t} else if (scannedSchemasIndex !== null) {\n\t\tdata[this.validationErrorsKey][scannedSchemasIndex] = this.errors.slice(startErrorCount);\n\t}\n\n\treturn this.handleError(error);\n};\nValidatorContext.prototype.validateFormat = function (data, schema) {\n\tif (typeof schema.format !== \'string\' || !this.formatValidators[schema.format]) {\n\t\treturn null;\n\t}\n\tvar errorMessage = this.formatValidators[schema.format].call(null, data, schema);\n\tif (typeof errorMessage === \'string\' || typeof errorMessage === \'number\') {\n\t\treturn this.createError(ErrorCodes.FORMAT_CUSTOM, {message: errorMessage}, \'\', \'/format\', null, data, schema);\n\t} else if (errorMessage && typeof errorMessage === \'object\') {\n\t\treturn this.createError(ErrorCodes.FORMAT_CUSTOM, {message: errorMessage.message || "?"}, errorMessage.dataPath || \'\', errorMessage.schemaPath || "/format", null, data, schema);\n\t}\n\treturn null;\n};\nValidatorContext.prototype.validateDefinedKeywords = function (data, schema, dataPointerPath) {\n\tfor (var key in this.definedKeywords) {\n\t\tif (typeof schema[key] === \'undefined\') {\n\t\t\tcontinue;\n\t\t}\n\t\tvar validationFunctions = this.definedKeywords[key];\n\t\tfor (var i = 0; i < validationFunctions.length; i++) {\n\t\t\tvar func = validationFunctions[i];\n\t\t\tvar result = func(data, schema[key], schema, dataPointerPath);\n\t\t\tif (typeof result === \'string\' || typeof result === \'number\') {\n\t\t\t\treturn this.createError(ErrorCodes.KEYWORD_CUSTOM, {key: key, message: result}, \'\', \'\', null, data, schema).prefixWith(null, key);\n\t\t\t} else if (result && typeof result === \'object\') {\n\t\t\t\tvar code = result.code;\n\t\t\t\tif (typeof code === \'string\') {\n\t\t\t\t\tif (!ErrorCodes[code]) {\n\t\t\t\t\t\tthrow new Error(\'Undefined error code (use defineError): \' + code);\n\t\t\t\t\t}\n\t\t\t\t\tcode = ErrorCodes[code];\n\t\t\t\t} else if (typeof code !== \'number\') {\n\t\t\t\t\tcode = ErrorCodes.KEYWORD_CUSTOM;\n\t\t\t\t}\n\t\t\t\tvar messageParams = (typeof result.message === \'object\') ? result.message : {key: key, message: result.message || "?"};\n\t\t\t\tvar schemaPath = result.schemaPath || ("/" + key.replace(/~/g, \'~0\').replace(/\\//g, \'~1\'));\n\t\t\t\treturn this.createError(code, messageParams, result.dataPath || null, schemaPath, null, data, schema);\n\t\t\t}\n\t\t}\n\t}\n\treturn null;\n};\n\nfunction recursiveCompare(A, B) {\n\tif (A === B) {\n\t\treturn true;\n\t}\n\tif (A && B && typeof A === "object" && typeof B === "object") {\n\t\tif (Array.isArray(A) !== Array.isArray(B)) {\n\t\t\treturn false;\n\t\t} else if (Array.isArray(A)) {\n\t\t\tif (A.length !== B.length) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tfor (var i = 0; i < A.length; i++) {\n\t\t\t\tif (!recursiveCompare(A[i], B[i])) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tvar key;\n\t\t\tfor (key in A) {\n\t\t\t\tif (B[key] === undefined && A[key] !== undefined) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (key in B) {\n\t\t\t\tif (A[key] === undefined && B[key] !== undefined) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (key in A) {\n\t\t\t\tif (!recursiveCompare(A[key], B[key])) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nValidatorContext.prototype.validateBasic = function validateBasic(data, schema, dataPointerPath) {\n\tvar error;\n\tif (error = this.validateType(data, schema, dataPointerPath)) {\n\t\treturn error.prefixWith(null, "type");\n\t}\n\tif (error = this.validateEnum(data, schema, dataPointerPath)) {\n\t\treturn error.prefixWith(null, "type");\n\t}\n\treturn null;\n};\n\nValidatorContext.prototype.validateType = function validateType(data, schema) {\n\tif (schema.type === undefined) {\n\t\treturn null;\n\t}\n\tvar dataType = typeof data;\n\tif (data === null) {\n\t\tdataType = "null";\n\t} else if (Array.isArray(data)) {\n\t\tdataType = "array";\n\t}\n\tvar allowedTypes = schema.type;\n\tif (!Array.isArray(allowedTypes)) {\n\t\tallowedTypes = [allowedTypes];\n\t}\n\n\tfor (var i = 0; i < allowedTypes.length; i++) {\n\t\tvar type = allowedTypes[i];\n\t\tif (type === dataType || (type === "integer" && dataType === "number" && (data % 1 === 0))) {\n\t\t\treturn null;\n\t\t}\n\t}\n\treturn this.createError(ErrorCodes.INVALID_TYPE, {type: dataType, expected: allowedTypes.join("/")}, \'\', \'\', null, data, schema);\n};\n\nValidatorContext.prototype.validateEnum = function validateEnum(data, schema) {\n\tif (schema["enum"] === undefined) {\n\t\treturn null;\n\t}\n\tfor (var i = 0; i < schema["enum"].length; i++) {\n\t\tvar enumVal = schema["enum"][i];\n\t\tif (recursiveCompare(data, enumVal)) {\n\t\t\treturn null;\n\t\t}\n\t}\n\treturn this.createError(ErrorCodes.ENUM_MISMATCH, {value: (typeof JSON !== \'undefined\') ? JSON.stringify(data) : data}, \'\', \'\', null, data, schema);\n};\n\nValidatorContext.prototype.validateNumeric = function validateNumeric(data, schema, dataPointerPath) {\n\treturn this.validateMultipleOf(data, schema, dataPointerPath)\n\t\t|| this.validateMinMax(data, schema, dataPointerPath)\n\t\t|| this.validateNaN(data, schema, dataPointerPath)\n\t\t|| null;\n};\n\nvar CLOSE_ENOUGH_LOW = Math.pow(2, -51);\nvar CLOSE_ENOUGH_HIGH = 1 - CLOSE_ENOUGH_LOW;\nValidatorContext.prototype.validateMultipleOf = function validateMultipleOf(data, schema) {\n\tvar multipleOf = schema.multipleOf || schema.divisibleBy;\n\tif (multipleOf === undefined) {\n\t\treturn null;\n\t}\n\tif (typeof data === "number") {\n\t\tvar remainder = (data/multipleOf)%1;\n\t\tif (remainder >= CLOSE_ENOUGH_LOW && remainder < CLOSE_ENOUGH_HIGH) {\n\t\t\treturn this.createError(ErrorCodes.NUMBER_MULTIPLE_OF, {value: data, multipleOf: multipleOf}, \'\', \'\', null, data, schema);\n\t\t}\n\t}\n\treturn null;\n};\n\nValidatorContext.prototype.validateMinMax = function validateMinMax(data, schema) {\n\tif (typeof data !== "number") {\n\t\treturn null;\n\t}\n\tif (schema.minimum !== undefined) {\n\t\tif (data < schema.minimum) {\n\t\t\treturn this.createError(ErrorCodes.NUMBER_MINIMUM, {value: data, minimum: schema.minimum}, \'\', \'/minimum\', null, data, schema);\n\t\t}\n\t\tif (schema.exclusiveMinimum && data === schema.minimum) {\n\t\t\treturn this.createError(ErrorCodes.NUMBER_MINIMUM_EXCLUSIVE, {value: data, minimum: schema.minimum}, \'\', \'/exclusiveMinimum\', null, data, schema);\n\t\t}\n\t}\n\tif (schema.maximum !== undefined) {\n\t\tif (data > schema.maximum) {\n\t\t\treturn this.createError(ErrorCodes.NUMBER_MAXIMUM, {value: data, maximum: schema.maximum}, \'\', \'/maximum\', null, data, schema);\n\t\t}\n\t\tif (schema.exclusiveMaximum && data === schema.maximum) {\n\t\t\treturn this.createError(ErrorCodes.NUMBER_MAXIMUM_EXCLUSIVE, {value: data, maximum: schema.maximum}, \'\', \'/exclusiveMaximum\', null, data, schema);\n\t\t}\n\t}\n\treturn null;\n};\n\nValidatorContext.prototype.validateNaN = function validateNaN(data, schema) {\n\tif (typeof data !== "number") {\n\t\treturn null;\n\t}\n\tif (isNaN(data) === true || data === Infinity || data === -Infinity) {\n\t\treturn this.createError(ErrorCodes.NUMBER_NOT_A_NUMBER, {value: data}, \'\', \'/type\', null, data, schema);\n\t}\n\treturn null;\n};\n\nValidatorContext.prototype.validateString = function validateString(data, schema, dataPointerPath) {\n\treturn this.validateStringLength(data, schema, dataPointerPath)\n\t\t|| this.validateStringPattern(data, schema, dataPointerPath)\n\t\t|| null;\n};\n\nValidatorContext.prototype.validateStringLength = function validateStringLength(data, schema) {\n\tif (typeof data !== "string") {\n\t\treturn null;\n\t}\n\tif (schema.minLength !== undefined) {\n\t\tif (data.length < schema.minLength) {\n\t\t\treturn this.createError(ErrorCodes.STRING_LENGTH_SHORT, {length: data.length, minimum: schema.minLength}, \'\', \'/minLength\', null, data, schema);\n\t\t}\n\t}\n\tif (schema.maxLength !== undefined) {\n\t\tif (data.length > schema.maxLength) {\n\t\t\treturn this.createError(ErrorCodes.STRING_LENGTH_LONG, {length: data.length, maximum: schema.maxLength}, \'\', \'/maxLength\', null, data, schema);\n\t\t}\n\t}\n\treturn null;\n};\n\nValidatorContext.prototype.validateStringPattern = function validateStringPattern(data, schema) {\n\tif (typeof data !== "string" || (typeof schema.pattern !== "string" && !(schema.pattern instanceof RegExp))) {\n\t\treturn null;\n\t}\n\tvar regexp;\n\tif (schema.pattern instanceof RegExp) {\n\t  regexp = schema.pattern;\n\t}\n\telse {\n\t  var body, flags = \'\';\n\t  // Check for regular expression literals\n\t  // @see http://www.ecma-international.org/ecma-262/5.1/#sec-7.8.5\n\t  var literal = schema.pattern.match(/^\\/(.+)\\/([img]*)$/);\n\t  if (literal) {\n\t    body = literal[1];\n\t    flags = literal[2];\n\t  }\n\t  else {\n\t    body = schema.pattern;\n\t  }\n\t  regexp = new RegExp(body, flags);\n\t}\n\tif (!regexp.test(data)) {\n\t\treturn this.createError(ErrorCodes.STRING_PATTERN, {pattern: schema.pattern}, \'\', \'/pattern\', null, data, schema);\n\t}\n\treturn null;\n};\n\nValidatorContext.prototype.validateArray = function validateArray(data, schema, dataPointerPath) {\n\tif (!Array.isArray(data)) {\n\t\treturn null;\n\t}\n\treturn this.validateArrayLength(data, schema, dataPointerPath)\n\t\t|| this.validateArrayUniqueItems(data, schema, dataPointerPath)\n\t\t|| this.validateArrayItems(data, schema, dataPointerPath)\n\t\t|| null;\n};\n\nValidatorContext.prototype.validateArrayLength = function validateArrayLength(data, schema) {\n\tvar error;\n\tif (schema.minItems !== undefined) {\n\t\tif (data.length < schema.minItems) {\n\t\t\terror = this.createError(ErrorCodes.ARRAY_LENGTH_SHORT, {length: data.length, minimum: schema.minItems}, \'\', \'/minItems\', null, data, schema);\n\t\t\tif (this.handleError(error)) {\n\t\t\t\treturn error;\n\t\t\t}\n\t\t}\n\t}\n\tif (schema.maxItems !== undefined) {\n\t\tif (data.length > schema.maxItems) {\n\t\t\terror = this.createError(ErrorCodes.ARRAY_LENGTH_LONG, {length: data.length, maximum: schema.maxItems}, \'\', \'/maxItems\', null, data, schema);\n\t\t\tif (this.handleError(error)) {\n\t\t\t\treturn error;\n\t\t\t}\n\t\t}\n\t}\n\treturn null;\n};\n\nValidatorContext.prototype.validateArrayUniqueItems = function validateArrayUniqueItems(data, schema) {\n\tif (schema.uniqueItems) {\n\t\tfor (var i = 0; i < data.length; i++) {\n\t\t\tfor (var j = i + 1; j < data.length; j++) {\n\t\t\t\tif (recursiveCompare(data[i], data[j])) {\n\t\t\t\t\tvar error = this.createError(ErrorCodes.ARRAY_UNIQUE, {match1: i, match2: j}, \'\', \'/uniqueItems\', null, data, schema);\n\t\t\t\t\tif (this.handleError(error)) {\n\t\t\t\t\t\treturn error;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn null;\n};\n\nValidatorContext.prototype.validateArrayItems = function validateArrayItems(data, schema, dataPointerPath) {\n\tif (schema.items === undefined) {\n\t\treturn null;\n\t}\n\tvar error, i;\n\tif (Array.isArray(schema.items)) {\n\t\tfor (i = 0; i < data.length; i++) {\n\t\t\tif (i < schema.items.length) {\n\t\t\t\tif (error = this.validateAll(data[i], schema.items[i], [i], ["items", i], dataPointerPath + "/" + i)) {\n\t\t\t\t\treturn error;\n\t\t\t\t}\n\t\t\t} else if (schema.additionalItems !== undefined) {\n\t\t\t\tif (typeof schema.additionalItems === "boolean") {\n\t\t\t\t\tif (!schema.additionalItems) {\n\t\t\t\t\t\terror = (this.createError(ErrorCodes.ARRAY_ADDITIONAL_ITEMS, {}, \'/\' + i, \'/additionalItems\', null, data, schema));\n\t\t\t\t\t\tif (this.handleError(error)) {\n\t\t\t\t\t\t\treturn error;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else if (error = this.validateAll(data[i], schema.additionalItems, [i], ["additionalItems"], dataPointerPath + "/" + i)) {\n\t\t\t\t\treturn error;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} else {\n\t\tfor (i = 0; i < data.length; i++) {\n\t\t\tif (error = this.validateAll(data[i], schema.items, [i], ["items"], dataPointerPath + "/" + i)) {\n\t\t\t\treturn error;\n\t\t\t}\n\t\t}\n\t}\n\treturn null;\n};\n\nValidatorContext.prototype.validateObject = function validateObject(data, schema, dataPointerPath) {\n\tif (typeof data !== "object" || data === null || Array.isArray(data)) {\n\t\treturn null;\n\t}\n\treturn this.validateObjectMinMaxProperties(data, schema, dataPointerPath)\n\t\t|| this.validateObjectRequiredProperties(data, schema, dataPointerPath)\n\t\t|| this.validateObjectProperties(data, schema, dataPointerPath)\n\t\t|| this.validateObjectDependencies(data, schema, dataPointerPath)\n\t\t|| null;\n};\n\nValidatorContext.prototype.validateObjectMinMaxProperties = function validateObjectMinMaxProperties(data, schema) {\n\tvar keys = Object.keys(data);\n\tvar error;\n\tif (schema.minProperties !== undefined) {\n\t\tif (keys.length < schema.minProperties) {\n\t\t\terror = this.createError(ErrorCodes.OBJECT_PROPERTIES_MINIMUM, {propertyCount: keys.length, minimum: schema.minProperties}, \'\', \'/minProperties\', null, data, schema);\n\t\t\tif (this.handleError(error)) {\n\t\t\t\treturn error;\n\t\t\t}\n\t\t}\n\t}\n\tif (schema.maxProperties !== undefined) {\n\t\tif (keys.length > schema.maxProperties) {\n\t\t\terror = this.createError(ErrorCodes.OBJECT_PROPERTIES_MAXIMUM, {propertyCount: keys.length, maximum: schema.maxProperties}, \'\', \'/maxProperties\', null, data, schema);\n\t\t\tif (this.handleError(error)) {\n\t\t\t\treturn error;\n\t\t\t}\n\t\t}\n\t}\n\treturn null;\n};\n\nValidatorContext.prototype.validateObjectRequiredProperties = function validateObjectRequiredProperties(data, schema) {\n\tif (schema.required !== undefined) {\n\t\tfor (var i = 0; i < schema.required.length; i++) {\n\t\t\tvar key = schema.required[i];\n\t\t\tif (data[key] === undefined) {\n\t\t\t\tvar error = this.createError(ErrorCodes.OBJECT_REQUIRED, {key: key}, \'\', \'/required/\' + i, null, data, schema);\n\t\t\t\tif (this.handleError(error)) {\n\t\t\t\t\treturn error;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn null;\n};\n\nValidatorContext.prototype.validateObjectProperties = function validateObjectProperties(data, schema, dataPointerPath) {\n\tvar error;\n\tfor (var key in data) {\n\t\tvar keyPointerPath = dataPointerPath + "/" + key.replace(/~/g, \'~0\').replace(/\\//g, \'~1\');\n\t\tvar foundMatch = false;\n\t\tif (schema.properties !== undefined && schema.properties[key] !== undefined) {\n\t\t\tfoundMatch = true;\n\t\t\tif (error = this.validateAll(data[key], schema.properties[key], [key], ["properties", key], keyPointerPath)) {\n\t\t\t\treturn error;\n\t\t\t}\n\t\t}\n\t\tif (schema.patternProperties !== undefined) {\n\t\t\tfor (var patternKey in schema.patternProperties) {\n\t\t\t\tvar regexp = new RegExp(patternKey);\n\t\t\t\tif (regexp.test(key)) {\n\t\t\t\t\tfoundMatch = true;\n\t\t\t\t\tif (error = this.validateAll(data[key], schema.patternProperties[patternKey], [key], ["patternProperties", patternKey], keyPointerPath)) {\n\t\t\t\t\t\treturn error;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (!foundMatch) {\n\t\t\tif (schema.additionalProperties !== undefined) {\n\t\t\t\tif (this.trackUnknownProperties) {\n\t\t\t\t\tthis.knownPropertyPaths[keyPointerPath] = true;\n\t\t\t\t\tdelete this.unknownPropertyPaths[keyPointerPath];\n\t\t\t\t}\n\t\t\t\tif (typeof schema.additionalProperties === "boolean") {\n\t\t\t\t\tif (!schema.additionalProperties) {\n\t\t\t\t\t\terror = this.createError(ErrorCodes.OBJECT_ADDITIONAL_PROPERTIES, {key: key}, \'\', \'/additionalProperties\', null, data, schema).prefixWith(key, null);\n\t\t\t\t\t\tif (this.handleError(error)) {\n\t\t\t\t\t\t\treturn error;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (error = this.validateAll(data[key], schema.additionalProperties, [key], ["additionalProperties"], keyPointerPath)) {\n\t\t\t\t\t\treturn error;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (this.trackUnknownProperties && !this.knownPropertyPaths[keyPointerPath]) {\n\t\t\t\tthis.unknownPropertyPaths[keyPointerPath] = true;\n\t\t\t}\n\t\t} else if (this.trackUnknownProperties) {\n\t\t\tthis.knownPropertyPaths[keyPointerPath] = true;\n\t\t\tdelete this.unknownPropertyPaths[keyPointerPath];\n\t\t}\n\t}\n\treturn null;\n};\n\nValidatorContext.prototype.validateObjectDependencies = function validateObjectDependencies(data, schema, dataPointerPath) {\n\tvar error;\n\tif (schema.dependencies !== undefined) {\n\t\tfor (var depKey in schema.dependencies) {\n\t\t\tif (data[depKey] !== undefined) {\n\t\t\t\tvar dep = schema.dependencies[depKey];\n\t\t\t\tif (typeof dep === "string") {\n\t\t\t\t\tif (data[dep] === undefined) {\n\t\t\t\t\t\terror = this.createError(ErrorCodes.OBJECT_DEPENDENCY_KEY, {key: depKey, missing: dep}, \'\', \'\', null, data, schema).prefixWith(null, depKey).prefixWith(null, "dependencies");\n\t\t\t\t\t\tif (this.handleError(error)) {\n\t\t\t\t\t\t\treturn error;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else if (Array.isArray(dep)) {\n\t\t\t\t\tfor (var i = 0; i < dep.length; i++) {\n\t\t\t\t\t\tvar requiredKey = dep[i];\n\t\t\t\t\t\tif (data[requiredKey] === undefined) {\n\t\t\t\t\t\t\terror = this.createError(ErrorCodes.OBJECT_DEPENDENCY_KEY, {key: depKey, missing: requiredKey}, \'\', \'/\' + i, null, data, schema).prefixWith(null, depKey).prefixWith(null, "dependencies");\n\t\t\t\t\t\t\tif (this.handleError(error)) {\n\t\t\t\t\t\t\t\treturn error;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (error = this.validateAll(data, dep, [], ["dependencies", depKey], dataPointerPath)) {\n\t\t\t\t\t\treturn error;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn null;\n};\n\nValidatorContext.prototype.validateCombinations = function validateCombinations(data, schema, dataPointerPath) {\n\treturn this.validateAllOf(data, schema, dataPointerPath)\n\t\t|| this.validateAnyOf(data, schema, dataPointerPath)\n\t\t|| this.validateOneOf(data, schema, dataPointerPath)\n\t\t|| this.validateNot(data, schema, dataPointerPath)\n\t\t|| null;\n};\n\nValidatorContext.prototype.validateAllOf = function validateAllOf(data, schema, dataPointerPath) {\n\tif (schema.allOf === undefined) {\n\t\treturn null;\n\t}\n\tvar error;\n\tfor (var i = 0; i < schema.allOf.length; i++) {\n\t\tvar subSchema = schema.allOf[i];\n\t\tif (error = this.validateAll(data, subSchema, [], ["allOf", i], dataPointerPath)) {\n\t\t\treturn error;\n\t\t}\n\t}\n\treturn null;\n};\n\nValidatorContext.prototype.validateAnyOf = function validateAnyOf(data, schema, dataPointerPath) {\n\tif (schema.anyOf === undefined) {\n\t\treturn null;\n\t}\n\tvar errors = [];\n\tvar startErrorCount = this.errors.length;\n\tvar oldUnknownPropertyPaths, oldKnownPropertyPaths;\n\tif (this.trackUnknownProperties) {\n\t\toldUnknownPropertyPaths = this.unknownPropertyPaths;\n\t\toldKnownPropertyPaths = this.knownPropertyPaths;\n\t}\n\tvar errorAtEnd = true;\n\tfor (var i = 0; i < schema.anyOf.length; i++) {\n\t\tif (this.trackUnknownProperties) {\n\t\t\tthis.unknownPropertyPaths = {};\n\t\t\tthis.knownPropertyPaths = {};\n\t\t}\n\t\tvar subSchema = schema.anyOf[i];\n\n\t\tvar errorCount = this.errors.length;\n\t\tvar error = this.validateAll(data, subSchema, [], ["anyOf", i], dataPointerPath);\n\n\t\tif (error === null && errorCount === this.errors.length) {\n\t\t\tthis.errors = this.errors.slice(0, startErrorCount);\n\n\t\t\tif (this.trackUnknownProperties) {\n\t\t\t\tfor (var knownKey in this.knownPropertyPaths) {\n\t\t\t\t\toldKnownPropertyPaths[knownKey] = true;\n\t\t\t\t\tdelete oldUnknownPropertyPaths[knownKey];\n\t\t\t\t}\n\t\t\t\tfor (var unknownKey in this.unknownPropertyPaths) {\n\t\t\t\t\tif (!oldKnownPropertyPaths[unknownKey]) {\n\t\t\t\t\t\toldUnknownPropertyPaths[unknownKey] = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// We need to continue looping so we catch all the property definitions, but we don\'t want to return an error\n\t\t\t\terrorAtEnd = false;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\treturn null;\n\t\t}\n\t\tif (error) {\n\t\t\terrors.push(error.prefixWith(null, "" + i).prefixWith(null, "anyOf"));\n\t\t}\n\t}\n\tif (this.trackUnknownProperties) {\n\t\tthis.unknownPropertyPaths = oldUnknownPropertyPaths;\n\t\tthis.knownPropertyPaths = oldKnownPropertyPaths;\n\t}\n\tif (errorAtEnd) {\n\t\terrors = errors.concat(this.errors.slice(startErrorCount));\n\t\tthis.errors = this.errors.slice(0, startErrorCount);\n\t\treturn this.createError(ErrorCodes.ANY_OF_MISSING, {}, "", "/anyOf", errors, data, schema);\n\t}\n};\n\nValidatorContext.prototype.validateOneOf = function validateOneOf(data, schema, dataPointerPath) {\n\tif (schema.oneOf === undefined) {\n\t\treturn null;\n\t}\n\tvar validIndex = null;\n\tvar errors = [];\n\tvar startErrorCount = this.errors.length;\n\tvar oldUnknownPropertyPaths, oldKnownPropertyPaths;\n\tif (this.trackUnknownProperties) {\n\t\toldUnknownPropertyPaths = this.unknownPropertyPaths;\n\t\toldKnownPropertyPaths = this.knownPropertyPaths;\n\t}\n\tfor (var i = 0; i < schema.oneOf.length; i++) {\n\t\tif (this.trackUnknownProperties) {\n\t\t\tthis.unknownPropertyPaths = {};\n\t\t\tthis.knownPropertyPaths = {};\n\t\t}\n\t\tvar subSchema = schema.oneOf[i];\n\n\t\tvar errorCount = this.errors.length;\n\t\tvar error = this.validateAll(data, subSchema, [], ["oneOf", i], dataPointerPath);\n\n\t\tif (error === null && errorCount === this.errors.length) {\n\t\t\tif (validIndex === null) {\n\t\t\t\tvalidIndex = i;\n\t\t\t} else {\n\t\t\t\tthis.errors = this.errors.slice(0, startErrorCount);\n\t\t\t\treturn this.createError(ErrorCodes.ONE_OF_MULTIPLE, {index1: validIndex, index2: i}, "", "/oneOf", null, data, schema);\n\t\t\t}\n\t\t\tif (this.trackUnknownProperties) {\n\t\t\t\tfor (var knownKey in this.knownPropertyPaths) {\n\t\t\t\t\toldKnownPropertyPaths[knownKey] = true;\n\t\t\t\t\tdelete oldUnknownPropertyPaths[knownKey];\n\t\t\t\t}\n\t\t\t\tfor (var unknownKey in this.unknownPropertyPaths) {\n\t\t\t\t\tif (!oldKnownPropertyPaths[unknownKey]) {\n\t\t\t\t\t\toldUnknownPropertyPaths[unknownKey] = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (error) {\n\t\t\terrors.push(error);\n\t\t}\n\t}\n\tif (this.trackUnknownProperties) {\n\t\tthis.unknownPropertyPaths = oldUnknownPropertyPaths;\n\t\tthis.knownPropertyPaths = oldKnownPropertyPaths;\n\t}\n\tif (validIndex === null) {\n\t\terrors = errors.concat(this.errors.slice(startErrorCount));\n\t\tthis.errors = this.errors.slice(0, startErrorCount);\n\t\treturn this.createError(ErrorCodes.ONE_OF_MISSING, {}, "", "/oneOf", errors, data, schema);\n\t} else {\n\t\tthis.errors = this.errors.slice(0, startErrorCount);\n\t}\n\treturn null;\n};\n\nValidatorContext.prototype.validateNot = function validateNot(data, schema, dataPointerPath) {\n\tif (schema.not === undefined) {\n\t\treturn null;\n\t}\n\tvar oldErrorCount = this.errors.length;\n\tvar oldUnknownPropertyPaths, oldKnownPropertyPaths;\n\tif (this.trackUnknownProperties) {\n\t\toldUnknownPropertyPaths = this.unknownPropertyPaths;\n\t\toldKnownPropertyPaths = this.knownPropertyPaths;\n\t\tthis.unknownPropertyPaths = {};\n\t\tthis.knownPropertyPaths = {};\n\t}\n\tvar error = this.validateAll(data, schema.not, null, null, dataPointerPath);\n\tvar notErrors = this.errors.slice(oldErrorCount);\n\tthis.errors = this.errors.slice(0, oldErrorCount);\n\tif (this.trackUnknownProperties) {\n\t\tthis.unknownPropertyPaths = oldUnknownPropertyPaths;\n\t\tthis.knownPropertyPaths = oldKnownPropertyPaths;\n\t}\n\tif (error === null && notErrors.length === 0) {\n\t\treturn this.createError(ErrorCodes.NOT_PASSED, {}, "", "/not", null, data, schema);\n\t}\n\treturn null;\n};\n\nValidatorContext.prototype.validateHypermedia = function validateCombinations(data, schema, dataPointerPath) {\n\tif (!schema.links) {\n\t\treturn null;\n\t}\n\tvar error;\n\tfor (var i = 0; i < schema.links.length; i++) {\n\t\tvar ldo = schema.links[i];\n\t\tif (ldo.rel === "describedby") {\n\t\t\tvar template = new UriTemplate(ldo.href);\n\t\t\tvar allPresent = true;\n\t\t\tfor (var j = 0; j < template.varNames.length; j++) {\n\t\t\t\tif (!(template.varNames[j] in data)) {\n\t\t\t\t\tallPresent = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (allPresent) {\n\t\t\t\tvar schemaUrl = template.fillFromObject(data);\n\t\t\t\tvar subSchema = {"$ref": schemaUrl};\n\t\t\t\tif (error = this.validateAll(data, subSchema, [], ["links", i], dataPointerPath)) {\n\t\t\t\t\treturn error;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n};\n\n// parseURI() and resolveUrl() are from https://gist.github.com/1088850\n//   -  released as public domain by author ("Yaffle") - see comments on gist\n\nfunction parseURI(url) {\n\tvar m = String(url).replace(/^\\s+|\\s+$/g, \'\').match(/^([^:\\/?#]+:)?(\\/\\/(?:[^:@]*(?::[^:@]*)?@)?(([^:\\/?#]*)(?::(\\d*))?))?([^?#]*)(\\?[^#]*)?(#[\\s\\S]*)?/);\n\t// authority = \'//\' + user + \':\' + pass \'@\' + hostname + \':\' port\n\treturn (m ? {\n\t\thref     : m[0] || \'\',\n\t\tprotocol : m[1] || \'\',\n\t\tauthority: m[2] || \'\',\n\t\thost     : m[3] || \'\',\n\t\thostname : m[4] || \'\',\n\t\tport     : m[5] || \'\',\n\t\tpathname : m[6] || \'\',\n\t\tsearch   : m[7] || \'\',\n\t\thash     : m[8] || \'\'\n\t} : null);\n}\n\nfunction resolveUrl(base, href) {// RFC 3986\n\n\tfunction removeDotSegments(input) {\n\t\tvar output = [];\n\t\tinput.replace(/^(\\.\\.?(\\/|$))+/, \'\')\n\t\t\t.replace(/\\/(\\.(\\/|$))+/g, \'/\')\n\t\t\t.replace(/\\/\\.\\.$/, \'/../\')\n\t\t\t.replace(/\\/?[^\\/]*/g, function (p) {\n\t\t\t\tif (p === \'/..\') {\n\t\t\t\t\toutput.pop();\n\t\t\t\t} else {\n\t\t\t\t\toutput.push(p);\n\t\t\t\t}\n\t\t});\n\t\treturn output.join(\'\').replace(/^\\//, input.charAt(0) === \'/\' ? \'/\' : \'\');\n\t}\n\n\thref = parseURI(href || \'\');\n\tbase = parseURI(base || \'\');\n\n\treturn !href || !base ? null : (href.protocol || base.protocol) +\n\t\t(href.protocol || href.authority ? href.authority : base.authority) +\n\t\tremoveDotSegments(href.protocol || href.authority || href.pathname.charAt(0) === \'/\' ? href.pathname : (href.pathname ? ((base.authority && !base.pathname ? \'/\' : \'\') + base.pathname.slice(0, base.pathname.lastIndexOf(\'/\') + 1) + href.pathname) : base.pathname)) +\n\t\t(href.protocol || href.authority || href.pathname ? href.search : (href.search || base.search)) +\n\t\thref.hash;\n}\n\nfunction getDocumentUri(uri) {\n\treturn uri.split(\'#\')[0];\n}\nfunction normSchema(schema, baseUri) {\n\tif (schema && typeof schema === "object") {\n\t\tif (baseUri === undefined) {\n\t\t\tbaseUri = schema.id;\n\t\t} else if (typeof schema.id === "string") {\n\t\t\tbaseUri = resolveUrl(baseUri, schema.id);\n\t\t\tschema.id = baseUri;\n\t\t}\n\t\tif (Array.isArray(schema)) {\n\t\t\tfor (var i = 0; i < schema.length; i++) {\n\t\t\t\tnormSchema(schema[i], baseUri);\n\t\t\t}\n\t\t} else {\n\t\t\tif (typeof schema[\'$ref\'] === "string") {\n\t\t\t\tschema[\'$ref\'] = resolveUrl(baseUri, schema[\'$ref\']);\n\t\t\t}\n\t\t\tfor (var key in schema) {\n\t\t\t\tif (key !== "enum") {\n\t\t\t\t\tnormSchema(schema[key], baseUri);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunction defaultErrorReporter(language) {\n\tlanguage = language || \'en\';\n\n\tvar errorMessages = languages[language];\n\n\treturn function (error) {\n\t\tvar messageTemplate = errorMessages[error.code] || ErrorMessagesDefault[error.code];\n\t\tif (typeof messageTemplate !== \'string\') {\n\t\t\treturn "Unknown error code " + error.code + ": " + JSON.stringify(error.messageParams);\n\t\t}\n\t\tvar messageParams = error.params;\n\t\t// Adapted from Crockford\'s supplant()\n\t\treturn messageTemplate.replace(/\\{([^{}]*)\\}/g, function (whole, varName) {\n\t\t\tvar subValue = messageParams[varName];\n\t\t\treturn typeof subValue === \'string\' || typeof subValue === \'number\' ? subValue : whole;\n\t\t});\n\t};\n}\n\nvar ErrorCodes = {\n\tINVALID_TYPE: 0,\n\tENUM_MISMATCH: 1,\n\tANY_OF_MISSING: 10,\n\tONE_OF_MISSING: 11,\n\tONE_OF_MULTIPLE: 12,\n\tNOT_PASSED: 13,\n\t// Numeric errors\n\tNUMBER_MULTIPLE_OF: 100,\n\tNUMBER_MINIMUM: 101,\n\tNUMBER_MINIMUM_EXCLUSIVE: 102,\n\tNUMBER_MAXIMUM: 103,\n\tNUMBER_MAXIMUM_EXCLUSIVE: 104,\n\tNUMBER_NOT_A_NUMBER: 105,\n\t// String errors\n\tSTRING_LENGTH_SHORT: 200,\n\tSTRING_LENGTH_LONG: 201,\n\tSTRING_PATTERN: 202,\n\t// Object errors\n\tOBJECT_PROPERTIES_MINIMUM: 300,\n\tOBJECT_PROPERTIES_MAXIMUM: 301,\n\tOBJECT_REQUIRED: 302,\n\tOBJECT_ADDITIONAL_PROPERTIES: 303,\n\tOBJECT_DEPENDENCY_KEY: 304,\n\t// Array errors\n\tARRAY_LENGTH_SHORT: 400,\n\tARRAY_LENGTH_LONG: 401,\n\tARRAY_UNIQUE: 402,\n\tARRAY_ADDITIONAL_ITEMS: 403,\n\t// Custom/user-defined errors\n\tFORMAT_CUSTOM: 500,\n\tKEYWORD_CUSTOM: 501,\n\t// Schema structure\n\tCIRCULAR_REFERENCE: 600,\n\t// Non-standard validation options\n\tUNKNOWN_PROPERTY: 1000\n};\nvar ErrorCodeLookup = {};\nfor (var key in ErrorCodes) {\n\tErrorCodeLookup[ErrorCodes[key]] = key;\n}\nvar ErrorMessagesDefault = {\n\tINVALID_TYPE: "Invalid type: {type} (expected {expected})",\n\tENUM_MISMATCH: "No enum match for: {value}",\n\tANY_OF_MISSING: "Data does not match any schemas from \\"anyOf\\"",\n\tONE_OF_MISSING: "Data does not match any schemas from \\"oneOf\\"",\n\tONE_OF_MULTIPLE: "Data is valid against more than one schema from \\"oneOf\\": indices {index1} and {index2}",\n\tNOT_PASSED: "Data matches schema from \\"not\\"",\n\t// Numeric errors\n\tNUMBER_MULTIPLE_OF: "Value {value} is not a multiple of {multipleOf}",\n\tNUMBER_MINIMUM: "Value {value} is less than minimum {minimum}",\n\tNUMBER_MINIMUM_EXCLUSIVE: "Value {value} is equal to exclusive minimum {minimum}",\n\tNUMBER_MAXIMUM: "Value {value} is greater than maximum {maximum}",\n\tNUMBER_MAXIMUM_EXCLUSIVE: "Value {value} is equal to exclusive maximum {maximum}",\n\tNUMBER_NOT_A_NUMBER: "Value {value} is not a valid number",\n\t// String errors\n\tSTRING_LENGTH_SHORT: "String is too short ({length} chars), minimum {minimum}",\n\tSTRING_LENGTH_LONG: "String is too long ({length} chars), maximum {maximum}",\n\tSTRING_PATTERN: "String does not match pattern: {pattern}",\n\t// Object errors\n\tOBJECT_PROPERTIES_MINIMUM: "Too few properties defined ({propertyCount}), minimum {minimum}",\n\tOBJECT_PROPERTIES_MAXIMUM: "Too many properties defined ({propertyCount}), maximum {maximum}",\n\tOBJECT_REQUIRED: "Missing required property: {key}",\n\tOBJECT_ADDITIONAL_PROPERTIES: "Additional properties not allowed",\n\tOBJECT_DEPENDENCY_KEY: "Dependency failed - key must exist: {missing} (due to key: {key})",\n\t// Array errors\n\tARRAY_LENGTH_SHORT: "Array is too short ({length}), minimum {minimum}",\n\tARRAY_LENGTH_LONG: "Array is too long ({length}), maximum {maximum}",\n\tARRAY_UNIQUE: "Array items are not unique (indices {match1} and {match2})",\n\tARRAY_ADDITIONAL_ITEMS: "Additional items not allowed",\n\t// Format errors\n\tFORMAT_CUSTOM: "Format validation failed ({message})",\n\tKEYWORD_CUSTOM: "Keyword failed: {key} ({message})",\n\t// Schema structure\n\tCIRCULAR_REFERENCE: "Circular $refs: {urls}",\n\t// Non-standard validation options\n\tUNKNOWN_PROPERTY: "Unknown property (not in schema)"\n};\n\nfunction ValidationError(code, params, dataPath, schemaPath, subErrors) {\n\tError.call(this);\n\tif (code === undefined) {\n\t\tthrow new Error ("No error code supplied: " + schemaPath);\n\t}\n\tthis.message = \'\';\n\tthis.params = params;\n\tthis.code = code;\n\tthis.dataPath = dataPath || "";\n\tthis.schemaPath = schemaPath || "";\n\tthis.subErrors = subErrors || null;\n\n\tvar err = new Error(this.message);\n\tthis.stack = err.stack || err.stacktrace;\n\tif (!this.stack) {\n\t\ttry {\n\t\t\tthrow err;\n\t\t}\n\t\tcatch(err) {\n\t\t\tthis.stack = err.stack || err.stacktrace;\n\t\t}\n\t}\n}\nValidationError.prototype = Object.create(Error.prototype);\nValidationError.prototype.constructor = ValidationError;\nValidationError.prototype.name = \'ValidationError\';\n\nValidationError.prototype.prefixWith = function (dataPrefix, schemaPrefix) {\n\tif (dataPrefix !== null) {\n\t\tdataPrefix = dataPrefix.replace(/~/g, "~0").replace(/\\//g, "~1");\n\t\tthis.dataPath = "/" + dataPrefix + this.dataPath;\n\t}\n\tif (schemaPrefix !== null) {\n\t\tschemaPrefix = schemaPrefix.replace(/~/g, "~0").replace(/\\//g, "~1");\n\t\tthis.schemaPath = "/" + schemaPrefix + this.schemaPath;\n\t}\n\tif (this.subErrors !== null) {\n\t\tfor (var i = 0; i < this.subErrors.length; i++) {\n\t\t\tthis.subErrors[i].prefixWith(dataPrefix, schemaPrefix);\n\t\t}\n\t}\n\treturn this;\n};\n\nfunction isTrustedUrl(baseUrl, testUrl) {\n\tif(testUrl.substring(0, baseUrl.length) === baseUrl){\n\t\tvar remainder = testUrl.substring(baseUrl.length);\n\t\tif ((testUrl.length > 0 && testUrl.charAt(baseUrl.length - 1) === "/")\n\t\t\t|| remainder.charAt(0) === "#"\n\t\t\t|| remainder.charAt(0) === "?") {\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nvar languages = {};\nfunction createApi(language) {\n\tvar globalContext = new ValidatorContext();\n\tvar currentLanguage;\n\tvar customErrorReporter;\n\tvar api = {\n\t\tsetErrorReporter: function (reporter) {\n\t\t\tif (typeof reporter === \'string\') {\n\t\t\t\treturn this.language(reporter);\n\t\t\t}\n\t\t\tcustomErrorReporter = reporter;\n\t\t\treturn true;\n\t\t},\n\t\taddFormat: function () {\n\t\t\tglobalContext.addFormat.apply(globalContext, arguments);\n\t\t},\n\t\tlanguage: function (code) {\n\t\t\tif (!code) {\n\t\t\t\treturn currentLanguage;\n\t\t\t}\n\t\t\tif (!languages[code]) {\n\t\t\t\tcode = code.split(\'-\')[0]; // fall back to base language\n\t\t\t}\n\t\t\tif (languages[code]) {\n\t\t\t\tcurrentLanguage = code;\n\t\t\t\treturn code; // so you can tell if fall-back has happened\n\t\t\t}\n\t\t\treturn false;\n\t\t},\n\t\taddLanguage: function (code, messageMap) {\n\t\t\tvar key;\n\t\t\tfor (key in ErrorCodes) {\n\t\t\t\tif (messageMap[key] && !messageMap[ErrorCodes[key]]) {\n\t\t\t\t\tmessageMap[ErrorCodes[key]] = messageMap[key];\n\t\t\t\t}\n\t\t\t}\n\t\t\tvar rootCode = code.split(\'-\')[0];\n\t\t\tif (!languages[rootCode]) { // use for base language if not yet defined\n\t\t\t\tlanguages[code] = messageMap;\n\t\t\t\tlanguages[rootCode] = messageMap;\n\t\t\t} else {\n\t\t\t\tlanguages[code] = Object.create(languages[rootCode]);\n\t\t\t\tfor (key in messageMap) {\n\t\t\t\t\tif (typeof languages[rootCode][key] === \'undefined\') {\n\t\t\t\t\t\tlanguages[rootCode][key] = messageMap[key];\n\t\t\t\t\t}\n\t\t\t\t\tlanguages[code][key] = messageMap[key];\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn this;\n\t\t},\n\t\tfreshApi: function (language) {\n\t\t\tvar result = createApi();\n\t\t\tif (language) {\n\t\t\t\tresult.language(language);\n\t\t\t}\n\t\t\treturn result;\n\t\t},\n\t\tvalidate: function (data, schema, checkRecursive, banUnknownProperties) {\n\t\t\tvar def = defaultErrorReporter(currentLanguage);\n\t\t\tvar errorReporter = customErrorReporter ? function (error, data, schema) {\n\t\t\t\treturn customErrorReporter(error, data, schema) || def(error, data, schema);\n\t\t\t} : def;\n\t\t\tvar context = new ValidatorContext(globalContext, false, errorReporter, checkRecursive, banUnknownProperties);\n\t\t\tif (typeof schema === "string") {\n\t\t\t\tschema = {"$ref": schema};\n\t\t\t}\n\t\t\tcontext.addSchema("", schema);\n\t\t\tvar error = context.validateAll(data, schema, null, null, "");\n\t\t\tif (!error && banUnknownProperties) {\n\t\t\t\terror = context.banUnknownProperties(data, schema);\n\t\t\t}\n\t\t\tthis.error = error;\n\t\t\tthis.missing = context.missing;\n\t\t\tthis.valid = (error === null);\n\t\t\treturn this.valid;\n\t\t},\n\t\tvalidateResult: function () {\n\t\t\tvar result = {};\n\t\t\tthis.validate.apply(result, arguments);\n\t\t\treturn result;\n\t\t},\n\t\tvalidateMultiple: function (data, schema, checkRecursive, banUnknownProperties) {\n\t\t\tvar def = defaultErrorReporter(currentLanguage);\n\t\t\tvar errorReporter = customErrorReporter ? function (error, data, schema) {\n\t\t\t\treturn customErrorReporter(error, data, schema) || def(error, data, schema);\n\t\t\t} : def;\n\t\t\tvar context = new ValidatorContext(globalContext, true, errorReporter, checkRecursive, banUnknownProperties);\n\t\t\tif (typeof schema === "string") {\n\t\t\t\tschema = {"$ref": schema};\n\t\t\t}\n\t\t\tcontext.addSchema("", schema);\n\t\t\tcontext.validateAll(data, schema, null, null, "");\n\t\t\tif (banUnknownProperties) {\n\t\t\t\tcontext.banUnknownProperties(data, schema);\n\t\t\t}\n\t\t\tvar result = {};\n\t\t\tresult.errors = context.errors;\n\t\t\tresult.missing = context.missing;\n\t\t\tresult.valid = (result.errors.length === 0);\n\t\t\treturn result;\n\t\t},\n\t\taddSchema: function () {\n\t\t\treturn globalContext.addSchema.apply(globalContext, arguments);\n\t\t},\n\t\tgetSchema: function () {\n\t\t\treturn globalContext.getSchema.apply(globalContext, arguments);\n\t\t},\n\t\tgetSchemaMap: function () {\n\t\t\treturn globalContext.getSchemaMap.apply(globalContext, arguments);\n\t\t},\n\t\tgetSchemaUris: function () {\n\t\t\treturn globalContext.getSchemaUris.apply(globalContext, arguments);\n\t\t},\n\t\tgetMissingUris: function () {\n\t\t\treturn globalContext.getMissingUris.apply(globalContext, arguments);\n\t\t},\n\t\tdropSchemas: function () {\n\t\t\tglobalContext.dropSchemas.apply(globalContext, arguments);\n\t\t},\n\t\tdefineKeyword: function () {\n\t\t\tglobalContext.defineKeyword.apply(globalContext, arguments);\n\t\t},\n\t\tdefineError: function (codeName, codeNumber, defaultMessage) {\n\t\t\tif (typeof codeName !== \'string\' || !/^[A-Z]+(_[A-Z]+)*$/.test(codeName)) {\n\t\t\t\tthrow new Error(\'Code name must be a string in UPPER_CASE_WITH_UNDERSCORES\');\n\t\t\t}\n\t\t\tif (typeof codeNumber !== \'number\' || codeNumber%1 !== 0 || codeNumber < 10000) {\n\t\t\t\tthrow new Error(\'Code number must be an integer > 10000\');\n\t\t\t}\n\t\t\tif (typeof ErrorCodes[codeName] !== \'undefined\') {\n\t\t\t\tthrow new Error(\'Error already defined: \' + codeName + \' as \' + ErrorCodes[codeName]);\n\t\t\t}\n\t\t\tif (typeof ErrorCodeLookup[codeNumber] !== \'undefined\') {\n\t\t\t\tthrow new Error(\'Error code already used: \' + ErrorCodeLookup[codeNumber] + \' as \' + codeNumber);\n\t\t\t}\n\t\t\tErrorCodes[codeName] = codeNumber;\n\t\t\tErrorCodeLookup[codeNumber] = codeName;\n\t\t\tErrorMessagesDefault[codeName] = ErrorMessagesDefault[codeNumber] = defaultMessage;\n\t\t\tfor (var langCode in languages) {\n\t\t\t\tvar language = languages[langCode];\n\t\t\t\tif (language[codeName]) {\n\t\t\t\t\tlanguage[codeNumber] = language[codeNumber] || language[codeName];\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\treset: function () {\n\t\t\tglobalContext.reset();\n\t\t\tthis.error = null;\n\t\t\tthis.missing = [];\n\t\t\tthis.valid = true;\n\t\t},\n\t\tmissing: [],\n\t\terror: null,\n\t\tvalid: true,\n\t\tnormSchema: normSchema,\n\t\tresolveUrl: resolveUrl,\n\t\tgetDocumentUri: getDocumentUri,\n\t\terrorCodes: ErrorCodes\n\t};\n\tapi.language(language || \'en\');\n\treturn api;\n}\n\nvar tv4 = createApi();\ntv4.addLanguage(\'en-gb\', ErrorMessagesDefault);\n\n//legacy property\ntv4.tv4 = tv4;\n\nreturn tv4; // used by _header.js to globalise.\n\n}));\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3R2NC90djQuanM/NDViNSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixlQUFlO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUIscUJBQXFCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsU0FBUztBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGOztBQUVBO0FBQ0E7QUFDQTtBQUNB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQsc0JBQXNCO0FBQzNFLEVBQUU7QUFDRixxREFBcUQscUNBQXFD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LENBQUMiLCJmaWxlIjoiMjguanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuQXV0aG9yOiBHZXJhaW50IEx1ZmYgYW5kIG90aGVyc1xuWWVhcjogMjAxM1xuXG5UaGlzIGNvZGUgaXMgcmVsZWFzZWQgaW50byB0aGUgXCJwdWJsaWMgZG9tYWluXCIgYnkgaXRzIGF1dGhvcihzKS4gIEFueWJvZHkgbWF5IHVzZSwgYWx0ZXIgYW5kIGRpc3RyaWJ1dGUgdGhlIGNvZGUgd2l0aG91dCByZXN0cmljdGlvbi4gIFRoZSBhdXRob3IgbWFrZXMgbm8gZ3VhcmFudGVlcywgYW5kIHRha2VzIG5vIGxpYWJpbGl0eSBvZiBhbnkga2luZCBmb3IgdXNlIG9mIHRoaXMgY29kZS5cblxuSWYgeW91IGZpbmQgYSBidWcgb3IgbWFrZSBhbiBpbXByb3ZlbWVudCwgaXQgd291bGQgYmUgY291cnRlb3VzIHRvIGxldCB0aGUgYXV0aG9yIGtub3csIGJ1dCBpdCBpcyBub3QgY29tcHVsc29yeS5cbiovXG4oZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuICBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XG4gICAgLy8gQU1ELiBSZWdpc3RlciBhcyBhbiBhbm9ueW1vdXMgbW9kdWxlLlxuICAgIGRlZmluZShbXSwgZmFjdG9yeSk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgJiYgbW9kdWxlLmV4cG9ydHMpe1xuICAgIC8vIENvbW1vbkpTLiBEZWZpbmUgZXhwb3J0LlxuICAgIG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpO1xuICB9IGVsc2Uge1xuICAgIC8vIEJyb3dzZXIgZ2xvYmFsc1xuICAgIGdsb2JhbC50djQgPSBmYWN0b3J5KCk7XG4gIH1cbn0odGhpcywgZnVuY3Rpb24gKCkge1xuXG4vLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9PYmplY3Qva2V5cz9yZWRpcmVjdGxvY2FsZT1lbi1VUyZyZWRpcmVjdHNsdWc9SmF2YVNjcmlwdCUyRlJlZmVyZW5jZSUyRkdsb2JhbF9PYmplY3RzJTJGT2JqZWN0JTJGa2V5c1xuaWYgKCFPYmplY3Qua2V5cykge1xuXHRPYmplY3Qua2V5cyA9IChmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSxcblx0XHRcdGhhc0RvbnRFbnVtQnVnID0gISh7dG9TdHJpbmc6IG51bGx9KS5wcm9wZXJ0eUlzRW51bWVyYWJsZSgndG9TdHJpbmcnKSxcblx0XHRcdGRvbnRFbnVtcyA9IFtcblx0XHRcdFx0J3RvU3RyaW5nJyxcblx0XHRcdFx0J3RvTG9jYWxlU3RyaW5nJyxcblx0XHRcdFx0J3ZhbHVlT2YnLFxuXHRcdFx0XHQnaGFzT3duUHJvcGVydHknLFxuXHRcdFx0XHQnaXNQcm90b3R5cGVPZicsXG5cdFx0XHRcdCdwcm9wZXJ0eUlzRW51bWVyYWJsZScsXG5cdFx0XHRcdCdjb25zdHJ1Y3Rvcidcblx0XHRcdF0sXG5cdFx0XHRkb250RW51bXNMZW5ndGggPSBkb250RW51bXMubGVuZ3RoO1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uIChvYmopIHtcblx0XHRcdGlmICh0eXBlb2Ygb2JqICE9PSAnb2JqZWN0JyAmJiB0eXBlb2Ygb2JqICE9PSAnZnVuY3Rpb24nIHx8IG9iaiA9PT0gbnVsbCkge1xuXHRcdFx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCdPYmplY3Qua2V5cyBjYWxsZWQgb24gbm9uLW9iamVjdCcpO1xuXHRcdFx0fVxuXG5cdFx0XHR2YXIgcmVzdWx0ID0gW107XG5cblx0XHRcdGZvciAodmFyIHByb3AgaW4gb2JqKSB7XG5cdFx0XHRcdGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgcHJvcCkpIHtcblx0XHRcdFx0XHRyZXN1bHQucHVzaChwcm9wKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoaGFzRG9udEVudW1CdWcpIHtcblx0XHRcdFx0Zm9yICh2YXIgaT0wOyBpIDwgZG9udEVudW1zTGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0XHRpZiAoaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGRvbnRFbnVtc1tpXSkpIHtcblx0XHRcdFx0XHRcdHJlc3VsdC5wdXNoKGRvbnRFbnVtc1tpXSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcmVzdWx0O1xuXHRcdH07XG5cdH0pKCk7XG59XG4vLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9PYmplY3QvY3JlYXRlXG5pZiAoIU9iamVjdC5jcmVhdGUpIHtcblx0T2JqZWN0LmNyZWF0ZSA9IChmdW5jdGlvbigpe1xuXHRcdGZ1bmN0aW9uIEYoKXt9XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24obyl7XG5cdFx0XHRpZiAoYXJndW1lbnRzLmxlbmd0aCAhPT0gMSkge1xuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ09iamVjdC5jcmVhdGUgaW1wbGVtZW50YXRpb24gb25seSBhY2NlcHRzIG9uZSBwYXJhbWV0ZXIuJyk7XG5cdFx0XHR9XG5cdFx0XHRGLnByb3RvdHlwZSA9IG87XG5cdFx0XHRyZXR1cm4gbmV3IEYoKTtcblx0XHR9O1xuXHR9KSgpO1xufVxuLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvQXJyYXkvaXNBcnJheT9yZWRpcmVjdGxvY2FsZT1lbi1VUyZyZWRpcmVjdHNsdWc9SmF2YVNjcmlwdCUyRlJlZmVyZW5jZSUyRkdsb2JhbF9PYmplY3RzJTJGQXJyYXklMkZpc0FycmF5XG5pZighQXJyYXkuaXNBcnJheSkge1xuXHRBcnJheS5pc0FycmF5ID0gZnVuY3Rpb24gKHZBcmcpIHtcblx0XHRyZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZBcmcpID09PSBcIltvYmplY3QgQXJyYXldXCI7XG5cdH07XG59XG4vLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9BcnJheS9pbmRleE9mP3JlZGlyZWN0bG9jYWxlPWVuLVVTJnJlZGlyZWN0c2x1Zz1KYXZhU2NyaXB0JTJGUmVmZXJlbmNlJTJGR2xvYmFsX09iamVjdHMlMkZBcnJheSUyRmluZGV4T2ZcbmlmICghQXJyYXkucHJvdG90eXBlLmluZGV4T2YpIHtcblx0QXJyYXkucHJvdG90eXBlLmluZGV4T2YgPSBmdW5jdGlvbiAoc2VhcmNoRWxlbWVudCAvKiwgZnJvbUluZGV4ICovICkge1xuXHRcdGlmICh0aGlzID09PSBudWxsKSB7XG5cdFx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCk7XG5cdFx0fVxuXHRcdHZhciB0ID0gT2JqZWN0KHRoaXMpO1xuXHRcdHZhciBsZW4gPSB0Lmxlbmd0aCA+Pj4gMDtcblxuXHRcdGlmIChsZW4gPT09IDApIHtcblx0XHRcdHJldHVybiAtMTtcblx0XHR9XG5cdFx0dmFyIG4gPSAwO1xuXHRcdGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuXHRcdFx0biA9IE51bWJlcihhcmd1bWVudHNbMV0pO1xuXHRcdFx0aWYgKG4gIT09IG4pIHsgLy8gc2hvcnRjdXQgZm9yIHZlcmlmeWluZyBpZiBpdCdzIE5hTlxuXHRcdFx0XHRuID0gMDtcblx0XHRcdH0gZWxzZSBpZiAobiAhPT0gMCAmJiBuICE9PSBJbmZpbml0eSAmJiBuICE9PSAtSW5maW5pdHkpIHtcblx0XHRcdFx0biA9IChuID4gMCB8fCAtMSkgKiBNYXRoLmZsb29yKE1hdGguYWJzKG4pKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0aWYgKG4gPj0gbGVuKSB7XG5cdFx0XHRyZXR1cm4gLTE7XG5cdFx0fVxuXHRcdHZhciBrID0gbiA+PSAwID8gbiA6IE1hdGgubWF4KGxlbiAtIE1hdGguYWJzKG4pLCAwKTtcblx0XHRmb3IgKDsgayA8IGxlbjsgaysrKSB7XG5cdFx0XHRpZiAoayBpbiB0ICYmIHRba10gPT09IHNlYXJjaEVsZW1lbnQpIHtcblx0XHRcdFx0cmV0dXJuIGs7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiAtMTtcblx0fTtcbn1cblxuLy8gR3J1bmdleSBPYmplY3QuaXNGcm96ZW4gaGFja1xuaWYgKCFPYmplY3QuaXNGcm96ZW4pIHtcblx0T2JqZWN0LmlzRnJvemVuID0gZnVuY3Rpb24gKG9iaikge1xuXHRcdHZhciBrZXkgPSBcInR2NF90ZXN0X2Zyb3plbl9rZXlcIjtcblx0XHR3aGlsZSAob2JqLmhhc093blByb3BlcnR5KGtleSkpIHtcblx0XHRcdGtleSArPSBNYXRoLnJhbmRvbSgpO1xuXHRcdH1cblx0XHR0cnkge1xuXHRcdFx0b2JqW2tleV0gPSB0cnVlO1xuXHRcdFx0ZGVsZXRlIG9ialtrZXldO1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblx0fTtcbn1cbi8vIEJhc2VkIG9uOiBodHRwczovL2dpdGh1Yi5jb20vZ2VyYWludGx1ZmYvdXJpLXRlbXBsYXRlcywgYnV0IHdpdGggYWxsIHRoZSBkZS1zdWJzdGl0dXRpb24gc3R1ZmYgcmVtb3ZlZFxuXG52YXIgdXJpVGVtcGxhdGVHbG9iYWxNb2RpZmllcnMgPSB7XG5cdFwiK1wiOiB0cnVlLFxuXHRcIiNcIjogdHJ1ZSxcblx0XCIuXCI6IHRydWUsXG5cdFwiL1wiOiB0cnVlLFxuXHRcIjtcIjogdHJ1ZSxcblx0XCI/XCI6IHRydWUsXG5cdFwiJlwiOiB0cnVlXG59O1xudmFyIHVyaVRlbXBsYXRlU3VmZmljZXMgPSB7XG5cdFwiKlwiOiB0cnVlXG59O1xuXG5mdW5jdGlvbiBub3RSZWFsbHlQZXJjZW50RW5jb2RlKHN0cmluZykge1xuXHRyZXR1cm4gZW5jb2RlVVJJKHN0cmluZykucmVwbGFjZSgvJTI1WzAtOV1bMC05XS9nLCBmdW5jdGlvbiAoZG91YmxlRW5jb2RlZCkge1xuXHRcdHJldHVybiBcIiVcIiArIGRvdWJsZUVuY29kZWQuc3Vic3RyaW5nKDMpO1xuXHR9KTtcbn1cblxuZnVuY3Rpb24gdXJpVGVtcGxhdGVTdWJzdGl0dXRpb24oc3BlYykge1xuXHR2YXIgbW9kaWZpZXIgPSBcIlwiO1xuXHRpZiAodXJpVGVtcGxhdGVHbG9iYWxNb2RpZmllcnNbc3BlYy5jaGFyQXQoMCldKSB7XG5cdFx0bW9kaWZpZXIgPSBzcGVjLmNoYXJBdCgwKTtcblx0XHRzcGVjID0gc3BlYy5zdWJzdHJpbmcoMSk7XG5cdH1cblx0dmFyIHNlcGFyYXRvciA9IFwiXCI7XG5cdHZhciBwcmVmaXggPSBcIlwiO1xuXHR2YXIgc2hvdWxkRXNjYXBlID0gdHJ1ZTtcblx0dmFyIHNob3dWYXJpYWJsZXMgPSBmYWxzZTtcblx0dmFyIHRyaW1FbXB0eVN0cmluZyA9IGZhbHNlO1xuXHRpZiAobW9kaWZpZXIgPT09ICcrJykge1xuXHRcdHNob3VsZEVzY2FwZSA9IGZhbHNlO1xuXHR9IGVsc2UgaWYgKG1vZGlmaWVyID09PSBcIi5cIikge1xuXHRcdHByZWZpeCA9IFwiLlwiO1xuXHRcdHNlcGFyYXRvciA9IFwiLlwiO1xuXHR9IGVsc2UgaWYgKG1vZGlmaWVyID09PSBcIi9cIikge1xuXHRcdHByZWZpeCA9IFwiL1wiO1xuXHRcdHNlcGFyYXRvciA9IFwiL1wiO1xuXHR9IGVsc2UgaWYgKG1vZGlmaWVyID09PSAnIycpIHtcblx0XHRwcmVmaXggPSBcIiNcIjtcblx0XHRzaG91bGRFc2NhcGUgPSBmYWxzZTtcblx0fSBlbHNlIGlmIChtb2RpZmllciA9PT0gJzsnKSB7XG5cdFx0cHJlZml4ID0gXCI7XCI7XG5cdFx0c2VwYXJhdG9yID0gXCI7XCI7XG5cdFx0c2hvd1ZhcmlhYmxlcyA9IHRydWU7XG5cdFx0dHJpbUVtcHR5U3RyaW5nID0gdHJ1ZTtcblx0fSBlbHNlIGlmIChtb2RpZmllciA9PT0gJz8nKSB7XG5cdFx0cHJlZml4ID0gXCI/XCI7XG5cdFx0c2VwYXJhdG9yID0gXCImXCI7XG5cdFx0c2hvd1ZhcmlhYmxlcyA9IHRydWU7XG5cdH0gZWxzZSBpZiAobW9kaWZpZXIgPT09ICcmJykge1xuXHRcdHByZWZpeCA9IFwiJlwiO1xuXHRcdHNlcGFyYXRvciA9IFwiJlwiO1xuXHRcdHNob3dWYXJpYWJsZXMgPSB0cnVlO1xuXHR9XG5cblx0dmFyIHZhck5hbWVzID0gW107XG5cdHZhciB2YXJMaXN0ID0gc3BlYy5zcGxpdChcIixcIik7XG5cdHZhciB2YXJTcGVjcyA9IFtdO1xuXHR2YXIgdmFyU3BlY01hcCA9IHt9O1xuXHRmb3IgKHZhciBpID0gMDsgaSA8IHZhckxpc3QubGVuZ3RoOyBpKyspIHtcblx0XHR2YXIgdmFyTmFtZSA9IHZhckxpc3RbaV07XG5cdFx0dmFyIHRydW5jYXRlID0gbnVsbDtcblx0XHRpZiAodmFyTmFtZS5pbmRleE9mKFwiOlwiKSAhPT0gLTEpIHtcblx0XHRcdHZhciBwYXJ0cyA9IHZhck5hbWUuc3BsaXQoXCI6XCIpO1xuXHRcdFx0dmFyTmFtZSA9IHBhcnRzWzBdO1xuXHRcdFx0dHJ1bmNhdGUgPSBwYXJzZUludChwYXJ0c1sxXSwgMTApO1xuXHRcdH1cblx0XHR2YXIgc3VmZmljZXMgPSB7fTtcblx0XHR3aGlsZSAodXJpVGVtcGxhdGVTdWZmaWNlc1t2YXJOYW1lLmNoYXJBdCh2YXJOYW1lLmxlbmd0aCAtIDEpXSkge1xuXHRcdFx0c3VmZmljZXNbdmFyTmFtZS5jaGFyQXQodmFyTmFtZS5sZW5ndGggLSAxKV0gPSB0cnVlO1xuXHRcdFx0dmFyTmFtZSA9IHZhck5hbWUuc3Vic3RyaW5nKDAsIHZhck5hbWUubGVuZ3RoIC0gMSk7XG5cdFx0fVxuXHRcdHZhciB2YXJTcGVjID0ge1xuXHRcdFx0dHJ1bmNhdGU6IHRydW5jYXRlLFxuXHRcdFx0bmFtZTogdmFyTmFtZSxcblx0XHRcdHN1ZmZpY2VzOiBzdWZmaWNlc1xuXHRcdH07XG5cdFx0dmFyU3BlY3MucHVzaCh2YXJTcGVjKTtcblx0XHR2YXJTcGVjTWFwW3Zhck5hbWVdID0gdmFyU3BlYztcblx0XHR2YXJOYW1lcy5wdXNoKHZhck5hbWUpO1xuXHR9XG5cdHZhciBzdWJGdW5jdGlvbiA9IGZ1bmN0aW9uICh2YWx1ZUZ1bmN0aW9uKSB7XG5cdFx0dmFyIHJlc3VsdCA9IFwiXCI7XG5cdFx0dmFyIHN0YXJ0SW5kZXggPSAwO1xuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgdmFyU3BlY3MubGVuZ3RoOyBpKyspIHtcblx0XHRcdHZhciB2YXJTcGVjID0gdmFyU3BlY3NbaV07XG5cdFx0XHR2YXIgdmFsdWUgPSB2YWx1ZUZ1bmN0aW9uKHZhclNwZWMubmFtZSk7XG5cdFx0XHRpZiAodmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09IHVuZGVmaW5lZCB8fCAoQXJyYXkuaXNBcnJheSh2YWx1ZSkgJiYgdmFsdWUubGVuZ3RoID09PSAwKSB8fCAodHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiBPYmplY3Qua2V5cyh2YWx1ZSkubGVuZ3RoID09PSAwKSkge1xuXHRcdFx0XHRzdGFydEluZGV4Kys7XG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fVxuXHRcdFx0aWYgKGkgPT09IHN0YXJ0SW5kZXgpIHtcblx0XHRcdFx0cmVzdWx0ICs9IHByZWZpeDtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHJlc3VsdCArPSAoc2VwYXJhdG9yIHx8IFwiLFwiKTtcblx0XHRcdH1cblx0XHRcdGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuXHRcdFx0XHRpZiAoc2hvd1ZhcmlhYmxlcykge1xuXHRcdFx0XHRcdHJlc3VsdCArPSB2YXJTcGVjLm5hbWUgKyBcIj1cIjtcblx0XHRcdFx0fVxuXHRcdFx0XHRmb3IgKHZhciBqID0gMDsgaiA8IHZhbHVlLmxlbmd0aDsgaisrKSB7XG5cdFx0XHRcdFx0aWYgKGogPiAwKSB7XG5cdFx0XHRcdFx0XHRyZXN1bHQgKz0gdmFyU3BlYy5zdWZmaWNlc1snKiddID8gKHNlcGFyYXRvciB8fCBcIixcIikgOiBcIixcIjtcblx0XHRcdFx0XHRcdGlmICh2YXJTcGVjLnN1ZmZpY2VzWycqJ10gJiYgc2hvd1ZhcmlhYmxlcykge1xuXHRcdFx0XHRcdFx0XHRyZXN1bHQgKz0gdmFyU3BlYy5uYW1lICsgXCI9XCI7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJlc3VsdCArPSBzaG91bGRFc2NhcGUgPyBlbmNvZGVVUklDb21wb25lbnQodmFsdWVbal0pLnJlcGxhY2UoLyEvZywgXCIlMjFcIikgOiBub3RSZWFsbHlQZXJjZW50RW5jb2RlKHZhbHVlW2pdKTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCIpIHtcblx0XHRcdFx0aWYgKHNob3dWYXJpYWJsZXMgJiYgIXZhclNwZWMuc3VmZmljZXNbJyonXSkge1xuXHRcdFx0XHRcdHJlc3VsdCArPSB2YXJTcGVjLm5hbWUgKyBcIj1cIjtcblx0XHRcdFx0fVxuXHRcdFx0XHR2YXIgZmlyc3QgPSB0cnVlO1xuXHRcdFx0XHRmb3IgKHZhciBrZXkgaW4gdmFsdWUpIHtcblx0XHRcdFx0XHRpZiAoIWZpcnN0KSB7XG5cdFx0XHRcdFx0XHRyZXN1bHQgKz0gdmFyU3BlYy5zdWZmaWNlc1snKiddID8gKHNlcGFyYXRvciB8fCBcIixcIikgOiBcIixcIjtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0Zmlyc3QgPSBmYWxzZTtcblx0XHRcdFx0XHRyZXN1bHQgKz0gc2hvdWxkRXNjYXBlID8gZW5jb2RlVVJJQ29tcG9uZW50KGtleSkucmVwbGFjZSgvIS9nLCBcIiUyMVwiKSA6IG5vdFJlYWxseVBlcmNlbnRFbmNvZGUoa2V5KTtcblx0XHRcdFx0XHRyZXN1bHQgKz0gdmFyU3BlYy5zdWZmaWNlc1snKiddID8gJz0nIDogXCIsXCI7XG5cdFx0XHRcdFx0cmVzdWx0ICs9IHNob3VsZEVzY2FwZSA/IGVuY29kZVVSSUNvbXBvbmVudCh2YWx1ZVtrZXldKS5yZXBsYWNlKC8hL2csIFwiJTIxXCIpIDogbm90UmVhbGx5UGVyY2VudEVuY29kZSh2YWx1ZVtrZXldKTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0aWYgKHNob3dWYXJpYWJsZXMpIHtcblx0XHRcdFx0XHRyZXN1bHQgKz0gdmFyU3BlYy5uYW1lO1xuXHRcdFx0XHRcdGlmICghdHJpbUVtcHR5U3RyaW5nIHx8IHZhbHVlICE9PSBcIlwiKSB7XG5cdFx0XHRcdFx0XHRyZXN1bHQgKz0gXCI9XCI7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICh2YXJTcGVjLnRydW5jYXRlICE9IG51bGwpIHtcblx0XHRcdFx0XHR2YWx1ZSA9IHZhbHVlLnN1YnN0cmluZygwLCB2YXJTcGVjLnRydW5jYXRlKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXN1bHQgKz0gc2hvdWxkRXNjYXBlID8gZW5jb2RlVVJJQ29tcG9uZW50KHZhbHVlKS5yZXBsYWNlKC8hL2csIFwiJTIxXCIpOiBub3RSZWFsbHlQZXJjZW50RW5jb2RlKHZhbHVlKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIHJlc3VsdDtcblx0fTtcblx0c3ViRnVuY3Rpb24udmFyTmFtZXMgPSB2YXJOYW1lcztcblx0cmV0dXJuIHtcblx0XHRwcmVmaXg6IHByZWZpeCxcblx0XHRzdWJzdGl0dXRpb246IHN1YkZ1bmN0aW9uXG5cdH07XG59XG5cbmZ1bmN0aW9uIFVyaVRlbXBsYXRlKHRlbXBsYXRlKSB7XG5cdGlmICghKHRoaXMgaW5zdGFuY2VvZiBVcmlUZW1wbGF0ZSkpIHtcblx0XHRyZXR1cm4gbmV3IFVyaVRlbXBsYXRlKHRlbXBsYXRlKTtcblx0fVxuXHR2YXIgcGFydHMgPSB0ZW1wbGF0ZS5zcGxpdChcIntcIik7XG5cdHZhciB0ZXh0UGFydHMgPSBbcGFydHMuc2hpZnQoKV07XG5cdHZhciBwcmVmaXhlcyA9IFtdO1xuXHR2YXIgc3Vic3RpdHV0aW9ucyA9IFtdO1xuXHR2YXIgdmFyTmFtZXMgPSBbXTtcblx0d2hpbGUgKHBhcnRzLmxlbmd0aCA+IDApIHtcblx0XHR2YXIgcGFydCA9IHBhcnRzLnNoaWZ0KCk7XG5cdFx0dmFyIHNwZWMgPSBwYXJ0LnNwbGl0KFwifVwiKVswXTtcblx0XHR2YXIgcmVtYWluZGVyID0gcGFydC5zdWJzdHJpbmcoc3BlYy5sZW5ndGggKyAxKTtcblx0XHR2YXIgZnVuY3MgPSB1cmlUZW1wbGF0ZVN1YnN0aXR1dGlvbihzcGVjKTtcblx0XHRzdWJzdGl0dXRpb25zLnB1c2goZnVuY3Muc3Vic3RpdHV0aW9uKTtcblx0XHRwcmVmaXhlcy5wdXNoKGZ1bmNzLnByZWZpeCk7XG5cdFx0dGV4dFBhcnRzLnB1c2gocmVtYWluZGVyKTtcblx0XHR2YXJOYW1lcyA9IHZhck5hbWVzLmNvbmNhdChmdW5jcy5zdWJzdGl0dXRpb24udmFyTmFtZXMpO1xuXHR9XG5cdHRoaXMuZmlsbCA9IGZ1bmN0aW9uICh2YWx1ZUZ1bmN0aW9uKSB7XG5cdFx0dmFyIHJlc3VsdCA9IHRleHRQYXJ0c1swXTtcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHN1YnN0aXR1dGlvbnMubGVuZ3RoOyBpKyspIHtcblx0XHRcdHZhciBzdWJzdGl0dXRpb24gPSBzdWJzdGl0dXRpb25zW2ldO1xuXHRcdFx0cmVzdWx0ICs9IHN1YnN0aXR1dGlvbih2YWx1ZUZ1bmN0aW9uKTtcblx0XHRcdHJlc3VsdCArPSB0ZXh0UGFydHNbaSArIDFdO1xuXHRcdH1cblx0XHRyZXR1cm4gcmVzdWx0O1xuXHR9O1xuXHR0aGlzLnZhck5hbWVzID0gdmFyTmFtZXM7XG5cdHRoaXMudGVtcGxhdGUgPSB0ZW1wbGF0ZTtcbn1cblVyaVRlbXBsYXRlLnByb3RvdHlwZSA9IHtcblx0dG9TdHJpbmc6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpcy50ZW1wbGF0ZTtcblx0fSxcblx0ZmlsbEZyb21PYmplY3Q6IGZ1bmN0aW9uIChvYmopIHtcblx0XHRyZXR1cm4gdGhpcy5maWxsKGZ1bmN0aW9uICh2YXJOYW1lKSB7XG5cdFx0XHRyZXR1cm4gb2JqW3Zhck5hbWVdO1xuXHRcdH0pO1xuXHR9XG59O1xudmFyIFZhbGlkYXRvckNvbnRleHQgPSBmdW5jdGlvbiBWYWxpZGF0b3JDb250ZXh0KHBhcmVudCwgY29sbGVjdE11bHRpcGxlLCBlcnJvclJlcG9ydGVyLCBjaGVja1JlY3Vyc2l2ZSwgdHJhY2tVbmtub3duUHJvcGVydGllcykge1xuXHR0aGlzLm1pc3NpbmcgPSBbXTtcblx0dGhpcy5taXNzaW5nTWFwID0ge307XG5cdHRoaXMuZm9ybWF0VmFsaWRhdG9ycyA9IHBhcmVudCA/IE9iamVjdC5jcmVhdGUocGFyZW50LmZvcm1hdFZhbGlkYXRvcnMpIDoge307XG5cdHRoaXMuc2NoZW1hcyA9IHBhcmVudCA/IE9iamVjdC5jcmVhdGUocGFyZW50LnNjaGVtYXMpIDoge307XG5cdHRoaXMuY29sbGVjdE11bHRpcGxlID0gY29sbGVjdE11bHRpcGxlO1xuXHR0aGlzLmVycm9ycyA9IFtdO1xuXHR0aGlzLmhhbmRsZUVycm9yID0gY29sbGVjdE11bHRpcGxlID8gdGhpcy5jb2xsZWN0RXJyb3IgOiB0aGlzLnJldHVybkVycm9yO1xuXHRpZiAoY2hlY2tSZWN1cnNpdmUpIHtcblx0XHR0aGlzLmNoZWNrUmVjdXJzaXZlID0gdHJ1ZTtcblx0XHR0aGlzLnNjYW5uZWQgPSBbXTtcblx0XHR0aGlzLnNjYW5uZWRGcm96ZW4gPSBbXTtcblx0XHR0aGlzLnNjYW5uZWRGcm96ZW5TY2hlbWFzID0gW107XG5cdFx0dGhpcy5zY2FubmVkRnJvemVuVmFsaWRhdGlvbkVycm9ycyA9IFtdO1xuXHRcdHRoaXMudmFsaWRhdGVkU2NoZW1hc0tleSA9ICd0djRfdmFsaWRhdGlvbl9pZCc7XG5cdFx0dGhpcy52YWxpZGF0aW9uRXJyb3JzS2V5ID0gJ3R2NF92YWxpZGF0aW9uX2Vycm9yc19pZCc7XG5cdH1cblx0aWYgKHRyYWNrVW5rbm93blByb3BlcnRpZXMpIHtcblx0XHR0aGlzLnRyYWNrVW5rbm93blByb3BlcnRpZXMgPSB0cnVlO1xuXHRcdHRoaXMua25vd25Qcm9wZXJ0eVBhdGhzID0ge307XG5cdFx0dGhpcy51bmtub3duUHJvcGVydHlQYXRocyA9IHt9O1xuXHR9XG5cdHRoaXMuZXJyb3JSZXBvcnRlciA9IGVycm9yUmVwb3J0ZXIgfHwgZGVmYXVsdEVycm9yUmVwb3J0ZXIoJ2VuJyk7XG5cdGlmICh0eXBlb2YgdGhpcy5lcnJvclJlcG9ydGVyID09PSAnc3RyaW5nJykge1xuXHRcdHRocm93IG5ldyBFcnJvcignZGVidWcnKTtcblx0fVxuXHR0aGlzLmRlZmluZWRLZXl3b3JkcyA9IHt9O1xuXHRpZiAocGFyZW50KSB7XG5cdFx0Zm9yICh2YXIga2V5IGluIHBhcmVudC5kZWZpbmVkS2V5d29yZHMpIHtcblx0XHRcdHRoaXMuZGVmaW5lZEtleXdvcmRzW2tleV0gPSBwYXJlbnQuZGVmaW5lZEtleXdvcmRzW2tleV0uc2xpY2UoMCk7XG5cdFx0fVxuXHR9XG59O1xuVmFsaWRhdG9yQ29udGV4dC5wcm90b3R5cGUuZGVmaW5lS2V5d29yZCA9IGZ1bmN0aW9uIChrZXl3b3JkLCBrZXl3b3JkRnVuY3Rpb24pIHtcblx0dGhpcy5kZWZpbmVkS2V5d29yZHNba2V5d29yZF0gPSB0aGlzLmRlZmluZWRLZXl3b3Jkc1trZXl3b3JkXSB8fCBbXTtcblx0dGhpcy5kZWZpbmVkS2V5d29yZHNba2V5d29yZF0ucHVzaChrZXl3b3JkRnVuY3Rpb24pO1xufTtcblZhbGlkYXRvckNvbnRleHQucHJvdG90eXBlLmNyZWF0ZUVycm9yID0gZnVuY3Rpb24gKGNvZGUsIG1lc3NhZ2VQYXJhbXMsIGRhdGFQYXRoLCBzY2hlbWFQYXRoLCBzdWJFcnJvcnMsIGRhdGEsIHNjaGVtYSkge1xuXHR2YXIgZXJyb3IgPSBuZXcgVmFsaWRhdGlvbkVycm9yKGNvZGUsIG1lc3NhZ2VQYXJhbXMsIGRhdGFQYXRoLCBzY2hlbWFQYXRoLCBzdWJFcnJvcnMpO1xuXHRlcnJvci5tZXNzYWdlID0gdGhpcy5lcnJvclJlcG9ydGVyKGVycm9yLCBkYXRhLCBzY2hlbWEpO1xuXHRyZXR1cm4gZXJyb3I7XG59O1xuVmFsaWRhdG9yQ29udGV4dC5wcm90b3R5cGUucmV0dXJuRXJyb3IgPSBmdW5jdGlvbiAoZXJyb3IpIHtcblx0cmV0dXJuIGVycm9yO1xufTtcblZhbGlkYXRvckNvbnRleHQucHJvdG90eXBlLmNvbGxlY3RFcnJvciA9IGZ1bmN0aW9uIChlcnJvcikge1xuXHRpZiAoZXJyb3IpIHtcblx0XHR0aGlzLmVycm9ycy5wdXNoKGVycm9yKTtcblx0fVxuXHRyZXR1cm4gbnVsbDtcbn07XG5WYWxpZGF0b3JDb250ZXh0LnByb3RvdHlwZS5wcmVmaXhFcnJvcnMgPSBmdW5jdGlvbiAoc3RhcnRJbmRleCwgZGF0YVBhdGgsIHNjaGVtYVBhdGgpIHtcblx0Zm9yICh2YXIgaSA9IHN0YXJ0SW5kZXg7IGkgPCB0aGlzLmVycm9ycy5sZW5ndGg7IGkrKykge1xuXHRcdHRoaXMuZXJyb3JzW2ldID0gdGhpcy5lcnJvcnNbaV0ucHJlZml4V2l0aChkYXRhUGF0aCwgc2NoZW1hUGF0aCk7XG5cdH1cblx0cmV0dXJuIHRoaXM7XG59O1xuVmFsaWRhdG9yQ29udGV4dC5wcm90b3R5cGUuYmFuVW5rbm93blByb3BlcnRpZXMgPSBmdW5jdGlvbiAoZGF0YSwgc2NoZW1hKSB7XG5cdGZvciAodmFyIHVua25vd25QYXRoIGluIHRoaXMudW5rbm93blByb3BlcnR5UGF0aHMpIHtcblx0XHR2YXIgZXJyb3IgPSB0aGlzLmNyZWF0ZUVycm9yKEVycm9yQ29kZXMuVU5LTk9XTl9QUk9QRVJUWSwge3BhdGg6IHVua25vd25QYXRofSwgdW5rbm93blBhdGgsIFwiXCIsIG51bGwsIGRhdGEsIHNjaGVtYSk7XG5cdFx0dmFyIHJlc3VsdCA9IHRoaXMuaGFuZGxlRXJyb3IoZXJyb3IpO1xuXHRcdGlmIChyZXN1bHQpIHtcblx0XHRcdHJldHVybiByZXN1bHQ7XG5cdFx0fVxuXHR9XG5cdHJldHVybiBudWxsO1xufTtcblxuVmFsaWRhdG9yQ29udGV4dC5wcm90b3R5cGUuYWRkRm9ybWF0ID0gZnVuY3Rpb24gKGZvcm1hdCwgdmFsaWRhdG9yKSB7XG5cdGlmICh0eXBlb2YgZm9ybWF0ID09PSAnb2JqZWN0Jykge1xuXHRcdGZvciAodmFyIGtleSBpbiBmb3JtYXQpIHtcblx0XHRcdHRoaXMuYWRkRm9ybWF0KGtleSwgZm9ybWF0W2tleV0pO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXHR0aGlzLmZvcm1hdFZhbGlkYXRvcnNbZm9ybWF0XSA9IHZhbGlkYXRvcjtcbn07XG5WYWxpZGF0b3JDb250ZXh0LnByb3RvdHlwZS5yZXNvbHZlUmVmcyA9IGZ1bmN0aW9uIChzY2hlbWEsIHVybEhpc3RvcnkpIHtcblx0aWYgKHNjaGVtYVsnJHJlZiddICE9PSB1bmRlZmluZWQpIHtcblx0XHR1cmxIaXN0b3J5ID0gdXJsSGlzdG9yeSB8fCB7fTtcblx0XHRpZiAodXJsSGlzdG9yeVtzY2hlbWFbJyRyZWYnXV0pIHtcblx0XHRcdHJldHVybiB0aGlzLmNyZWF0ZUVycm9yKEVycm9yQ29kZXMuQ0lSQ1VMQVJfUkVGRVJFTkNFLCB7dXJsczogT2JqZWN0LmtleXModXJsSGlzdG9yeSkuam9pbignLCAnKX0sICcnLCAnJywgbnVsbCwgdW5kZWZpbmVkLCBzY2hlbWEpO1xuXHRcdH1cblx0XHR1cmxIaXN0b3J5W3NjaGVtYVsnJHJlZiddXSA9IHRydWU7XG5cdFx0c2NoZW1hID0gdGhpcy5nZXRTY2hlbWEoc2NoZW1hWyckcmVmJ10sIHVybEhpc3RvcnkpO1xuXHR9XG5cdHJldHVybiBzY2hlbWE7XG59O1xuVmFsaWRhdG9yQ29udGV4dC5wcm90b3R5cGUuZ2V0U2NoZW1hID0gZnVuY3Rpb24gKHVybCwgdXJsSGlzdG9yeSkge1xuXHR2YXIgc2NoZW1hO1xuXHRpZiAodGhpcy5zY2hlbWFzW3VybF0gIT09IHVuZGVmaW5lZCkge1xuXHRcdHNjaGVtYSA9IHRoaXMuc2NoZW1hc1t1cmxdO1xuXHRcdHJldHVybiB0aGlzLnJlc29sdmVSZWZzKHNjaGVtYSwgdXJsSGlzdG9yeSk7XG5cdH1cblx0dmFyIGJhc2VVcmwgPSB1cmw7XG5cdHZhciBmcmFnbWVudCA9IFwiXCI7XG5cdGlmICh1cmwuaW5kZXhPZignIycpICE9PSAtMSkge1xuXHRcdGZyYWdtZW50ID0gdXJsLnN1YnN0cmluZyh1cmwuaW5kZXhPZihcIiNcIikgKyAxKTtcblx0XHRiYXNlVXJsID0gdXJsLnN1YnN0cmluZygwLCB1cmwuaW5kZXhPZihcIiNcIikpO1xuXHR9XG5cdGlmICh0eXBlb2YgdGhpcy5zY2hlbWFzW2Jhc2VVcmxdID09PSAnb2JqZWN0Jykge1xuXHRcdHNjaGVtYSA9IHRoaXMuc2NoZW1hc1tiYXNlVXJsXTtcblx0XHR2YXIgcG9pbnRlclBhdGggPSBkZWNvZGVVUklDb21wb25lbnQoZnJhZ21lbnQpO1xuXHRcdGlmIChwb2ludGVyUGF0aCA9PT0gXCJcIikge1xuXHRcdFx0cmV0dXJuIHRoaXMucmVzb2x2ZVJlZnMoc2NoZW1hLCB1cmxIaXN0b3J5KTtcblx0XHR9IGVsc2UgaWYgKHBvaW50ZXJQYXRoLmNoYXJBdCgwKSAhPT0gXCIvXCIpIHtcblx0XHRcdHJldHVybiB1bmRlZmluZWQ7XG5cdFx0fVxuXHRcdHZhciBwYXJ0cyA9IHBvaW50ZXJQYXRoLnNwbGl0KFwiL1wiKS5zbGljZSgxKTtcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHBhcnRzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR2YXIgY29tcG9uZW50ID0gcGFydHNbaV0ucmVwbGFjZSgvfjEvZywgXCIvXCIpLnJlcGxhY2UoL34wL2csIFwiflwiKTtcblx0XHRcdGlmIChzY2hlbWFbY29tcG9uZW50XSA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdHNjaGVtYSA9IHVuZGVmaW5lZDtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0XHRzY2hlbWEgPSBzY2hlbWFbY29tcG9uZW50XTtcblx0XHR9XG5cdFx0aWYgKHNjaGVtYSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5yZXNvbHZlUmVmcyhzY2hlbWEsIHVybEhpc3RvcnkpO1xuXHRcdH1cblx0fVxuXHRpZiAodGhpcy5taXNzaW5nW2Jhc2VVcmxdID09PSB1bmRlZmluZWQpIHtcblx0XHR0aGlzLm1pc3NpbmcucHVzaChiYXNlVXJsKTtcblx0XHR0aGlzLm1pc3NpbmdbYmFzZVVybF0gPSBiYXNlVXJsO1xuXHRcdHRoaXMubWlzc2luZ01hcFtiYXNlVXJsXSA9IGJhc2VVcmw7XG5cdH1cbn07XG5WYWxpZGF0b3JDb250ZXh0LnByb3RvdHlwZS5zZWFyY2hTY2hlbWFzID0gZnVuY3Rpb24gKHNjaGVtYSwgdXJsKSB7XG5cdGlmIChBcnJheS5pc0FycmF5KHNjaGVtYSkpIHtcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHNjaGVtYS5sZW5ndGg7IGkrKykge1xuXHRcdFx0dGhpcy5zZWFyY2hTY2hlbWFzKHNjaGVtYVtpXSwgdXJsKTtcblx0XHR9XG5cdH0gZWxzZSBpZiAoc2NoZW1hICYmIHR5cGVvZiBzY2hlbWEgPT09IFwib2JqZWN0XCIpIHtcblx0XHRpZiAodHlwZW9mIHNjaGVtYS5pZCA9PT0gXCJzdHJpbmdcIikge1xuXHRcdFx0aWYgKGlzVHJ1c3RlZFVybCh1cmwsIHNjaGVtYS5pZCkpIHtcblx0XHRcdFx0aWYgKHRoaXMuc2NoZW1hc1tzY2hlbWEuaWRdID09PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0XHR0aGlzLnNjaGVtYXNbc2NoZW1hLmlkXSA9IHNjaGVtYTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHRmb3IgKHZhciBrZXkgaW4gc2NoZW1hKSB7XG5cdFx0XHRpZiAoa2V5ICE9PSBcImVudW1cIikge1xuXHRcdFx0XHRpZiAodHlwZW9mIHNjaGVtYVtrZXldID09PSBcIm9iamVjdFwiKSB7XG5cdFx0XHRcdFx0dGhpcy5zZWFyY2hTY2hlbWFzKHNjaGVtYVtrZXldLCB1cmwpO1xuXHRcdFx0XHR9IGVsc2UgaWYgKGtleSA9PT0gXCIkcmVmXCIpIHtcblx0XHRcdFx0XHR2YXIgdXJpID0gZ2V0RG9jdW1lbnRVcmkoc2NoZW1hW2tleV0pO1xuXHRcdFx0XHRcdGlmICh1cmkgJiYgdGhpcy5zY2hlbWFzW3VyaV0gPT09IHVuZGVmaW5lZCAmJiB0aGlzLm1pc3NpbmdNYXBbdXJpXSA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdFx0XHR0aGlzLm1pc3NpbmdNYXBbdXJpXSA9IHVyaTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cbn07XG5WYWxpZGF0b3JDb250ZXh0LnByb3RvdHlwZS5hZGRTY2hlbWEgPSBmdW5jdGlvbiAodXJsLCBzY2hlbWEpIHtcblx0Ly9vdmVybG9hZFxuXHRpZiAodHlwZW9mIHVybCAhPT0gJ3N0cmluZycgfHwgdHlwZW9mIHNjaGVtYSA9PT0gJ3VuZGVmaW5lZCcpIHtcblx0XHRpZiAodHlwZW9mIHVybCA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIHVybC5pZCA9PT0gJ3N0cmluZycpIHtcblx0XHRcdHNjaGVtYSA9IHVybDtcblx0XHRcdHVybCA9IHNjaGVtYS5pZDtcblx0XHR9XG5cdFx0ZWxzZSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHR9XG5cdGlmICh1cmwgPT09IGdldERvY3VtZW50VXJpKHVybCkgKyBcIiNcIikge1xuXHRcdC8vIFJlbW92ZSBlbXB0eSBmcmFnbWVudFxuXHRcdHVybCA9IGdldERvY3VtZW50VXJpKHVybCk7XG5cdH1cblx0dGhpcy5zY2hlbWFzW3VybF0gPSBzY2hlbWE7XG5cdGRlbGV0ZSB0aGlzLm1pc3NpbmdNYXBbdXJsXTtcblx0bm9ybVNjaGVtYShzY2hlbWEsIHVybCk7XG5cdHRoaXMuc2VhcmNoU2NoZW1hcyhzY2hlbWEsIHVybCk7XG59O1xuXG5WYWxpZGF0b3JDb250ZXh0LnByb3RvdHlwZS5nZXRTY2hlbWFNYXAgPSBmdW5jdGlvbiAoKSB7XG5cdHZhciBtYXAgPSB7fTtcblx0Zm9yICh2YXIga2V5IGluIHRoaXMuc2NoZW1hcykge1xuXHRcdG1hcFtrZXldID0gdGhpcy5zY2hlbWFzW2tleV07XG5cdH1cblx0cmV0dXJuIG1hcDtcbn07XG5cblZhbGlkYXRvckNvbnRleHQucHJvdG90eXBlLmdldFNjaGVtYVVyaXMgPSBmdW5jdGlvbiAoZmlsdGVyUmVnRXhwKSB7XG5cdHZhciBsaXN0ID0gW107XG5cdGZvciAodmFyIGtleSBpbiB0aGlzLnNjaGVtYXMpIHtcblx0XHRpZiAoIWZpbHRlclJlZ0V4cCB8fCBmaWx0ZXJSZWdFeHAudGVzdChrZXkpKSB7XG5cdFx0XHRsaXN0LnB1c2goa2V5KTtcblx0XHR9XG5cdH1cblx0cmV0dXJuIGxpc3Q7XG59O1xuXG5WYWxpZGF0b3JDb250ZXh0LnByb3RvdHlwZS5nZXRNaXNzaW5nVXJpcyA9IGZ1bmN0aW9uIChmaWx0ZXJSZWdFeHApIHtcblx0dmFyIGxpc3QgPSBbXTtcblx0Zm9yICh2YXIga2V5IGluIHRoaXMubWlzc2luZ01hcCkge1xuXHRcdGlmICghZmlsdGVyUmVnRXhwIHx8IGZpbHRlclJlZ0V4cC50ZXN0KGtleSkpIHtcblx0XHRcdGxpc3QucHVzaChrZXkpO1xuXHRcdH1cblx0fVxuXHRyZXR1cm4gbGlzdDtcbn07XG5cblZhbGlkYXRvckNvbnRleHQucHJvdG90eXBlLmRyb3BTY2hlbWFzID0gZnVuY3Rpb24gKCkge1xuXHR0aGlzLnNjaGVtYXMgPSB7fTtcblx0dGhpcy5yZXNldCgpO1xufTtcblZhbGlkYXRvckNvbnRleHQucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24gKCkge1xuXHR0aGlzLm1pc3NpbmcgPSBbXTtcblx0dGhpcy5taXNzaW5nTWFwID0ge307XG5cdHRoaXMuZXJyb3JzID0gW107XG59O1xuXG5WYWxpZGF0b3JDb250ZXh0LnByb3RvdHlwZS52YWxpZGF0ZUFsbCA9IGZ1bmN0aW9uIChkYXRhLCBzY2hlbWEsIGRhdGFQYXRoUGFydHMsIHNjaGVtYVBhdGhQYXJ0cywgZGF0YVBvaW50ZXJQYXRoKSB7XG5cdHZhciB0b3BMZXZlbDtcblx0c2NoZW1hID0gdGhpcy5yZXNvbHZlUmVmcyhzY2hlbWEpO1xuXHRpZiAoIXNjaGVtYSkge1xuXHRcdHJldHVybiBudWxsO1xuXHR9IGVsc2UgaWYgKHNjaGVtYSBpbnN0YW5jZW9mIFZhbGlkYXRpb25FcnJvcikge1xuXHRcdHRoaXMuZXJyb3JzLnB1c2goc2NoZW1hKTtcblx0XHRyZXR1cm4gc2NoZW1hO1xuXHR9XG5cblx0dmFyIHN0YXJ0RXJyb3JDb3VudCA9IHRoaXMuZXJyb3JzLmxlbmd0aDtcblx0dmFyIGZyb3plbkluZGV4LCBzY2FubmVkRnJvemVuU2NoZW1hSW5kZXggPSBudWxsLCBzY2FubmVkU2NoZW1hc0luZGV4ID0gbnVsbDtcblx0aWYgKHRoaXMuY2hlY2tSZWN1cnNpdmUgJiYgZGF0YSAmJiB0eXBlb2YgZGF0YSA9PT0gJ29iamVjdCcpIHtcblx0XHR0b3BMZXZlbCA9ICF0aGlzLnNjYW5uZWQubGVuZ3RoO1xuXHRcdGlmIChkYXRhW3RoaXMudmFsaWRhdGVkU2NoZW1hc0tleV0pIHtcblx0XHRcdHZhciBzY2hlbWFJbmRleCA9IGRhdGFbdGhpcy52YWxpZGF0ZWRTY2hlbWFzS2V5XS5pbmRleE9mKHNjaGVtYSk7XG5cdFx0XHRpZiAoc2NoZW1hSW5kZXggIT09IC0xKSB7XG5cdFx0XHRcdHRoaXMuZXJyb3JzID0gdGhpcy5lcnJvcnMuY29uY2F0KGRhdGFbdGhpcy52YWxpZGF0aW9uRXJyb3JzS2V5XVtzY2hlbWFJbmRleF0pO1xuXHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdH1cblx0XHR9XG5cdFx0aWYgKE9iamVjdC5pc0Zyb3plbihkYXRhKSkge1xuXHRcdFx0ZnJvemVuSW5kZXggPSB0aGlzLnNjYW5uZWRGcm96ZW4uaW5kZXhPZihkYXRhKTtcblx0XHRcdGlmIChmcm96ZW5JbmRleCAhPT0gLTEpIHtcblx0XHRcdFx0dmFyIGZyb3plblNjaGVtYUluZGV4ID0gdGhpcy5zY2FubmVkRnJvemVuU2NoZW1hc1tmcm96ZW5JbmRleF0uaW5kZXhPZihzY2hlbWEpO1xuXHRcdFx0XHRpZiAoZnJvemVuU2NoZW1hSW5kZXggIT09IC0xKSB7XG5cdFx0XHRcdFx0dGhpcy5lcnJvcnMgPSB0aGlzLmVycm9ycy5jb25jYXQodGhpcy5zY2FubmVkRnJvemVuVmFsaWRhdGlvbkVycm9yc1tmcm96ZW5JbmRleF1bZnJvemVuU2NoZW1hSW5kZXhdKTtcblx0XHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHR0aGlzLnNjYW5uZWQucHVzaChkYXRhKTtcblx0XHRpZiAoT2JqZWN0LmlzRnJvemVuKGRhdGEpKSB7XG5cdFx0XHRpZiAoZnJvemVuSW5kZXggPT09IC0xKSB7XG5cdFx0XHRcdGZyb3plbkluZGV4ID0gdGhpcy5zY2FubmVkRnJvemVuLmxlbmd0aDtcblx0XHRcdFx0dGhpcy5zY2FubmVkRnJvemVuLnB1c2goZGF0YSk7XG5cdFx0XHRcdHRoaXMuc2Nhbm5lZEZyb3plblNjaGVtYXMucHVzaChbXSk7XG5cdFx0XHR9XG5cdFx0XHRzY2FubmVkRnJvemVuU2NoZW1hSW5kZXggPSB0aGlzLnNjYW5uZWRGcm96ZW5TY2hlbWFzW2Zyb3plbkluZGV4XS5sZW5ndGg7XG5cdFx0XHR0aGlzLnNjYW5uZWRGcm96ZW5TY2hlbWFzW2Zyb3plbkluZGV4XVtzY2FubmVkRnJvemVuU2NoZW1hSW5kZXhdID0gc2NoZW1hO1xuXHRcdFx0dGhpcy5zY2FubmVkRnJvemVuVmFsaWRhdGlvbkVycm9yc1tmcm96ZW5JbmRleF1bc2Nhbm5lZEZyb3plblNjaGVtYUluZGV4XSA9IFtdO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRpZiAoIWRhdGFbdGhpcy52YWxpZGF0ZWRTY2hlbWFzS2V5XSkge1xuXHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShkYXRhLCB0aGlzLnZhbGlkYXRlZFNjaGVtYXNLZXksIHtcblx0XHRcdFx0XHRcdHZhbHVlOiBbXSxcblx0XHRcdFx0XHRcdGNvbmZpZ3VyYWJsZTogdHJ1ZVxuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShkYXRhLCB0aGlzLnZhbGlkYXRpb25FcnJvcnNLZXksIHtcblx0XHRcdFx0XHRcdHZhbHVlOiBbXSxcblx0XHRcdFx0XHRcdGNvbmZpZ3VyYWJsZTogdHJ1ZVxuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9IGNhdGNoIChlKSB7XG5cdFx0XHRcdFx0Ly9JRSA3Lzggd29ya2Fyb3VuZFxuXHRcdFx0XHRcdGRhdGFbdGhpcy52YWxpZGF0ZWRTY2hlbWFzS2V5XSA9IFtdO1xuXHRcdFx0XHRcdGRhdGFbdGhpcy52YWxpZGF0aW9uRXJyb3JzS2V5XSA9IFtdO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRzY2FubmVkU2NoZW1hc0luZGV4ID0gZGF0YVt0aGlzLnZhbGlkYXRlZFNjaGVtYXNLZXldLmxlbmd0aDtcblx0XHRcdGRhdGFbdGhpcy52YWxpZGF0ZWRTY2hlbWFzS2V5XVtzY2FubmVkU2NoZW1hc0luZGV4XSA9IHNjaGVtYTtcblx0XHRcdGRhdGFbdGhpcy52YWxpZGF0aW9uRXJyb3JzS2V5XVtzY2FubmVkU2NoZW1hc0luZGV4XSA9IFtdO1xuXHRcdH1cblx0fVxuXG5cdHZhciBlcnJvckNvdW50ID0gdGhpcy5lcnJvcnMubGVuZ3RoO1xuXHR2YXIgZXJyb3IgPSB0aGlzLnZhbGlkYXRlQmFzaWMoZGF0YSwgc2NoZW1hLCBkYXRhUG9pbnRlclBhdGgpXG5cdFx0fHwgdGhpcy52YWxpZGF0ZU51bWVyaWMoZGF0YSwgc2NoZW1hLCBkYXRhUG9pbnRlclBhdGgpXG5cdFx0fHwgdGhpcy52YWxpZGF0ZVN0cmluZyhkYXRhLCBzY2hlbWEsIGRhdGFQb2ludGVyUGF0aClcblx0XHR8fCB0aGlzLnZhbGlkYXRlQXJyYXkoZGF0YSwgc2NoZW1hLCBkYXRhUG9pbnRlclBhdGgpXG5cdFx0fHwgdGhpcy52YWxpZGF0ZU9iamVjdChkYXRhLCBzY2hlbWEsIGRhdGFQb2ludGVyUGF0aClcblx0XHR8fCB0aGlzLnZhbGlkYXRlQ29tYmluYXRpb25zKGRhdGEsIHNjaGVtYSwgZGF0YVBvaW50ZXJQYXRoKVxuXHRcdHx8IHRoaXMudmFsaWRhdGVIeXBlcm1lZGlhKGRhdGEsIHNjaGVtYSwgZGF0YVBvaW50ZXJQYXRoKVxuXHRcdHx8IHRoaXMudmFsaWRhdGVGb3JtYXQoZGF0YSwgc2NoZW1hLCBkYXRhUG9pbnRlclBhdGgpXG5cdFx0fHwgdGhpcy52YWxpZGF0ZURlZmluZWRLZXl3b3JkcyhkYXRhLCBzY2hlbWEsIGRhdGFQb2ludGVyUGF0aClcblx0XHR8fCBudWxsO1xuXG5cdGlmICh0b3BMZXZlbCkge1xuXHRcdHdoaWxlICh0aGlzLnNjYW5uZWQubGVuZ3RoKSB7XG5cdFx0XHR2YXIgaXRlbSA9IHRoaXMuc2Nhbm5lZC5wb3AoKTtcblx0XHRcdGRlbGV0ZSBpdGVtW3RoaXMudmFsaWRhdGVkU2NoZW1hc0tleV07XG5cdFx0fVxuXHRcdHRoaXMuc2Nhbm5lZEZyb3plbiA9IFtdO1xuXHRcdHRoaXMuc2Nhbm5lZEZyb3plblNjaGVtYXMgPSBbXTtcblx0fVxuXG5cdGlmIChlcnJvciB8fCBlcnJvckNvdW50ICE9PSB0aGlzLmVycm9ycy5sZW5ndGgpIHtcblx0XHR3aGlsZSAoKGRhdGFQYXRoUGFydHMgJiYgZGF0YVBhdGhQYXJ0cy5sZW5ndGgpIHx8IChzY2hlbWFQYXRoUGFydHMgJiYgc2NoZW1hUGF0aFBhcnRzLmxlbmd0aCkpIHtcblx0XHRcdHZhciBkYXRhUGFydCA9IChkYXRhUGF0aFBhcnRzICYmIGRhdGFQYXRoUGFydHMubGVuZ3RoKSA/IFwiXCIgKyBkYXRhUGF0aFBhcnRzLnBvcCgpIDogbnVsbDtcblx0XHRcdHZhciBzY2hlbWFQYXJ0ID0gKHNjaGVtYVBhdGhQYXJ0cyAmJiBzY2hlbWFQYXRoUGFydHMubGVuZ3RoKSA/IFwiXCIgKyBzY2hlbWFQYXRoUGFydHMucG9wKCkgOiBudWxsO1xuXHRcdFx0aWYgKGVycm9yKSB7XG5cdFx0XHRcdGVycm9yID0gZXJyb3IucHJlZml4V2l0aChkYXRhUGFydCwgc2NoZW1hUGFydCk7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLnByZWZpeEVycm9ycyhlcnJvckNvdW50LCBkYXRhUGFydCwgc2NoZW1hUGFydCk7XG5cdFx0fVxuXHR9XG5cblx0aWYgKHNjYW5uZWRGcm96ZW5TY2hlbWFJbmRleCAhPT0gbnVsbCkge1xuXHRcdHRoaXMuc2Nhbm5lZEZyb3plblZhbGlkYXRpb25FcnJvcnNbZnJvemVuSW5kZXhdW3NjYW5uZWRGcm96ZW5TY2hlbWFJbmRleF0gPSB0aGlzLmVycm9ycy5zbGljZShzdGFydEVycm9yQ291bnQpO1xuXHR9IGVsc2UgaWYgKHNjYW5uZWRTY2hlbWFzSW5kZXggIT09IG51bGwpIHtcblx0XHRkYXRhW3RoaXMudmFsaWRhdGlvbkVycm9yc0tleV1bc2Nhbm5lZFNjaGVtYXNJbmRleF0gPSB0aGlzLmVycm9ycy5zbGljZShzdGFydEVycm9yQ291bnQpO1xuXHR9XG5cblx0cmV0dXJuIHRoaXMuaGFuZGxlRXJyb3IoZXJyb3IpO1xufTtcblZhbGlkYXRvckNvbnRleHQucHJvdG90eXBlLnZhbGlkYXRlRm9ybWF0ID0gZnVuY3Rpb24gKGRhdGEsIHNjaGVtYSkge1xuXHRpZiAodHlwZW9mIHNjaGVtYS5mb3JtYXQgIT09ICdzdHJpbmcnIHx8ICF0aGlzLmZvcm1hdFZhbGlkYXRvcnNbc2NoZW1hLmZvcm1hdF0pIHtcblx0XHRyZXR1cm4gbnVsbDtcblx0fVxuXHR2YXIgZXJyb3JNZXNzYWdlID0gdGhpcy5mb3JtYXRWYWxpZGF0b3JzW3NjaGVtYS5mb3JtYXRdLmNhbGwobnVsbCwgZGF0YSwgc2NoZW1hKTtcblx0aWYgKHR5cGVvZiBlcnJvck1lc3NhZ2UgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiBlcnJvck1lc3NhZ2UgPT09ICdudW1iZXInKSB7XG5cdFx0cmV0dXJuIHRoaXMuY3JlYXRlRXJyb3IoRXJyb3JDb2Rlcy5GT1JNQVRfQ1VTVE9NLCB7bWVzc2FnZTogZXJyb3JNZXNzYWdlfSwgJycsICcvZm9ybWF0JywgbnVsbCwgZGF0YSwgc2NoZW1hKTtcblx0fSBlbHNlIGlmIChlcnJvck1lc3NhZ2UgJiYgdHlwZW9mIGVycm9yTWVzc2FnZSA9PT0gJ29iamVjdCcpIHtcblx0XHRyZXR1cm4gdGhpcy5jcmVhdGVFcnJvcihFcnJvckNvZGVzLkZPUk1BVF9DVVNUT00sIHttZXNzYWdlOiBlcnJvck1lc3NhZ2UubWVzc2FnZSB8fCBcIj9cIn0sIGVycm9yTWVzc2FnZS5kYXRhUGF0aCB8fCAnJywgZXJyb3JNZXNzYWdlLnNjaGVtYVBhdGggfHwgXCIvZm9ybWF0XCIsIG51bGwsIGRhdGEsIHNjaGVtYSk7XG5cdH1cblx0cmV0dXJuIG51bGw7XG59O1xuVmFsaWRhdG9yQ29udGV4dC5wcm90b3R5cGUudmFsaWRhdGVEZWZpbmVkS2V5d29yZHMgPSBmdW5jdGlvbiAoZGF0YSwgc2NoZW1hLCBkYXRhUG9pbnRlclBhdGgpIHtcblx0Zm9yICh2YXIga2V5IGluIHRoaXMuZGVmaW5lZEtleXdvcmRzKSB7XG5cdFx0aWYgKHR5cGVvZiBzY2hlbWFba2V5XSA9PT0gJ3VuZGVmaW5lZCcpIHtcblx0XHRcdGNvbnRpbnVlO1xuXHRcdH1cblx0XHR2YXIgdmFsaWRhdGlvbkZ1bmN0aW9ucyA9IHRoaXMuZGVmaW5lZEtleXdvcmRzW2tleV07XG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCB2YWxpZGF0aW9uRnVuY3Rpb25zLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR2YXIgZnVuYyA9IHZhbGlkYXRpb25GdW5jdGlvbnNbaV07XG5cdFx0XHR2YXIgcmVzdWx0ID0gZnVuYyhkYXRhLCBzY2hlbWFba2V5XSwgc2NoZW1hLCBkYXRhUG9pbnRlclBhdGgpO1xuXHRcdFx0aWYgKHR5cGVvZiByZXN1bHQgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiByZXN1bHQgPT09ICdudW1iZXInKSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLmNyZWF0ZUVycm9yKEVycm9yQ29kZXMuS0VZV09SRF9DVVNUT00sIHtrZXk6IGtleSwgbWVzc2FnZTogcmVzdWx0fSwgJycsICcnLCBudWxsLCBkYXRhLCBzY2hlbWEpLnByZWZpeFdpdGgobnVsbCwga2V5KTtcblx0XHRcdH0gZWxzZSBpZiAocmVzdWx0ICYmIHR5cGVvZiByZXN1bHQgPT09ICdvYmplY3QnKSB7XG5cdFx0XHRcdHZhciBjb2RlID0gcmVzdWx0LmNvZGU7XG5cdFx0XHRcdGlmICh0eXBlb2YgY29kZSA9PT0gJ3N0cmluZycpIHtcblx0XHRcdFx0XHRpZiAoIUVycm9yQ29kZXNbY29kZV0pIHtcblx0XHRcdFx0XHRcdHRocm93IG5ldyBFcnJvcignVW5kZWZpbmVkIGVycm9yIGNvZGUgKHVzZSBkZWZpbmVFcnJvcik6ICcgKyBjb2RlKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0Y29kZSA9IEVycm9yQ29kZXNbY29kZV07XG5cdFx0XHRcdH0gZWxzZSBpZiAodHlwZW9mIGNvZGUgIT09ICdudW1iZXInKSB7XG5cdFx0XHRcdFx0Y29kZSA9IEVycm9yQ29kZXMuS0VZV09SRF9DVVNUT007XG5cdFx0XHRcdH1cblx0XHRcdFx0dmFyIG1lc3NhZ2VQYXJhbXMgPSAodHlwZW9mIHJlc3VsdC5tZXNzYWdlID09PSAnb2JqZWN0JykgPyByZXN1bHQubWVzc2FnZSA6IHtrZXk6IGtleSwgbWVzc2FnZTogcmVzdWx0Lm1lc3NhZ2UgfHwgXCI/XCJ9O1xuXHRcdFx0XHR2YXIgc2NoZW1hUGF0aCA9IHJlc3VsdC5zY2hlbWFQYXRoIHx8IChcIi9cIiArIGtleS5yZXBsYWNlKC9+L2csICd+MCcpLnJlcGxhY2UoL1xcLy9nLCAnfjEnKSk7XG5cdFx0XHRcdHJldHVybiB0aGlzLmNyZWF0ZUVycm9yKGNvZGUsIG1lc3NhZ2VQYXJhbXMsIHJlc3VsdC5kYXRhUGF0aCB8fCBudWxsLCBzY2hlbWFQYXRoLCBudWxsLCBkYXRhLCBzY2hlbWEpO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXHRyZXR1cm4gbnVsbDtcbn07XG5cbmZ1bmN0aW9uIHJlY3Vyc2l2ZUNvbXBhcmUoQSwgQikge1xuXHRpZiAoQSA9PT0gQikge1xuXHRcdHJldHVybiB0cnVlO1xuXHR9XG5cdGlmIChBICYmIEIgJiYgdHlwZW9mIEEgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIEIgPT09IFwib2JqZWN0XCIpIHtcblx0XHRpZiAoQXJyYXkuaXNBcnJheShBKSAhPT0gQXJyYXkuaXNBcnJheShCKSkge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShBKSkge1xuXHRcdFx0aWYgKEEubGVuZ3RoICE9PSBCLmxlbmd0aCkge1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IEEubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0aWYgKCFyZWN1cnNpdmVDb21wYXJlKEFbaV0sIEJbaV0pKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdHZhciBrZXk7XG5cdFx0XHRmb3IgKGtleSBpbiBBKSB7XG5cdFx0XHRcdGlmIChCW2tleV0gPT09IHVuZGVmaW5lZCAmJiBBW2tleV0gIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0Zm9yIChrZXkgaW4gQikge1xuXHRcdFx0XHRpZiAoQVtrZXldID09PSB1bmRlZmluZWQgJiYgQltrZXldICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGZvciAoa2V5IGluIEEpIHtcblx0XHRcdFx0aWYgKCFyZWN1cnNpdmVDb21wYXJlKEFba2V5XSwgQltrZXldKSkge1xuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gdHJ1ZTtcblx0fVxuXHRyZXR1cm4gZmFsc2U7XG59XG5cblZhbGlkYXRvckNvbnRleHQucHJvdG90eXBlLnZhbGlkYXRlQmFzaWMgPSBmdW5jdGlvbiB2YWxpZGF0ZUJhc2ljKGRhdGEsIHNjaGVtYSwgZGF0YVBvaW50ZXJQYXRoKSB7XG5cdHZhciBlcnJvcjtcblx0aWYgKGVycm9yID0gdGhpcy52YWxpZGF0ZVR5cGUoZGF0YSwgc2NoZW1hLCBkYXRhUG9pbnRlclBhdGgpKSB7XG5cdFx0cmV0dXJuIGVycm9yLnByZWZpeFdpdGgobnVsbCwgXCJ0eXBlXCIpO1xuXHR9XG5cdGlmIChlcnJvciA9IHRoaXMudmFsaWRhdGVFbnVtKGRhdGEsIHNjaGVtYSwgZGF0YVBvaW50ZXJQYXRoKSkge1xuXHRcdHJldHVybiBlcnJvci5wcmVmaXhXaXRoKG51bGwsIFwidHlwZVwiKTtcblx0fVxuXHRyZXR1cm4gbnVsbDtcbn07XG5cblZhbGlkYXRvckNvbnRleHQucHJvdG90eXBlLnZhbGlkYXRlVHlwZSA9IGZ1bmN0aW9uIHZhbGlkYXRlVHlwZShkYXRhLCBzY2hlbWEpIHtcblx0aWYgKHNjaGVtYS50eXBlID09PSB1bmRlZmluZWQpIHtcblx0XHRyZXR1cm4gbnVsbDtcblx0fVxuXHR2YXIgZGF0YVR5cGUgPSB0eXBlb2YgZGF0YTtcblx0aWYgKGRhdGEgPT09IG51bGwpIHtcblx0XHRkYXRhVHlwZSA9IFwibnVsbFwiO1xuXHR9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoZGF0YSkpIHtcblx0XHRkYXRhVHlwZSA9IFwiYXJyYXlcIjtcblx0fVxuXHR2YXIgYWxsb3dlZFR5cGVzID0gc2NoZW1hLnR5cGU7XG5cdGlmICghQXJyYXkuaXNBcnJheShhbGxvd2VkVHlwZXMpKSB7XG5cdFx0YWxsb3dlZFR5cGVzID0gW2FsbG93ZWRUeXBlc107XG5cdH1cblxuXHRmb3IgKHZhciBpID0gMDsgaSA8IGFsbG93ZWRUeXBlcy5sZW5ndGg7IGkrKykge1xuXHRcdHZhciB0eXBlID0gYWxsb3dlZFR5cGVzW2ldO1xuXHRcdGlmICh0eXBlID09PSBkYXRhVHlwZSB8fCAodHlwZSA9PT0gXCJpbnRlZ2VyXCIgJiYgZGF0YVR5cGUgPT09IFwibnVtYmVyXCIgJiYgKGRhdGEgJSAxID09PSAwKSkpIHtcblx0XHRcdHJldHVybiBudWxsO1xuXHRcdH1cblx0fVxuXHRyZXR1cm4gdGhpcy5jcmVhdGVFcnJvcihFcnJvckNvZGVzLklOVkFMSURfVFlQRSwge3R5cGU6IGRhdGFUeXBlLCBleHBlY3RlZDogYWxsb3dlZFR5cGVzLmpvaW4oXCIvXCIpfSwgJycsICcnLCBudWxsLCBkYXRhLCBzY2hlbWEpO1xufTtcblxuVmFsaWRhdG9yQ29udGV4dC5wcm90b3R5cGUudmFsaWRhdGVFbnVtID0gZnVuY3Rpb24gdmFsaWRhdGVFbnVtKGRhdGEsIHNjaGVtYSkge1xuXHRpZiAoc2NoZW1hW1wiZW51bVwiXSA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0cmV0dXJuIG51bGw7XG5cdH1cblx0Zm9yICh2YXIgaSA9IDA7IGkgPCBzY2hlbWFbXCJlbnVtXCJdLmxlbmd0aDsgaSsrKSB7XG5cdFx0dmFyIGVudW1WYWwgPSBzY2hlbWFbXCJlbnVtXCJdW2ldO1xuXHRcdGlmIChyZWN1cnNpdmVDb21wYXJlKGRhdGEsIGVudW1WYWwpKSB7XG5cdFx0XHRyZXR1cm4gbnVsbDtcblx0XHR9XG5cdH1cblx0cmV0dXJuIHRoaXMuY3JlYXRlRXJyb3IoRXJyb3JDb2Rlcy5FTlVNX01JU01BVENILCB7dmFsdWU6ICh0eXBlb2YgSlNPTiAhPT0gJ3VuZGVmaW5lZCcpID8gSlNPTi5zdHJpbmdpZnkoZGF0YSkgOiBkYXRhfSwgJycsICcnLCBudWxsLCBkYXRhLCBzY2hlbWEpO1xufTtcblxuVmFsaWRhdG9yQ29udGV4dC5wcm90b3R5cGUudmFsaWRhdGVOdW1lcmljID0gZnVuY3Rpb24gdmFsaWRhdGVOdW1lcmljKGRhdGEsIHNjaGVtYSwgZGF0YVBvaW50ZXJQYXRoKSB7XG5cdHJldHVybiB0aGlzLnZhbGlkYXRlTXVsdGlwbGVPZihkYXRhLCBzY2hlbWEsIGRhdGFQb2ludGVyUGF0aClcblx0XHR8fCB0aGlzLnZhbGlkYXRlTWluTWF4KGRhdGEsIHNjaGVtYSwgZGF0YVBvaW50ZXJQYXRoKVxuXHRcdHx8IHRoaXMudmFsaWRhdGVOYU4oZGF0YSwgc2NoZW1hLCBkYXRhUG9pbnRlclBhdGgpXG5cdFx0fHwgbnVsbDtcbn07XG5cbnZhciBDTE9TRV9FTk9VR0hfTE9XID0gTWF0aC5wb3coMiwgLTUxKTtcbnZhciBDTE9TRV9FTk9VR0hfSElHSCA9IDEgLSBDTE9TRV9FTk9VR0hfTE9XO1xuVmFsaWRhdG9yQ29udGV4dC5wcm90b3R5cGUudmFsaWRhdGVNdWx0aXBsZU9mID0gZnVuY3Rpb24gdmFsaWRhdGVNdWx0aXBsZU9mKGRhdGEsIHNjaGVtYSkge1xuXHR2YXIgbXVsdGlwbGVPZiA9IHNjaGVtYS5tdWx0aXBsZU9mIHx8IHNjaGVtYS5kaXZpc2libGVCeTtcblx0aWYgKG11bHRpcGxlT2YgPT09IHVuZGVmaW5lZCkge1xuXHRcdHJldHVybiBudWxsO1xuXHR9XG5cdGlmICh0eXBlb2YgZGF0YSA9PT0gXCJudW1iZXJcIikge1xuXHRcdHZhciByZW1haW5kZXIgPSAoZGF0YS9tdWx0aXBsZU9mKSUxO1xuXHRcdGlmIChyZW1haW5kZXIgPj0gQ0xPU0VfRU5PVUdIX0xPVyAmJiByZW1haW5kZXIgPCBDTE9TRV9FTk9VR0hfSElHSCkge1xuXHRcdFx0cmV0dXJuIHRoaXMuY3JlYXRlRXJyb3IoRXJyb3JDb2Rlcy5OVU1CRVJfTVVMVElQTEVfT0YsIHt2YWx1ZTogZGF0YSwgbXVsdGlwbGVPZjogbXVsdGlwbGVPZn0sICcnLCAnJywgbnVsbCwgZGF0YSwgc2NoZW1hKTtcblx0XHR9XG5cdH1cblx0cmV0dXJuIG51bGw7XG59O1xuXG5WYWxpZGF0b3JDb250ZXh0LnByb3RvdHlwZS52YWxpZGF0ZU1pbk1heCA9IGZ1bmN0aW9uIHZhbGlkYXRlTWluTWF4KGRhdGEsIHNjaGVtYSkge1xuXHRpZiAodHlwZW9mIGRhdGEgIT09IFwibnVtYmVyXCIpIHtcblx0XHRyZXR1cm4gbnVsbDtcblx0fVxuXHRpZiAoc2NoZW1hLm1pbmltdW0gIT09IHVuZGVmaW5lZCkge1xuXHRcdGlmIChkYXRhIDwgc2NoZW1hLm1pbmltdW0pIHtcblx0XHRcdHJldHVybiB0aGlzLmNyZWF0ZUVycm9yKEVycm9yQ29kZXMuTlVNQkVSX01JTklNVU0sIHt2YWx1ZTogZGF0YSwgbWluaW11bTogc2NoZW1hLm1pbmltdW19LCAnJywgJy9taW5pbXVtJywgbnVsbCwgZGF0YSwgc2NoZW1hKTtcblx0XHR9XG5cdFx0aWYgKHNjaGVtYS5leGNsdXNpdmVNaW5pbXVtICYmIGRhdGEgPT09IHNjaGVtYS5taW5pbXVtKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5jcmVhdGVFcnJvcihFcnJvckNvZGVzLk5VTUJFUl9NSU5JTVVNX0VYQ0xVU0lWRSwge3ZhbHVlOiBkYXRhLCBtaW5pbXVtOiBzY2hlbWEubWluaW11bX0sICcnLCAnL2V4Y2x1c2l2ZU1pbmltdW0nLCBudWxsLCBkYXRhLCBzY2hlbWEpO1xuXHRcdH1cblx0fVxuXHRpZiAoc2NoZW1hLm1heGltdW0gIT09IHVuZGVmaW5lZCkge1xuXHRcdGlmIChkYXRhID4gc2NoZW1hLm1heGltdW0pIHtcblx0XHRcdHJldHVybiB0aGlzLmNyZWF0ZUVycm9yKEVycm9yQ29kZXMuTlVNQkVSX01BWElNVU0sIHt2YWx1ZTogZGF0YSwgbWF4aW11bTogc2NoZW1hLm1heGltdW19LCAnJywgJy9tYXhpbXVtJywgbnVsbCwgZGF0YSwgc2NoZW1hKTtcblx0XHR9XG5cdFx0aWYgKHNjaGVtYS5leGNsdXNpdmVNYXhpbXVtICYmIGRhdGEgPT09IHNjaGVtYS5tYXhpbXVtKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5jcmVhdGVFcnJvcihFcnJvckNvZGVzLk5VTUJFUl9NQVhJTVVNX0VYQ0xVU0lWRSwge3ZhbHVlOiBkYXRhLCBtYXhpbXVtOiBzY2hlbWEubWF4aW11bX0sICcnLCAnL2V4Y2x1c2l2ZU1heGltdW0nLCBudWxsLCBkYXRhLCBzY2hlbWEpO1xuXHRcdH1cblx0fVxuXHRyZXR1cm4gbnVsbDtcbn07XG5cblZhbGlkYXRvckNvbnRleHQucHJvdG90eXBlLnZhbGlkYXRlTmFOID0gZnVuY3Rpb24gdmFsaWRhdGVOYU4oZGF0YSwgc2NoZW1hKSB7XG5cdGlmICh0eXBlb2YgZGF0YSAhPT0gXCJudW1iZXJcIikge1xuXHRcdHJldHVybiBudWxsO1xuXHR9XG5cdGlmIChpc05hTihkYXRhKSA9PT0gdHJ1ZSB8fCBkYXRhID09PSBJbmZpbml0eSB8fCBkYXRhID09PSAtSW5maW5pdHkpIHtcblx0XHRyZXR1cm4gdGhpcy5jcmVhdGVFcnJvcihFcnJvckNvZGVzLk5VTUJFUl9OT1RfQV9OVU1CRVIsIHt2YWx1ZTogZGF0YX0sICcnLCAnL3R5cGUnLCBudWxsLCBkYXRhLCBzY2hlbWEpO1xuXHR9XG5cdHJldHVybiBudWxsO1xufTtcblxuVmFsaWRhdG9yQ29udGV4dC5wcm90b3R5cGUudmFsaWRhdGVTdHJpbmcgPSBmdW5jdGlvbiB2YWxpZGF0ZVN0cmluZyhkYXRhLCBzY2hlbWEsIGRhdGFQb2ludGVyUGF0aCkge1xuXHRyZXR1cm4gdGhpcy52YWxpZGF0ZVN0cmluZ0xlbmd0aChkYXRhLCBzY2hlbWEsIGRhdGFQb2ludGVyUGF0aClcblx0XHR8fCB0aGlzLnZhbGlkYXRlU3RyaW5nUGF0dGVybihkYXRhLCBzY2hlbWEsIGRhdGFQb2ludGVyUGF0aClcblx0XHR8fCBudWxsO1xufTtcblxuVmFsaWRhdG9yQ29udGV4dC5wcm90b3R5cGUudmFsaWRhdGVTdHJpbmdMZW5ndGggPSBmdW5jdGlvbiB2YWxpZGF0ZVN0cmluZ0xlbmd0aChkYXRhLCBzY2hlbWEpIHtcblx0aWYgKHR5cGVvZiBkYXRhICE9PSBcInN0cmluZ1wiKSB7XG5cdFx0cmV0dXJuIG51bGw7XG5cdH1cblx0aWYgKHNjaGVtYS5taW5MZW5ndGggIT09IHVuZGVmaW5lZCkge1xuXHRcdGlmIChkYXRhLmxlbmd0aCA8IHNjaGVtYS5taW5MZW5ndGgpIHtcblx0XHRcdHJldHVybiB0aGlzLmNyZWF0ZUVycm9yKEVycm9yQ29kZXMuU1RSSU5HX0xFTkdUSF9TSE9SVCwge2xlbmd0aDogZGF0YS5sZW5ndGgsIG1pbmltdW06IHNjaGVtYS5taW5MZW5ndGh9LCAnJywgJy9taW5MZW5ndGgnLCBudWxsLCBkYXRhLCBzY2hlbWEpO1xuXHRcdH1cblx0fVxuXHRpZiAoc2NoZW1hLm1heExlbmd0aCAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0aWYgKGRhdGEubGVuZ3RoID4gc2NoZW1hLm1heExlbmd0aCkge1xuXHRcdFx0cmV0dXJuIHRoaXMuY3JlYXRlRXJyb3IoRXJyb3JDb2Rlcy5TVFJJTkdfTEVOR1RIX0xPTkcsIHtsZW5ndGg6IGRhdGEubGVuZ3RoLCBtYXhpbXVtOiBzY2hlbWEubWF4TGVuZ3RofSwgJycsICcvbWF4TGVuZ3RoJywgbnVsbCwgZGF0YSwgc2NoZW1hKTtcblx0XHR9XG5cdH1cblx0cmV0dXJuIG51bGw7XG59O1xuXG5WYWxpZGF0b3JDb250ZXh0LnByb3RvdHlwZS52YWxpZGF0ZVN0cmluZ1BhdHRlcm4gPSBmdW5jdGlvbiB2YWxpZGF0ZVN0cmluZ1BhdHRlcm4oZGF0YSwgc2NoZW1hKSB7XG5cdGlmICh0eXBlb2YgZGF0YSAhPT0gXCJzdHJpbmdcIiB8fCAodHlwZW9mIHNjaGVtYS5wYXR0ZXJuICE9PSBcInN0cmluZ1wiICYmICEoc2NoZW1hLnBhdHRlcm4gaW5zdGFuY2VvZiBSZWdFeHApKSkge1xuXHRcdHJldHVybiBudWxsO1xuXHR9XG5cdHZhciByZWdleHA7XG5cdGlmIChzY2hlbWEucGF0dGVybiBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuXHQgIHJlZ2V4cCA9IHNjaGVtYS5wYXR0ZXJuO1xuXHR9XG5cdGVsc2Uge1xuXHQgIHZhciBib2R5LCBmbGFncyA9ICcnO1xuXHQgIC8vIENoZWNrIGZvciByZWd1bGFyIGV4cHJlc3Npb24gbGl0ZXJhbHNcblx0ICAvLyBAc2VlIGh0dHA6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi81LjEvI3NlYy03LjguNVxuXHQgIHZhciBsaXRlcmFsID0gc2NoZW1hLnBhdHRlcm4ubWF0Y2goL15cXC8oLispXFwvKFtpbWddKikkLyk7XG5cdCAgaWYgKGxpdGVyYWwpIHtcblx0ICAgIGJvZHkgPSBsaXRlcmFsWzFdO1xuXHQgICAgZmxhZ3MgPSBsaXRlcmFsWzJdO1xuXHQgIH1cblx0ICBlbHNlIHtcblx0ICAgIGJvZHkgPSBzY2hlbWEucGF0dGVybjtcblx0ICB9XG5cdCAgcmVnZXhwID0gbmV3IFJlZ0V4cChib2R5LCBmbGFncyk7XG5cdH1cblx0aWYgKCFyZWdleHAudGVzdChkYXRhKSkge1xuXHRcdHJldHVybiB0aGlzLmNyZWF0ZUVycm9yKEVycm9yQ29kZXMuU1RSSU5HX1BBVFRFUk4sIHtwYXR0ZXJuOiBzY2hlbWEucGF0dGVybn0sICcnLCAnL3BhdHRlcm4nLCBudWxsLCBkYXRhLCBzY2hlbWEpO1xuXHR9XG5cdHJldHVybiBudWxsO1xufTtcblxuVmFsaWRhdG9yQ29udGV4dC5wcm90b3R5cGUudmFsaWRhdGVBcnJheSA9IGZ1bmN0aW9uIHZhbGlkYXRlQXJyYXkoZGF0YSwgc2NoZW1hLCBkYXRhUG9pbnRlclBhdGgpIHtcblx0aWYgKCFBcnJheS5pc0FycmF5KGRhdGEpKSB7XG5cdFx0cmV0dXJuIG51bGw7XG5cdH1cblx0cmV0dXJuIHRoaXMudmFsaWRhdGVBcnJheUxlbmd0aChkYXRhLCBzY2hlbWEsIGRhdGFQb2ludGVyUGF0aClcblx0XHR8fCB0aGlzLnZhbGlkYXRlQXJyYXlVbmlxdWVJdGVtcyhkYXRhLCBzY2hlbWEsIGRhdGFQb2ludGVyUGF0aClcblx0XHR8fCB0aGlzLnZhbGlkYXRlQXJyYXlJdGVtcyhkYXRhLCBzY2hlbWEsIGRhdGFQb2ludGVyUGF0aClcblx0XHR8fCBudWxsO1xufTtcblxuVmFsaWRhdG9yQ29udGV4dC5wcm90b3R5cGUudmFsaWRhdGVBcnJheUxlbmd0aCA9IGZ1bmN0aW9uIHZhbGlkYXRlQXJyYXlMZW5ndGgoZGF0YSwgc2NoZW1hKSB7XG5cdHZhciBlcnJvcjtcblx0aWYgKHNjaGVtYS5taW5JdGVtcyAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0aWYgKGRhdGEubGVuZ3RoIDwgc2NoZW1hLm1pbkl0ZW1zKSB7XG5cdFx0XHRlcnJvciA9IHRoaXMuY3JlYXRlRXJyb3IoRXJyb3JDb2Rlcy5BUlJBWV9MRU5HVEhfU0hPUlQsIHtsZW5ndGg6IGRhdGEubGVuZ3RoLCBtaW5pbXVtOiBzY2hlbWEubWluSXRlbXN9LCAnJywgJy9taW5JdGVtcycsIG51bGwsIGRhdGEsIHNjaGVtYSk7XG5cdFx0XHRpZiAodGhpcy5oYW5kbGVFcnJvcihlcnJvcikpIHtcblx0XHRcdFx0cmV0dXJuIGVycm9yO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXHRpZiAoc2NoZW1hLm1heEl0ZW1zICE9PSB1bmRlZmluZWQpIHtcblx0XHRpZiAoZGF0YS5sZW5ndGggPiBzY2hlbWEubWF4SXRlbXMpIHtcblx0XHRcdGVycm9yID0gdGhpcy5jcmVhdGVFcnJvcihFcnJvckNvZGVzLkFSUkFZX0xFTkdUSF9MT05HLCB7bGVuZ3RoOiBkYXRhLmxlbmd0aCwgbWF4aW11bTogc2NoZW1hLm1heEl0ZW1zfSwgJycsICcvbWF4SXRlbXMnLCBudWxsLCBkYXRhLCBzY2hlbWEpO1xuXHRcdFx0aWYgKHRoaXMuaGFuZGxlRXJyb3IoZXJyb3IpKSB7XG5cdFx0XHRcdHJldHVybiBlcnJvcjtcblx0XHRcdH1cblx0XHR9XG5cdH1cblx0cmV0dXJuIG51bGw7XG59O1xuXG5WYWxpZGF0b3JDb250ZXh0LnByb3RvdHlwZS52YWxpZGF0ZUFycmF5VW5pcXVlSXRlbXMgPSBmdW5jdGlvbiB2YWxpZGF0ZUFycmF5VW5pcXVlSXRlbXMoZGF0YSwgc2NoZW1hKSB7XG5cdGlmIChzY2hlbWEudW5pcXVlSXRlbXMpIHtcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyBpKyspIHtcblx0XHRcdGZvciAodmFyIGogPSBpICsgMTsgaiA8IGRhdGEubGVuZ3RoOyBqKyspIHtcblx0XHRcdFx0aWYgKHJlY3Vyc2l2ZUNvbXBhcmUoZGF0YVtpXSwgZGF0YVtqXSkpIHtcblx0XHRcdFx0XHR2YXIgZXJyb3IgPSB0aGlzLmNyZWF0ZUVycm9yKEVycm9yQ29kZXMuQVJSQVlfVU5JUVVFLCB7bWF0Y2gxOiBpLCBtYXRjaDI6IGp9LCAnJywgJy91bmlxdWVJdGVtcycsIG51bGwsIGRhdGEsIHNjaGVtYSk7XG5cdFx0XHRcdFx0aWYgKHRoaXMuaGFuZGxlRXJyb3IoZXJyb3IpKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZXJyb3I7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cdHJldHVybiBudWxsO1xufTtcblxuVmFsaWRhdG9yQ29udGV4dC5wcm90b3R5cGUudmFsaWRhdGVBcnJheUl0ZW1zID0gZnVuY3Rpb24gdmFsaWRhdGVBcnJheUl0ZW1zKGRhdGEsIHNjaGVtYSwgZGF0YVBvaW50ZXJQYXRoKSB7XG5cdGlmIChzY2hlbWEuaXRlbXMgPT09IHVuZGVmaW5lZCkge1xuXHRcdHJldHVybiBudWxsO1xuXHR9XG5cdHZhciBlcnJvciwgaTtcblx0aWYgKEFycmF5LmlzQXJyYXkoc2NoZW1hLml0ZW1zKSkge1xuXHRcdGZvciAoaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRpZiAoaSA8IHNjaGVtYS5pdGVtcy5sZW5ndGgpIHtcblx0XHRcdFx0aWYgKGVycm9yID0gdGhpcy52YWxpZGF0ZUFsbChkYXRhW2ldLCBzY2hlbWEuaXRlbXNbaV0sIFtpXSwgW1wiaXRlbXNcIiwgaV0sIGRhdGFQb2ludGVyUGF0aCArIFwiL1wiICsgaSkpIHtcblx0XHRcdFx0XHRyZXR1cm4gZXJyb3I7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSBpZiAoc2NoZW1hLmFkZGl0aW9uYWxJdGVtcyAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdGlmICh0eXBlb2Ygc2NoZW1hLmFkZGl0aW9uYWxJdGVtcyA9PT0gXCJib29sZWFuXCIpIHtcblx0XHRcdFx0XHRpZiAoIXNjaGVtYS5hZGRpdGlvbmFsSXRlbXMpIHtcblx0XHRcdFx0XHRcdGVycm9yID0gKHRoaXMuY3JlYXRlRXJyb3IoRXJyb3JDb2Rlcy5BUlJBWV9BRERJVElPTkFMX0lURU1TLCB7fSwgJy8nICsgaSwgJy9hZGRpdGlvbmFsSXRlbXMnLCBudWxsLCBkYXRhLCBzY2hlbWEpKTtcblx0XHRcdFx0XHRcdGlmICh0aGlzLmhhbmRsZUVycm9yKGVycm9yKSkge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gZXJyb3I7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IGVsc2UgaWYgKGVycm9yID0gdGhpcy52YWxpZGF0ZUFsbChkYXRhW2ldLCBzY2hlbWEuYWRkaXRpb25hbEl0ZW1zLCBbaV0sIFtcImFkZGl0aW9uYWxJdGVtc1wiXSwgZGF0YVBvaW50ZXJQYXRoICsgXCIvXCIgKyBpKSkge1xuXHRcdFx0XHRcdHJldHVybiBlcnJvcjtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fSBlbHNlIHtcblx0XHRmb3IgKGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkrKykge1xuXHRcdFx0aWYgKGVycm9yID0gdGhpcy52YWxpZGF0ZUFsbChkYXRhW2ldLCBzY2hlbWEuaXRlbXMsIFtpXSwgW1wiaXRlbXNcIl0sIGRhdGFQb2ludGVyUGF0aCArIFwiL1wiICsgaSkpIHtcblx0XHRcdFx0cmV0dXJuIGVycm9yO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXHRyZXR1cm4gbnVsbDtcbn07XG5cblZhbGlkYXRvckNvbnRleHQucHJvdG90eXBlLnZhbGlkYXRlT2JqZWN0ID0gZnVuY3Rpb24gdmFsaWRhdGVPYmplY3QoZGF0YSwgc2NoZW1hLCBkYXRhUG9pbnRlclBhdGgpIHtcblx0aWYgKHR5cGVvZiBkYXRhICE9PSBcIm9iamVjdFwiIHx8IGRhdGEgPT09IG51bGwgfHwgQXJyYXkuaXNBcnJheShkYXRhKSkge1xuXHRcdHJldHVybiBudWxsO1xuXHR9XG5cdHJldHVybiB0aGlzLnZhbGlkYXRlT2JqZWN0TWluTWF4UHJvcGVydGllcyhkYXRhLCBzY2hlbWEsIGRhdGFQb2ludGVyUGF0aClcblx0XHR8fCB0aGlzLnZhbGlkYXRlT2JqZWN0UmVxdWlyZWRQcm9wZXJ0aWVzKGRhdGEsIHNjaGVtYSwgZGF0YVBvaW50ZXJQYXRoKVxuXHRcdHx8IHRoaXMudmFsaWRhdGVPYmplY3RQcm9wZXJ0aWVzKGRhdGEsIHNjaGVtYSwgZGF0YVBvaW50ZXJQYXRoKVxuXHRcdHx8IHRoaXMudmFsaWRhdGVPYmplY3REZXBlbmRlbmNpZXMoZGF0YSwgc2NoZW1hLCBkYXRhUG9pbnRlclBhdGgpXG5cdFx0fHwgbnVsbDtcbn07XG5cblZhbGlkYXRvckNvbnRleHQucHJvdG90eXBlLnZhbGlkYXRlT2JqZWN0TWluTWF4UHJvcGVydGllcyA9IGZ1bmN0aW9uIHZhbGlkYXRlT2JqZWN0TWluTWF4UHJvcGVydGllcyhkYXRhLCBzY2hlbWEpIHtcblx0dmFyIGtleXMgPSBPYmplY3Qua2V5cyhkYXRhKTtcblx0dmFyIGVycm9yO1xuXHRpZiAoc2NoZW1hLm1pblByb3BlcnRpZXMgIT09IHVuZGVmaW5lZCkge1xuXHRcdGlmIChrZXlzLmxlbmd0aCA8IHNjaGVtYS5taW5Qcm9wZXJ0aWVzKSB7XG5cdFx0XHRlcnJvciA9IHRoaXMuY3JlYXRlRXJyb3IoRXJyb3JDb2Rlcy5PQkpFQ1RfUFJPUEVSVElFU19NSU5JTVVNLCB7cHJvcGVydHlDb3VudDoga2V5cy5sZW5ndGgsIG1pbmltdW06IHNjaGVtYS5taW5Qcm9wZXJ0aWVzfSwgJycsICcvbWluUHJvcGVydGllcycsIG51bGwsIGRhdGEsIHNjaGVtYSk7XG5cdFx0XHRpZiAodGhpcy5oYW5kbGVFcnJvcihlcnJvcikpIHtcblx0XHRcdFx0cmV0dXJuIGVycm9yO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXHRpZiAoc2NoZW1hLm1heFByb3BlcnRpZXMgIT09IHVuZGVmaW5lZCkge1xuXHRcdGlmIChrZXlzLmxlbmd0aCA+IHNjaGVtYS5tYXhQcm9wZXJ0aWVzKSB7XG5cdFx0XHRlcnJvciA9IHRoaXMuY3JlYXRlRXJyb3IoRXJyb3JDb2Rlcy5PQkpFQ1RfUFJPUEVSVElFU19NQVhJTVVNLCB7cHJvcGVydHlDb3VudDoga2V5cy5sZW5ndGgsIG1heGltdW06IHNjaGVtYS5tYXhQcm9wZXJ0aWVzfSwgJycsICcvbWF4UHJvcGVydGllcycsIG51bGwsIGRhdGEsIHNjaGVtYSk7XG5cdFx0XHRpZiAodGhpcy5oYW5kbGVFcnJvcihlcnJvcikpIHtcblx0XHRcdFx0cmV0dXJuIGVycm9yO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXHRyZXR1cm4gbnVsbDtcbn07XG5cblZhbGlkYXRvckNvbnRleHQucHJvdG90eXBlLnZhbGlkYXRlT2JqZWN0UmVxdWlyZWRQcm9wZXJ0aWVzID0gZnVuY3Rpb24gdmFsaWRhdGVPYmplY3RSZXF1aXJlZFByb3BlcnRpZXMoZGF0YSwgc2NoZW1hKSB7XG5cdGlmIChzY2hlbWEucmVxdWlyZWQgIT09IHVuZGVmaW5lZCkge1xuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgc2NoZW1hLnJlcXVpcmVkLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR2YXIga2V5ID0gc2NoZW1hLnJlcXVpcmVkW2ldO1xuXHRcdFx0aWYgKGRhdGFba2V5XSA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdHZhciBlcnJvciA9IHRoaXMuY3JlYXRlRXJyb3IoRXJyb3JDb2Rlcy5PQkpFQ1RfUkVRVUlSRUQsIHtrZXk6IGtleX0sICcnLCAnL3JlcXVpcmVkLycgKyBpLCBudWxsLCBkYXRhLCBzY2hlbWEpO1xuXHRcdFx0XHRpZiAodGhpcy5oYW5kbGVFcnJvcihlcnJvcikpIHtcblx0XHRcdFx0XHRyZXR1cm4gZXJyb3I7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblx0cmV0dXJuIG51bGw7XG59O1xuXG5WYWxpZGF0b3JDb250ZXh0LnByb3RvdHlwZS52YWxpZGF0ZU9iamVjdFByb3BlcnRpZXMgPSBmdW5jdGlvbiB2YWxpZGF0ZU9iamVjdFByb3BlcnRpZXMoZGF0YSwgc2NoZW1hLCBkYXRhUG9pbnRlclBhdGgpIHtcblx0dmFyIGVycm9yO1xuXHRmb3IgKHZhciBrZXkgaW4gZGF0YSkge1xuXHRcdHZhciBrZXlQb2ludGVyUGF0aCA9IGRhdGFQb2ludGVyUGF0aCArIFwiL1wiICsga2V5LnJlcGxhY2UoL34vZywgJ34wJykucmVwbGFjZSgvXFwvL2csICd+MScpO1xuXHRcdHZhciBmb3VuZE1hdGNoID0gZmFsc2U7XG5cdFx0aWYgKHNjaGVtYS5wcm9wZXJ0aWVzICE9PSB1bmRlZmluZWQgJiYgc2NoZW1hLnByb3BlcnRpZXNba2V5XSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRmb3VuZE1hdGNoID0gdHJ1ZTtcblx0XHRcdGlmIChlcnJvciA9IHRoaXMudmFsaWRhdGVBbGwoZGF0YVtrZXldLCBzY2hlbWEucHJvcGVydGllc1trZXldLCBba2V5XSwgW1wicHJvcGVydGllc1wiLCBrZXldLCBrZXlQb2ludGVyUGF0aCkpIHtcblx0XHRcdFx0cmV0dXJuIGVycm9yO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRpZiAoc2NoZW1hLnBhdHRlcm5Qcm9wZXJ0aWVzICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdGZvciAodmFyIHBhdHRlcm5LZXkgaW4gc2NoZW1hLnBhdHRlcm5Qcm9wZXJ0aWVzKSB7XG5cdFx0XHRcdHZhciByZWdleHAgPSBuZXcgUmVnRXhwKHBhdHRlcm5LZXkpO1xuXHRcdFx0XHRpZiAocmVnZXhwLnRlc3Qoa2V5KSkge1xuXHRcdFx0XHRcdGZvdW5kTWF0Y2ggPSB0cnVlO1xuXHRcdFx0XHRcdGlmIChlcnJvciA9IHRoaXMudmFsaWRhdGVBbGwoZGF0YVtrZXldLCBzY2hlbWEucGF0dGVyblByb3BlcnRpZXNbcGF0dGVybktleV0sIFtrZXldLCBbXCJwYXR0ZXJuUHJvcGVydGllc1wiLCBwYXR0ZXJuS2V5XSwga2V5UG9pbnRlclBhdGgpKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZXJyb3I7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGlmICghZm91bmRNYXRjaCkge1xuXHRcdFx0aWYgKHNjaGVtYS5hZGRpdGlvbmFsUHJvcGVydGllcyAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdGlmICh0aGlzLnRyYWNrVW5rbm93blByb3BlcnRpZXMpIHtcblx0XHRcdFx0XHR0aGlzLmtub3duUHJvcGVydHlQYXRoc1trZXlQb2ludGVyUGF0aF0gPSB0cnVlO1xuXHRcdFx0XHRcdGRlbGV0ZSB0aGlzLnVua25vd25Qcm9wZXJ0eVBhdGhzW2tleVBvaW50ZXJQYXRoXTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAodHlwZW9mIHNjaGVtYS5hZGRpdGlvbmFsUHJvcGVydGllcyA9PT0gXCJib29sZWFuXCIpIHtcblx0XHRcdFx0XHRpZiAoIXNjaGVtYS5hZGRpdGlvbmFsUHJvcGVydGllcykge1xuXHRcdFx0XHRcdFx0ZXJyb3IgPSB0aGlzLmNyZWF0ZUVycm9yKEVycm9yQ29kZXMuT0JKRUNUX0FERElUSU9OQUxfUFJPUEVSVElFUywge2tleToga2V5fSwgJycsICcvYWRkaXRpb25hbFByb3BlcnRpZXMnLCBudWxsLCBkYXRhLCBzY2hlbWEpLnByZWZpeFdpdGgoa2V5LCBudWxsKTtcblx0XHRcdFx0XHRcdGlmICh0aGlzLmhhbmRsZUVycm9yKGVycm9yKSkge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gZXJyb3I7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGlmIChlcnJvciA9IHRoaXMudmFsaWRhdGVBbGwoZGF0YVtrZXldLCBzY2hlbWEuYWRkaXRpb25hbFByb3BlcnRpZXMsIFtrZXldLCBbXCJhZGRpdGlvbmFsUHJvcGVydGllc1wiXSwga2V5UG9pbnRlclBhdGgpKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZXJyb3I7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2UgaWYgKHRoaXMudHJhY2tVbmtub3duUHJvcGVydGllcyAmJiAhdGhpcy5rbm93blByb3BlcnR5UGF0aHNba2V5UG9pbnRlclBhdGhdKSB7XG5cdFx0XHRcdHRoaXMudW5rbm93blByb3BlcnR5UGF0aHNba2V5UG9pbnRlclBhdGhdID0gdHJ1ZTtcblx0XHRcdH1cblx0XHR9IGVsc2UgaWYgKHRoaXMudHJhY2tVbmtub3duUHJvcGVydGllcykge1xuXHRcdFx0dGhpcy5rbm93blByb3BlcnR5UGF0aHNba2V5UG9pbnRlclBhdGhdID0gdHJ1ZTtcblx0XHRcdGRlbGV0ZSB0aGlzLnVua25vd25Qcm9wZXJ0eVBhdGhzW2tleVBvaW50ZXJQYXRoXTtcblx0XHR9XG5cdH1cblx0cmV0dXJuIG51bGw7XG59O1xuXG5WYWxpZGF0b3JDb250ZXh0LnByb3RvdHlwZS52YWxpZGF0ZU9iamVjdERlcGVuZGVuY2llcyA9IGZ1bmN0aW9uIHZhbGlkYXRlT2JqZWN0RGVwZW5kZW5jaWVzKGRhdGEsIHNjaGVtYSwgZGF0YVBvaW50ZXJQYXRoKSB7XG5cdHZhciBlcnJvcjtcblx0aWYgKHNjaGVtYS5kZXBlbmRlbmNpZXMgIT09IHVuZGVmaW5lZCkge1xuXHRcdGZvciAodmFyIGRlcEtleSBpbiBzY2hlbWEuZGVwZW5kZW5jaWVzKSB7XG5cdFx0XHRpZiAoZGF0YVtkZXBLZXldICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0dmFyIGRlcCA9IHNjaGVtYS5kZXBlbmRlbmNpZXNbZGVwS2V5XTtcblx0XHRcdFx0aWYgKHR5cGVvZiBkZXAgPT09IFwic3RyaW5nXCIpIHtcblx0XHRcdFx0XHRpZiAoZGF0YVtkZXBdID09PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0XHRcdGVycm9yID0gdGhpcy5jcmVhdGVFcnJvcihFcnJvckNvZGVzLk9CSkVDVF9ERVBFTkRFTkNZX0tFWSwge2tleTogZGVwS2V5LCBtaXNzaW5nOiBkZXB9LCAnJywgJycsIG51bGwsIGRhdGEsIHNjaGVtYSkucHJlZml4V2l0aChudWxsLCBkZXBLZXkpLnByZWZpeFdpdGgobnVsbCwgXCJkZXBlbmRlbmNpZXNcIik7XG5cdFx0XHRcdFx0XHRpZiAodGhpcy5oYW5kbGVFcnJvcihlcnJvcikpIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIGVycm9yO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSBlbHNlIGlmIChBcnJheS5pc0FycmF5KGRlcCkpIHtcblx0XHRcdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGRlcC5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRcdFx0dmFyIHJlcXVpcmVkS2V5ID0gZGVwW2ldO1xuXHRcdFx0XHRcdFx0aWYgKGRhdGFbcmVxdWlyZWRLZXldID09PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0XHRcdFx0ZXJyb3IgPSB0aGlzLmNyZWF0ZUVycm9yKEVycm9yQ29kZXMuT0JKRUNUX0RFUEVOREVOQ1lfS0VZLCB7a2V5OiBkZXBLZXksIG1pc3Npbmc6IHJlcXVpcmVkS2V5fSwgJycsICcvJyArIGksIG51bGwsIGRhdGEsIHNjaGVtYSkucHJlZml4V2l0aChudWxsLCBkZXBLZXkpLnByZWZpeFdpdGgobnVsbCwgXCJkZXBlbmRlbmNpZXNcIik7XG5cdFx0XHRcdFx0XHRcdGlmICh0aGlzLmhhbmRsZUVycm9yKGVycm9yKSkge1xuXHRcdFx0XHRcdFx0XHRcdHJldHVybiBlcnJvcjtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRpZiAoZXJyb3IgPSB0aGlzLnZhbGlkYXRlQWxsKGRhdGEsIGRlcCwgW10sIFtcImRlcGVuZGVuY2llc1wiLCBkZXBLZXldLCBkYXRhUG9pbnRlclBhdGgpKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZXJyb3I7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cdHJldHVybiBudWxsO1xufTtcblxuVmFsaWRhdG9yQ29udGV4dC5wcm90b3R5cGUudmFsaWRhdGVDb21iaW5hdGlvbnMgPSBmdW5jdGlvbiB2YWxpZGF0ZUNvbWJpbmF0aW9ucyhkYXRhLCBzY2hlbWEsIGRhdGFQb2ludGVyUGF0aCkge1xuXHRyZXR1cm4gdGhpcy52YWxpZGF0ZUFsbE9mKGRhdGEsIHNjaGVtYSwgZGF0YVBvaW50ZXJQYXRoKVxuXHRcdHx8IHRoaXMudmFsaWRhdGVBbnlPZihkYXRhLCBzY2hlbWEsIGRhdGFQb2ludGVyUGF0aClcblx0XHR8fCB0aGlzLnZhbGlkYXRlT25lT2YoZGF0YSwgc2NoZW1hLCBkYXRhUG9pbnRlclBhdGgpXG5cdFx0fHwgdGhpcy52YWxpZGF0ZU5vdChkYXRhLCBzY2hlbWEsIGRhdGFQb2ludGVyUGF0aClcblx0XHR8fCBudWxsO1xufTtcblxuVmFsaWRhdG9yQ29udGV4dC5wcm90b3R5cGUudmFsaWRhdGVBbGxPZiA9IGZ1bmN0aW9uIHZhbGlkYXRlQWxsT2YoZGF0YSwgc2NoZW1hLCBkYXRhUG9pbnRlclBhdGgpIHtcblx0aWYgKHNjaGVtYS5hbGxPZiA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0cmV0dXJuIG51bGw7XG5cdH1cblx0dmFyIGVycm9yO1xuXHRmb3IgKHZhciBpID0gMDsgaSA8IHNjaGVtYS5hbGxPZi5sZW5ndGg7IGkrKykge1xuXHRcdHZhciBzdWJTY2hlbWEgPSBzY2hlbWEuYWxsT2ZbaV07XG5cdFx0aWYgKGVycm9yID0gdGhpcy52YWxpZGF0ZUFsbChkYXRhLCBzdWJTY2hlbWEsIFtdLCBbXCJhbGxPZlwiLCBpXSwgZGF0YVBvaW50ZXJQYXRoKSkge1xuXHRcdFx0cmV0dXJuIGVycm9yO1xuXHRcdH1cblx0fVxuXHRyZXR1cm4gbnVsbDtcbn07XG5cblZhbGlkYXRvckNvbnRleHQucHJvdG90eXBlLnZhbGlkYXRlQW55T2YgPSBmdW5jdGlvbiB2YWxpZGF0ZUFueU9mKGRhdGEsIHNjaGVtYSwgZGF0YVBvaW50ZXJQYXRoKSB7XG5cdGlmIChzY2hlbWEuYW55T2YgPT09IHVuZGVmaW5lZCkge1xuXHRcdHJldHVybiBudWxsO1xuXHR9XG5cdHZhciBlcnJvcnMgPSBbXTtcblx0dmFyIHN0YXJ0RXJyb3JDb3VudCA9IHRoaXMuZXJyb3JzLmxlbmd0aDtcblx0dmFyIG9sZFVua25vd25Qcm9wZXJ0eVBhdGhzLCBvbGRLbm93blByb3BlcnR5UGF0aHM7XG5cdGlmICh0aGlzLnRyYWNrVW5rbm93blByb3BlcnRpZXMpIHtcblx0XHRvbGRVbmtub3duUHJvcGVydHlQYXRocyA9IHRoaXMudW5rbm93blByb3BlcnR5UGF0aHM7XG5cdFx0b2xkS25vd25Qcm9wZXJ0eVBhdGhzID0gdGhpcy5rbm93blByb3BlcnR5UGF0aHM7XG5cdH1cblx0dmFyIGVycm9yQXRFbmQgPSB0cnVlO1xuXHRmb3IgKHZhciBpID0gMDsgaSA8IHNjaGVtYS5hbnlPZi5sZW5ndGg7IGkrKykge1xuXHRcdGlmICh0aGlzLnRyYWNrVW5rbm93blByb3BlcnRpZXMpIHtcblx0XHRcdHRoaXMudW5rbm93blByb3BlcnR5UGF0aHMgPSB7fTtcblx0XHRcdHRoaXMua25vd25Qcm9wZXJ0eVBhdGhzID0ge307XG5cdFx0fVxuXHRcdHZhciBzdWJTY2hlbWEgPSBzY2hlbWEuYW55T2ZbaV07XG5cblx0XHR2YXIgZXJyb3JDb3VudCA9IHRoaXMuZXJyb3JzLmxlbmd0aDtcblx0XHR2YXIgZXJyb3IgPSB0aGlzLnZhbGlkYXRlQWxsKGRhdGEsIHN1YlNjaGVtYSwgW10sIFtcImFueU9mXCIsIGldLCBkYXRhUG9pbnRlclBhdGgpO1xuXG5cdFx0aWYgKGVycm9yID09PSBudWxsICYmIGVycm9yQ291bnQgPT09IHRoaXMuZXJyb3JzLmxlbmd0aCkge1xuXHRcdFx0dGhpcy5lcnJvcnMgPSB0aGlzLmVycm9ycy5zbGljZSgwLCBzdGFydEVycm9yQ291bnQpO1xuXG5cdFx0XHRpZiAodGhpcy50cmFja1Vua25vd25Qcm9wZXJ0aWVzKSB7XG5cdFx0XHRcdGZvciAodmFyIGtub3duS2V5IGluIHRoaXMua25vd25Qcm9wZXJ0eVBhdGhzKSB7XG5cdFx0XHRcdFx0b2xkS25vd25Qcm9wZXJ0eVBhdGhzW2tub3duS2V5XSA9IHRydWU7XG5cdFx0XHRcdFx0ZGVsZXRlIG9sZFVua25vd25Qcm9wZXJ0eVBhdGhzW2tub3duS2V5XTtcblx0XHRcdFx0fVxuXHRcdFx0XHRmb3IgKHZhciB1bmtub3duS2V5IGluIHRoaXMudW5rbm93blByb3BlcnR5UGF0aHMpIHtcblx0XHRcdFx0XHRpZiAoIW9sZEtub3duUHJvcGVydHlQYXRoc1t1bmtub3duS2V5XSkge1xuXHRcdFx0XHRcdFx0b2xkVW5rbm93blByb3BlcnR5UGF0aHNbdW5rbm93bktleV0gPSB0cnVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHQvLyBXZSBuZWVkIHRvIGNvbnRpbnVlIGxvb3Bpbmcgc28gd2UgY2F0Y2ggYWxsIHRoZSBwcm9wZXJ0eSBkZWZpbml0aW9ucywgYnV0IHdlIGRvbid0IHdhbnQgdG8gcmV0dXJuIGFuIGVycm9yXG5cdFx0XHRcdGVycm9yQXRFbmQgPSBmYWxzZTtcblx0XHRcdFx0Y29udGludWU7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBudWxsO1xuXHRcdH1cblx0XHRpZiAoZXJyb3IpIHtcblx0XHRcdGVycm9ycy5wdXNoKGVycm9yLnByZWZpeFdpdGgobnVsbCwgXCJcIiArIGkpLnByZWZpeFdpdGgobnVsbCwgXCJhbnlPZlwiKSk7XG5cdFx0fVxuXHR9XG5cdGlmICh0aGlzLnRyYWNrVW5rbm93blByb3BlcnRpZXMpIHtcblx0XHR0aGlzLnVua25vd25Qcm9wZXJ0eVBhdGhzID0gb2xkVW5rbm93blByb3BlcnR5UGF0aHM7XG5cdFx0dGhpcy5rbm93blByb3BlcnR5UGF0aHMgPSBvbGRLbm93blByb3BlcnR5UGF0aHM7XG5cdH1cblx0aWYgKGVycm9yQXRFbmQpIHtcblx0XHRlcnJvcnMgPSBlcnJvcnMuY29uY2F0KHRoaXMuZXJyb3JzLnNsaWNlKHN0YXJ0RXJyb3JDb3VudCkpO1xuXHRcdHRoaXMuZXJyb3JzID0gdGhpcy5lcnJvcnMuc2xpY2UoMCwgc3RhcnRFcnJvckNvdW50KTtcblx0XHRyZXR1cm4gdGhpcy5jcmVhdGVFcnJvcihFcnJvckNvZGVzLkFOWV9PRl9NSVNTSU5HLCB7fSwgXCJcIiwgXCIvYW55T2ZcIiwgZXJyb3JzLCBkYXRhLCBzY2hlbWEpO1xuXHR9XG59O1xuXG5WYWxpZGF0b3JDb250ZXh0LnByb3RvdHlwZS52YWxpZGF0ZU9uZU9mID0gZnVuY3Rpb24gdmFsaWRhdGVPbmVPZihkYXRhLCBzY2hlbWEsIGRhdGFQb2ludGVyUGF0aCkge1xuXHRpZiAoc2NoZW1hLm9uZU9mID09PSB1bmRlZmluZWQpIHtcblx0XHRyZXR1cm4gbnVsbDtcblx0fVxuXHR2YXIgdmFsaWRJbmRleCA9IG51bGw7XG5cdHZhciBlcnJvcnMgPSBbXTtcblx0dmFyIHN0YXJ0RXJyb3JDb3VudCA9IHRoaXMuZXJyb3JzLmxlbmd0aDtcblx0dmFyIG9sZFVua25vd25Qcm9wZXJ0eVBhdGhzLCBvbGRLbm93blByb3BlcnR5UGF0aHM7XG5cdGlmICh0aGlzLnRyYWNrVW5rbm93blByb3BlcnRpZXMpIHtcblx0XHRvbGRVbmtub3duUHJvcGVydHlQYXRocyA9IHRoaXMudW5rbm93blByb3BlcnR5UGF0aHM7XG5cdFx0b2xkS25vd25Qcm9wZXJ0eVBhdGhzID0gdGhpcy5rbm93blByb3BlcnR5UGF0aHM7XG5cdH1cblx0Zm9yICh2YXIgaSA9IDA7IGkgPCBzY2hlbWEub25lT2YubGVuZ3RoOyBpKyspIHtcblx0XHRpZiAodGhpcy50cmFja1Vua25vd25Qcm9wZXJ0aWVzKSB7XG5cdFx0XHR0aGlzLnVua25vd25Qcm9wZXJ0eVBhdGhzID0ge307XG5cdFx0XHR0aGlzLmtub3duUHJvcGVydHlQYXRocyA9IHt9O1xuXHRcdH1cblx0XHR2YXIgc3ViU2NoZW1hID0gc2NoZW1hLm9uZU9mW2ldO1xuXG5cdFx0dmFyIGVycm9yQ291bnQgPSB0aGlzLmVycm9ycy5sZW5ndGg7XG5cdFx0dmFyIGVycm9yID0gdGhpcy52YWxpZGF0ZUFsbChkYXRhLCBzdWJTY2hlbWEsIFtdLCBbXCJvbmVPZlwiLCBpXSwgZGF0YVBvaW50ZXJQYXRoKTtcblxuXHRcdGlmIChlcnJvciA9PT0gbnVsbCAmJiBlcnJvckNvdW50ID09PSB0aGlzLmVycm9ycy5sZW5ndGgpIHtcblx0XHRcdGlmICh2YWxpZEluZGV4ID09PSBudWxsKSB7XG5cdFx0XHRcdHZhbGlkSW5kZXggPSBpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGhpcy5lcnJvcnMgPSB0aGlzLmVycm9ycy5zbGljZSgwLCBzdGFydEVycm9yQ291bnQpO1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5jcmVhdGVFcnJvcihFcnJvckNvZGVzLk9ORV9PRl9NVUxUSVBMRSwge2luZGV4MTogdmFsaWRJbmRleCwgaW5kZXgyOiBpfSwgXCJcIiwgXCIvb25lT2ZcIiwgbnVsbCwgZGF0YSwgc2NoZW1hKTtcblx0XHRcdH1cblx0XHRcdGlmICh0aGlzLnRyYWNrVW5rbm93blByb3BlcnRpZXMpIHtcblx0XHRcdFx0Zm9yICh2YXIga25vd25LZXkgaW4gdGhpcy5rbm93blByb3BlcnR5UGF0aHMpIHtcblx0XHRcdFx0XHRvbGRLbm93blByb3BlcnR5UGF0aHNba25vd25LZXldID0gdHJ1ZTtcblx0XHRcdFx0XHRkZWxldGUgb2xkVW5rbm93blByb3BlcnR5UGF0aHNba25vd25LZXldO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGZvciAodmFyIHVua25vd25LZXkgaW4gdGhpcy51bmtub3duUHJvcGVydHlQYXRocykge1xuXHRcdFx0XHRcdGlmICghb2xkS25vd25Qcm9wZXJ0eVBhdGhzW3Vua25vd25LZXldKSB7XG5cdFx0XHRcdFx0XHRvbGRVbmtub3duUHJvcGVydHlQYXRoc1t1bmtub3duS2V5XSA9IHRydWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSBlbHNlIGlmIChlcnJvcikge1xuXHRcdFx0ZXJyb3JzLnB1c2goZXJyb3IpO1xuXHRcdH1cblx0fVxuXHRpZiAodGhpcy50cmFja1Vua25vd25Qcm9wZXJ0aWVzKSB7XG5cdFx0dGhpcy51bmtub3duUHJvcGVydHlQYXRocyA9IG9sZFVua25vd25Qcm9wZXJ0eVBhdGhzO1xuXHRcdHRoaXMua25vd25Qcm9wZXJ0eVBhdGhzID0gb2xkS25vd25Qcm9wZXJ0eVBhdGhzO1xuXHR9XG5cdGlmICh2YWxpZEluZGV4ID09PSBudWxsKSB7XG5cdFx0ZXJyb3JzID0gZXJyb3JzLmNvbmNhdCh0aGlzLmVycm9ycy5zbGljZShzdGFydEVycm9yQ291bnQpKTtcblx0XHR0aGlzLmVycm9ycyA9IHRoaXMuZXJyb3JzLnNsaWNlKDAsIHN0YXJ0RXJyb3JDb3VudCk7XG5cdFx0cmV0dXJuIHRoaXMuY3JlYXRlRXJyb3IoRXJyb3JDb2Rlcy5PTkVfT0ZfTUlTU0lORywge30sIFwiXCIsIFwiL29uZU9mXCIsIGVycm9ycywgZGF0YSwgc2NoZW1hKTtcblx0fSBlbHNlIHtcblx0XHR0aGlzLmVycm9ycyA9IHRoaXMuZXJyb3JzLnNsaWNlKDAsIHN0YXJ0RXJyb3JDb3VudCk7XG5cdH1cblx0cmV0dXJuIG51bGw7XG59O1xuXG5WYWxpZGF0b3JDb250ZXh0LnByb3RvdHlwZS52YWxpZGF0ZU5vdCA9IGZ1bmN0aW9uIHZhbGlkYXRlTm90KGRhdGEsIHNjaGVtYSwgZGF0YVBvaW50ZXJQYXRoKSB7XG5cdGlmIChzY2hlbWEubm90ID09PSB1bmRlZmluZWQpIHtcblx0XHRyZXR1cm4gbnVsbDtcblx0fVxuXHR2YXIgb2xkRXJyb3JDb3VudCA9IHRoaXMuZXJyb3JzLmxlbmd0aDtcblx0dmFyIG9sZFVua25vd25Qcm9wZXJ0eVBhdGhzLCBvbGRLbm93blByb3BlcnR5UGF0aHM7XG5cdGlmICh0aGlzLnRyYWNrVW5rbm93blByb3BlcnRpZXMpIHtcblx0XHRvbGRVbmtub3duUHJvcGVydHlQYXRocyA9IHRoaXMudW5rbm93blByb3BlcnR5UGF0aHM7XG5cdFx0b2xkS25vd25Qcm9wZXJ0eVBhdGhzID0gdGhpcy5rbm93blByb3BlcnR5UGF0aHM7XG5cdFx0dGhpcy51bmtub3duUHJvcGVydHlQYXRocyA9IHt9O1xuXHRcdHRoaXMua25vd25Qcm9wZXJ0eVBhdGhzID0ge307XG5cdH1cblx0dmFyIGVycm9yID0gdGhpcy52YWxpZGF0ZUFsbChkYXRhLCBzY2hlbWEubm90LCBudWxsLCBudWxsLCBkYXRhUG9pbnRlclBhdGgpO1xuXHR2YXIgbm90RXJyb3JzID0gdGhpcy5lcnJvcnMuc2xpY2Uob2xkRXJyb3JDb3VudCk7XG5cdHRoaXMuZXJyb3JzID0gdGhpcy5lcnJvcnMuc2xpY2UoMCwgb2xkRXJyb3JDb3VudCk7XG5cdGlmICh0aGlzLnRyYWNrVW5rbm93blByb3BlcnRpZXMpIHtcblx0XHR0aGlzLnVua25vd25Qcm9wZXJ0eVBhdGhzID0gb2xkVW5rbm93blByb3BlcnR5UGF0aHM7XG5cdFx0dGhpcy5rbm93blByb3BlcnR5UGF0aHMgPSBvbGRLbm93blByb3BlcnR5UGF0aHM7XG5cdH1cblx0aWYgKGVycm9yID09PSBudWxsICYmIG5vdEVycm9ycy5sZW5ndGggPT09IDApIHtcblx0XHRyZXR1cm4gdGhpcy5jcmVhdGVFcnJvcihFcnJvckNvZGVzLk5PVF9QQVNTRUQsIHt9LCBcIlwiLCBcIi9ub3RcIiwgbnVsbCwgZGF0YSwgc2NoZW1hKTtcblx0fVxuXHRyZXR1cm4gbnVsbDtcbn07XG5cblZhbGlkYXRvckNvbnRleHQucHJvdG90eXBlLnZhbGlkYXRlSHlwZXJtZWRpYSA9IGZ1bmN0aW9uIHZhbGlkYXRlQ29tYmluYXRpb25zKGRhdGEsIHNjaGVtYSwgZGF0YVBvaW50ZXJQYXRoKSB7XG5cdGlmICghc2NoZW1hLmxpbmtzKSB7XG5cdFx0cmV0dXJuIG51bGw7XG5cdH1cblx0dmFyIGVycm9yO1xuXHRmb3IgKHZhciBpID0gMDsgaSA8IHNjaGVtYS5saW5rcy5sZW5ndGg7IGkrKykge1xuXHRcdHZhciBsZG8gPSBzY2hlbWEubGlua3NbaV07XG5cdFx0aWYgKGxkby5yZWwgPT09IFwiZGVzY3JpYmVkYnlcIikge1xuXHRcdFx0dmFyIHRlbXBsYXRlID0gbmV3IFVyaVRlbXBsYXRlKGxkby5ocmVmKTtcblx0XHRcdHZhciBhbGxQcmVzZW50ID0gdHJ1ZTtcblx0XHRcdGZvciAodmFyIGogPSAwOyBqIDwgdGVtcGxhdGUudmFyTmFtZXMubGVuZ3RoOyBqKyspIHtcblx0XHRcdFx0aWYgKCEodGVtcGxhdGUudmFyTmFtZXNbal0gaW4gZGF0YSkpIHtcblx0XHRcdFx0XHRhbGxQcmVzZW50ID0gZmFsc2U7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGlmIChhbGxQcmVzZW50KSB7XG5cdFx0XHRcdHZhciBzY2hlbWFVcmwgPSB0ZW1wbGF0ZS5maWxsRnJvbU9iamVjdChkYXRhKTtcblx0XHRcdFx0dmFyIHN1YlNjaGVtYSA9IHtcIiRyZWZcIjogc2NoZW1hVXJsfTtcblx0XHRcdFx0aWYgKGVycm9yID0gdGhpcy52YWxpZGF0ZUFsbChkYXRhLCBzdWJTY2hlbWEsIFtdLCBbXCJsaW5rc1wiLCBpXSwgZGF0YVBvaW50ZXJQYXRoKSkge1xuXHRcdFx0XHRcdHJldHVybiBlcnJvcjtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxufTtcblxuLy8gcGFyc2VVUkkoKSBhbmQgcmVzb2x2ZVVybCgpIGFyZSBmcm9tIGh0dHBzOi8vZ2lzdC5naXRodWIuY29tLzEwODg4NTBcbi8vICAgLSAgcmVsZWFzZWQgYXMgcHVibGljIGRvbWFpbiBieSBhdXRob3IgKFwiWWFmZmxlXCIpIC0gc2VlIGNvbW1lbnRzIG9uIGdpc3RcblxuZnVuY3Rpb24gcGFyc2VVUkkodXJsKSB7XG5cdHZhciBtID0gU3RyaW5nKHVybCkucmVwbGFjZSgvXlxccyt8XFxzKyQvZywgJycpLm1hdGNoKC9eKFteOlxcLz8jXSs6KT8oXFwvXFwvKD86W146QF0qKD86OlteOkBdKik/QCk/KChbXjpcXC8/I10qKSg/OjooXFxkKikpPykpPyhbXj8jXSopKFxcP1teI10qKT8oI1tcXHNcXFNdKik/Lyk7XG5cdC8vIGF1dGhvcml0eSA9ICcvLycgKyB1c2VyICsgJzonICsgcGFzcyAnQCcgKyBob3N0bmFtZSArICc6JyBwb3J0XG5cdHJldHVybiAobSA/IHtcblx0XHRocmVmICAgICA6IG1bMF0gfHwgJycsXG5cdFx0cHJvdG9jb2wgOiBtWzFdIHx8ICcnLFxuXHRcdGF1dGhvcml0eTogbVsyXSB8fCAnJyxcblx0XHRob3N0ICAgICA6IG1bM10gfHwgJycsXG5cdFx0aG9zdG5hbWUgOiBtWzRdIHx8ICcnLFxuXHRcdHBvcnQgICAgIDogbVs1XSB8fCAnJyxcblx0XHRwYXRobmFtZSA6IG1bNl0gfHwgJycsXG5cdFx0c2VhcmNoICAgOiBtWzddIHx8ICcnLFxuXHRcdGhhc2ggICAgIDogbVs4XSB8fCAnJ1xuXHR9IDogbnVsbCk7XG59XG5cbmZ1bmN0aW9uIHJlc29sdmVVcmwoYmFzZSwgaHJlZikgey8vIFJGQyAzOTg2XG5cblx0ZnVuY3Rpb24gcmVtb3ZlRG90U2VnbWVudHMoaW5wdXQpIHtcblx0XHR2YXIgb3V0cHV0ID0gW107XG5cdFx0aW5wdXQucmVwbGFjZSgvXihcXC5cXC4/KFxcL3wkKSkrLywgJycpXG5cdFx0XHQucmVwbGFjZSgvXFwvKFxcLihcXC98JCkpKy9nLCAnLycpXG5cdFx0XHQucmVwbGFjZSgvXFwvXFwuXFwuJC8sICcvLi4vJylcblx0XHRcdC5yZXBsYWNlKC9cXC8/W15cXC9dKi9nLCBmdW5jdGlvbiAocCkge1xuXHRcdFx0XHRpZiAocCA9PT0gJy8uLicpIHtcblx0XHRcdFx0XHRvdXRwdXQucG9wKCk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0b3V0cHV0LnB1c2gocCk7XG5cdFx0XHRcdH1cblx0XHR9KTtcblx0XHRyZXR1cm4gb3V0cHV0LmpvaW4oJycpLnJlcGxhY2UoL15cXC8vLCBpbnB1dC5jaGFyQXQoMCkgPT09ICcvJyA/ICcvJyA6ICcnKTtcblx0fVxuXG5cdGhyZWYgPSBwYXJzZVVSSShocmVmIHx8ICcnKTtcblx0YmFzZSA9IHBhcnNlVVJJKGJhc2UgfHwgJycpO1xuXG5cdHJldHVybiAhaHJlZiB8fCAhYmFzZSA/IG51bGwgOiAoaHJlZi5wcm90b2NvbCB8fCBiYXNlLnByb3RvY29sKSArXG5cdFx0KGhyZWYucHJvdG9jb2wgfHwgaHJlZi5hdXRob3JpdHkgPyBocmVmLmF1dGhvcml0eSA6IGJhc2UuYXV0aG9yaXR5KSArXG5cdFx0cmVtb3ZlRG90U2VnbWVudHMoaHJlZi5wcm90b2NvbCB8fCBocmVmLmF1dGhvcml0eSB8fCBocmVmLnBhdGhuYW1lLmNoYXJBdCgwKSA9PT0gJy8nID8gaHJlZi5wYXRobmFtZSA6IChocmVmLnBhdGhuYW1lID8gKChiYXNlLmF1dGhvcml0eSAmJiAhYmFzZS5wYXRobmFtZSA/ICcvJyA6ICcnKSArIGJhc2UucGF0aG5hbWUuc2xpY2UoMCwgYmFzZS5wYXRobmFtZS5sYXN0SW5kZXhPZignLycpICsgMSkgKyBocmVmLnBhdGhuYW1lKSA6IGJhc2UucGF0aG5hbWUpKSArXG5cdFx0KGhyZWYucHJvdG9jb2wgfHwgaHJlZi5hdXRob3JpdHkgfHwgaHJlZi5wYXRobmFtZSA/IGhyZWYuc2VhcmNoIDogKGhyZWYuc2VhcmNoIHx8IGJhc2Uuc2VhcmNoKSkgK1xuXHRcdGhyZWYuaGFzaDtcbn1cblxuZnVuY3Rpb24gZ2V0RG9jdW1lbnRVcmkodXJpKSB7XG5cdHJldHVybiB1cmkuc3BsaXQoJyMnKVswXTtcbn1cbmZ1bmN0aW9uIG5vcm1TY2hlbWEoc2NoZW1hLCBiYXNlVXJpKSB7XG5cdGlmIChzY2hlbWEgJiYgdHlwZW9mIHNjaGVtYSA9PT0gXCJvYmplY3RcIikge1xuXHRcdGlmIChiYXNlVXJpID09PSB1bmRlZmluZWQpIHtcblx0XHRcdGJhc2VVcmkgPSBzY2hlbWEuaWQ7XG5cdFx0fSBlbHNlIGlmICh0eXBlb2Ygc2NoZW1hLmlkID09PSBcInN0cmluZ1wiKSB7XG5cdFx0XHRiYXNlVXJpID0gcmVzb2x2ZVVybChiYXNlVXJpLCBzY2hlbWEuaWQpO1xuXHRcdFx0c2NoZW1hLmlkID0gYmFzZVVyaTtcblx0XHR9XG5cdFx0aWYgKEFycmF5LmlzQXJyYXkoc2NoZW1hKSkge1xuXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBzY2hlbWEubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0bm9ybVNjaGVtYShzY2hlbWFbaV0sIGJhc2VVcmkpO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRpZiAodHlwZW9mIHNjaGVtYVsnJHJlZiddID09PSBcInN0cmluZ1wiKSB7XG5cdFx0XHRcdHNjaGVtYVsnJHJlZiddID0gcmVzb2x2ZVVybChiYXNlVXJpLCBzY2hlbWFbJyRyZWYnXSk7XG5cdFx0XHR9XG5cdFx0XHRmb3IgKHZhciBrZXkgaW4gc2NoZW1hKSB7XG5cdFx0XHRcdGlmIChrZXkgIT09IFwiZW51bVwiKSB7XG5cdFx0XHRcdFx0bm9ybVNjaGVtYShzY2hlbWFba2V5XSwgYmFzZVVyaSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cbn1cblxuZnVuY3Rpb24gZGVmYXVsdEVycm9yUmVwb3J0ZXIobGFuZ3VhZ2UpIHtcblx0bGFuZ3VhZ2UgPSBsYW5ndWFnZSB8fCAnZW4nO1xuXG5cdHZhciBlcnJvck1lc3NhZ2VzID0gbGFuZ3VhZ2VzW2xhbmd1YWdlXTtcblxuXHRyZXR1cm4gZnVuY3Rpb24gKGVycm9yKSB7XG5cdFx0dmFyIG1lc3NhZ2VUZW1wbGF0ZSA9IGVycm9yTWVzc2FnZXNbZXJyb3IuY29kZV0gfHwgRXJyb3JNZXNzYWdlc0RlZmF1bHRbZXJyb3IuY29kZV07XG5cdFx0aWYgKHR5cGVvZiBtZXNzYWdlVGVtcGxhdGUgIT09ICdzdHJpbmcnKSB7XG5cdFx0XHRyZXR1cm4gXCJVbmtub3duIGVycm9yIGNvZGUgXCIgKyBlcnJvci5jb2RlICsgXCI6IFwiICsgSlNPTi5zdHJpbmdpZnkoZXJyb3IubWVzc2FnZVBhcmFtcyk7XG5cdFx0fVxuXHRcdHZhciBtZXNzYWdlUGFyYW1zID0gZXJyb3IucGFyYW1zO1xuXHRcdC8vIEFkYXB0ZWQgZnJvbSBDcm9ja2ZvcmQncyBzdXBwbGFudCgpXG5cdFx0cmV0dXJuIG1lc3NhZ2VUZW1wbGF0ZS5yZXBsYWNlKC9cXHsoW157fV0qKVxcfS9nLCBmdW5jdGlvbiAod2hvbGUsIHZhck5hbWUpIHtcblx0XHRcdHZhciBzdWJWYWx1ZSA9IG1lc3NhZ2VQYXJhbXNbdmFyTmFtZV07XG5cdFx0XHRyZXR1cm4gdHlwZW9mIHN1YlZhbHVlID09PSAnc3RyaW5nJyB8fCB0eXBlb2Ygc3ViVmFsdWUgPT09ICdudW1iZXInID8gc3ViVmFsdWUgOiB3aG9sZTtcblx0XHR9KTtcblx0fTtcbn1cblxudmFyIEVycm9yQ29kZXMgPSB7XG5cdElOVkFMSURfVFlQRTogMCxcblx0RU5VTV9NSVNNQVRDSDogMSxcblx0QU5ZX09GX01JU1NJTkc6IDEwLFxuXHRPTkVfT0ZfTUlTU0lORzogMTEsXG5cdE9ORV9PRl9NVUxUSVBMRTogMTIsXG5cdE5PVF9QQVNTRUQ6IDEzLFxuXHQvLyBOdW1lcmljIGVycm9yc1xuXHROVU1CRVJfTVVMVElQTEVfT0Y6IDEwMCxcblx0TlVNQkVSX01JTklNVU06IDEwMSxcblx0TlVNQkVSX01JTklNVU1fRVhDTFVTSVZFOiAxMDIsXG5cdE5VTUJFUl9NQVhJTVVNOiAxMDMsXG5cdE5VTUJFUl9NQVhJTVVNX0VYQ0xVU0lWRTogMTA0LFxuXHROVU1CRVJfTk9UX0FfTlVNQkVSOiAxMDUsXG5cdC8vIFN0cmluZyBlcnJvcnNcblx0U1RSSU5HX0xFTkdUSF9TSE9SVDogMjAwLFxuXHRTVFJJTkdfTEVOR1RIX0xPTkc6IDIwMSxcblx0U1RSSU5HX1BBVFRFUk46IDIwMixcblx0Ly8gT2JqZWN0IGVycm9yc1xuXHRPQkpFQ1RfUFJPUEVSVElFU19NSU5JTVVNOiAzMDAsXG5cdE9CSkVDVF9QUk9QRVJUSUVTX01BWElNVU06IDMwMSxcblx0T0JKRUNUX1JFUVVJUkVEOiAzMDIsXG5cdE9CSkVDVF9BRERJVElPTkFMX1BST1BFUlRJRVM6IDMwMyxcblx0T0JKRUNUX0RFUEVOREVOQ1lfS0VZOiAzMDQsXG5cdC8vIEFycmF5IGVycm9yc1xuXHRBUlJBWV9MRU5HVEhfU0hPUlQ6IDQwMCxcblx0QVJSQVlfTEVOR1RIX0xPTkc6IDQwMSxcblx0QVJSQVlfVU5JUVVFOiA0MDIsXG5cdEFSUkFZX0FERElUSU9OQUxfSVRFTVM6IDQwMyxcblx0Ly8gQ3VzdG9tL3VzZXItZGVmaW5lZCBlcnJvcnNcblx0Rk9STUFUX0NVU1RPTTogNTAwLFxuXHRLRVlXT1JEX0NVU1RPTTogNTAxLFxuXHQvLyBTY2hlbWEgc3RydWN0dXJlXG5cdENJUkNVTEFSX1JFRkVSRU5DRTogNjAwLFxuXHQvLyBOb24tc3RhbmRhcmQgdmFsaWRhdGlvbiBvcHRpb25zXG5cdFVOS05PV05fUFJPUEVSVFk6IDEwMDBcbn07XG52YXIgRXJyb3JDb2RlTG9va3VwID0ge307XG5mb3IgKHZhciBrZXkgaW4gRXJyb3JDb2Rlcykge1xuXHRFcnJvckNvZGVMb29rdXBbRXJyb3JDb2Rlc1trZXldXSA9IGtleTtcbn1cbnZhciBFcnJvck1lc3NhZ2VzRGVmYXVsdCA9IHtcblx0SU5WQUxJRF9UWVBFOiBcIkludmFsaWQgdHlwZToge3R5cGV9IChleHBlY3RlZCB7ZXhwZWN0ZWR9KVwiLFxuXHRFTlVNX01JU01BVENIOiBcIk5vIGVudW0gbWF0Y2ggZm9yOiB7dmFsdWV9XCIsXG5cdEFOWV9PRl9NSVNTSU5HOiBcIkRhdGEgZG9lcyBub3QgbWF0Y2ggYW55IHNjaGVtYXMgZnJvbSBcXFwiYW55T2ZcXFwiXCIsXG5cdE9ORV9PRl9NSVNTSU5HOiBcIkRhdGEgZG9lcyBub3QgbWF0Y2ggYW55IHNjaGVtYXMgZnJvbSBcXFwib25lT2ZcXFwiXCIsXG5cdE9ORV9PRl9NVUxUSVBMRTogXCJEYXRhIGlzIHZhbGlkIGFnYWluc3QgbW9yZSB0aGFuIG9uZSBzY2hlbWEgZnJvbSBcXFwib25lT2ZcXFwiOiBpbmRpY2VzIHtpbmRleDF9IGFuZCB7aW5kZXgyfVwiLFxuXHROT1RfUEFTU0VEOiBcIkRhdGEgbWF0Y2hlcyBzY2hlbWEgZnJvbSBcXFwibm90XFxcIlwiLFxuXHQvLyBOdW1lcmljIGVycm9yc1xuXHROVU1CRVJfTVVMVElQTEVfT0Y6IFwiVmFsdWUge3ZhbHVlfSBpcyBub3QgYSBtdWx0aXBsZSBvZiB7bXVsdGlwbGVPZn1cIixcblx0TlVNQkVSX01JTklNVU06IFwiVmFsdWUge3ZhbHVlfSBpcyBsZXNzIHRoYW4gbWluaW11bSB7bWluaW11bX1cIixcblx0TlVNQkVSX01JTklNVU1fRVhDTFVTSVZFOiBcIlZhbHVlIHt2YWx1ZX0gaXMgZXF1YWwgdG8gZXhjbHVzaXZlIG1pbmltdW0ge21pbmltdW19XCIsXG5cdE5VTUJFUl9NQVhJTVVNOiBcIlZhbHVlIHt2YWx1ZX0gaXMgZ3JlYXRlciB0aGFuIG1heGltdW0ge21heGltdW19XCIsXG5cdE5VTUJFUl9NQVhJTVVNX0VYQ0xVU0lWRTogXCJWYWx1ZSB7dmFsdWV9IGlzIGVxdWFsIHRvIGV4Y2x1c2l2ZSBtYXhpbXVtIHttYXhpbXVtfVwiLFxuXHROVU1CRVJfTk9UX0FfTlVNQkVSOiBcIlZhbHVlIHt2YWx1ZX0gaXMgbm90IGEgdmFsaWQgbnVtYmVyXCIsXG5cdC8vIFN0cmluZyBlcnJvcnNcblx0U1RSSU5HX0xFTkdUSF9TSE9SVDogXCJTdHJpbmcgaXMgdG9vIHNob3J0ICh7bGVuZ3RofSBjaGFycyksIG1pbmltdW0ge21pbmltdW19XCIsXG5cdFNUUklOR19MRU5HVEhfTE9ORzogXCJTdHJpbmcgaXMgdG9vIGxvbmcgKHtsZW5ndGh9IGNoYXJzKSwgbWF4aW11bSB7bWF4aW11bX1cIixcblx0U1RSSU5HX1BBVFRFUk46IFwiU3RyaW5nIGRvZXMgbm90IG1hdGNoIHBhdHRlcm46IHtwYXR0ZXJufVwiLFxuXHQvLyBPYmplY3QgZXJyb3JzXG5cdE9CSkVDVF9QUk9QRVJUSUVTX01JTklNVU06IFwiVG9vIGZldyBwcm9wZXJ0aWVzIGRlZmluZWQgKHtwcm9wZXJ0eUNvdW50fSksIG1pbmltdW0ge21pbmltdW19XCIsXG5cdE9CSkVDVF9QUk9QRVJUSUVTX01BWElNVU06IFwiVG9vIG1hbnkgcHJvcGVydGllcyBkZWZpbmVkICh7cHJvcGVydHlDb3VudH0pLCBtYXhpbXVtIHttYXhpbXVtfVwiLFxuXHRPQkpFQ1RfUkVRVUlSRUQ6IFwiTWlzc2luZyByZXF1aXJlZCBwcm9wZXJ0eToge2tleX1cIixcblx0T0JKRUNUX0FERElUSU9OQUxfUFJPUEVSVElFUzogXCJBZGRpdGlvbmFsIHByb3BlcnRpZXMgbm90IGFsbG93ZWRcIixcblx0T0JKRUNUX0RFUEVOREVOQ1lfS0VZOiBcIkRlcGVuZGVuY3kgZmFpbGVkIC0ga2V5IG11c3QgZXhpc3Q6IHttaXNzaW5nfSAoZHVlIHRvIGtleToge2tleX0pXCIsXG5cdC8vIEFycmF5IGVycm9yc1xuXHRBUlJBWV9MRU5HVEhfU0hPUlQ6IFwiQXJyYXkgaXMgdG9vIHNob3J0ICh7bGVuZ3RofSksIG1pbmltdW0ge21pbmltdW19XCIsXG5cdEFSUkFZX0xFTkdUSF9MT05HOiBcIkFycmF5IGlzIHRvbyBsb25nICh7bGVuZ3RofSksIG1heGltdW0ge21heGltdW19XCIsXG5cdEFSUkFZX1VOSVFVRTogXCJBcnJheSBpdGVtcyBhcmUgbm90IHVuaXF1ZSAoaW5kaWNlcyB7bWF0Y2gxfSBhbmQge21hdGNoMn0pXCIsXG5cdEFSUkFZX0FERElUSU9OQUxfSVRFTVM6IFwiQWRkaXRpb25hbCBpdGVtcyBub3QgYWxsb3dlZFwiLFxuXHQvLyBGb3JtYXQgZXJyb3JzXG5cdEZPUk1BVF9DVVNUT006IFwiRm9ybWF0IHZhbGlkYXRpb24gZmFpbGVkICh7bWVzc2FnZX0pXCIsXG5cdEtFWVdPUkRfQ1VTVE9NOiBcIktleXdvcmQgZmFpbGVkOiB7a2V5fSAoe21lc3NhZ2V9KVwiLFxuXHQvLyBTY2hlbWEgc3RydWN0dXJlXG5cdENJUkNVTEFSX1JFRkVSRU5DRTogXCJDaXJjdWxhciAkcmVmczoge3VybHN9XCIsXG5cdC8vIE5vbi1zdGFuZGFyZCB2YWxpZGF0aW9uIG9wdGlvbnNcblx0VU5LTk9XTl9QUk9QRVJUWTogXCJVbmtub3duIHByb3BlcnR5IChub3QgaW4gc2NoZW1hKVwiXG59O1xuXG5mdW5jdGlvbiBWYWxpZGF0aW9uRXJyb3IoY29kZSwgcGFyYW1zLCBkYXRhUGF0aCwgc2NoZW1hUGF0aCwgc3ViRXJyb3JzKSB7XG5cdEVycm9yLmNhbGwodGhpcyk7XG5cdGlmIChjb2RlID09PSB1bmRlZmluZWQpIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IgKFwiTm8gZXJyb3IgY29kZSBzdXBwbGllZDogXCIgKyBzY2hlbWFQYXRoKTtcblx0fVxuXHR0aGlzLm1lc3NhZ2UgPSAnJztcblx0dGhpcy5wYXJhbXMgPSBwYXJhbXM7XG5cdHRoaXMuY29kZSA9IGNvZGU7XG5cdHRoaXMuZGF0YVBhdGggPSBkYXRhUGF0aCB8fCBcIlwiO1xuXHR0aGlzLnNjaGVtYVBhdGggPSBzY2hlbWFQYXRoIHx8IFwiXCI7XG5cdHRoaXMuc3ViRXJyb3JzID0gc3ViRXJyb3JzIHx8IG51bGw7XG5cblx0dmFyIGVyciA9IG5ldyBFcnJvcih0aGlzLm1lc3NhZ2UpO1xuXHR0aGlzLnN0YWNrID0gZXJyLnN0YWNrIHx8IGVyci5zdGFja3RyYWNlO1xuXHRpZiAoIXRoaXMuc3RhY2spIHtcblx0XHR0cnkge1xuXHRcdFx0dGhyb3cgZXJyO1xuXHRcdH1cblx0XHRjYXRjaChlcnIpIHtcblx0XHRcdHRoaXMuc3RhY2sgPSBlcnIuc3RhY2sgfHwgZXJyLnN0YWNrdHJhY2U7XG5cdFx0fVxuXHR9XG59XG5WYWxpZGF0aW9uRXJyb3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShFcnJvci5wcm90b3R5cGUpO1xuVmFsaWRhdGlvbkVycm9yLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFZhbGlkYXRpb25FcnJvcjtcblZhbGlkYXRpb25FcnJvci5wcm90b3R5cGUubmFtZSA9ICdWYWxpZGF0aW9uRXJyb3InO1xuXG5WYWxpZGF0aW9uRXJyb3IucHJvdG90eXBlLnByZWZpeFdpdGggPSBmdW5jdGlvbiAoZGF0YVByZWZpeCwgc2NoZW1hUHJlZml4KSB7XG5cdGlmIChkYXRhUHJlZml4ICE9PSBudWxsKSB7XG5cdFx0ZGF0YVByZWZpeCA9IGRhdGFQcmVmaXgucmVwbGFjZSgvfi9nLCBcIn4wXCIpLnJlcGxhY2UoL1xcLy9nLCBcIn4xXCIpO1xuXHRcdHRoaXMuZGF0YVBhdGggPSBcIi9cIiArIGRhdGFQcmVmaXggKyB0aGlzLmRhdGFQYXRoO1xuXHR9XG5cdGlmIChzY2hlbWFQcmVmaXggIT09IG51bGwpIHtcblx0XHRzY2hlbWFQcmVmaXggPSBzY2hlbWFQcmVmaXgucmVwbGFjZSgvfi9nLCBcIn4wXCIpLnJlcGxhY2UoL1xcLy9nLCBcIn4xXCIpO1xuXHRcdHRoaXMuc2NoZW1hUGF0aCA9IFwiL1wiICsgc2NoZW1hUHJlZml4ICsgdGhpcy5zY2hlbWFQYXRoO1xuXHR9XG5cdGlmICh0aGlzLnN1YkVycm9ycyAhPT0gbnVsbCkge1xuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5zdWJFcnJvcnMubGVuZ3RoOyBpKyspIHtcblx0XHRcdHRoaXMuc3ViRXJyb3JzW2ldLnByZWZpeFdpdGgoZGF0YVByZWZpeCwgc2NoZW1hUHJlZml4KTtcblx0XHR9XG5cdH1cblx0cmV0dXJuIHRoaXM7XG59O1xuXG5mdW5jdGlvbiBpc1RydXN0ZWRVcmwoYmFzZVVybCwgdGVzdFVybCkge1xuXHRpZih0ZXN0VXJsLnN1YnN0cmluZygwLCBiYXNlVXJsLmxlbmd0aCkgPT09IGJhc2VVcmwpe1xuXHRcdHZhciByZW1haW5kZXIgPSB0ZXN0VXJsLnN1YnN0cmluZyhiYXNlVXJsLmxlbmd0aCk7XG5cdFx0aWYgKCh0ZXN0VXJsLmxlbmd0aCA+IDAgJiYgdGVzdFVybC5jaGFyQXQoYmFzZVVybC5sZW5ndGggLSAxKSA9PT0gXCIvXCIpXG5cdFx0XHR8fCByZW1haW5kZXIuY2hhckF0KDApID09PSBcIiNcIlxuXHRcdFx0fHwgcmVtYWluZGVyLmNoYXJBdCgwKSA9PT0gXCI/XCIpIHtcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblx0fVxuXHRyZXR1cm4gZmFsc2U7XG59XG5cbnZhciBsYW5ndWFnZXMgPSB7fTtcbmZ1bmN0aW9uIGNyZWF0ZUFwaShsYW5ndWFnZSkge1xuXHR2YXIgZ2xvYmFsQ29udGV4dCA9IG5ldyBWYWxpZGF0b3JDb250ZXh0KCk7XG5cdHZhciBjdXJyZW50TGFuZ3VhZ2U7XG5cdHZhciBjdXN0b21FcnJvclJlcG9ydGVyO1xuXHR2YXIgYXBpID0ge1xuXHRcdHNldEVycm9yUmVwb3J0ZXI6IGZ1bmN0aW9uIChyZXBvcnRlcikge1xuXHRcdFx0aWYgKHR5cGVvZiByZXBvcnRlciA9PT0gJ3N0cmluZycpIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMubGFuZ3VhZ2UocmVwb3J0ZXIpO1xuXHRcdFx0fVxuXHRcdFx0Y3VzdG9tRXJyb3JSZXBvcnRlciA9IHJlcG9ydGVyO1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fSxcblx0XHRhZGRGb3JtYXQ6IGZ1bmN0aW9uICgpIHtcblx0XHRcdGdsb2JhbENvbnRleHQuYWRkRm9ybWF0LmFwcGx5KGdsb2JhbENvbnRleHQsIGFyZ3VtZW50cyk7XG5cdFx0fSxcblx0XHRsYW5ndWFnZTogZnVuY3Rpb24gKGNvZGUpIHtcblx0XHRcdGlmICghY29kZSkge1xuXHRcdFx0XHRyZXR1cm4gY3VycmVudExhbmd1YWdlO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCFsYW5ndWFnZXNbY29kZV0pIHtcblx0XHRcdFx0Y29kZSA9IGNvZGUuc3BsaXQoJy0nKVswXTsgLy8gZmFsbCBiYWNrIHRvIGJhc2UgbGFuZ3VhZ2Vcblx0XHRcdH1cblx0XHRcdGlmIChsYW5ndWFnZXNbY29kZV0pIHtcblx0XHRcdFx0Y3VycmVudExhbmd1YWdlID0gY29kZTtcblx0XHRcdFx0cmV0dXJuIGNvZGU7IC8vIHNvIHlvdSBjYW4gdGVsbCBpZiBmYWxsLWJhY2sgaGFzIGhhcHBlbmVkXG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fSxcblx0XHRhZGRMYW5ndWFnZTogZnVuY3Rpb24gKGNvZGUsIG1lc3NhZ2VNYXApIHtcblx0XHRcdHZhciBrZXk7XG5cdFx0XHRmb3IgKGtleSBpbiBFcnJvckNvZGVzKSB7XG5cdFx0XHRcdGlmIChtZXNzYWdlTWFwW2tleV0gJiYgIW1lc3NhZ2VNYXBbRXJyb3JDb2Rlc1trZXldXSkge1xuXHRcdFx0XHRcdG1lc3NhZ2VNYXBbRXJyb3JDb2Rlc1trZXldXSA9IG1lc3NhZ2VNYXBba2V5XTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0dmFyIHJvb3RDb2RlID0gY29kZS5zcGxpdCgnLScpWzBdO1xuXHRcdFx0aWYgKCFsYW5ndWFnZXNbcm9vdENvZGVdKSB7IC8vIHVzZSBmb3IgYmFzZSBsYW5ndWFnZSBpZiBub3QgeWV0IGRlZmluZWRcblx0XHRcdFx0bGFuZ3VhZ2VzW2NvZGVdID0gbWVzc2FnZU1hcDtcblx0XHRcdFx0bGFuZ3VhZ2VzW3Jvb3RDb2RlXSA9IG1lc3NhZ2VNYXA7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRsYW5ndWFnZXNbY29kZV0gPSBPYmplY3QuY3JlYXRlKGxhbmd1YWdlc1tyb290Q29kZV0pO1xuXHRcdFx0XHRmb3IgKGtleSBpbiBtZXNzYWdlTWFwKSB7XG5cdFx0XHRcdFx0aWYgKHR5cGVvZiBsYW5ndWFnZXNbcm9vdENvZGVdW2tleV0gPT09ICd1bmRlZmluZWQnKSB7XG5cdFx0XHRcdFx0XHRsYW5ndWFnZXNbcm9vdENvZGVdW2tleV0gPSBtZXNzYWdlTWFwW2tleV07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGxhbmd1YWdlc1tjb2RlXVtrZXldID0gbWVzc2FnZU1hcFtrZXldO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9LFxuXHRcdGZyZXNoQXBpOiBmdW5jdGlvbiAobGFuZ3VhZ2UpIHtcblx0XHRcdHZhciByZXN1bHQgPSBjcmVhdGVBcGkoKTtcblx0XHRcdGlmIChsYW5ndWFnZSkge1xuXHRcdFx0XHRyZXN1bHQubGFuZ3VhZ2UobGFuZ3VhZ2UpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHJlc3VsdDtcblx0XHR9LFxuXHRcdHZhbGlkYXRlOiBmdW5jdGlvbiAoZGF0YSwgc2NoZW1hLCBjaGVja1JlY3Vyc2l2ZSwgYmFuVW5rbm93blByb3BlcnRpZXMpIHtcblx0XHRcdHZhciBkZWYgPSBkZWZhdWx0RXJyb3JSZXBvcnRlcihjdXJyZW50TGFuZ3VhZ2UpO1xuXHRcdFx0dmFyIGVycm9yUmVwb3J0ZXIgPSBjdXN0b21FcnJvclJlcG9ydGVyID8gZnVuY3Rpb24gKGVycm9yLCBkYXRhLCBzY2hlbWEpIHtcblx0XHRcdFx0cmV0dXJuIGN1c3RvbUVycm9yUmVwb3J0ZXIoZXJyb3IsIGRhdGEsIHNjaGVtYSkgfHwgZGVmKGVycm9yLCBkYXRhLCBzY2hlbWEpO1xuXHRcdFx0fSA6IGRlZjtcblx0XHRcdHZhciBjb250ZXh0ID0gbmV3IFZhbGlkYXRvckNvbnRleHQoZ2xvYmFsQ29udGV4dCwgZmFsc2UsIGVycm9yUmVwb3J0ZXIsIGNoZWNrUmVjdXJzaXZlLCBiYW5Vbmtub3duUHJvcGVydGllcyk7XG5cdFx0XHRpZiAodHlwZW9mIHNjaGVtYSA9PT0gXCJzdHJpbmdcIikge1xuXHRcdFx0XHRzY2hlbWEgPSB7XCIkcmVmXCI6IHNjaGVtYX07XG5cdFx0XHR9XG5cdFx0XHRjb250ZXh0LmFkZFNjaGVtYShcIlwiLCBzY2hlbWEpO1xuXHRcdFx0dmFyIGVycm9yID0gY29udGV4dC52YWxpZGF0ZUFsbChkYXRhLCBzY2hlbWEsIG51bGwsIG51bGwsIFwiXCIpO1xuXHRcdFx0aWYgKCFlcnJvciAmJiBiYW5Vbmtub3duUHJvcGVydGllcykge1xuXHRcdFx0XHRlcnJvciA9IGNvbnRleHQuYmFuVW5rbm93blByb3BlcnRpZXMoZGF0YSwgc2NoZW1hKTtcblx0XHRcdH1cblx0XHRcdHRoaXMuZXJyb3IgPSBlcnJvcjtcblx0XHRcdHRoaXMubWlzc2luZyA9IGNvbnRleHQubWlzc2luZztcblx0XHRcdHRoaXMudmFsaWQgPSAoZXJyb3IgPT09IG51bGwpO1xuXHRcdFx0cmV0dXJuIHRoaXMudmFsaWQ7XG5cdFx0fSxcblx0XHR2YWxpZGF0ZVJlc3VsdDogZnVuY3Rpb24gKCkge1xuXHRcdFx0dmFyIHJlc3VsdCA9IHt9O1xuXHRcdFx0dGhpcy52YWxpZGF0ZS5hcHBseShyZXN1bHQsIGFyZ3VtZW50cyk7XG5cdFx0XHRyZXR1cm4gcmVzdWx0O1xuXHRcdH0sXG5cdFx0dmFsaWRhdGVNdWx0aXBsZTogZnVuY3Rpb24gKGRhdGEsIHNjaGVtYSwgY2hlY2tSZWN1cnNpdmUsIGJhblVua25vd25Qcm9wZXJ0aWVzKSB7XG5cdFx0XHR2YXIgZGVmID0gZGVmYXVsdEVycm9yUmVwb3J0ZXIoY3VycmVudExhbmd1YWdlKTtcblx0XHRcdHZhciBlcnJvclJlcG9ydGVyID0gY3VzdG9tRXJyb3JSZXBvcnRlciA/IGZ1bmN0aW9uIChlcnJvciwgZGF0YSwgc2NoZW1hKSB7XG5cdFx0XHRcdHJldHVybiBjdXN0b21FcnJvclJlcG9ydGVyKGVycm9yLCBkYXRhLCBzY2hlbWEpIHx8IGRlZihlcnJvciwgZGF0YSwgc2NoZW1hKTtcblx0XHRcdH0gOiBkZWY7XG5cdFx0XHR2YXIgY29udGV4dCA9IG5ldyBWYWxpZGF0b3JDb250ZXh0KGdsb2JhbENvbnRleHQsIHRydWUsIGVycm9yUmVwb3J0ZXIsIGNoZWNrUmVjdXJzaXZlLCBiYW5Vbmtub3duUHJvcGVydGllcyk7XG5cdFx0XHRpZiAodHlwZW9mIHNjaGVtYSA9PT0gXCJzdHJpbmdcIikge1xuXHRcdFx0XHRzY2hlbWEgPSB7XCIkcmVmXCI6IHNjaGVtYX07XG5cdFx0XHR9XG5cdFx0XHRjb250ZXh0LmFkZFNjaGVtYShcIlwiLCBzY2hlbWEpO1xuXHRcdFx0Y29udGV4dC52YWxpZGF0ZUFsbChkYXRhLCBzY2hlbWEsIG51bGwsIG51bGwsIFwiXCIpO1xuXHRcdFx0aWYgKGJhblVua25vd25Qcm9wZXJ0aWVzKSB7XG5cdFx0XHRcdGNvbnRleHQuYmFuVW5rbm93blByb3BlcnRpZXMoZGF0YSwgc2NoZW1hKTtcblx0XHRcdH1cblx0XHRcdHZhciByZXN1bHQgPSB7fTtcblx0XHRcdHJlc3VsdC5lcnJvcnMgPSBjb250ZXh0LmVycm9ycztcblx0XHRcdHJlc3VsdC5taXNzaW5nID0gY29udGV4dC5taXNzaW5nO1xuXHRcdFx0cmVzdWx0LnZhbGlkID0gKHJlc3VsdC5lcnJvcnMubGVuZ3RoID09PSAwKTtcblx0XHRcdHJldHVybiByZXN1bHQ7XG5cdFx0fSxcblx0XHRhZGRTY2hlbWE6IGZ1bmN0aW9uICgpIHtcblx0XHRcdHJldHVybiBnbG9iYWxDb250ZXh0LmFkZFNjaGVtYS5hcHBseShnbG9iYWxDb250ZXh0LCBhcmd1bWVudHMpO1xuXHRcdH0sXG5cdFx0Z2V0U2NoZW1hOiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRyZXR1cm4gZ2xvYmFsQ29udGV4dC5nZXRTY2hlbWEuYXBwbHkoZ2xvYmFsQ29udGV4dCwgYXJndW1lbnRzKTtcblx0XHR9LFxuXHRcdGdldFNjaGVtYU1hcDogZnVuY3Rpb24gKCkge1xuXHRcdFx0cmV0dXJuIGdsb2JhbENvbnRleHQuZ2V0U2NoZW1hTWFwLmFwcGx5KGdsb2JhbENvbnRleHQsIGFyZ3VtZW50cyk7XG5cdFx0fSxcblx0XHRnZXRTY2hlbWFVcmlzOiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRyZXR1cm4gZ2xvYmFsQ29udGV4dC5nZXRTY2hlbWFVcmlzLmFwcGx5KGdsb2JhbENvbnRleHQsIGFyZ3VtZW50cyk7XG5cdFx0fSxcblx0XHRnZXRNaXNzaW5nVXJpczogZnVuY3Rpb24gKCkge1xuXHRcdFx0cmV0dXJuIGdsb2JhbENvbnRleHQuZ2V0TWlzc2luZ1VyaXMuYXBwbHkoZ2xvYmFsQ29udGV4dCwgYXJndW1lbnRzKTtcblx0XHR9LFxuXHRcdGRyb3BTY2hlbWFzOiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRnbG9iYWxDb250ZXh0LmRyb3BTY2hlbWFzLmFwcGx5KGdsb2JhbENvbnRleHQsIGFyZ3VtZW50cyk7XG5cdFx0fSxcblx0XHRkZWZpbmVLZXl3b3JkOiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRnbG9iYWxDb250ZXh0LmRlZmluZUtleXdvcmQuYXBwbHkoZ2xvYmFsQ29udGV4dCwgYXJndW1lbnRzKTtcblx0XHR9LFxuXHRcdGRlZmluZUVycm9yOiBmdW5jdGlvbiAoY29kZU5hbWUsIGNvZGVOdW1iZXIsIGRlZmF1bHRNZXNzYWdlKSB7XG5cdFx0XHRpZiAodHlwZW9mIGNvZGVOYW1lICE9PSAnc3RyaW5nJyB8fCAhL15bQS1aXSsoX1tBLVpdKykqJC8udGVzdChjb2RlTmFtZSkpIHtcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCdDb2RlIG5hbWUgbXVzdCBiZSBhIHN0cmluZyBpbiBVUFBFUl9DQVNFX1dJVEhfVU5ERVJTQ09SRVMnKTtcblx0XHRcdH1cblx0XHRcdGlmICh0eXBlb2YgY29kZU51bWJlciAhPT0gJ251bWJlcicgfHwgY29kZU51bWJlciUxICE9PSAwIHx8IGNvZGVOdW1iZXIgPCAxMDAwMCkge1xuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ0NvZGUgbnVtYmVyIG11c3QgYmUgYW4gaW50ZWdlciA+IDEwMDAwJyk7XG5cdFx0XHR9XG5cdFx0XHRpZiAodHlwZW9mIEVycm9yQ29kZXNbY29kZU5hbWVdICE9PSAndW5kZWZpbmVkJykge1xuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ0Vycm9yIGFscmVhZHkgZGVmaW5lZDogJyArIGNvZGVOYW1lICsgJyBhcyAnICsgRXJyb3JDb2Rlc1tjb2RlTmFtZV0pO1xuXHRcdFx0fVxuXHRcdFx0aWYgKHR5cGVvZiBFcnJvckNvZGVMb29rdXBbY29kZU51bWJlcl0gIT09ICd1bmRlZmluZWQnKSB7XG5cdFx0XHRcdHRocm93IG5ldyBFcnJvcignRXJyb3IgY29kZSBhbHJlYWR5IHVzZWQ6ICcgKyBFcnJvckNvZGVMb29rdXBbY29kZU51bWJlcl0gKyAnIGFzICcgKyBjb2RlTnVtYmVyKTtcblx0XHRcdH1cblx0XHRcdEVycm9yQ29kZXNbY29kZU5hbWVdID0gY29kZU51bWJlcjtcblx0XHRcdEVycm9yQ29kZUxvb2t1cFtjb2RlTnVtYmVyXSA9IGNvZGVOYW1lO1xuXHRcdFx0RXJyb3JNZXNzYWdlc0RlZmF1bHRbY29kZU5hbWVdID0gRXJyb3JNZXNzYWdlc0RlZmF1bHRbY29kZU51bWJlcl0gPSBkZWZhdWx0TWVzc2FnZTtcblx0XHRcdGZvciAodmFyIGxhbmdDb2RlIGluIGxhbmd1YWdlcykge1xuXHRcdFx0XHR2YXIgbGFuZ3VhZ2UgPSBsYW5ndWFnZXNbbGFuZ0NvZGVdO1xuXHRcdFx0XHRpZiAobGFuZ3VhZ2VbY29kZU5hbWVdKSB7XG5cdFx0XHRcdFx0bGFuZ3VhZ2VbY29kZU51bWJlcl0gPSBsYW5ndWFnZVtjb2RlTnVtYmVyXSB8fCBsYW5ndWFnZVtjb2RlTmFtZV07XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9LFxuXHRcdHJlc2V0OiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRnbG9iYWxDb250ZXh0LnJlc2V0KCk7XG5cdFx0XHR0aGlzLmVycm9yID0gbnVsbDtcblx0XHRcdHRoaXMubWlzc2luZyA9IFtdO1xuXHRcdFx0dGhpcy52YWxpZCA9IHRydWU7XG5cdFx0fSxcblx0XHRtaXNzaW5nOiBbXSxcblx0XHRlcnJvcjogbnVsbCxcblx0XHR2YWxpZDogdHJ1ZSxcblx0XHRub3JtU2NoZW1hOiBub3JtU2NoZW1hLFxuXHRcdHJlc29sdmVVcmw6IHJlc29sdmVVcmwsXG5cdFx0Z2V0RG9jdW1lbnRVcmk6IGdldERvY3VtZW50VXJpLFxuXHRcdGVycm9yQ29kZXM6IEVycm9yQ29kZXNcblx0fTtcblx0YXBpLmxhbmd1YWdlKGxhbmd1YWdlIHx8ICdlbicpO1xuXHRyZXR1cm4gYXBpO1xufVxuXG52YXIgdHY0ID0gY3JlYXRlQXBpKCk7XG50djQuYWRkTGFuZ3VhZ2UoJ2VuLWdiJywgRXJyb3JNZXNzYWdlc0RlZmF1bHQpO1xuXG4vL2xlZ2FjeSBwcm9wZXJ0eVxudHY0LnR2NCA9IHR2NDtcblxucmV0dXJuIHR2NDsgLy8gdXNlZCBieSBfaGVhZGVyLmpzIHRvIGdsb2JhbGlzZS5cblxufSkpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi90djQvdHY0LmpzXG4vLyBtb2R1bGUgaWQgPSAyOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9');
},function(module,exports){eval("/**\n * Convert array of 16 byte values to UUID string format of the form:\n * XXXXXXXX-XXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX\n */\nvar byteToHex = [];\nfor (var i = 0; i < 256; ++i) {\n  byteToHex[i] = (i + 0x100).toString(16).substr(1);\n}\n\nfunction bytesToUuid(buf, offset) {\n  var i = offset || 0;\n  var bth = byteToHex;\n  return  bth[buf[i++]] + bth[buf[i++]] +\n          bth[buf[i++]] + bth[buf[i++]] + '-' +\n          bth[buf[i++]] + bth[buf[i++]] + '-' +\n          bth[buf[i++]] + bth[buf[i++]] + '-' +\n          bth[buf[i++]] + bth[buf[i++]] + '-' +\n          bth[buf[i++]] + bth[buf[i++]] +\n          bth[buf[i++]] + bth[buf[i++]] +\n          bth[buf[i++]] + bth[buf[i++]];\n}\n\nmodule.exports = bytesToUuid;\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3V1aWQvbGliL2J5dGVzVG9VdWlkLmpzPzMwNjgiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsU0FBUztBQUN4QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsImZpbGUiOiIyOS5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ29udmVydCBhcnJheSBvZiAxNiBieXRlIHZhbHVlcyB0byBVVUlEIHN0cmluZyBmb3JtYXQgb2YgdGhlIGZvcm06XG4gKiBYWFhYWFhYWC1YWFhYLVhYWFgtWFhYWC1YWFhYLVhYWFhYWFhYWFhYWFxuICovXG52YXIgYnl0ZVRvSGV4ID0gW107XG5mb3IgKHZhciBpID0gMDsgaSA8IDI1NjsgKytpKSB7XG4gIGJ5dGVUb0hleFtpXSA9IChpICsgMHgxMDApLnRvU3RyaW5nKDE2KS5zdWJzdHIoMSk7XG59XG5cbmZ1bmN0aW9uIGJ5dGVzVG9VdWlkKGJ1Ziwgb2Zmc2V0KSB7XG4gIHZhciBpID0gb2Zmc2V0IHx8IDA7XG4gIHZhciBidGggPSBieXRlVG9IZXg7XG4gIHJldHVybiAgYnRoW2J1ZltpKytdXSArIGJ0aFtidWZbaSsrXV0gK1xuICAgICAgICAgIGJ0aFtidWZbaSsrXV0gKyBidGhbYnVmW2krK11dICsgJy0nICtcbiAgICAgICAgICBidGhbYnVmW2krK11dICsgYnRoW2J1ZltpKytdXSArICctJyArXG4gICAgICAgICAgYnRoW2J1ZltpKytdXSArIGJ0aFtidWZbaSsrXV0gKyAnLScgK1xuICAgICAgICAgIGJ0aFtidWZbaSsrXV0gKyBidGhbYnVmW2krK11dICsgJy0nICtcbiAgICAgICAgICBidGhbYnVmW2krK11dICsgYnRoW2J1ZltpKytdXSArXG4gICAgICAgICAgYnRoW2J1ZltpKytdXSArIGJ0aFtidWZbaSsrXV0gK1xuICAgICAgICAgIGJ0aFtidWZbaSsrXV0gKyBidGhbYnVmW2krK11dO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJ5dGVzVG9VdWlkO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3V1aWQvbGliL2J5dGVzVG9VdWlkLmpzXG4vLyBtb2R1bGUgaWQgPSAyOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9")},function(module,exports){eval("/* WEBPACK VAR INJECTION */(function(global) {// Unique ID creation requires a high quality random # generator.  In the\n// browser this is a little complicated due to unknown quality of Math.random()\n// and inconsistent support for the `crypto` API.  We do the best we can via\n// feature-detection\nvar rng;\n\nvar crypto = global.crypto || global.msCrypto; // for IE 11\nif (crypto && crypto.getRandomValues) {\n  // WHATWG crypto RNG - http://wiki.whatwg.org/wiki/Crypto\n  var rnds8 = new Uint8Array(16);\n  rng = function whatwgRNG() {\n    crypto.getRandomValues(rnds8);\n    return rnds8;\n  };\n}\n\nif (!rng) {\n  // Math.random()-based (RNG)\n  //\n  // If all else fails, use Math.random().  It's fast, but is of unspecified\n  // quality.\n  var  rnds = new Array(16);\n  rng = function() {\n    for (var i = 0, r; i < 16; i++) {\n      if ((i & 0x03) === 0) r = Math.random() * 0x100000000;\n      rnds[i] = r >>> ((i & 0x03) << 3) & 0xff;\n    }\n\n    return rnds;\n  };\n}\n\nmodule.exports = rng;\n\n/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3V1aWQvbGliL3JuZy1icm93c2VyLmpzPzk0NWUiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw4Q0FBOEM7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixRQUFRO0FBQzlCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEiLCJmaWxlIjoiMzAuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBVbmlxdWUgSUQgY3JlYXRpb24gcmVxdWlyZXMgYSBoaWdoIHF1YWxpdHkgcmFuZG9tICMgZ2VuZXJhdG9yLiAgSW4gdGhlXG4vLyBicm93c2VyIHRoaXMgaXMgYSBsaXR0bGUgY29tcGxpY2F0ZWQgZHVlIHRvIHVua25vd24gcXVhbGl0eSBvZiBNYXRoLnJhbmRvbSgpXG4vLyBhbmQgaW5jb25zaXN0ZW50IHN1cHBvcnQgZm9yIHRoZSBgY3J5cHRvYCBBUEkuICBXZSBkbyB0aGUgYmVzdCB3ZSBjYW4gdmlhXG4vLyBmZWF0dXJlLWRldGVjdGlvblxudmFyIHJuZztcblxudmFyIGNyeXB0byA9IGdsb2JhbC5jcnlwdG8gfHwgZ2xvYmFsLm1zQ3J5cHRvOyAvLyBmb3IgSUUgMTFcbmlmIChjcnlwdG8gJiYgY3J5cHRvLmdldFJhbmRvbVZhbHVlcykge1xuICAvLyBXSEFUV0cgY3J5cHRvIFJORyAtIGh0dHA6Ly93aWtpLndoYXR3Zy5vcmcvd2lraS9DcnlwdG9cbiAgdmFyIHJuZHM4ID0gbmV3IFVpbnQ4QXJyYXkoMTYpO1xuICBybmcgPSBmdW5jdGlvbiB3aGF0d2dSTkcoKSB7XG4gICAgY3J5cHRvLmdldFJhbmRvbVZhbHVlcyhybmRzOCk7XG4gICAgcmV0dXJuIHJuZHM4O1xuICB9O1xufVxuXG5pZiAoIXJuZykge1xuICAvLyBNYXRoLnJhbmRvbSgpLWJhc2VkIChSTkcpXG4gIC8vXG4gIC8vIElmIGFsbCBlbHNlIGZhaWxzLCB1c2UgTWF0aC5yYW5kb20oKS4gIEl0J3MgZmFzdCwgYnV0IGlzIG9mIHVuc3BlY2lmaWVkXG4gIC8vIHF1YWxpdHkuXG4gIHZhciAgcm5kcyA9IG5ldyBBcnJheSgxNik7XG4gIHJuZyA9IGZ1bmN0aW9uKCkge1xuICAgIGZvciAodmFyIGkgPSAwLCByOyBpIDwgMTY7IGkrKykge1xuICAgICAgaWYgKChpICYgMHgwMykgPT09IDApIHIgPSBNYXRoLnJhbmRvbSgpICogMHgxMDAwMDAwMDA7XG4gICAgICBybmRzW2ldID0gciA+Pj4gKChpICYgMHgwMykgPDwgMykgJiAweGZmO1xuICAgIH1cblxuICAgIHJldHVybiBybmRzO1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHJuZztcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi91dWlkL2xpYi9ybmctYnJvd3Nlci5qc1xuLy8gbW9kdWxlIGlkID0gMzBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==")},function(module,exports,__webpack_require__){eval("var rng = __webpack_require__(30);\nvar bytesToUuid = __webpack_require__(29);\n\nfunction v4(options, buf, offset) {\n  var i = buf && offset || 0;\n\n  if (typeof(options) == 'string') {\n    buf = options == 'binary' ? new Array(16) : null;\n    options = null;\n  }\n  options = options || {};\n\n  var rnds = options.random || (options.rng || rng)();\n\n  // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`\n  rnds[6] = (rnds[6] & 0x0f) | 0x40;\n  rnds[8] = (rnds[8] & 0x3f) | 0x80;\n\n  // Copy bytes to buffer, if provided\n  if (buf) {\n    for (var ii = 0; ii < 16; ++ii) {\n      buf[i + ii] = rnds[ii];\n    }\n  }\n\n  return buf || bytesToUuid(rnds);\n}\n\nmodule.exports = v4;\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3V1aWQvdjQuanM/NDJlNyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBIiwiZmlsZSI6IjMxLmpzIiwic291cmNlc0NvbnRlbnQiOlsidmFyIHJuZyA9IHJlcXVpcmUoJy4vbGliL3JuZycpO1xudmFyIGJ5dGVzVG9VdWlkID0gcmVxdWlyZSgnLi9saWIvYnl0ZXNUb1V1aWQnKTtcblxuZnVuY3Rpb24gdjQob3B0aW9ucywgYnVmLCBvZmZzZXQpIHtcbiAgdmFyIGkgPSBidWYgJiYgb2Zmc2V0IHx8IDA7XG5cbiAgaWYgKHR5cGVvZihvcHRpb25zKSA9PSAnc3RyaW5nJykge1xuICAgIGJ1ZiA9IG9wdGlvbnMgPT0gJ2JpbmFyeScgPyBuZXcgQXJyYXkoMTYpIDogbnVsbDtcbiAgICBvcHRpb25zID0gbnVsbDtcbiAgfVxuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICB2YXIgcm5kcyA9IG9wdGlvbnMucmFuZG9tIHx8IChvcHRpb25zLnJuZyB8fCBybmcpKCk7XG5cbiAgLy8gUGVyIDQuNCwgc2V0IGJpdHMgZm9yIHZlcnNpb24gYW5kIGBjbG9ja19zZXFfaGlfYW5kX3Jlc2VydmVkYFxuICBybmRzWzZdID0gKHJuZHNbNl0gJiAweDBmKSB8IDB4NDA7XG4gIHJuZHNbOF0gPSAocm5kc1s4XSAmIDB4M2YpIHwgMHg4MDtcblxuICAvLyBDb3B5IGJ5dGVzIHRvIGJ1ZmZlciwgaWYgcHJvdmlkZWRcbiAgaWYgKGJ1Zikge1xuICAgIGZvciAodmFyIGlpID0gMDsgaWkgPCAxNjsgKytpaSkge1xuICAgICAgYnVmW2kgKyBpaV0gPSBybmRzW2lpXTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gYnVmIHx8IGJ5dGVzVG9VdWlkKHJuZHMpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHY0O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3V1aWQvdjQuanNcbi8vIG1vZHVsZSBpZCA9IDMxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=")},function(module,exports,__webpack_require__){eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/* global define */\n/*!\n * webfinger.js\n *   version 2.6.4\n *   http://github.com/silverbucket/webfinger.js\n *\n * Developed and Maintained by:\n *   Nick Jennings <nick@silverbucket.net> 2012\n *\n * webfinger.js is released under the AGPL (see LICENSE).\n *\n * You don't have to do anything special to choose one license or the other and you don't\n * have to notify anyone which license you are using.\n * Please see the corresponding license file for details of these licenses.\n * You are free to use, modify and distribute this software, but all copyright\n * information must remain.\n *\n */\n\nif (typeof XMLHttpRequest === 'undefined') {\n  // XMLHttpRequest = require('xmlhttprequest').XMLHttpRequest;\n  XMLHttpRequest = __webpack_require__(33);\n}\n\n(function (global) {\n\n  // URI to property name map\n  var LINK_URI_MAPS = {\n    'http://webfist.org/spec/rel': 'webfist',\n    'http://webfinger.net/rel/avatar': 'avatar',\n    'remotestorage': 'remotestorage',\n    'http://tools.ietf.org/id/draft-dejong-remotestorage': 'remotestorage',\n    'remoteStorage': 'remotestorage',\n    'http://www.packetizer.com/rel/share': 'share',\n    'http://webfinger.net/rel/profile-page': 'profile',\n    'me': 'profile',\n    'vcard': 'vcard',\n    'blog': 'blog',\n    'http://packetizer.com/rel/blog': 'blog',\n    'http://schemas.google.com/g/2010#updates-from': 'updates',\n    'https://camlistore.org/rel/server': 'camilstore'\n  };\n\n  var LINK_PROPERTIES = {\n    'avatar': [],\n    'remotestorage': [],\n    'blog': [],\n    'vcard': [],\n    'updates': [],\n    'share': [],\n    'profile': [],\n    'webfist': [],\n    'camlistore': []\n  };\n\n  // list of endpoints to try, fallback from beginning to end.\n  var URIS = ['webfinger', 'host-meta', 'host-meta.json'];\n\n  function generateErrorObject(obj) {\n    obj.toString = function () {\n      return this.message;\n    };\n    return obj;\n  }\n\n  // given a URL ensures it's HTTPS.\n  // returns false for null string or non-HTTPS URL.\n  function isSecure(url) {\n    if (typeof url !== 'string') {\n      return false;\n    }\n    var parts = url.split('://');\n    if (parts[0] === 'https') {\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * Function: WebFinger\n   *\n   * WebFinger constructor\n   *\n   * Returns:\n   *\n   *   return WebFinger object\n   */\n  function WebFinger(config) {\n    if (typeof config !== 'object') {\n      config = {};\n    }\n\n    this.config = {\n      tls_only:         (typeof config.tls_only !== 'undefined') ? config.tls_only : true,\n      webfist_fallback: (typeof config.webfist_fallback !== 'undefined') ? config.webfist_fallback : false,\n      uri_fallback:     (typeof config.uri_fallback !== 'undefined') ? config.uri_fallback : false,\n      request_timeout:  (typeof config.request_timeout !== 'undefined') ? config.request_timeout : 10000\n    };\n  }\n\n  // make an http request and look for JRD response, fails if request fails\n  // or response not json.\n  WebFinger.prototype.__fetchJRD = function (url, errorHandler, sucessHandler) {\n    var self = this;\n\n    var xhr = new XMLHttpRequest();\n    xhr.timeout = this.config.request_timeout;\n\n    function __processState() {\n      if (xhr.status === 200) {\n        if (self.__isValidJSON(xhr.responseText)) {\n          return sucessHandler(xhr.responseText);\n        } else {\n          return errorHandler(generateErrorObject({\n            message: 'invalid json',\n            url: url,\n            status: xhr.status\n          }));\n        }\n      } else if (xhr.status === 404) {\n        return errorHandler(generateErrorObject({\n          message: 'resource not found',\n          url: url,\n          status: xhr.status\n        }));\n      } else if ((xhr.status >= 301) && (xhr.status <= 302)) {\n        var location = xhr.getResponseHeader('Location');\n        if (isSecure(location)) {\n          return __makeRequest(location); // follow redirect\n        } else {\n          return errorHandler(generateErrorObject({\n            message: 'no redirect URL found',\n            url: url,\n            status: xhr.status\n          }));\n        }\n      } else {\n        return errorHandler(generateErrorObject({\n          message: 'error during request',\n          url: url,\n          status: xhr.status\n        }));\n      }\n    }\n\n    function __makeRequest() {\n      xhr.onreadystatechange = function () {\n        if (xhr.readyState === 4) {\n          __processState();\n        }\n      };\n\n      xhr.onload = function () {\n        __processState();\n      };\n\n      xhr.ontimeout = function () {\n        return errorHandler(generateErrorObject({\n          message: 'request timed out',\n          url: url,\n          status: xhr.status\n        }));\n      };\n\n      xhr.open('GET', url, true);\n      xhr.setRequestHeader('Accept', 'application/jrd+json, application/json');\n      xhr.send();\n    }\n\n    return __makeRequest();\n  };\n\n  WebFinger.prototype.__isValidJSON = function (str) {\n    try {\n      JSON.parse(str);\n    } catch (e) {\n      return false;\n    }\n    return true;\n  };\n\n  WebFinger.prototype.__isLocalhost = function (host) {\n    var local = /^localhost(\\.localdomain)?(\\:[0-9]+)?$/;\n    return local.test(host);\n  };\n\n  // processes JRD object as if it's a webfinger response object\n  // looks for known properties and adds them to profile datat struct.\n  WebFinger.prototype.__processJRD = function (URL, JRD, errorHandler, successHandler) {\n    var parsedJRD = JSON.parse(JRD);\n    if ((typeof parsedJRD !== 'object') ||\n        (typeof parsedJRD.links !== 'object')) {\n      if (typeof parsedJRD.error !== 'undefined') {\n        return errorHandler(generateErrorObject({ message: parsedJRD.error, request: URL }));\n      } else {\n        return errorHandler(generateErrorObject({ message: 'unknown response from server', request: URL }));\n      }\n    }\n\n    var links = parsedJRD.links;\n    if (!Array.isArray(links)) {\n      links = [];\n    }\n    var result = {  // webfinger JRD - object, json, and our own indexing\n      object: parsedJRD,\n      json: JRD,\n      idx: {}\n    };\n\n    result.idx.properties = {\n      'name': undefined\n    };\n    result.idx.links = JSON.parse(JSON.stringify(LINK_PROPERTIES));\n\n    // process links\n    links.map(function (link, i) {\n      if (LINK_URI_MAPS.hasOwnProperty(link.rel)) {\n        if (result.idx.links[LINK_URI_MAPS[link.rel]]) {\n          var entry = {};\n          Object.keys(link).map(function (item, n) {\n            entry[item] = link[item];\n          });\n          result.idx.links[LINK_URI_MAPS[link.rel]].push(entry);\n        }\n      }\n    });\n\n    // process properties\n    var props = JSON.parse(JRD).properties;\n    for (var key in props) {\n      if (props.hasOwnProperty(key)) {\n        if (key === 'http://packetizer.com/ns/name') {\n          result.idx.properties.name = props[key];\n        }\n      }\n    }\n    return successHandler(result);\n  };\n\n  WebFinger.prototype.lookup = function (address, cb) {\n    if (typeof address !== 'string') {\n      throw new Error('first parameter must be a user address');\n    } else if (typeof cb !== 'function') {\n      throw new Error('second parameter must be a callback');\n    }\n\n    var self = this;\n    var host = '';\n    if (address.indexOf('://') > -1) {\n      // other uri format\n      host = address.replace(/ /g,'').split('/')[2];\n    } else {\n      // useraddress\n      host = address.replace(/ /g,'').split('@')[1];\n    }\n    var uri_index = 0;      // track which URIS we've tried already\n    var protocol = 'https'; // we use https by default\n\n    if (self.__isLocalhost(host)) {\n      protocol = 'http';\n    }\n\n    function __buildURL() {\n      var uri = '';\n      if (! address.split('://')[1]) {\n        // the URI has not been defined, default to acct\n        uri = 'acct:';\n      }\n      return protocol + '://' + host + '/.well-known/' +\n             URIS[uri_index] + '?resource=' + uri + address;\n    }\n\n    // control flow for failures, what to do in various cases, etc.\n    function __fallbackChecks(err) {\n      if ((self.config.uri_fallback) && (host !== 'webfist.org') && (uri_index !== URIS.length - 1)) { // we have uris left to try\n        uri_index = uri_index + 1;\n        return __call();\n      } else if ((!self.config.tls_only) && (protocol === 'https')) { // try normal http\n        uri_index = 0;\n        protocol = 'http';\n        return __call();\n      } else if ((self.config.webfist_fallback) && (host !== 'webfist.org')) { // webfist attempt\n        uri_index = 0;\n        protocol = 'http';\n        host = 'webfist.org';\n        // webfist will\n        // 1. make a query to the webfist server for the users account\n        // 2. from the response, get a link to the actual webfinger json data\n        //    (stored somewhere in control of the user)\n        // 3. make a request to that url and get the json\n        // 4. process it like a normal webfinger response\n        var URL = __buildURL();\n        self.__fetchJRD(URL, cb, function (data) { // get link to users JRD\n          self.__processJRD(URL, data, cb, function (result) {\n            if ((typeof result.idx.links.webfist === 'object') &&\n                (typeof result.idx.links.webfist[0].href === 'string')) {\n              self.__fetchJRD(result.idx.links.webfist[0].href, cb, function (JRD) {\n                self.__processJRD(URL, JRD, cb, function (result) {\n                  return cb(null, cb);\n                });\n              });\n            }\n          });\n        });\n      } else {\n        return cb(err);\n      }\n    }\n\n    function __call() {\n      // make request\n      var URL = __buildURL();\n      self.__fetchJRD(URL, __fallbackChecks, function (JRD) {\n        self.__processJRD(URL, JRD, cb, function (result) { cb(null, result); });\n      });\n    }\n\n    return setTimeout(__call, 0);\n  };\n\n  WebFinger.prototype.lookupLink = function (address, rel, cb) {\n    if (LINK_PROPERTIES.hasOwnProperty(rel)) {\n      this.lookup(address, function (err, p) {\n        var links  = p.idx.links[rel];\n        if (err) {\n          return cb(err);\n        } else if (links.length === 0) {\n          return cb('no links found with rel=\"' + rel + '\"');\n        } else {\n          return cb(null, links[0]);\n        }\n      });\n    } else {\n      return cb('unsupported rel ' + rel);\n    }\n  };\n\n\n\n  // AMD support\n  if (true) {\n      !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function () { return WebFinger; }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  // CommonJS and Node.js module support.\n  } else if (typeof exports !== 'undefined') {\n    // Support Node.js specific `module.exports` (which can be a function)\n    if (typeof module !== 'undefined' && module.exports) {\n        exports = module.exports = WebFinger;\n    }\n    // But always support CommonJS module 1.1.1 spec (`exports` cannot be a function)\n    exports.WebFinger = WebFinger;\n  } else {\n    // browser <script> support\n    global.WebFinger = WebFinger;\n  }\n})(this);\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3dlYmZpbmdlci5qcy9zcmMvd2ViZmluZ2VyLmpzPzExYTUiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekMsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELHlDQUF5QztBQUMxRixPQUFPO0FBQ1AsaURBQWlELHdEQUF3RDtBQUN6RztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QiwyQkFBMkI7O0FBRTNCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHNHQUFzRztBQUN0RztBQUNBO0FBQ0EsT0FBTyw4REFBOEQ7QUFDckU7QUFDQTtBQUNBO0FBQ0EsT0FBTyx1RUFBdUU7QUFDOUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0Q7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGVBQWU7QUFDZjtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRCxrQkFBa0IsRUFBRTtBQUMvRSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBLHdGQUE4QixrQkFBa0IsRUFBRTtBQUNsRDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsQ0FBQyIsImZpbGUiOiIzMi5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qIGdsb2JhbCBkZWZpbmUgKi9cbi8qIVxuICogd2ViZmluZ2VyLmpzXG4gKiAgIHZlcnNpb24gMi42LjRcbiAqICAgaHR0cDovL2dpdGh1Yi5jb20vc2lsdmVyYnVja2V0L3dlYmZpbmdlci5qc1xuICpcbiAqIERldmVsb3BlZCBhbmQgTWFpbnRhaW5lZCBieTpcbiAqICAgTmljayBKZW5uaW5ncyA8bmlja0BzaWx2ZXJidWNrZXQubmV0PiAyMDEyXG4gKlxuICogd2ViZmluZ2VyLmpzIGlzIHJlbGVhc2VkIHVuZGVyIHRoZSBBR1BMIChzZWUgTElDRU5TRSkuXG4gKlxuICogWW91IGRvbid0IGhhdmUgdG8gZG8gYW55dGhpbmcgc3BlY2lhbCB0byBjaG9vc2Ugb25lIGxpY2Vuc2Ugb3IgdGhlIG90aGVyIGFuZCB5b3UgZG9uJ3RcbiAqIGhhdmUgdG8gbm90aWZ5IGFueW9uZSB3aGljaCBsaWNlbnNlIHlvdSBhcmUgdXNpbmcuXG4gKiBQbGVhc2Ugc2VlIHRoZSBjb3JyZXNwb25kaW5nIGxpY2Vuc2UgZmlsZSBmb3IgZGV0YWlscyBvZiB0aGVzZSBsaWNlbnNlcy5cbiAqIFlvdSBhcmUgZnJlZSB0byB1c2UsIG1vZGlmeSBhbmQgZGlzdHJpYnV0ZSB0aGlzIHNvZnR3YXJlLCBidXQgYWxsIGNvcHlyaWdodFxuICogaW5mb3JtYXRpb24gbXVzdCByZW1haW4uXG4gKlxuICovXG5cbmlmICh0eXBlb2YgWE1MSHR0cFJlcXVlc3QgPT09ICd1bmRlZmluZWQnKSB7XG4gIC8vIFhNTEh0dHBSZXF1ZXN0ID0gcmVxdWlyZSgneG1saHR0cHJlcXVlc3QnKS5YTUxIdHRwUmVxdWVzdDtcbiAgWE1MSHR0cFJlcXVlc3QgPSByZXF1aXJlKCd4aHIyJyk7XG59XG5cbihmdW5jdGlvbiAoZ2xvYmFsKSB7XG5cbiAgLy8gVVJJIHRvIHByb3BlcnR5IG5hbWUgbWFwXG4gIHZhciBMSU5LX1VSSV9NQVBTID0ge1xuICAgICdodHRwOi8vd2ViZmlzdC5vcmcvc3BlYy9yZWwnOiAnd2ViZmlzdCcsXG4gICAgJ2h0dHA6Ly93ZWJmaW5nZXIubmV0L3JlbC9hdmF0YXInOiAnYXZhdGFyJyxcbiAgICAncmVtb3Rlc3RvcmFnZSc6ICdyZW1vdGVzdG9yYWdlJyxcbiAgICAnaHR0cDovL3Rvb2xzLmlldGYub3JnL2lkL2RyYWZ0LWRlam9uZy1yZW1vdGVzdG9yYWdlJzogJ3JlbW90ZXN0b3JhZ2UnLFxuICAgICdyZW1vdGVTdG9yYWdlJzogJ3JlbW90ZXN0b3JhZ2UnLFxuICAgICdodHRwOi8vd3d3LnBhY2tldGl6ZXIuY29tL3JlbC9zaGFyZSc6ICdzaGFyZScsXG4gICAgJ2h0dHA6Ly93ZWJmaW5nZXIubmV0L3JlbC9wcm9maWxlLXBhZ2UnOiAncHJvZmlsZScsXG4gICAgJ21lJzogJ3Byb2ZpbGUnLFxuICAgICd2Y2FyZCc6ICd2Y2FyZCcsXG4gICAgJ2Jsb2cnOiAnYmxvZycsXG4gICAgJ2h0dHA6Ly9wYWNrZXRpemVyLmNvbS9yZWwvYmxvZyc6ICdibG9nJyxcbiAgICAnaHR0cDovL3NjaGVtYXMuZ29vZ2xlLmNvbS9nLzIwMTAjdXBkYXRlcy1mcm9tJzogJ3VwZGF0ZXMnLFxuICAgICdodHRwczovL2NhbWxpc3RvcmUub3JnL3JlbC9zZXJ2ZXInOiAnY2FtaWxzdG9yZSdcbiAgfTtcblxuICB2YXIgTElOS19QUk9QRVJUSUVTID0ge1xuICAgICdhdmF0YXInOiBbXSxcbiAgICAncmVtb3Rlc3RvcmFnZSc6IFtdLFxuICAgICdibG9nJzogW10sXG4gICAgJ3ZjYXJkJzogW10sXG4gICAgJ3VwZGF0ZXMnOiBbXSxcbiAgICAnc2hhcmUnOiBbXSxcbiAgICAncHJvZmlsZSc6IFtdLFxuICAgICd3ZWJmaXN0JzogW10sXG4gICAgJ2NhbWxpc3RvcmUnOiBbXVxuICB9O1xuXG4gIC8vIGxpc3Qgb2YgZW5kcG9pbnRzIHRvIHRyeSwgZmFsbGJhY2sgZnJvbSBiZWdpbm5pbmcgdG8gZW5kLlxuICB2YXIgVVJJUyA9IFsnd2ViZmluZ2VyJywgJ2hvc3QtbWV0YScsICdob3N0LW1ldGEuanNvbiddO1xuXG4gIGZ1bmN0aW9uIGdlbmVyYXRlRXJyb3JPYmplY3Qob2JqKSB7XG4gICAgb2JqLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMubWVzc2FnZTtcbiAgICB9O1xuICAgIHJldHVybiBvYmo7XG4gIH1cblxuICAvLyBnaXZlbiBhIFVSTCBlbnN1cmVzIGl0J3MgSFRUUFMuXG4gIC8vIHJldHVybnMgZmFsc2UgZm9yIG51bGwgc3RyaW5nIG9yIG5vbi1IVFRQUyBVUkwuXG4gIGZ1bmN0aW9uIGlzU2VjdXJlKHVybCkge1xuICAgIGlmICh0eXBlb2YgdXJsICE9PSAnc3RyaW5nJykge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB2YXIgcGFydHMgPSB1cmwuc3BsaXQoJzovLycpO1xuICAgIGlmIChwYXJ0c1swXSA9PT0gJ2h0dHBzJykge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGdW5jdGlvbjogV2ViRmluZ2VyXG4gICAqXG4gICAqIFdlYkZpbmdlciBjb25zdHJ1Y3RvclxuICAgKlxuICAgKiBSZXR1cm5zOlxuICAgKlxuICAgKiAgIHJldHVybiBXZWJGaW5nZXIgb2JqZWN0XG4gICAqL1xuICBmdW5jdGlvbiBXZWJGaW5nZXIoY29uZmlnKSB7XG4gICAgaWYgKHR5cGVvZiBjb25maWcgIT09ICdvYmplY3QnKSB7XG4gICAgICBjb25maWcgPSB7fTtcbiAgICB9XG5cbiAgICB0aGlzLmNvbmZpZyA9IHtcbiAgICAgIHRsc19vbmx5OiAgICAgICAgICh0eXBlb2YgY29uZmlnLnRsc19vbmx5ICE9PSAndW5kZWZpbmVkJykgPyBjb25maWcudGxzX29ubHkgOiB0cnVlLFxuICAgICAgd2ViZmlzdF9mYWxsYmFjazogKHR5cGVvZiBjb25maWcud2ViZmlzdF9mYWxsYmFjayAhPT0gJ3VuZGVmaW5lZCcpID8gY29uZmlnLndlYmZpc3RfZmFsbGJhY2sgOiBmYWxzZSxcbiAgICAgIHVyaV9mYWxsYmFjazogICAgICh0eXBlb2YgY29uZmlnLnVyaV9mYWxsYmFjayAhPT0gJ3VuZGVmaW5lZCcpID8gY29uZmlnLnVyaV9mYWxsYmFjayA6IGZhbHNlLFxuICAgICAgcmVxdWVzdF90aW1lb3V0OiAgKHR5cGVvZiBjb25maWcucmVxdWVzdF90aW1lb3V0ICE9PSAndW5kZWZpbmVkJykgPyBjb25maWcucmVxdWVzdF90aW1lb3V0IDogMTAwMDBcbiAgICB9O1xuICB9XG5cbiAgLy8gbWFrZSBhbiBodHRwIHJlcXVlc3QgYW5kIGxvb2sgZm9yIEpSRCByZXNwb25zZSwgZmFpbHMgaWYgcmVxdWVzdCBmYWlsc1xuICAvLyBvciByZXNwb25zZSBub3QganNvbi5cbiAgV2ViRmluZ2VyLnByb3RvdHlwZS5fX2ZldGNoSlJEID0gZnVuY3Rpb24gKHVybCwgZXJyb3JIYW5kbGVyLCBzdWNlc3NIYW5kbGVyKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgdmFyIHhociA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuICAgIHhoci50aW1lb3V0ID0gdGhpcy5jb25maWcucmVxdWVzdF90aW1lb3V0O1xuXG4gICAgZnVuY3Rpb24gX19wcm9jZXNzU3RhdGUoKSB7XG4gICAgICBpZiAoeGhyLnN0YXR1cyA9PT0gMjAwKSB7XG4gICAgICAgIGlmIChzZWxmLl9faXNWYWxpZEpTT04oeGhyLnJlc3BvbnNlVGV4dCkpIHtcbiAgICAgICAgICByZXR1cm4gc3VjZXNzSGFuZGxlcih4aHIucmVzcG9uc2VUZXh0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gZXJyb3JIYW5kbGVyKGdlbmVyYXRlRXJyb3JPYmplY3Qoe1xuICAgICAgICAgICAgbWVzc2FnZTogJ2ludmFsaWQganNvbicsXG4gICAgICAgICAgICB1cmw6IHVybCxcbiAgICAgICAgICAgIHN0YXR1czogeGhyLnN0YXR1c1xuICAgICAgICAgIH0pKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh4aHIuc3RhdHVzID09PSA0MDQpIHtcbiAgICAgICAgcmV0dXJuIGVycm9ySGFuZGxlcihnZW5lcmF0ZUVycm9yT2JqZWN0KHtcbiAgICAgICAgICBtZXNzYWdlOiAncmVzb3VyY2Ugbm90IGZvdW5kJyxcbiAgICAgICAgICB1cmw6IHVybCxcbiAgICAgICAgICBzdGF0dXM6IHhoci5zdGF0dXNcbiAgICAgICAgfSkpO1xuICAgICAgfSBlbHNlIGlmICgoeGhyLnN0YXR1cyA+PSAzMDEpICYmICh4aHIuc3RhdHVzIDw9IDMwMikpIHtcbiAgICAgICAgdmFyIGxvY2F0aW9uID0geGhyLmdldFJlc3BvbnNlSGVhZGVyKCdMb2NhdGlvbicpO1xuICAgICAgICBpZiAoaXNTZWN1cmUobG9jYXRpb24pKSB7XG4gICAgICAgICAgcmV0dXJuIF9fbWFrZVJlcXVlc3QobG9jYXRpb24pOyAvLyBmb2xsb3cgcmVkaXJlY3RcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gZXJyb3JIYW5kbGVyKGdlbmVyYXRlRXJyb3JPYmplY3Qoe1xuICAgICAgICAgICAgbWVzc2FnZTogJ25vIHJlZGlyZWN0IFVSTCBmb3VuZCcsXG4gICAgICAgICAgICB1cmw6IHVybCxcbiAgICAgICAgICAgIHN0YXR1czogeGhyLnN0YXR1c1xuICAgICAgICAgIH0pKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGVycm9ySGFuZGxlcihnZW5lcmF0ZUVycm9yT2JqZWN0KHtcbiAgICAgICAgICBtZXNzYWdlOiAnZXJyb3IgZHVyaW5nIHJlcXVlc3QnLFxuICAgICAgICAgIHVybDogdXJsLFxuICAgICAgICAgIHN0YXR1czogeGhyLnN0YXR1c1xuICAgICAgICB9KSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gX19tYWtlUmVxdWVzdCgpIHtcbiAgICAgIHhoci5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh4aHIucmVhZHlTdGF0ZSA9PT0gNCkge1xuICAgICAgICAgIF9fcHJvY2Vzc1N0YXRlKCk7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIHhoci5vbmxvYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIF9fcHJvY2Vzc1N0YXRlKCk7XG4gICAgICB9O1xuXG4gICAgICB4aHIub250aW1lb3V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gZXJyb3JIYW5kbGVyKGdlbmVyYXRlRXJyb3JPYmplY3Qoe1xuICAgICAgICAgIG1lc3NhZ2U6ICdyZXF1ZXN0IHRpbWVkIG91dCcsXG4gICAgICAgICAgdXJsOiB1cmwsXG4gICAgICAgICAgc3RhdHVzOiB4aHIuc3RhdHVzXG4gICAgICAgIH0pKTtcbiAgICAgIH07XG5cbiAgICAgIHhoci5vcGVuKCdHRVQnLCB1cmwsIHRydWUpO1xuICAgICAgeGhyLnNldFJlcXVlc3RIZWFkZXIoJ0FjY2VwdCcsICdhcHBsaWNhdGlvbi9qcmQranNvbiwgYXBwbGljYXRpb24vanNvbicpO1xuICAgICAgeGhyLnNlbmQoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gX19tYWtlUmVxdWVzdCgpO1xuICB9O1xuXG4gIFdlYkZpbmdlci5wcm90b3R5cGUuX19pc1ZhbGlkSlNPTiA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgICB0cnkge1xuICAgICAgSlNPTi5wYXJzZShzdHIpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH07XG5cbiAgV2ViRmluZ2VyLnByb3RvdHlwZS5fX2lzTG9jYWxob3N0ID0gZnVuY3Rpb24gKGhvc3QpIHtcbiAgICB2YXIgbG9jYWwgPSAvXmxvY2FsaG9zdChcXC5sb2NhbGRvbWFpbik/KFxcOlswLTldKyk/JC87XG4gICAgcmV0dXJuIGxvY2FsLnRlc3QoaG9zdCk7XG4gIH07XG5cbiAgLy8gcHJvY2Vzc2VzIEpSRCBvYmplY3QgYXMgaWYgaXQncyBhIHdlYmZpbmdlciByZXNwb25zZSBvYmplY3RcbiAgLy8gbG9va3MgZm9yIGtub3duIHByb3BlcnRpZXMgYW5kIGFkZHMgdGhlbSB0byBwcm9maWxlIGRhdGF0IHN0cnVjdC5cbiAgV2ViRmluZ2VyLnByb3RvdHlwZS5fX3Byb2Nlc3NKUkQgPSBmdW5jdGlvbiAoVVJMLCBKUkQsIGVycm9ySGFuZGxlciwgc3VjY2Vzc0hhbmRsZXIpIHtcbiAgICB2YXIgcGFyc2VkSlJEID0gSlNPTi5wYXJzZShKUkQpO1xuICAgIGlmICgodHlwZW9mIHBhcnNlZEpSRCAhPT0gJ29iamVjdCcpIHx8XG4gICAgICAgICh0eXBlb2YgcGFyc2VkSlJELmxpbmtzICE9PSAnb2JqZWN0JykpIHtcbiAgICAgIGlmICh0eXBlb2YgcGFyc2VkSlJELmVycm9yICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICByZXR1cm4gZXJyb3JIYW5kbGVyKGdlbmVyYXRlRXJyb3JPYmplY3QoeyBtZXNzYWdlOiBwYXJzZWRKUkQuZXJyb3IsIHJlcXVlc3Q6IFVSTCB9KSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gZXJyb3JIYW5kbGVyKGdlbmVyYXRlRXJyb3JPYmplY3QoeyBtZXNzYWdlOiAndW5rbm93biByZXNwb25zZSBmcm9tIHNlcnZlcicsIHJlcXVlc3Q6IFVSTCB9KSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGxpbmtzID0gcGFyc2VkSlJELmxpbmtzO1xuICAgIGlmICghQXJyYXkuaXNBcnJheShsaW5rcykpIHtcbiAgICAgIGxpbmtzID0gW107XG4gICAgfVxuICAgIHZhciByZXN1bHQgPSB7ICAvLyB3ZWJmaW5nZXIgSlJEIC0gb2JqZWN0LCBqc29uLCBhbmQgb3VyIG93biBpbmRleGluZ1xuICAgICAgb2JqZWN0OiBwYXJzZWRKUkQsXG4gICAgICBqc29uOiBKUkQsXG4gICAgICBpZHg6IHt9XG4gICAgfTtcblxuICAgIHJlc3VsdC5pZHgucHJvcGVydGllcyA9IHtcbiAgICAgICduYW1lJzogdW5kZWZpbmVkXG4gICAgfTtcbiAgICByZXN1bHQuaWR4LmxpbmtzID0gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShMSU5LX1BST1BFUlRJRVMpKTtcblxuICAgIC8vIHByb2Nlc3MgbGlua3NcbiAgICBsaW5rcy5tYXAoZnVuY3Rpb24gKGxpbmssIGkpIHtcbiAgICAgIGlmIChMSU5LX1VSSV9NQVBTLmhhc093blByb3BlcnR5KGxpbmsucmVsKSkge1xuICAgICAgICBpZiAocmVzdWx0LmlkeC5saW5rc1tMSU5LX1VSSV9NQVBTW2xpbmsucmVsXV0pIHtcbiAgICAgICAgICB2YXIgZW50cnkgPSB7fTtcbiAgICAgICAgICBPYmplY3Qua2V5cyhsaW5rKS5tYXAoZnVuY3Rpb24gKGl0ZW0sIG4pIHtcbiAgICAgICAgICAgIGVudHJ5W2l0ZW1dID0gbGlua1tpdGVtXTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZXN1bHQuaWR4LmxpbmtzW0xJTktfVVJJX01BUFNbbGluay5yZWxdXS5wdXNoKGVudHJ5KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gcHJvY2VzcyBwcm9wZXJ0aWVzXG4gICAgdmFyIHByb3BzID0gSlNPTi5wYXJzZShKUkQpLnByb3BlcnRpZXM7XG4gICAgZm9yICh2YXIga2V5IGluIHByb3BzKSB7XG4gICAgICBpZiAocHJvcHMuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICBpZiAoa2V5ID09PSAnaHR0cDovL3BhY2tldGl6ZXIuY29tL25zL25hbWUnKSB7XG4gICAgICAgICAgcmVzdWx0LmlkeC5wcm9wZXJ0aWVzLm5hbWUgPSBwcm9wc1trZXldO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzdWNjZXNzSGFuZGxlcihyZXN1bHQpO1xuICB9O1xuXG4gIFdlYkZpbmdlci5wcm90b3R5cGUubG9va3VwID0gZnVuY3Rpb24gKGFkZHJlc3MsIGNiKSB7XG4gICAgaWYgKHR5cGVvZiBhZGRyZXNzICE9PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdmaXJzdCBwYXJhbWV0ZXIgbXVzdCBiZSBhIHVzZXIgYWRkcmVzcycpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGNiICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3NlY29uZCBwYXJhbWV0ZXIgbXVzdCBiZSBhIGNhbGxiYWNrJyk7XG4gICAgfVxuXG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBob3N0ID0gJyc7XG4gICAgaWYgKGFkZHJlc3MuaW5kZXhPZignOi8vJykgPiAtMSkge1xuICAgICAgLy8gb3RoZXIgdXJpIGZvcm1hdFxuICAgICAgaG9zdCA9IGFkZHJlc3MucmVwbGFjZSgvIC9nLCcnKS5zcGxpdCgnLycpWzJdO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyB1c2VyYWRkcmVzc1xuICAgICAgaG9zdCA9IGFkZHJlc3MucmVwbGFjZSgvIC9nLCcnKS5zcGxpdCgnQCcpWzFdO1xuICAgIH1cbiAgICB2YXIgdXJpX2luZGV4ID0gMDsgICAgICAvLyB0cmFjayB3aGljaCBVUklTIHdlJ3ZlIHRyaWVkIGFscmVhZHlcbiAgICB2YXIgcHJvdG9jb2wgPSAnaHR0cHMnOyAvLyB3ZSB1c2UgaHR0cHMgYnkgZGVmYXVsdFxuXG4gICAgaWYgKHNlbGYuX19pc0xvY2FsaG9zdChob3N0KSkge1xuICAgICAgcHJvdG9jb2wgPSAnaHR0cCc7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gX19idWlsZFVSTCgpIHtcbiAgICAgIHZhciB1cmkgPSAnJztcbiAgICAgIGlmICghIGFkZHJlc3Muc3BsaXQoJzovLycpWzFdKSB7XG4gICAgICAgIC8vIHRoZSBVUkkgaGFzIG5vdCBiZWVuIGRlZmluZWQsIGRlZmF1bHQgdG8gYWNjdFxuICAgICAgICB1cmkgPSAnYWNjdDonO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHByb3RvY29sICsgJzovLycgKyBob3N0ICsgJy8ud2VsbC1rbm93bi8nICtcbiAgICAgICAgICAgICBVUklTW3VyaV9pbmRleF0gKyAnP3Jlc291cmNlPScgKyB1cmkgKyBhZGRyZXNzO1xuICAgIH1cblxuICAgIC8vIGNvbnRyb2wgZmxvdyBmb3IgZmFpbHVyZXMsIHdoYXQgdG8gZG8gaW4gdmFyaW91cyBjYXNlcywgZXRjLlxuICAgIGZ1bmN0aW9uIF9fZmFsbGJhY2tDaGVja3MoZXJyKSB7XG4gICAgICBpZiAoKHNlbGYuY29uZmlnLnVyaV9mYWxsYmFjaykgJiYgKGhvc3QgIT09ICd3ZWJmaXN0Lm9yZycpICYmICh1cmlfaW5kZXggIT09IFVSSVMubGVuZ3RoIC0gMSkpIHsgLy8gd2UgaGF2ZSB1cmlzIGxlZnQgdG8gdHJ5XG4gICAgICAgIHVyaV9pbmRleCA9IHVyaV9pbmRleCArIDE7XG4gICAgICAgIHJldHVybiBfX2NhbGwoKTtcbiAgICAgIH0gZWxzZSBpZiAoKCFzZWxmLmNvbmZpZy50bHNfb25seSkgJiYgKHByb3RvY29sID09PSAnaHR0cHMnKSkgeyAvLyB0cnkgbm9ybWFsIGh0dHBcbiAgICAgICAgdXJpX2luZGV4ID0gMDtcbiAgICAgICAgcHJvdG9jb2wgPSAnaHR0cCc7XG4gICAgICAgIHJldHVybiBfX2NhbGwoKTtcbiAgICAgIH0gZWxzZSBpZiAoKHNlbGYuY29uZmlnLndlYmZpc3RfZmFsbGJhY2spICYmIChob3N0ICE9PSAnd2ViZmlzdC5vcmcnKSkgeyAvLyB3ZWJmaXN0IGF0dGVtcHRcbiAgICAgICAgdXJpX2luZGV4ID0gMDtcbiAgICAgICAgcHJvdG9jb2wgPSAnaHR0cCc7XG4gICAgICAgIGhvc3QgPSAnd2ViZmlzdC5vcmcnO1xuICAgICAgICAvLyB3ZWJmaXN0IHdpbGxcbiAgICAgICAgLy8gMS4gbWFrZSBhIHF1ZXJ5IHRvIHRoZSB3ZWJmaXN0IHNlcnZlciBmb3IgdGhlIHVzZXJzIGFjY291bnRcbiAgICAgICAgLy8gMi4gZnJvbSB0aGUgcmVzcG9uc2UsIGdldCBhIGxpbmsgdG8gdGhlIGFjdHVhbCB3ZWJmaW5nZXIganNvbiBkYXRhXG4gICAgICAgIC8vICAgIChzdG9yZWQgc29tZXdoZXJlIGluIGNvbnRyb2wgb2YgdGhlIHVzZXIpXG4gICAgICAgIC8vIDMuIG1ha2UgYSByZXF1ZXN0IHRvIHRoYXQgdXJsIGFuZCBnZXQgdGhlIGpzb25cbiAgICAgICAgLy8gNC4gcHJvY2VzcyBpdCBsaWtlIGEgbm9ybWFsIHdlYmZpbmdlciByZXNwb25zZVxuICAgICAgICB2YXIgVVJMID0gX19idWlsZFVSTCgpO1xuICAgICAgICBzZWxmLl9fZmV0Y2hKUkQoVVJMLCBjYiwgZnVuY3Rpb24gKGRhdGEpIHsgLy8gZ2V0IGxpbmsgdG8gdXNlcnMgSlJEXG4gICAgICAgICAgc2VsZi5fX3Byb2Nlc3NKUkQoVVJMLCBkYXRhLCBjYiwgZnVuY3Rpb24gKHJlc3VsdCkge1xuICAgICAgICAgICAgaWYgKCh0eXBlb2YgcmVzdWx0LmlkeC5saW5rcy53ZWJmaXN0ID09PSAnb2JqZWN0JykgJiZcbiAgICAgICAgICAgICAgICAodHlwZW9mIHJlc3VsdC5pZHgubGlua3Mud2ViZmlzdFswXS5ocmVmID09PSAnc3RyaW5nJykpIHtcbiAgICAgICAgICAgICAgc2VsZi5fX2ZldGNoSlJEKHJlc3VsdC5pZHgubGlua3Mud2ViZmlzdFswXS5ocmVmLCBjYiwgZnVuY3Rpb24gKEpSRCkge1xuICAgICAgICAgICAgICAgIHNlbGYuX19wcm9jZXNzSlJEKFVSTCwgSlJELCBjYiwgZnVuY3Rpb24gKHJlc3VsdCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGNiKG51bGwsIGNiKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGNiKGVycik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gX19jYWxsKCkge1xuICAgICAgLy8gbWFrZSByZXF1ZXN0XG4gICAgICB2YXIgVVJMID0gX19idWlsZFVSTCgpO1xuICAgICAgc2VsZi5fX2ZldGNoSlJEKFVSTCwgX19mYWxsYmFja0NoZWNrcywgZnVuY3Rpb24gKEpSRCkge1xuICAgICAgICBzZWxmLl9fcHJvY2Vzc0pSRChVUkwsIEpSRCwgY2IsIGZ1bmN0aW9uIChyZXN1bHQpIHsgY2IobnVsbCwgcmVzdWx0KTsgfSk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gc2V0VGltZW91dChfX2NhbGwsIDApO1xuICB9O1xuXG4gIFdlYkZpbmdlci5wcm90b3R5cGUubG9va3VwTGluayA9IGZ1bmN0aW9uIChhZGRyZXNzLCByZWwsIGNiKSB7XG4gICAgaWYgKExJTktfUFJPUEVSVElFUy5oYXNPd25Qcm9wZXJ0eShyZWwpKSB7XG4gICAgICB0aGlzLmxvb2t1cChhZGRyZXNzLCBmdW5jdGlvbiAoZXJyLCBwKSB7XG4gICAgICAgIHZhciBsaW5rcyAgPSBwLmlkeC5saW5rc1tyZWxdO1xuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgcmV0dXJuIGNiKGVycik7XG4gICAgICAgIH0gZWxzZSBpZiAobGlua3MubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgcmV0dXJuIGNiKCdubyBsaW5rcyBmb3VuZCB3aXRoIHJlbD1cIicgKyByZWwgKyAnXCInKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gY2IobnVsbCwgbGlua3NbMF0pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGNiKCd1bnN1cHBvcnRlZCByZWwgJyArIHJlbCk7XG4gICAgfVxuICB9O1xuXG5cblxuICAvLyBBTUQgc3VwcG9ydFxuICBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XG4gICAgICBkZWZpbmUoW10sIGZ1bmN0aW9uICgpIHsgcmV0dXJuIFdlYkZpbmdlcjsgfSk7XG4gIC8vIENvbW1vbkpTIGFuZCBOb2RlLmpzIG1vZHVsZSBzdXBwb3J0LlxuICB9IGVsc2UgaWYgKHR5cGVvZiBleHBvcnRzICE9PSAndW5kZWZpbmVkJykge1xuICAgIC8vIFN1cHBvcnQgTm9kZS5qcyBzcGVjaWZpYyBgbW9kdWxlLmV4cG9ydHNgICh3aGljaCBjYW4gYmUgYSBmdW5jdGlvbilcbiAgICBpZiAodHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgJiYgbW9kdWxlLmV4cG9ydHMpIHtcbiAgICAgICAgZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gV2ViRmluZ2VyO1xuICAgIH1cbiAgICAvLyBCdXQgYWx3YXlzIHN1cHBvcnQgQ29tbW9uSlMgbW9kdWxlIDEuMS4xIHNwZWMgKGBleHBvcnRzYCBjYW5ub3QgYmUgYSBmdW5jdGlvbilcbiAgICBleHBvcnRzLldlYkZpbmdlciA9IFdlYkZpbmdlcjtcbiAgfSBlbHNlIHtcbiAgICAvLyBicm93c2VyIDxzY3JpcHQ+IHN1cHBvcnRcbiAgICBnbG9iYWwuV2ViRmluZ2VyID0gV2ViRmluZ2VyO1xuICB9XG59KSh0aGlzKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi93ZWJmaW5nZXIuanMvc3JjL3dlYmZpbmdlci5qc1xuLy8gbW9kdWxlIGlkID0gMzJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==");
},function(module,exports){eval("module.exports = XMLHttpRequest;\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3hocjIvbGliL2Jyb3dzZXIuanM/MjQyMCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSIsImZpbGUiOiIzMy5qcyIsInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gWE1MSHR0cFJlcXVlc3Q7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34veGhyMi9saWIvYnJvd3Nlci5qc1xuLy8gbW9kdWxlIGlkID0gMzNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==")}])});