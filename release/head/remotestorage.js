(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory(require("xmlhttprequest"));
	else if(typeof define === 'function' && define.amd)
		define("RemoteStorage", ["xmlhttprequest"], factory);
	else if(typeof exports === 'object')
		exports["RemoteStorage"] = factory(require("xmlhttprequest"));
	else
		root["RemoteStorage"] = factory(root["xmlhttprequest"]);
})(this, function(__WEBPACK_EXTERNAL_MODULE_22__) {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(1);


/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';\n\nvar _RemoteStorage$protot;\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nvar hasLocalStorage;\n\nfunction emitUnauthorized(r) {\n  if (r.statusCode === 403 || r.statusCode === 401) {\n    this._emit('error', new Authorize.Unauthorized());\n  }\n  return Promise.resolve(r);\n}\n\nvar util = __webpack_require__(2);\nvar Dropbox = __webpack_require__(6);\nvar GoogleDrive = __webpack_require__(19);\nvar Discover = __webpack_require__(20);\nvar BaseClient = __webpack_require__(8);\nvar config = __webpack_require__(5);\nvar Authorize = __webpack_require__(7);\nvar Sync = __webpack_require__(17);\nvar SyncedGetPutDelete = __webpack_require__(23);\nvar _log = __webpack_require__(4);\nvar Features = __webpack_require__(24);\nvar globalContext = util.getGlobalContext();\nvar eventHandling = __webpack_require__(3);\n\n/**\n * Class: RemoteStorage\n *\n * TODO needs proper introduction and links to relevant classes etc\n *\n * Constructor for remoteStorage object.\n *\n * This class primarily contains feature detection code and convenience API.\n *\n * Depending on which features are built in, it contains different attributes and\n * functions. See the individual features for more information.\n *\n *  (start code)\n *  var remoteStorage = new RemoteStorage({\n *    logging: true,  // defaults to false\n *    cordovaRedirectUri: 'https://app.mygreatapp.com' // defaults to undefined\n *  });\n *  (end code)\n */\nvar RemoteStorage = function RemoteStorage(cfg) {\n  /**\n   * Event: ready\n   *\n   * Fired when ready\n   **/\n  /**\n   * Event: not-connected\n   *\n   * Fired when ready, but no storage connected (\"anonymous mode\")\n   **/\n  /**\n   * Event: connected\n   *\n   * Fired when a remote storage has been connected\n   **/\n  /**\n   * Event: disconnected\n   *\n   * Fired after disconnect\n   **/\n  /**\n   * Event: error\n   *\n   * Fired when an error occurs\n   *\n   * Arguments:\n   * the error\n   **/\n  /**\n   * Event: features-loaded\n   *\n   * Fired when all features are loaded\n   **/\n  /**\n   * Event: connecting\n   *\n   * Fired before webfinger lookup\n   **/\n  /**\n   * Event: authing\n   *\n   * Fired before redirecting to the authing server\n   **/\n  /**\n   * Event: wire-busy\n   *\n   * Fired when a wire request starts\n   **/\n  /**\n   * Event: wire-done\n   *\n   * Fired when a wire request completes\n   **/\n  /**\n   * Event: network-offline\n   *\n   * Fired once when a wire request fails for the first time, and\n   * `remote.online` is set to false\n   **/\n  /**\n   * Event: network-online\n   *\n   * Fired once when a wire request succeeds for the first time after a\n   * failed one, and `remote.online` is set back to true\n   **/\n\n  // Initial configuration property settings.\n  // TODO merge user configuration with default configuration\n  if ((typeof cfg === 'undefined' ? 'undefined' : _typeof(cfg)) === 'object') {\n    config.logging = !!cfg.logging;\n    config.cache = !!cfg.cache;\n    config.cordovaRedirectUri = cfg.cordovaRedirectUri;\n  }\n\n  eventHandling(this, 'ready', 'connected', 'disconnected', 'not-connected', 'conflict', 'error', 'features-loaded', 'connecting', 'authing', 'sync-interval-change', 'wire-busy', 'wire-done', 'network-offline', 'network-online');\n\n  // pending get/put/delete calls.\n  this._pending = [];\n\n  this._setGPD({\n    get: this._pendingGPD('get'),\n    put: this._pendingGPD('put'),\n    delete: this._pendingGPD('delete')\n  });\n\n  this._cleanups = [];\n\n  this._pathHandlers = { change: {} };\n\n  this.apiKeys = {};\n\n  hasLocalStorage = util.localStorageAvailable();\n\n  if (hasLocalStorage) {\n    try {\n      this.apiKeys = JSON.parse(localStorage.getItem('remotestorage:api-keys')) || {};\n    } catch (exc) {\n      // ignored\n    }\n    this.setBackend(localStorage.getItem('remotestorage:backend') || 'remotestorage');\n  }\n\n  var origOn = this.on;\n\n  this.on = function (eventName, handler) {\n    if (eventName === 'ready' && this.remote && this.remote.connected && this._allLoaded) {\n      setTimeout(handler, 0);\n    } else if (eventName === 'features-loaded' && this._allLoaded) {\n      setTimeout(handler, 0);\n    }\n    return origOn.call(this, eventName, handler);\n  };\n\n  // load all features and emit `ready`\n  this._init();\n\n  this.fireInitial = function () {\n    if (this.local) {\n      setTimeout(this.local.fireInitial.bind(this.local), 0);\n    }\n  }.bind(this);\n\n  this.on('ready', this.fireInitial.bind(this));\n};\n\n// TOFIX: Instead of doing this, would be better to only \n// export setAuthURL / getAuthURL from RemoteStorage prototype\nRemoteStorage.Authorize = Authorize;\n\nRemoteStorage.SyncError = Sync.SyncError;\nRemoteStorage.Unauthorized = Authorize.Unauthorized;\nRemoteStorage.DiscoveryError = Discover.DiscoveryError;\n\nRemoteStorage.prototype = (_RemoteStorage$protot = {\n  authorize: function authorize(authURL, cordovaRedirectUri) {\n    this.access.setStorageType(this.remote.storageType);\n    var scope = this.access.scopeParameter;\n\n    var redirectUri = globalContext.cordova ? cordovaRedirectUri : String(Authorize.getLocation());\n\n    var clientId = redirectUri.match(/^(https?:\\/\\/[^\\/]+)/)[0];\n\n    Authorize(this, authURL, scope, redirectUri, clientId);\n  },\n\n  /**\n   * Property: remote\n   *\n   * Properties:\n   *\n   *   connected   - Boolean, whether or not a remote store is connected\n   *   online      - Boolean, whether last sync action was successful or not\n   *   userAddress - String, the user address of the connected user\n   *   properties  - String, the properties of the WebFinger link\n   */\n\n  /**\n   * Method: scope\n   *\n   * Returns a BaseClient with a certain scope (base path). Please use this method\n   * only for debugging, and always use defineModule instead, to get access to a\n   * BaseClient from a module in an app.\n   *\n   * Parameters:\n   *\n   *   scope - A string, with a leading and a trailing slash, specifying the\n   *           base path of the BaseClient that will be returned.\n   *\n   * Code example:\n   *\n   * (start code)\n   * remoteStorage.scope('/pictures/').getListing('');\n   * remoteStorage.scope('/public/pictures/').getListing('');\n   */\n\n  /**\n   * Method: startSync\n   *\n   * Start synchronization with remote storage, downloading and uploading any\n   * changes within the cached paths.\n   *\n   * Please consider: local changes will attempt sync immediately, and remote\n   * changes should also be synced timely when using library defaults. So\n   * this is mostly useful for letting users sync manually, when pressing a\n   * sync button for example. This might feel safer to them sometimes, esp.\n   * when shifting between offline and online a lot.\n   */\n  // (see src/sync.js for implementation)\n\n  /**\n   * Method: connect\n   *\n   * Connect to a remoteStorage server.\n   *\n   * Parameters:\n   *   userAddress        - The user address (user@host) to connect to.\n   *   token              - (optional) A bearer token acquired beforehand\n   *\n   * Discovers the WebFinger profile of the given user address and initiates\n   * the OAuth dance.\n   *\n   * This method must be called *after* all required access has been claimed.\n   * When using the connect widget, it will call this method itself.\n   *\n   * Special cases:\n   *\n   * 1. If a bearer token is supplied as second argument, the OAuth dance\n   *    will be skipped and the supplied token be used instead. This is\n   *    useful outside of browser environments, where the token has been\n   *    acquired in a different way.\n   *\n   * 2. If the Webfinger profile for the given user address doesn't contain\n   *    an auth URL, the library will assume that client and server have\n   *    established authorization among themselves, which will omit bearer\n   *    tokens in all requests later on. This is useful for example when using\n   *    Kerberos and similar protocols.\n   */\n  connect: function connect(userAddress, token) {\n    this.setBackend('remotestorage');\n    if (userAddress.indexOf('@') < 0) {\n      this._emit('error', new RemoteStorage.DiscoveryError(\"User address doesn't contain an @.\"));\n      return;\n    }\n\n    if (globalContext.cordova) {\n      if (typeof config.cordovaRedirectUri !== 'string') {\n        this._emit('error', new RemoteStorage.DiscoveryError(\"Please supply a custom HTTPS redirect URI for your Cordova app\"));\n        return;\n      }\n      if (!globalContext.cordova.InAppBrowser) {\n        this._emit('error', new RemoteStorage.DiscoveryError(\"Please include the InAppBrowser Cordova plugin to enable OAuth\"));\n        return;\n      }\n    }\n\n    this.remote.configure({\n      userAddress: userAddress\n    });\n    this._emit('connecting');\n\n    var discoveryTimeout = setTimeout(function () {\n      this._emit('error', new RemoteStorage.DiscoveryError(\"No storage information found for this user address.\"));\n    }.bind(this), config.discoveryTimeout);\n\n    Discover(userAddress).then(function (info) {\n      // Info contains fields: href, storageApi, authURL (optional), properties\n\n      clearTimeout(discoveryTimeout);\n      this._emit('authing');\n      info.userAddress = userAddress;\n      this.remote.configure(info);\n      if (!this.remote.connected) {\n        if (info.authURL) {\n          if (typeof token === 'undefined') {\n            // Normal authorization step; the default way to connect\n            this.authorize(info.authURL, config.cordovaRedirectUri);\n          } else if (typeof token === 'string') {\n            // Token supplied directly by app/developer/user\n            _log('Skipping authorization sequence and connecting with known token');\n            this.remote.configure({ token: token });\n          } else {\n            throw new Error(\"Supplied bearer token must be a string\");\n          }\n        } else {\n          // In lieu of an excplicit authURL, assume that the browser and\n          // server handle any authorization needs; for instance, TLS may\n          // trigger the browser to use a client certificate, or a 401 Not\n          // Authorized response may make the browser send a Kerberos ticket\n          // using the SPNEGO method.\n          this.impliedauth();\n        }\n      }\n    }.bind(this), function (err) {\n      clearTimeout(discoveryTimeout);\n      this._emit('error', new RemoteStorage.DiscoveryError(\"No storage information found for this user address.\"));\n    }.bind(this));\n  },\n\n  /**\n   * Method: disconnect\n   *\n   * \"Disconnect\" from remotestorage server to terminate current session.\n   * This method clears all stored settings and deletes the entire local\n   * cache.\n   */\n  disconnect: function disconnect() {\n    if (this.remote) {\n      this.remote.configure({\n        userAddress: null,\n        href: null,\n        storageApi: null,\n        token: null,\n        properties: null\n      });\n    }\n    this._setGPD({\n      get: this._pendingGPD('get'),\n      put: this._pendingGPD('put'),\n      delete: this._pendingGPD('delete')\n    });\n    var n = this._cleanups.length,\n        i = 0;\n\n    var oneDone = function () {\n      i++;\n      if (i >= n) {\n        this._init();\n        _log('Done cleaning up, emitting disconnected and disconnect events');\n        this._emit('disconnected');\n      }\n    }.bind(this);\n\n    if (n > 0) {\n      this._cleanups.forEach(function (cleanup) {\n        var cleanupResult = cleanup(this);\n        if ((typeof cleanupResult === 'undefined' ? 'undefined' : _typeof(cleanupResult)) === 'object' && typeof cleanupResult.then === 'function') {\n          cleanupResult.then(oneDone);\n        } else {\n          oneDone();\n        }\n      }.bind(this));\n    } else {\n      oneDone();\n    }\n  },\n\n  setBackend: function setBackend(what) {\n    this.backend = what;\n    if (hasLocalStorage) {\n      if (what) {\n        localStorage.setItem('remotestorage:backend', what);\n      } else {\n        localStorage.removeItem('remotestorage:backend');\n      }\n    }\n  },\n\n  /**\n   * Method: onChange\n   *\n   * Add a \"change\" event handler to the given path. Whenever a \"change\"\n   * happens (as determined by the backend, such as e.g.\n   * <RemoteStorage.IndexedDB>) and the affected path is equal to or below\n   * the given 'path', the given handler is called.\n   *\n   * You should usually not use this method directly, but instead use the\n   * \"change\" events provided by <RemoteStorage.BaseClient>.\n   *\n   * Parameters:\n   *   path    - Absolute path to attach handler to.\n   *   handler - Handler function.\n   */\n  onChange: function onChange(path, handler) {\n    if (!this._pathHandlers.change[path]) {\n      this._pathHandlers.change[path] = [];\n    }\n    this._pathHandlers.change[path].push(handler);\n  },\n\n  /**\n   * Method: enableLog\n   *\n   * Enable remoteStorage logging.\n   */\n  enableLog: function enableLog() {\n    config.logging = true;\n  },\n\n  /**\n   * Method: disableLog\n   *\n   * Disable remoteStorage logging\n   */\n  disableLog: function disableLog() {\n    config.logging = false;\n  },\n\n  /**\n   * Method: log\n   *\n   * The same as <RemoteStorage.log>.\n   */\n  log: function log() {\n    _log.apply(RemoteStorage, arguments);\n  },\n\n  /**\n   * Method: setApiKeys (experimental)\n   *\n   * Set API keys for (currently) GoogleDrive and/or Dropbox backend support.\n   * See also the 'backends' example in the starter-kit. Note that support for\n   * both these backends is still experimental.\n   *\n   * Parameters:\n   *   type - string, either 'googledrive' or 'dropbox'\n   *   keys - object, with one string field; 'clientId' for GoogleDrive, or\n   *          'appKey' for Dropbox.\n   *\n   */\n  setApiKeys: function setApiKeys(type, keys) {\n    if (keys) {\n      this.apiKeys[type] = keys;\n      if (type === 'dropbox' && (typeof this.dropbox === 'undefined' || this.dropbox.clientId !== keys.appKey)) {\n        Dropbox._rs_init(this);\n      } else if (type === 'googledrive' && (typeof this.googledrive === 'undefined' || this.googledrive.clientId !== keys.clientId)) {\n        GoogleDrive._rs_init(this);\n      }\n    } else {\n      delete this.apiKeys[type];\n    }\n    if (hasLocalStorage) {\n      localStorage.setItem('remotestorage:api-keys', JSON.stringify(this.apiKeys));\n    }\n  },\n\n  /**\n   * Method: setCordovaRedirectUri\n   *\n   * Set redirect URI to be used for the OAuth redirect within the\n   * in-app-browser window in Cordova apps.\n   *\n   * Parameters:\n   *   uri - string, valid HTTP(S) URI\n   */\n  setCordovaRedirectUri: function setCordovaRedirectUri(uri) {\n    if (typeof uri !== 'string' || !uri.match(/http(s)?\\:\\/\\//)) {\n      throw new Error(\"Cordova redirectingect URI must be a URI string\");\n    }\n    config.cordovaRedirectUri = uri;\n  },\n\n  /* FEATURES INITIALIZATION */\n  _init: Features.loadFeatures,\n  features: Features.features,\n  loadFeature: Features.loadFeature,\n  featureSupported: Features.featureSupported,\n  featureDone: Features.featureDone,\n  featuresDone: Features.featuresDone,\n  featuresLoaded: Features.featuresLoaded,\n  featureInitialized: Features.featureInitialized,\n  featureFailed: Features.featureFailed\n}, _defineProperty(_RemoteStorage$protot, 'featureSupported', Features.featureSupported), _defineProperty(_RemoteStorage$protot, 'hasFeature', Features.hasFeature), _defineProperty(_RemoteStorage$protot, '_setCachingModule', Features._setCachingModule), _defineProperty(_RemoteStorage$protot, '_collectCleanupFunctions', Features._collectCleanupFunctions), _defineProperty(_RemoteStorage$protot, '_fireReady', Features._fireReady), _defineProperty(_RemoteStorage$protot, 'initFeature', Features.initFeature), _defineProperty(_RemoteStorage$protot, '_setGPD', function _setGPD(impl, context) {\n  function wrap(func) {\n    return function () {\n      return func.apply(context, arguments).then(emitUnauthorized.bind(this));\n    };\n  }\n  this.get = wrap(impl.get);\n  this.put = wrap(impl.put);\n  this.delete = wrap(impl.delete);\n}), _defineProperty(_RemoteStorage$protot, '_pendingGPD', function _pendingGPD(methodName) {\n  return function () {\n    var pending = Promise.defer();\n    this._pending.push({\n      method: methodName,\n      args: Array.prototype.slice.call(arguments),\n      promise: pending\n    });\n    return pending.promise;\n  }.bind(this);\n}), _defineProperty(_RemoteStorage$protot, '_processPending', function _processPending() {\n  this._pending.forEach(function (pending) {\n    try {\n      this[pending.method].apply(this, pending.args).then(pending.promise.resolve, pending.promise.reject);\n    } catch (e) {\n      pending.promise.reject(e);\n    }\n  }.bind(this));\n  this._pending = [];\n}), _defineProperty(_RemoteStorage$protot, '_bindChange', function _bindChange(object) {\n  object.on('change', this._dispatchEvent.bind(this, 'change'));\n}), _defineProperty(_RemoteStorage$protot, '_dispatchEvent', function _dispatchEvent(eventName, event) {\n  var self = this;\n  Object.keys(this._pathHandlers[eventName]).forEach(function (path) {\n    var pl = path.length;\n    if (event.path.substr(0, pl) === path) {\n      self._pathHandlers[eventName][path].forEach(function (handler) {\n        var ev = {};\n        for (var key in event) {\n          ev[key] = event[key];\n        }\n        ev.relativePath = event.path.replace(new RegExp('^' + path), '');\n        try {\n          handler(ev);\n        } catch (e) {\n          console.error(\"'change' handler failed: \", e, e.stack);\n          self._emit('error', e);\n        }\n      });\n    }\n  });\n}), _defineProperty(_RemoteStorage$protot, 'scope', function scope(path) {\n  if (typeof path !== 'string') {\n    throw 'Argument \\'path\\' of baseClient.scope must be a string';\n  }\n\n  if (!this.access.checkPathPermission(path, 'r')) {\n    var escapedPath = path.replace(/(['\\\\])/g, '\\\\$1');\n    console.warn('WARNING: please call remoteStorage.access.claim(\\'' + escapedPath + '\\', \\'r\\') (read only) or remoteStorage.access.claim(\\'' + escapedPath + '\\', \\'rw\\') (read/write) first');\n  }\n  return new BaseClient(this, path);\n}), _defineProperty(_RemoteStorage$protot, 'getSyncInterval', function getSyncInterval() {\n  return config.syncInterval;\n}), _defineProperty(_RemoteStorage$protot, 'setSyncInterval', function setSyncInterval(interval) {\n  if (!isValidInterval(interval)) {\n    throw interval + \" is not a valid sync interval\";\n  }\n  var oldValue = config.syncInterval;\n  config.syncInterval = parseInt(interval, 10);\n  this._emit('sync-interval-change', { oldValue: oldValue, newValue: interval });\n}), _defineProperty(_RemoteStorage$protot, 'getBackgroundSyncInterval', function getBackgroundSyncInterval() {\n  return config.backgroundSyncInterval;\n}), _defineProperty(_RemoteStorage$protot, 'setBackgroundSyncInterval', function setBackgroundSyncInterval(interval) {\n  if (!isValidInterval(interval)) {\n    throw interval + \" is not a valid sync interval\";\n  }\n  var oldValue = config.backgroundSyncInterval;\n  config.backgroundSyncInterval = parseInt(interval, 10);\n  this._emit('sync-interval-change', { oldValue: oldValue, newValue: interval });\n}), _defineProperty(_RemoteStorage$protot, 'getCurrentSyncInterval', function getCurrentSyncInterval() {\n  return config.isBackground ? config.backgroundSyncInterval : config.syncInterval;\n}), _defineProperty(_RemoteStorage$protot, 'syncCycle', function syncCycle() {\n  if (this.sync.stopped) {\n    return;\n  }\n\n  this.sync.on('done', function () {\n    _log('[Sync] Sync done. Setting timer to', this.getCurrentSyncInterval());\n    if (!this.sync.stopped) {\n      if (this._syncTimer) {\n        clearTimeout(this._syncTimer);\n      }\n      this._syncTimer = setTimeout(this.sync.sync.bind(this.sync), this.getCurrentSyncInterval());\n    }\n  }.bind(this));\n\n  this.sync.sync();\n}), _defineProperty(_RemoteStorage$protot, 'stopSync', function stopSync() {\n  if (this.sync) {\n    _log('[Sync] Stopping sync');\n    this.sync.stopped = true;\n  } else {\n    // TODO When is this ever the case and what is syncStopped for then?\n    _log('[Sync] Will instantiate sync stopped');\n    this.syncStopped = true;\n  }\n}), _defineProperty(_RemoteStorage$protot, 'startSync', function startSync() {\n  if (!config.cache) return;\n  this.sync.stopped = false;\n  this.syncStopped = false;\n  this.sync.sync();\n}), _RemoteStorage$protot);\n\n/**\n* Check if interval is valid: numeric and between 1000ms and 3600000ms\n*\n*/\nfunction isValidInterval(interval) {\n  return typeof interval === 'number' && interval > 1000 && interval < 3600000;\n}\n\nRemoteStorage.util = util;\n// RemoteStorage.defineModule = modules.defineModule;\n\n/**\n * Property: connected\n *\n * Boolean property indicating if remoteStorage is currently connected.\n */\nObject.defineProperty(RemoteStorage.prototype, 'connected', {\n  get: function get() {\n    return this.remote.connected;\n  }\n});\n\n/**\n * Property: access\n *\n * Tracking claimed access scopes. A <RemoteStorage.Access> instance.\n*/\nvar Access = __webpack_require__(26);\nObject.defineProperty(RemoteStorage.prototype, 'access', {\n  get: function get() {\n    var access = new Access();\n    Object.defineProperty(this, 'access', {\n      value: access\n    });\n    return access;\n  },\n  configurable: true\n});\n\n/* TOFIX (in sync.js also... has to be a shared property) */\nconfig.syncInterval = 10000, config.backgroundSyncInterval = 60000, config.isBackground = false;\n\n// TODO clean up/harmonize how modules are loaded and/or document this architecture properly\n//\n// At this point the remoteStorage object has not been created yet.\n// Only its prototype exists so far, so we define a self-constructing\n// property on there:\n/**\n *\n * Property: caching\n *\n * Caching settings. A <RemoteStorage.Caching> instance.\n *\n * Not available in no-cache builds.\n *\n */\nvar Caching = __webpack_require__(27);\nObject.defineProperty(RemoteStorage.prototype, 'caching', {\n  configurable: true,\n  get: function get() {\n    var caching = new Caching();\n    Object.defineProperty(this, 'caching', {\n      value: caching\n    });\n    return caching;\n  }\n});\n\n/*\n* Property: remote\n*\n* Access to the remote backend used. Usually a <RemoteStorage.WireClient>.\n*\n*\n* Property: local\n*\n* Access to the local caching backend used. Usually either a\n* <RemoteStorage.IndexedDB> or <RemoteStorage.LocalStorage> instance.\n*\n* Not available in no-cache builds.\n*/\n\nmodule.exports = RemoteStorage;\n__webpack_require__(32);\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvcmVtb3Rlc3RvcmFnZS5qcz9hMTc4Il0sIm5hbWVzIjpbImhhc0xvY2FsU3RvcmFnZSIsImVtaXRVbmF1dGhvcml6ZWQiLCJyIiwic3RhdHVzQ29kZSIsIl9lbWl0IiwiQXV0aG9yaXplIiwiVW5hdXRob3JpemVkIiwiUHJvbWlzZSIsInJlc29sdmUiLCJ1dGlsIiwicmVxdWlyZSIsIkRyb3Bib3giLCJHb29nbGVEcml2ZSIsIkRpc2NvdmVyIiwiQmFzZUNsaWVudCIsImNvbmZpZyIsIlN5bmMiLCJTeW5jZWRHZXRQdXREZWxldGUiLCJsb2ciLCJGZWF0dXJlcyIsImdsb2JhbENvbnRleHQiLCJnZXRHbG9iYWxDb250ZXh0IiwiZXZlbnRIYW5kbGluZyIsIlJlbW90ZVN0b3JhZ2UiLCJjZmciLCJsb2dnaW5nIiwiY2FjaGUiLCJjb3Jkb3ZhUmVkaXJlY3RVcmkiLCJfcGVuZGluZyIsIl9zZXRHUEQiLCJnZXQiLCJfcGVuZGluZ0dQRCIsInB1dCIsImRlbGV0ZSIsIl9jbGVhbnVwcyIsIl9wYXRoSGFuZGxlcnMiLCJjaGFuZ2UiLCJhcGlLZXlzIiwibG9jYWxTdG9yYWdlQXZhaWxhYmxlIiwiSlNPTiIsInBhcnNlIiwibG9jYWxTdG9yYWdlIiwiZ2V0SXRlbSIsImV4YyIsInNldEJhY2tlbmQiLCJvcmlnT24iLCJvbiIsImV2ZW50TmFtZSIsImhhbmRsZXIiLCJyZW1vdGUiLCJjb25uZWN0ZWQiLCJfYWxsTG9hZGVkIiwic2V0VGltZW91dCIsImNhbGwiLCJfaW5pdCIsImZpcmVJbml0aWFsIiwibG9jYWwiLCJiaW5kIiwiU3luY0Vycm9yIiwiRGlzY292ZXJ5RXJyb3IiLCJwcm90b3R5cGUiLCJhdXRob3JpemUiLCJhdXRoVVJMIiwiYWNjZXNzIiwic2V0U3RvcmFnZVR5cGUiLCJzdG9yYWdlVHlwZSIsInNjb3BlIiwic2NvcGVQYXJhbWV0ZXIiLCJyZWRpcmVjdFVyaSIsImNvcmRvdmEiLCJTdHJpbmciLCJnZXRMb2NhdGlvbiIsImNsaWVudElkIiwibWF0Y2giLCJjb25uZWN0IiwidXNlckFkZHJlc3MiLCJ0b2tlbiIsImluZGV4T2YiLCJJbkFwcEJyb3dzZXIiLCJjb25maWd1cmUiLCJkaXNjb3ZlcnlUaW1lb3V0IiwidGhlbiIsImluZm8iLCJjbGVhclRpbWVvdXQiLCJFcnJvciIsImltcGxpZWRhdXRoIiwiZXJyIiwiZGlzY29ubmVjdCIsImhyZWYiLCJzdG9yYWdlQXBpIiwicHJvcGVydGllcyIsIm4iLCJsZW5ndGgiLCJpIiwib25lRG9uZSIsImZvckVhY2giLCJjbGVhbnVwIiwiY2xlYW51cFJlc3VsdCIsIndoYXQiLCJiYWNrZW5kIiwic2V0SXRlbSIsInJlbW92ZUl0ZW0iLCJvbkNoYW5nZSIsInBhdGgiLCJwdXNoIiwiZW5hYmxlTG9nIiwiZGlzYWJsZUxvZyIsImFwcGx5IiwiYXJndW1lbnRzIiwic2V0QXBpS2V5cyIsInR5cGUiLCJrZXlzIiwiZHJvcGJveCIsImFwcEtleSIsIl9yc19pbml0IiwiZ29vZ2xlZHJpdmUiLCJzdHJpbmdpZnkiLCJzZXRDb3Jkb3ZhUmVkaXJlY3RVcmkiLCJ1cmkiLCJsb2FkRmVhdHVyZXMiLCJmZWF0dXJlcyIsImxvYWRGZWF0dXJlIiwiZmVhdHVyZVN1cHBvcnRlZCIsImZlYXR1cmVEb25lIiwiZmVhdHVyZXNEb25lIiwiZmVhdHVyZXNMb2FkZWQiLCJmZWF0dXJlSW5pdGlhbGl6ZWQiLCJmZWF0dXJlRmFpbGVkIiwiaGFzRmVhdHVyZSIsIl9zZXRDYWNoaW5nTW9kdWxlIiwiX2NvbGxlY3RDbGVhbnVwRnVuY3Rpb25zIiwiX2ZpcmVSZWFkeSIsImluaXRGZWF0dXJlIiwiaW1wbCIsImNvbnRleHQiLCJ3cmFwIiwiZnVuYyIsIm1ldGhvZE5hbWUiLCJwZW5kaW5nIiwiZGVmZXIiLCJtZXRob2QiLCJhcmdzIiwiQXJyYXkiLCJzbGljZSIsInByb21pc2UiLCJyZWplY3QiLCJlIiwib2JqZWN0IiwiX2Rpc3BhdGNoRXZlbnQiLCJldmVudCIsInNlbGYiLCJPYmplY3QiLCJwbCIsInN1YnN0ciIsImV2Iiwia2V5IiwicmVsYXRpdmVQYXRoIiwicmVwbGFjZSIsIlJlZ0V4cCIsImNvbnNvbGUiLCJlcnJvciIsInN0YWNrIiwiY2hlY2tQYXRoUGVybWlzc2lvbiIsImVzY2FwZWRQYXRoIiwid2FybiIsInN5bmNJbnRlcnZhbCIsImludGVydmFsIiwiaXNWYWxpZEludGVydmFsIiwib2xkVmFsdWUiLCJwYXJzZUludCIsIm5ld1ZhbHVlIiwiYmFja2dyb3VuZFN5bmNJbnRlcnZhbCIsImlzQmFja2dyb3VuZCIsInN5bmMiLCJzdG9wcGVkIiwiZ2V0Q3VycmVudFN5bmNJbnRlcnZhbCIsIl9zeW5jVGltZXIiLCJzeW5jU3RvcHBlZCIsImRlZmluZVByb3BlcnR5IiwiQWNjZXNzIiwidmFsdWUiLCJjb25maWd1cmFibGUiLCJDYWNoaW5nIiwiY2FjaGluZyIsIm1vZHVsZSIsImV4cG9ydHMiXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7OztBQUNFLElBQUlBLGVBQUo7O0FBRUEsU0FBU0MsZ0JBQVQsQ0FBMEJDLENBQTFCLEVBQTZCO0FBQzNCLE1BQUlBLEVBQUVDLFVBQUYsS0FBaUIsR0FBakIsSUFBeUJELEVBQUVDLFVBQUYsS0FBaUIsR0FBOUMsRUFBbUQ7QUFDakQsU0FBS0MsS0FBTCxDQUFXLE9BQVgsRUFBb0IsSUFBSUMsVUFBVUMsWUFBZCxFQUFwQjtBQUNEO0FBQ0QsU0FBT0MsUUFBUUMsT0FBUixDQUFnQk4sQ0FBaEIsQ0FBUDtBQUNEOztBQUVELElBQU1PLE9BQU8sbUJBQUFDLENBQVEsQ0FBUixDQUFiO0FBQ0EsSUFBTUMsVUFBVSxtQkFBQUQsQ0FBUSxDQUFSLENBQWhCO0FBQ0EsSUFBTUUsY0FBYyxtQkFBQUYsQ0FBUSxFQUFSLENBQXBCO0FBQ0EsSUFBTUcsV0FBVyxtQkFBQUgsQ0FBUSxFQUFSLENBQWpCO0FBQ0EsSUFBTUksYUFBYSxtQkFBQUosQ0FBUSxDQUFSLENBQW5CO0FBQ0EsSUFBTUssU0FBUyxtQkFBQUwsQ0FBUSxDQUFSLENBQWY7QUFDQSxJQUFNTCxZQUFZ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Ozs7QUFTQSxJQUFJVSxVQUFVLG1CQUFBNUssQ0FBUSxFQUFSLENBQWQ7QUFDQTZJLE9BQU8yQixjQUFQLENBQXNCM0osY0FBY3FDLFNBQXBDLEVBQStDLFNBQS9DLEVBQTBEO0FBQ3hEeUgsZ0JBQWMsSUFEMEM7QUFFeER2SixPQUFLLGVBQVk7QUFDZixRQUFJeUosVUFBVSxJQUFJRCxPQUFKLEVBQWQ7QUFDQS9CLFdBQU8yQixjQUFQLENBQXNCLElBQXRCLEVBQTRCLFNBQTVCLEVBQXVDO0FBQ3JDRSxhQUFPRztBQUQ4QixLQUF2QztBQUdBLFdBQU9BLE9BQVA7QUFDRDtBQVJ1RCxDQUExRDs7QUFXQzs7Ozs7Ozs7Ozs7Ozs7QUFlSEMsT0FBT0MsT0FBUCxHQUFpQmxLLGFBQWpCO0FBQ0EsbUJBQUFiLENBQVEsRUFBUiIsImZpbGUiOiIxLmpzIiwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuICB2YXIgaGFzTG9jYWxTdG9yYWdlO1xuXG4gIGZ1bmN0aW9uIGVtaXRVbmF1dGhvcml6ZWQocikge1xuICAgIGlmIChyLnN0YXR1c0NvZGUgPT09IDQwMyAgfHwgci5zdGF0dXNDb2RlID09PSA0MDEpIHtcbiAgICAgIHRoaXMuX2VtaXQoJ2Vycm9yJywgbmV3IEF1dGhvcml6ZS5VbmF1dGhvcml6ZWQoKSk7XG4gICAgfVxuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUocik7XG4gIH1cblxuICBjb25zdCB1dGlsID0gcmVxdWlyZSgnLi91dGlsJylcbiAgY29uc3QgRHJvcGJveCA9IHJlcXVpcmUoJy4vZHJvcGJveCcpO1xuICBjb25zdCBHb29nbGVEcml2ZSA9IHJlcXVpcmUoJy4vZ29vZ2xlZHJpdmUnKTtcbiAgY29uc3QgRGlzY292ZXIgPSByZXF1aXJlKCcuL2Rpc2NvdmVyJyk7XG4gIGNvbnN0IEJhc2VDbGllbnQgPSByZXF1aXJlKCcuL2Jhc2VjbGllbnQnKTtcbiAgY29uc3QgY29uZmlnID0gcmVxdWlyZSgnLi9jb25maWcnKTtcbiAgY29uc3QgQXV0aG9yaXplID0gcmVxdWlyZSgnLi9hdXRob3JpemUnKTtcbiAgY29uc3QgU3luYyA9IHJlcXVpcmUoJy4vc3luYycpO1xuICBjb25zdCBTeW5jZWRHZXRQdXREZWxldGUgPSByZXF1aXJlKCcuL3N5bmNlZGdldHB1dGRlbGV0ZScpO1xuICBjb25zdCBsb2cgPSByZXF1aXJlKCcuL2xvZycpO1xuICBjb25zdCBGZWF0dXJlcyA9IHJlcXVpcmUoJy4vZmVhdHVyZXMnKTtcbiAgY29uc3QgZ2xvYmFsQ29udGV4dCA9IHV0aWwuZ2V0R2xvYmFsQ29udGV4dCgpO1xuICBjb25zdCBldmVudEhhbmRsaW5nID0gcmVxdWlyZSgnLi9ldmVudGhhbmRsaW5nJyk7XG5cblxuICAvKipcbiAgICogQ2xhc3M6IFJlbW90ZVN0b3JhZ2VcbiAgICpcbiAgICogVE9ETyBuZWVkcyBwcm9wZXIgaW50cm9kdWN0aW9uIGFuZCBsaW5rcyB0byByZWxldmFudCBjbGFzc2VzIGV0Y1xuICAgKlxuICAgKiBDb25zdHJ1Y3RvciBmb3IgcmVtb3RlU3RvcmFnZSBvYmplY3QuXG4gICAqXG4gICAqIFRoaXMgY2xhc3MgcHJpbWFyaWx5IGNvbnRhaW5zIGZlYXR1cmUgZGV0ZWN0aW9uIGNvZGUgYW5kIGNvbnZlbmllbmNlIEFQSS5cbiAgICpcbiAgICogRGVwZW5kaW5nIG9uIHdoaWNoIGZlYXR1cmVzIGFyZSBidWlsdCBpbiwgaXQgY29udGFpbnMgZGlmZmVyZW50IGF0dHJpYnV0ZXMgYW5kXG4gICAqIGZ1bmN0aW9ucy4gU2VlIHRoZSBpbmRpdmlkdWFsIGZlYXR1cmVzIGZvciBtb3JlIGluZm9ybWF0aW9uLlxuICAgKlxuICAgKiAgKHN0YXJ0IGNvZGUpXG4gICAqICB2YXIgcmVtb3RlU3RvcmFnZSA9IG5ldyBSZW1vdGVTdG9yYWdlKHtcbiAgICogICAgbG9nZ2luZzogdHJ1ZSwgIC8vIGRlZmF1bHRzIHRvIGZhbHNlXG4gICAqICAgIGNvcmRvdmFSZWRpcmVjdFVyaTogJ2h0dHBzOi8vYXBwLm15Z3JlYXRhcHAuY29tJyAvLyBkZWZhdWx0cyB0byB1bmRlZmluZWRcbiAgICogIH0pO1xuICAgKiAgKGVuZCBjb2RlKVxuICAgKi9cbiAgdmFyIFJlbW90ZVN0b3JhZ2UgPSBmdW5jdGlvbiAoY2ZnKSB7XG4gICAgLyoqXG4gICAgICogRXZlbnQ6IHJlYWR5XG4gICAgICpcbiAgICAgKiBGaXJlZCB3aGVuIHJlYWR5XG4gICAgICoqL1xuICAgIC8qKlxuICAgICAqIEV2ZW50OiBub3QtY29ubmVjdGVkXG4gICAgICpcbiAgICAgKiBGaXJlZCB3aGVuIHJlYWR5LCBidXQgbm8gc3RvcmFnZSBjb25uZWN0ZWQgKFwiYW5vbnltb3VzIG1vZGVcIilcbiAgICAgKiovXG4gICAgLyoqXG4gICAgICogRXZlbnQ6IGNvbm5lY3RlZFxuICAgICAqXG4gICAgICogRmlyZWQgd2hlbiBhIHJlbW90ZSBzdG9yYWdlIGhhcyBiZWVuIGNvbm5lY3RlZFxuICAgICAqKi9cbiAgICAvKipcbiAgICAgKiBFdmVudDogZGlzY29ubmVjdGVkXG4gICAgICpcbiAgICAgKiBGaXJlZCBhZnRlciBkaXNjb25uZWN0XG4gICAgICoqL1xuICAgIC8qKlxuICAgICAqIEV2ZW50OiBlcnJvclxuICAgICAqXG4gICAgICogRmlyZWQgd2hlbiBhbiBlcnJvciBvY2N1cnNcbiAgICAgKlxuICAgICAqIEFyZ3VtZW50czpcbiAgICAgKiB0aGUgZXJyb3JcbiAgICAgKiovXG4gICAgLyoqXG4gICAgICogRXZlbnQ6IGZlYXR1cmVzLWxvYWRlZFxuICAgICAqXG4gICAgICogRmlyZWQgd2hlbiBhbGwgZmVhdHVyZXMgYXJlIGxvYWRlZFxuICAgICAqKi9cbiAgICAvKipcbiAgICAgKiBFdmVudDogY29ubmVjdGluZ1xuICAgICAqXG4gICAgICogRmlyZWQgYmVmb3JlIHdlYmZpbmdlciBsb29rdXBcbiAgICAgKiovXG4gICAgLyoqXG4gICAgICogRXZlbnQ6IGF1dGhpbmdcbiAgICAgKlxuICAgICAqIEZpcmVkIGJlZm9yZSByZWRpcmVjdGluZyB0byB0aGUgYXV0aGluZyBzZXJ2ZXJcbiAgICAgKiovXG4gICAgLyoqXG4gICAgICogRXZlbnQ6IHdpcmUtYnVzeVxuICAgICAqXG4gICAgICogRmlyZWQgd2hlbiBhIHdpcmUgcmVxdWVzdCBzdGFydHNcbiAgICAgKiovXG4gICAgLyoqXG4gICAgICogRXZlbnQ6IHdpcmUtZG9uZVxuICAgICAqXG4gICAgICogRmlyZWQgd2hlbiBhIHdpcmUgcmVxdWVzdCBjb21wbGV0ZXNcbiAgICAgKiovXG4gICAgLyoqXG4gICAgICogRXZlbnQ6IG5ldHdvcmstb2ZmbGluZVxuICAgICAqXG4gICAgICogRmlyZWQgb25jZSB3aGVuIGEgd2lyZSByZXF1ZXN0IGZhaWxzIGZvciB0aGUgZmlyc3QgdGltZSwgYW5kXG4gICAgICogYHJlbW90ZS5vbmxpbmVgIGlzIHNldCB0byBmYWxzZVxuICAgICAqKi9cbiAgICAvKipcbiAgICAgKiBFdmVudDogbmV0d29yay1vbmxpbmVcbiAgICAgKlxuICAgICAqIEZpcmVkIG9uY2Ugd2hlbiBhIHdpcmUgcmVxdWVzdCBzdWNjZWVkcyBmb3IgdGhlIGZpcnN0IHRpbWUgYWZ0ZXIgYVxuICAgICAqIGZhaWxlZCBvbmUsIGFuZCBgcmVtb3RlLm9ubGluZWAgaXMgc2V0IGJhY2sgdG8gdHJ1ZVxuICAgICAqKi9cblxuICAgIC8vIEluaXRpYWwgY29uZmlndXJhdGlvbiBwcm9wZXJ0eSBzZXR0aW5ncy5cbiAgICAvLyBUT0RPIG1lcmdlIHVzZXIgY29uZmlndXJhdGlvbiB3aXRoIGRlZmF1bHQgY29uZmlndXJhdGlvblxuICAgIGlmICh0eXBlb2YgY2ZnID09PSAnb2JqZWN0Jykge1xuICAgICAgY29uZmlnLmxvZ2dpbmcgPSAhIWNmZy5sb2dnaW5nO1xuICAgICAgY29uZmlnLmNhY2hlID0gISFjZmcuY2FjaGU7XG4gICAgICBjb25maWcuY29yZG92YVJlZGlyZWN0VXJpID0gY2ZnLmNvcmRvdmFSZWRpcmVjdFVyaTtcbiAgICB9XG5cbiAgICBldmVudEhhbmRsaW5nKFxuICAgICAgdGhpcywgJ3JlYWR5JywgJ2Nvbm5lY3RlZCcsICdkaXNjb25uZWN0ZWQnLCAnbm90LWNvbm5lY3RlZCcsICdjb25mbGljdCcsXG4gICAgICAgICAgICAnZXJyb3InLCAnZmVhdHVyZXMtbG9hZGVkJywgJ2Nvbm5lY3RpbmcnLCAnYXV0aGluZycsXG4gICAgICAgICAgICAnc3luYy1pbnRlcnZhbC1jaGFuZ2UnLCAnd2lyZS1idXN5JywgJ3dpcmUtZG9uZScsXG4gICAgICAgICAgICAnbmV0d29yay1vZmZsaW5lJywgJ25ldHdvcmstb25saW5lJ1xuICAgICk7XG5cbiAgICAvLyBwZW5kaW5nIGdldC9wdXQvZGVsZXRlIGNhbGxzLlxuICAgIHRoaXMuX3BlbmRpbmcgPSBbXTtcblxuICAgIHRoaXMuX3NldEdQRCh7XG4gICAgICBnZXQ6IHRoaXMuX3BlbmRpbmdHUEQoJ2dldCcpLFxuICAgICAgcHV0OiB0aGlzLl9wZW5kaW5nR1BEKCdwdXQnKSxcbiAgICAgIGRlbGV0ZTogdGhpcy5fcGVuZGluZ0dQRCgnZGVsZXRlJylcbiAgICB9KTtcblxuICAgIHRoaXMuX2NsZWFudXBzID0gW107XG5cbiAgICB0aGlzLl9wYXRoSGFuZGxlcnMgPSB7IGNoYW5nZToge30gfTtcblxuICAgIHRoaXMuYXBpS2V5cyA9IHt9O1xuXG4gICAgaGFzTG9jYWxTdG9yYWdlID0gdXRpbC5sb2NhbFN0b3JhZ2VBdmFpbGFibGUoKTtcblxuICAgIGlmIChoYXNMb2NhbFN0b3JhZ2UpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHRoaXMuYXBpS2V5cyA9IEpTT04ucGFyc2UobG9jYWxTdG9yYWdlLmdldEl0ZW0oJ3JlbW90ZXN0b3JhZ2U6YXBpLWtleXMnKSkgfHwge307XG4gICAgICB9IGNhdGNoKGV4Yykge1xuICAgICAgICAvLyBpZ25vcmVkXG4gICAgICB9XG4gICAgICB0aGlzLnNldEJhY2tlbmQobG9jYWxTdG9yYWdlLmdldEl0ZW0oJ3JlbW90ZXN0b3JhZ2U6YmFja2VuZCcpIHx8ICdyZW1vdGVzdG9yYWdlJyk7XG4gICAgfVxuXG4gICAgdmFyIG9yaWdPbiA9IHRoaXMub247XG5cbiAgICB0aGlzLm9uID0gZnVuY3Rpb24gKGV2ZW50TmFtZSwgaGFuZGxlcikge1xuICAgICAgaWYgKGV2ZW50TmFtZSA9PT0gJ3JlYWR5JyAmJiB0aGlzLnJlbW90ZSAmJiB0aGlzLnJlbW90ZS5jb25uZWN0ZWQgJiYgdGhpcy5fYWxsTG9hZGVkKSB7XG4gICAgICAgIHNldFRpbWVvdXQoaGFuZGxlciwgMCk7XG4gICAgICB9IGVsc2UgaWYgKGV2ZW50TmFtZSA9PT0gJ2ZlYXR1cmVzLWxvYWRlZCcgJiYgdGhpcy5fYWxsTG9hZGVkKSB7XG4gICAgICAgIHNldFRpbWVvdXQoaGFuZGxlciwgMCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gb3JpZ09uLmNhbGwodGhpcywgZXZlbnROYW1lLCBoYW5kbGVyKTtcbiAgICB9O1xuXG4gICAgLy8gbG9hZCBhbGwgZmVhdHVyZXMgYW5kIGVtaXQgYHJlYWR5YFxuICAgIHRoaXMuX2luaXQoKVxuXG4gICAgdGhpcy5maXJlSW5pdGlhbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICh0aGlzLmxvY2FsKSB7XG4gICAgICAgIHNldFRpbWVvdXQodGhpcy5sb2NhbC5maXJlSW5pdGlhbC5iaW5kKHRoaXMubG9jYWwpLCAwKTtcbiAgICAgIH1cbiAgICB9LmJpbmQodGhpcyk7XG5cbiAgICB0aGlzLm9uKCdyZWFkeScsIHRoaXMuZmlyZUluaXRpYWwuYmluZCh0aGlzKSk7XG4gIH07XG5cblxuICAvLyBUT0ZJWDogSW5zdGVhZCBvZiBkb2luZyB0aGlzLCB3b3VsZCBiZSBiZXR0ZXIgdG8gb25seSBcbiAgLy8gZXhwb3J0IHNldEF1dGhVUkwgLyBnZXRBdXRoVVJMIGZyb20gUmVtb3RlU3RvcmFnZSBwcm90b3R5cGVcbiAgUmVtb3RlU3RvcmFnZS5BdXRob3JpemUgPSBBdXRob3JpemU7XG5cbiAgUmVtb3RlU3RvcmFnZS5TeW5jRXJyb3IgPSBTeW5jLlN5bmNFcnJvcjtcbiAgUmVtb3RlU3RvcmFnZS5VbmF1dGhvcml6ZWQgPSBBdXRob3JpemUuVW5hdXRob3JpemVkO1xuICBSZW1vdGVTdG9yYWdlLkRpc2NvdmVyeUVycm9yID0gRGlzY292ZXIuRGlzY292ZXJ5RXJyb3I7XG5cbiBcbiAgUmVtb3RlU3RvcmFnZS5wcm90b3R5cGUgPSB7XG4gICAgYXV0aG9yaXplOiBmdW5jdGlvbiBhdXRob3JpemUoYXV0aFVSTCwgY29yZG92YVJlZGlyZWN0VXJpKSB7XG4gICAgICB0aGlzLmFjY2Vzcy5zZXRTdG9yYWdlVHlwZSh0aGlzLnJlbW90ZS5zdG9yYWdlVHlwZSk7XG4gICAgICB2YXIgc2NvcGUgPSB0aGlzLmFjY2Vzcy5zY29wZVBhcmFtZXRlcjtcblxuICAgICAgdmFyIHJlZGlyZWN0VXJpID0gZ2xvYmFsQ29udGV4dC5jb3Jkb3ZhID9cbiAgICAgICAgY29yZG92YVJlZGlyZWN0VXJpIDpcbiAgICAgICAgU3RyaW5nKEF1dGhvcml6ZS5nZXRMb2NhdGlvbigpKTtcblxuICAgICAgdmFyIGNsaWVudElkID0gcmVkaXJlY3RVcmkubWF0Y2goL14oaHR0cHM/OlxcL1xcL1teXFwvXSspLylbMF07XG5cbiAgICAgIEF1dGhvcml6ZSh0aGlzLCBhdXRoVVJMLCBzY29wZSwgcmVkaXJlY3RVcmksIGNsaWVudElkKTtcbiAgICB9LFxuICBcblxuICAgIC8qKlxuICAgICAqIFByb3BlcnR5OiByZW1vdGVcbiAgICAgKlxuICAgICAqIFByb3BlcnRpZXM6XG4gICAgICpcbiAgICAgKiAgIGNvbm5lY3RlZCAgIC0gQm9vbGVhbiwgd2hldGhlciBvciBub3QgYSByZW1vdGUgc3RvcmUgaXMgY29ubmVjdGVkXG4gICAgICogICBvbmxpbmUgICAgICAtIEJvb2xlYW4sIHdoZXRoZXIgbGFzdCBzeW5jIGFjdGlvbiB3YXMgc3VjY2Vzc2Z1bCBvciBub3RcbiAgICAgKiAgIHVzZXJBZGRyZXNzIC0gU3RyaW5nLCB0aGUgdXNlciBhZGRyZXNzIG9mIHRoZSBjb25uZWN0ZWQgdXNlclxuICAgICAqICAgcHJvcGVydGllcyAgLSBTdHJpbmcsIHRoZSBwcm9wZXJ0aWVzIG9mIHRoZSBXZWJGaW5nZXIgbGlua1xuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogTWV0aG9kOiBzY29wZVxuICAgICAqXG4gICAgICogUmV0dXJucyBhIEJhc2VDbGllbnQgd2l0aCBhIGNlcnRhaW4gc2NvcGUgKGJhc2UgcGF0aCkuIFBsZWFzZSB1c2UgdGhpcyBtZXRob2RcbiAgICAgKiBvbmx5IGZvciBkZWJ1Z2dpbmcsIGFuZCBhbHdheXMgdXNlIGRlZmluZU1vZHVsZSBpbnN0ZWFkLCB0byBnZXQgYWNjZXNzIHRvIGFcbiAgICAgKiBCYXNlQ2xpZW50IGZyb20gYSBtb2R1bGUgaW4gYW4gYXBwLlxuICAgICAqXG4gICAgICogUGFyYW1ldGVyczpcbiAgICAgKlxuICAgICAqICAgc2NvcGUgLSBBIHN0cmluZywgd2l0aCBhIGxlYWRpbmcgYW5kIGEgdHJhaWxpbmcgc2xhc2gsIHNwZWNpZnlpbmcgdGhlXG4gICAgICogICAgICAgICAgIGJhc2UgcGF0aCBvZiB0aGUgQmFzZUNsaWVudCB0aGF0IHdpbGwgYmUgcmV0dXJuZWQuXG4gICAgICpcbiAgICAgKiBDb2RlIGV4YW1wbGU6XG4gICAgICpcbiAgICAgKiAoc3RhcnQgY29kZSlcbiAgICAgKiByZW1vdGVTdG9yYWdlLnNjb3BlKCcvcGljdHVyZXMvJykuZ2V0TGlzdGluZygnJyk7XG4gICAgICogcmVtb3RlU3RvcmFnZS5zY29wZSgnL3B1YmxpYy9waWN0dXJlcy8nKS5nZXRMaXN0aW5nKCcnKTtcbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIE1ldGhvZDogc3RhcnRTeW5jXG4gICAgICpcbiAgICAgKiBTdGFydCBzeW5jaHJvbml6YXRpb24gd2l0aCByZW1vdGUgc3RvcmFnZSwgZG93bmxvYWRpbmcgYW5kIHVwbG9hZGluZyBhbnlcbiAgICAgKiBjaGFuZ2VzIHdpdGhpbiB0aGUgY2FjaGVkIHBhdGhzLlxuICAgICAqXG4gICAgICogUGxlYXNlIGNvbnNpZGVyOiBsb2NhbCBjaGFuZ2VzIHdpbGwgYXR0ZW1wdCBzeW5jIGltbWVkaWF0ZWx5LCBhbmQgcmVtb3RlXG4gICAgICogY2hhbmdlcyBzaG91bGQgYWxzbyBiZSBzeW5jZWQgdGltZWx5IHdoZW4gdXNpbmcgbGlicmFyeSBkZWZhdWx0cy4gU29cbiAgICAgKiB0aGlzIGlzIG1vc3RseSB1c2VmdWwgZm9yIGxldHRpbmcgdXNlcnMgc3luYyBtYW51YWxseSwgd2hlbiBwcmVzc2luZyBhXG4gICAgICogc3luYyBidXR0b24gZm9yIGV4YW1wbGUuIFRoaXMgbWlnaHQgZmVlbCBzYWZlciB0byB0aGVtIHNvbWV0aW1lcywgZXNwLlxuICAgICAqIHdoZW4gc2hpZnRpbmcgYmV0d2VlbiBvZmZsaW5lIGFuZCBvbmxpbmUgYSBsb3QuXG4gICAgICovXG4gICAgIC8vIChzZWUgc3JjL3N5bmMuanMgZm9yIGltcGxlbWVudGF0aW9uKVxuXG4gICAgLyoqXG4gICAgICogTWV0aG9kOiBjb25uZWN0XG4gICAgICpcbiAgICAgKiBDb25uZWN0IHRvIGEgcmVtb3RlU3RvcmFnZSBzZXJ2ZXIuXG4gICAgICpcbiAgICAgKiBQYXJhbWV0ZXJzOlxuICAgICAqICAgdXNlckFkZHJlc3MgICAgICAgIC0gVGhlIHVzZXIgYWRkcmVzcyAodXNlckBob3N0KSB0byBjb25uZWN0IHRvLlxuICAgICAqICAgdG9rZW4gICAgICAgICAgICAgIC0gKG9wdGlvbmFsKSBBIGJlYXJlciB0b2tlbiBhY3F1aXJlZCBiZWZvcmVoYW5kXG4gICAgICpcbiAgICAgKiBEaXNjb3ZlcnMgdGhlIFdlYkZpbmdlciBwcm9maWxlIG9mIHRoZSBnaXZlbiB1c2VyIGFkZHJlc3MgYW5kIGluaXRpYXRlc1xuICAgICAqIHRoZSBPQXV0aCBkYW5jZS5cbiAgICAgKlxuICAgICAqIFRoaXMgbWV0aG9kIG11c3QgYmUgY2FsbGVkICphZnRlciogYWxsIHJlcXVpcmVkIGFjY2VzcyBoYXMgYmVlbiBjbGFpbWVkLlxuICAgICAqIFdoZW4gdXNpbmcgdGhlIGNvbm5lY3Qgd2lkZ2V0LCBpdCB3aWxsIGNhbGwgdGhpcyBtZXRob2QgaXRzZWxmLlxuICAgICAqXG4gICAgICogU3BlY2lhbCBjYXNlczpcbiAgICAgKlxuICAgICAqIDEuIElmIGEgYmVhcmVyIHRva2VuIGlzIHN1cHBsaWVkIGFzIHNlY29uZCBhcmd1bWVudCwgdGhlIE9BdXRoIGRhbmNlXG4gICAgICogICAgd2lsbCBiZSBza2lwcGVkIGFuZCB0aGUgc3VwcGxpZWQgdG9rZW4gYmUgdXNlZCBpbnN0ZWFkLiBUaGlzIGlzXG4gICAgICogICAgdXNlZnVsIG91dHNpZGUgb2YgYnJvd3NlciBlbnZpcm9ubWVudHMsIHdoZXJlIHRoZSB0b2tlbiBoYXMgYmVlblxuICAgICAqICAgIGFjcXVpcmVkIGluIGEgZGlmZmVyZW50IHdheS5cbiAgICAgKlxuICAgICAqIDIuIElmIHRoZSBXZWJmaW5nZXIgcHJvZmlsZSBmb3IgdGhlIGdpdmVuIHVzZXIgYWRkcmVzcyBkb2Vzbid0IGNvbnRhaW5cbiAgICAgKiAgICBhbiBhdXRoIFVSTCwgdGhlIGxpYnJhcnkgd2lsbCBhc3N1bWUgdGhhdCBjbGllbnQgYW5kIHNlcnZlciBoYXZlXG4gICAgICogICAgZXN0YWJsaXNoZWQgYXV0aG9yaXphdGlvbiBhbW9uZyB0aGVtc2VsdmVzLCB3aGljaCB3aWxsIG9taXQgYmVhcmVyXG4gICAgICogICAgdG9rZW5zIGluIGFsbCByZXF1ZXN0cyBsYXRlciBvbi4gVGhpcyBpcyB1c2VmdWwgZm9yIGV4YW1wbGUgd2hlbiB1c2luZ1xuICAgICAqICAgIEtlcmJlcm9zIGFuZCBzaW1pbGFyIHByb3RvY29scy5cbiAgICAgKi9cbiAgICBjb25uZWN0OiBmdW5jdGlvbiAodXNlckFkZHJlc3MsIHRva2VuKSB7XG4gICAgICB0aGlzLnNldEJhY2tlbmQoJ3JlbW90ZXN0b3JhZ2UnKTtcbiAgICAgIGlmICh1c2VyQWRkcmVzcy5pbmRleE9mKCdAJykgPCAwKSB7XG4gICAgICAgIHRoaXMuX2VtaXQoJ2Vycm9yJywgbmV3IFJlbW90ZVN0b3JhZ2UuRGlzY292ZXJ5RXJyb3IoXCJVc2VyIGFkZHJlc3MgZG9lc24ndCBjb250YWluIGFuIEAuXCIpKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoZ2xvYmFsQ29udGV4dC5jb3Jkb3ZhKSB7XG4gICAgICAgIGlmICh0eXBlb2YgY29uZmlnLmNvcmRvdmFSZWRpcmVjdFVyaSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICB0aGlzLl9lbWl0KCdlcnJvcicsIG5ldyBSZW1vdGVTdG9yYWdlLkRpc2NvdmVyeUVycm9yKFwiUGxlYXNlIHN1cHBseSBhIGN1c3RvbSBIVFRQUyByZWRpcmVjdCBVUkkgZm9yIHlvdXIgQ29yZG92YSBhcHBcIikpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWdsb2JhbENvbnRleHQuY29yZG92YS5JbkFwcEJyb3dzZXIpIHtcbiAgICAgICAgICB0aGlzLl9lbWl0KCdlcnJvcicsIG5ldyBSZW1vdGVTdG9yYWdlLkRpc2NvdmVyeUVycm9yKFwiUGxlYXNlIGluY2x1ZGUgdGhlIEluQXBwQnJvd3NlciBDb3Jkb3ZhIHBsdWdpbiB0byBlbmFibGUgT0F1dGhcIikpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB0aGlzLnJlbW90ZS5jb25maWd1cmUoe1xuICAgICAgICB1c2VyQWRkcmVzczogdXNlckFkZHJlc3NcbiAgICAgIH0pO1xuICAgICAgdGhpcy5fZW1pdCgnY29ubmVjdGluZycpO1xuXG4gICAgICB2YXIgZGlzY292ZXJ5VGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9lbWl0KCdlcnJvcicsIG5ldyBSZW1vdGVTdG9yYWdlLkRpc2NvdmVyeUVycm9yKFwiTm8gc3RvcmFnZSBpbmZvcm1hdGlvbiBmb3VuZCBmb3IgdGhpcyB1c2VyIGFkZHJlc3MuXCIpKTtcbiAgICAgIH0uYmluZCh0aGlzKSwgY29uZmlnLmRpc2NvdmVyeVRpbWVvdXQpO1xuXG4gICAgICBEaXNjb3Zlcih1c2VyQWRkcmVzcykudGhlbihmdW5jdGlvbiAoaW5mbykge1xuICAgICAgICAvLyBJbmZvIGNvbnRhaW5zIGZpZWxkczogaHJlZiwgc3RvcmFnZUFwaSwgYXV0aFVSTCAob3B0aW9uYWwpLCBwcm9wZXJ0aWVzXG5cbiAgICAgICAgY2xlYXJUaW1lb3V0KGRpc2NvdmVyeVRpbWVvdXQpO1xuICAgICAgICB0aGlzLl9lbWl0KCdhdXRoaW5nJyk7XG4gICAgICAgIGluZm8udXNlckFkZHJlc3MgPSB1c2VyQWRkcmVzcztcbiAgICAgICAgdGhpcy5yZW1vdGUuY29uZmlndXJlKGluZm8pO1xuICAgICAgICBpZiAoISB0aGlzLnJlbW90ZS5jb25uZWN0ZWQpIHtcbiAgICAgICAgICBpZiAoaW5mby5hdXRoVVJMKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHRva2VuID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAvLyBOb3JtYWwgYXV0aG9yaXphdGlvbiBzdGVwOyB0aGUgZGVmYXVsdCB3YXkgdG8gY29ubmVjdFxuICAgICAgICAgICAgICB0aGlzLmF1dGhvcml6ZShpbmZvLmF1dGhVUkwsIGNvbmZpZy5jb3Jkb3ZhUmVkaXJlY3RVcmkpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdG9rZW4gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgIC8vIFRva2VuIHN1cHBsaWVkIGRpcmVjdGx5IGJ5IGFwcC9kZXZlbG9wZXIvdXNlclxuICAgICAgICAgICAgICBsb2coJ1NraXBwaW5nIGF1dGhvcml6YXRpb24gc2VxdWVuY2UgYW5kIGNvbm5lY3Rpbmcgd2l0aCBrbm93biB0b2tlbicpO1xuICAgICAgICAgICAgICB0aGlzLnJlbW90ZS5jb25maWd1cmUoeyB0b2tlbjogdG9rZW4gfSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJTdXBwbGllZCBiZWFyZXIgdG9rZW4gbXVzdCBiZSBhIHN0cmluZ1wiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gSW4gbGlldSBvZiBhbiBleGNwbGljaXQgYXV0aFVSTCwgYXNzdW1lIHRoYXQgdGhlIGJyb3dzZXIgYW5kXG4gICAgICAgICAgICAvLyBzZXJ2ZXIgaGFuZGxlIGFueSBhdXRob3JpemF0aW9uIG5lZWRzOyBmb3IgaW5zdGFuY2UsIFRMUyBtYXlcbiAgICAgICAgICAgIC8vIHRyaWdnZXIgdGhlIGJyb3dzZXIgdG8gdXNlIGEgY2xpZW50IGNlcnRpZmljYXRlLCBvciBhIDQwMSBOb3RcbiAgICAgICAgICAgIC8vIEF1dGhvcml6ZWQgcmVzcG9uc2UgbWF5IG1ha2UgdGhlIGJyb3dzZXIgc2VuZCBhIEtlcmJlcm9zIHRpY2tldFxuICAgICAgICAgICAgLy8gdXNpbmcgdGhlIFNQTkVHTyBtZXRob2QuXG4gICAgICAgICAgICB0aGlzLmltcGxpZWRhdXRoKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LmJpbmQodGhpcyksIGZ1bmN0aW9uKGVycikge1xuICAgICAgICBjbGVhclRpbWVvdXQoZGlzY292ZXJ5VGltZW91dCk7XG4gICAgICAgIHRoaXMuX2VtaXQoJ2Vycm9yJywgbmV3IFJlbW90ZVN0b3JhZ2UuRGlzY292ZXJ5RXJyb3IoXCJObyBzdG9yYWdlIGluZm9ybWF0aW9uIGZvdW5kIGZvciB0aGlzIHVzZXIgYWRkcmVzcy5cIikpO1xuICAgICAgfS5iaW5kKHRoaXMpKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTWV0aG9kOiBkaXNjb25uZWN0XG4gICAgICpcbiAgICAgKiBcIkRpc2Nvbm5lY3RcIiBmcm9tIHJlbW90ZXN0b3JhZ2Ugc2VydmVyIHRvIHRlcm1pbmF0ZSBjdXJyZW50IHNlc3Npb24uXG4gICAgICogVGhpcyBtZXRob2QgY2xlYXJzIGFsbCBzdG9yZWQgc2V0dGluZ3MgYW5kIGRlbGV0ZXMgdGhlIGVudGlyZSBsb2NhbFxuICAgICAqIGNhY2hlLlxuICAgICAqL1xuICAgIGRpc2Nvbm5lY3Q6IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICh0aGlzLnJlbW90ZSkge1xuICAgICAgICB0aGlzLnJlbW90ZS5jb25maWd1cmUoe1xuICAgICAgICAgIHVzZXJBZGRyZXNzOiBudWxsLFxuICAgICAgICAgIGhyZWY6IG51bGwsXG4gICAgICAgICAgc3RvcmFnZUFwaTogbnVsbCxcbiAgICAgICAgICB0b2tlbjogbnVsbCxcbiAgICAgICAgICBwcm9wZXJ0aWVzOiBudWxsXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgdGhpcy5fc2V0R1BEKHtcbiAgICAgICAgZ2V0OiB0aGlzLl9wZW5kaW5nR1BEKCdnZXQnKSxcbiAgICAgICAgcHV0OiB0aGlzLl9wZW5kaW5nR1BEKCdwdXQnKSxcbiAgICAgICAgZGVsZXRlOiB0aGlzLl9wZW5kaW5nR1BEKCdkZWxldGUnKVxuICAgICAgfSk7XG4gICAgICB2YXIgbiA9IHRoaXMuX2NsZWFudXBzLmxlbmd0aCwgaSA9IDA7XG5cbiAgICAgIHZhciBvbmVEb25lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpKys7XG4gICAgICAgIGlmIChpID49IG4pIHtcbiAgICAgICAgICB0aGlzLl9pbml0KCk7XG4gICAgICAgICAgbG9nKCdEb25lIGNsZWFuaW5nIHVwLCBlbWl0dGluZyBkaXNjb25uZWN0ZWQgYW5kIGRpc2Nvbm5lY3QgZXZlbnRzJyk7XG4gICAgICAgICAgdGhpcy5fZW1pdCgnZGlzY29ubmVjdGVkJyk7XG4gICAgICAgIH1cbiAgICAgIH0uYmluZCh0aGlzKTtcblxuICAgICAgaWYgKG4gPiAwKSB7XG4gICAgICAgIHRoaXMuX2NsZWFudXBzLmZvckVhY2goZnVuY3Rpb24gKGNsZWFudXApIHtcbiAgICAgICAgICB2YXIgY2xlYW51cFJlc3VsdCA9IGNsZWFudXAodGhpcyk7XG4gICAgICAgICAgaWYgKHR5cGVvZihjbGVhbnVwUmVzdWx0KSA9PT0gJ29iamVjdCcgJiYgdHlwZW9mKGNsZWFudXBSZXN1bHQudGhlbikgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNsZWFudXBSZXN1bHQudGhlbihvbmVEb25lKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgb25lRG9uZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfS5iaW5kKHRoaXMpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG9uZURvbmUoKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgc2V0QmFja2VuZDogZnVuY3Rpb24gKHdoYXQpIHtcbiAgICAgIHRoaXMuYmFja2VuZCA9IHdoYXQ7XG4gICAgICBpZiAoaGFzTG9jYWxTdG9yYWdlKSB7XG4gICAgICAgIGlmICh3aGF0KSB7XG4gICAgICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oJ3JlbW90ZXN0b3JhZ2U6YmFja2VuZCcsIHdoYXQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKCdyZW1vdGVzdG9yYWdlOmJhY2tlbmQnKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNZXRob2Q6IG9uQ2hhbmdlXG4gICAgICpcbiAgICAgKiBBZGQgYSBcImNoYW5nZVwiIGV2ZW50IGhhbmRsZXIgdG8gdGhlIGdpdmVuIHBhdGguIFdoZW5ldmVyIGEgXCJjaGFuZ2VcIlxuICAgICAqIGhhcHBlbnMgKGFzIGRldGVybWluZWQgYnkgdGhlIGJhY2tlbmQsIHN1Y2ggYXMgZS5nLlxuICAgICAqIDxSZW1vdGVTdG9yYWdlLkluZGV4ZWREQj4pIGFuZCB0aGUgYWZmZWN0ZWQgcGF0aCBpcyBlcXVhbCB0byBvciBiZWxvd1xuICAgICAqIHRoZSBnaXZlbiAncGF0aCcsIHRoZSBnaXZlbiBoYW5kbGVyIGlzIGNhbGxlZC5cbiAgICAgKlxuICAgICAqIFlvdSBzaG91bGQgdXN1YWxseSBub3QgdXNlIHRoaXMgbWV0aG9kIGRpcmVjdGx5LCBidXQgaW5zdGVhZCB1c2UgdGhlXG4gICAgICogXCJjaGFuZ2VcIiBldmVudHMgcHJvdmlkZWQgYnkgPFJlbW90ZVN0b3JhZ2UuQmFzZUNsaWVudD4uXG4gICAgICpcbiAgICAgKiBQYXJhbWV0ZXJzOlxuICAgICAqICAgcGF0aCAgICAtIEFic29sdXRlIHBhdGggdG8gYXR0YWNoIGhhbmRsZXIgdG8uXG4gICAgICogICBoYW5kbGVyIC0gSGFuZGxlciBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBvbkNoYW5nZTogZnVuY3Rpb24gKHBhdGgsIGhhbmRsZXIpIHtcbiAgICAgIGlmICghIHRoaXMuX3BhdGhIYW5kbGVycy5jaGFuZ2VbcGF0aF0pIHtcbiAgICAgICAgdGhpcy5fcGF0aEhhbmRsZXJzLmNoYW5nZVtwYXRoXSA9IFtdO1xuICAgICAgfVxuICAgICAgdGhpcy5fcGF0aEhhbmRsZXJzLmNoYW5nZVtwYXRoXS5wdXNoKGhhbmRsZXIpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNZXRob2Q6IGVuYWJsZUxvZ1xuICAgICAqXG4gICAgICogRW5hYmxlIHJlbW90ZVN0b3JhZ2UgbG9nZ2luZy5cbiAgICAgKi9cbiAgICBlbmFibGVMb2c6IGZ1bmN0aW9uICgpIHtcbiAgICAgIGNvbmZpZy5sb2dnaW5nID0gdHJ1ZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTWV0aG9kOiBkaXNhYmxlTG9nXG4gICAgICpcbiAgICAgKiBEaXNhYmxlIHJlbW90ZVN0b3JhZ2UgbG9nZ2luZ1xuICAgICAqL1xuICAgIGRpc2FibGVMb2c6IGZ1bmN0aW9uICgpIHtcbiAgICAgIGNvbmZpZy5sb2dnaW5nID0gZmFsc2U7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1ldGhvZDogbG9nXG4gICAgICpcbiAgICAgKiBUaGUgc2FtZSBhcyA8UmVtb3RlU3RvcmFnZS5sb2c+LlxuICAgICAqL1xuICAgIGxvZzogZnVuY3Rpb24gKCkge1xuICAgICAgbG9nLmFwcGx5KFJlbW90ZVN0b3JhZ2UsIGFyZ3VtZW50cyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1ldGhvZDogc2V0QXBpS2V5cyAoZXhwZXJpbWVudGFsKVxuICAgICAqXG4gICAgICogU2V0IEFQSSBrZXlzIGZvciAoY3VycmVudGx5KSBHb29nbGVEcml2ZSBhbmQvb3IgRHJvcGJveCBiYWNrZW5kIHN1cHBvcnQuXG4gICAgICogU2VlIGFsc28gdGhlICdiYWNrZW5kcycgZXhhbXBsZSBpbiB0aGUgc3RhcnRlci1raXQuIE5vdGUgdGhhdCBzdXBwb3J0IGZvclxuICAgICAqIGJvdGggdGhlc2UgYmFja2VuZHMgaXMgc3RpbGwgZXhwZXJpbWVudGFsLlxuICAgICAqXG4gICAgICogUGFyYW1ldGVyczpcbiAgICAgKiAgIHR5cGUgLSBzdHJpbmcsIGVpdGhlciAnZ29vZ2xlZHJpdmUnIG9yICdkcm9wYm94J1xuICAgICAqICAga2V5cyAtIG9iamVjdCwgd2l0aCBvbmUgc3RyaW5nIGZpZWxkOyAnY2xpZW50SWQnIGZvciBHb29nbGVEcml2ZSwgb3JcbiAgICAgKiAgICAgICAgICAnYXBwS2V5JyBmb3IgRHJvcGJveC5cbiAgICAgKlxuICAgICAqL1xuICAgIHNldEFwaUtleXM6IGZ1bmN0aW9uICh0eXBlLCBrZXlzKSB7XG4gICAgICBpZiAoa2V5cykge1xuICAgICAgICB0aGlzLmFwaUtleXNbdHlwZV0gPSBrZXlzO1xuICAgICAgICBpZiAodHlwZSA9PT0gJ2Ryb3Bib3gnICYmICh0eXBlb2YgdGhpcy5kcm9wYm94ID09PSAndW5kZWZpbmVkJyB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRyb3Bib3guY2xpZW50SWQgIT09IGtleXMuYXBwS2V5KSkge1xuICAgICAgICAgIERyb3Bib3guX3JzX2luaXQodGhpcyk7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ2dvb2dsZWRyaXZlJyAmJiAodHlwZW9mIHRoaXMuZ29vZ2xlZHJpdmUgPT09ICd1bmRlZmluZWQnIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5nb29nbGVkcml2ZS5jbGllbnRJZCAhPT0ga2V5cy5jbGllbnRJZCkpIHtcbiAgICAgICAgICBHb29nbGVEcml2ZS5fcnNfaW5pdCh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGVsZXRlIHRoaXMuYXBpS2V5c1t0eXBlXTtcbiAgICAgIH1cbiAgICAgIGlmIChoYXNMb2NhbFN0b3JhZ2UpIHtcbiAgICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oJ3JlbW90ZXN0b3JhZ2U6YXBpLWtleXMnLCBKU09OLnN0cmluZ2lmeSh0aGlzLmFwaUtleXMpKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTWV0aG9kOiBzZXRDb3Jkb3ZhUmVkaXJlY3RVcmlcbiAgICAgKlxuICAgICAqIFNldCByZWRpcmVjdCBVUkkgdG8gYmUgdXNlZCBmb3IgdGhlIE9BdXRoIHJlZGlyZWN0IHdpdGhpbiB0aGVcbiAgICAgKiBpbi1hcHAtYnJvd3NlciB3aW5kb3cgaW4gQ29yZG92YSBhcHBzLlxuICAgICAqXG4gICAgICogUGFyYW1ldGVyczpcbiAgICAgKiAgIHVyaSAtIHN0cmluZywgdmFsaWQgSFRUUChTKSBVUklcbiAgICAgKi9cbiAgICBzZXRDb3Jkb3ZhUmVkaXJlY3RVcmk6IGZ1bmN0aW9uICh1cmkpIHtcbiAgICAgIGlmICh0eXBlb2YgdXJpICE9PSAnc3RyaW5nJyB8fCAhdXJpLm1hdGNoKC9odHRwKHMpP1xcOlxcL1xcLy8pKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNvcmRvdmEgcmVkaXJlY3RpbmdlY3QgVVJJIG11c3QgYmUgYSBVUkkgc3RyaW5nXCIpO1xuICAgICAgfVxuICAgICAgY29uZmlnLmNvcmRvdmFSZWRpcmVjdFVyaSA9IHVyaTtcbiAgICB9LFxuXG5cbiAgICAvKiBGRUFUVVJFUyBJTklUSUFMSVpBVElPTiAqL1xuICAgIF9pbml0OiBGZWF0dXJlcy5sb2FkRmVhdHVyZXMsXG4gICAgZmVhdHVyZXM6IEZlYXR1cmVzLmZlYXR1cmVzLFxuICAgIGxvYWRGZWF0dXJlOiBGZWF0dXJlcy5sb2FkRmVhdHVyZSxcbiAgICBmZWF0dXJlU3VwcG9ydGVkOiBGZWF0dXJlcy5mZWF0dXJlU3VwcG9ydGVkLFxuICAgIGZlYXR1cmVEb25lOiBGZWF0dXJlcy5mZWF0dXJlRG9uZSxcbiAgICBmZWF0dXJlc0RvbmU6IEZlYXR1cmVzLmZlYXR1cmVzRG9uZSxcbiAgICBmZWF0dXJlc0xvYWRlZDogRmVhdHVyZXMuZmVhdHVyZXNMb2FkZWQsXG4gICAgZmVhdHVyZUluaXRpYWxpemVkOiBGZWF0dXJlcy5mZWF0dXJlSW5pdGlhbGl6ZWQsXG4gICAgZmVhdHVyZUZhaWxlZDogRmVhdHVyZXMuZmVhdHVyZUZhaWxlZCxcbiAgICBmZWF0dXJlU3VwcG9ydGVkOiBGZWF0dXJlcy5mZWF0dXJlU3VwcG9ydGVkLFxuICAgIGhhc0ZlYXR1cmU6IEZlYXR1cmVzLmhhc0ZlYXR1cmUsXG4gICAgX3NldENhY2hpbmdNb2R1bGU6IEZlYXR1cmVzLl9zZXRDYWNoaW5nTW9kdWxlLFxuICAgIF9jb2xsZWN0Q2xlYW51cEZ1bmN0aW9uczogRmVhdHVyZXMuX2NvbGxlY3RDbGVhbnVwRnVuY3Rpb25zLFxuICAgIF9maXJlUmVhZHk6IEZlYXR1cmVzLl9maXJlUmVhZHksXG4gICAgaW5pdEZlYXR1cmU6IEZlYXR1cmVzLmluaXRGZWF0dXJlLFxuXG5cblxuICAgIC8qKlxuICAgICAqKiBHRVQvUFVUL0RFTEVURSBJTlRFUkZBQ0UgSEVMUEVSU1xuICAgICAqKi9cbiAgICBfc2V0R1BEOiBmdW5jdGlvbiAoaW1wbCwgY29udGV4dCkge1xuICAgICAgZnVuY3Rpb24gd3JhcChmdW5jKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIGZ1bmMuYXBwbHkoY29udGV4dCwgYXJndW1lbnRzKVxuICAgICAgICAgICAgLnRoZW4oZW1pdFVuYXV0aG9yaXplZC5iaW5kKHRoaXMpKTtcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIHRoaXMuZ2V0ID0gd3JhcChpbXBsLmdldCk7XG4gICAgICB0aGlzLnB1dCA9IHdyYXAoaW1wbC5wdXQpO1xuICAgICAgdGhpcy5kZWxldGUgPSB3cmFwKGltcGwuZGVsZXRlKTtcbiAgICB9LFxuXG4gICAgX3BlbmRpbmdHUEQ6IGZ1bmN0aW9uIChtZXRob2ROYW1lKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcGVuZGluZyA9IFByb21pc2UuZGVmZXIoKTtcbiAgICAgICAgdGhpcy5fcGVuZGluZy5wdXNoKHtcbiAgICAgICAgICBtZXRob2Q6IG1ldGhvZE5hbWUsXG4gICAgICAgICAgYXJnczogQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKSxcbiAgICAgICAgICBwcm9taXNlOiBwZW5kaW5nXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcGVuZGluZy5wcm9taXNlO1xuICAgICAgfS5iaW5kKHRoaXMpO1xuICAgIH0sXG5cbiAgICBfcHJvY2Vzc1BlbmRpbmc6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMuX3BlbmRpbmcuZm9yRWFjaChmdW5jdGlvbiAocGVuZGluZykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHRoaXNbcGVuZGluZy5tZXRob2RdLmFwcGx5KHRoaXMsIHBlbmRpbmcuYXJncykudGhlbihwZW5kaW5nLnByb21pc2UucmVzb2x2ZSwgcGVuZGluZy5wcm9taXNlLnJlamVjdCk7XG4gICAgICAgIH0gY2F0Y2goZSkge1xuICAgICAgICAgIHBlbmRpbmcucHJvbWlzZS5yZWplY3QoZSk7XG4gICAgICAgIH1cbiAgICAgIH0uYmluZCh0aGlzKSk7XG4gICAgICB0aGlzLl9wZW5kaW5nID0gW107XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqKiBDSEFOR0UgRVZFTlQgSEFORExJTkdcbiAgICAgKiovXG4gICAgX2JpbmRDaGFuZ2U6IGZ1bmN0aW9uIChvYmplY3QpIHtcbiAgICAgIG9iamVjdC5vbignY2hhbmdlJywgdGhpcy5fZGlzcGF0Y2hFdmVudC5iaW5kKHRoaXMsICdjaGFuZ2UnKSk7XG4gICAgfSxcblxuICAgIF9kaXNwYXRjaEV2ZW50OiBmdW5jdGlvbiAoZXZlbnROYW1lLCBldmVudCkge1xuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgT2JqZWN0LmtleXModGhpcy5fcGF0aEhhbmRsZXJzW2V2ZW50TmFtZV0pLmZvckVhY2goZnVuY3Rpb24gKHBhdGgpIHtcbiAgICAgICAgdmFyIHBsID0gcGF0aC5sZW5ndGg7XG4gICAgICAgIGlmIChldmVudC5wYXRoLnN1YnN0cigwLCBwbCkgPT09IHBhdGgpIHtcbiAgICAgICAgICBzZWxmLl9wYXRoSGFuZGxlcnNbZXZlbnROYW1lXVtwYXRoXS5mb3JFYWNoKGZ1bmN0aW9uIChoYW5kbGVyKSB7XG4gICAgICAgICAgICB2YXIgZXYgPSB7fTtcbiAgICAgICAgICAgIGZvciAodmFyIGtleSBpbiBldmVudCkgeyBldltrZXldID0gZXZlbnRba2V5XTsgfVxuICAgICAgICAgICAgZXYucmVsYXRpdmVQYXRoID0gZXZlbnQucGF0aC5yZXBsYWNlKG5ldyBSZWdFeHAoJ14nICsgcGF0aCksICcnKTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIGhhbmRsZXIoZXYpO1xuICAgICAgICAgICAgfSBjYXRjaChlKSB7XG4gICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCInY2hhbmdlJyBoYW5kbGVyIGZhaWxlZDogXCIsIGUsIGUuc3RhY2spO1xuICAgICAgICAgICAgICBzZWxmLl9lbWl0KCdlcnJvcicsIGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9LFxuXG5cbiAgICBzY29wZTogZnVuY3Rpb24gKHBhdGgpIHtcbiAgICAgIGlmICh0eXBlb2YocGF0aCkgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRocm93ICdBcmd1bWVudCBcXCdwYXRoXFwnIG9mIGJhc2VDbGllbnQuc2NvcGUgbXVzdCBiZSBhIHN0cmluZyc7XG4gICAgICB9XG5cbiAgICAgIGlmICghdGhpcy5hY2Nlc3MuY2hlY2tQYXRoUGVybWlzc2lvbihwYXRoLCAncicpKSB7XG4gICAgICAgIHZhciBlc2NhcGVkUGF0aCA9IHBhdGgucmVwbGFjZSgvKFsnXFxcXF0pL2csICdcXFxcJDEnKTtcbiAgICAgICAgY29uc29sZS53YXJuKCdXQVJOSU5HOiBwbGVhc2UgY2FsbCByZW1vdGVTdG9yYWdlLmFjY2Vzcy5jbGFpbShcXCcnICsgZXNjYXBlZFBhdGggKyAnXFwnLCBcXCdyXFwnKSAocmVhZCBvbmx5KSBvciByZW1vdGVTdG9yYWdlLmFjY2Vzcy5jbGFpbShcXCcnICsgZXNjYXBlZFBhdGggKyAnXFwnLCBcXCdyd1xcJykgKHJlYWQvd3JpdGUpIGZpcnN0Jyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbmV3IEJhc2VDbGllbnQodGhpcywgcGF0aCk7XG4gICAgfSxcblxuXG5cblxuICAgIC8qKlxuICAgICAqIE1ldGhvZDogZ2V0U3luY0ludGVydmFsXG4gICAgICpcbiAgICAgKiBHZXQgdGhlIHZhbHVlIG9mIHRoZSBzeW5jIGludGVydmFsIHdoZW4gYXBwbGljYXRpb24gaXMgaW4gdGhlIGZvcmVncm91bmRcbiAgICAgKlxuICAgICAqIFJldHVybnMgYSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzXG4gICAgICpcbiAgICAvLyAgKi9cbiAgICBnZXRTeW5jSW50ZXJ2YWw6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBjb25maWcuc3luY0ludGVydmFsO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNZXRob2Q6IHNldFN5bmNJbnRlcnZhbFxuICAgICAqXG4gICAgICogU2V0IHRoZSB2YWx1ZSBvZiB0aGUgc3luYyBpbnRlcnZhbCB3aGVuIGFwcGxpY2F0aW9uIGlzIGluIHRoZSBmb3JlZ3JvdW5kXG4gICAgICpcbiAgICAgKiBQYXJhbWV0ZXJzOlxuICAgICAqICAgaW50ZXJ2YWwgLSBzeW5jIGludGVydmFsIGluIG1pbGxpc2Vjb25kc1xuICAgICAqXG4gICAgICovXG4gICAgc2V0U3luY0ludGVydmFsOiBmdW5jdGlvbiAoaW50ZXJ2YWwpIHtcbiAgICAgIGlmICghaXNWYWxpZEludGVydmFsKGludGVydmFsKSkge1xuICAgICAgICB0aHJvdyBpbnRlcnZhbCArIFwiIGlzIG5vdCBhIHZhbGlkIHN5bmMgaW50ZXJ2YWxcIjtcbiAgICAgIH1cbiAgICAgIHZhciBvbGRWYWx1ZSA9IGNvbmZpZy5zeW5jSW50ZXJ2YWw7XG4gICAgICBjb25maWcuc3luY0ludGVydmFsID0gcGFyc2VJbnQoaW50ZXJ2YWwsIDEwKTtcbiAgICAgIHRoaXMuX2VtaXQoJ3N5bmMtaW50ZXJ2YWwtY2hhbmdlJywge29sZFZhbHVlOiBvbGRWYWx1ZSwgbmV3VmFsdWU6IGludGVydmFsfSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1ldGhvZDogZ2V0QmFja2dyb3VuZFN5bmNJbnRlcnZhbFxuICAgICAqXG4gICAgICogR2V0IHRoZSB2YWx1ZSBvZiB0aGUgc3luYyBpbnRlcnZhbCB3aGVuIGFwcGxpY2F0aW9uIGlzIGluIHRoZSBiYWNrZ3JvdW5kXG4gICAgICpcbiAgICAgKiBSZXR1cm5zIGEgbnVtYmVyIG9mIG1pbGxpc2Vjb25kc1xuICAgICAqXG4gICAgICovXG4gICAgZ2V0QmFja2dyb3VuZFN5bmNJbnRlcnZhbDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIGNvbmZpZy5iYWNrZ3JvdW5kU3luY0ludGVydmFsO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNZXRob2Q6IHNldEJhY2tncm91bmRTeW5jSW50ZXJ2YWxcbiAgICAgKlxuICAgICAqIFNldCB0aGUgdmFsdWUgb2YgdGhlIHN5bmMgaW50ZXJ2YWwgd2hlbiB0aGUgYXBwbGljYXRpb24gaXMgaW4gdGhlIGJhY2tncm91bmRcbiAgICAgKlxuICAgICAqIFBhcmFtZXRlcnM6XG4gICAgICogICBpbnRlcnZhbCAtIHN5bmMgaW50ZXJ2YWwgaW4gbWlsbGlzZWNvbmRzXG4gICAgICpcbiAgICAgKi9cbiAgICBzZXRCYWNrZ3JvdW5kU3luY0ludGVydmFsOiBmdW5jdGlvbiAoaW50ZXJ2YWwpIHtcbiAgICAgIGlmKCFpc1ZhbGlkSW50ZXJ2YWwoaW50ZXJ2YWwpKSB7XG4gICAgICAgIHRocm93IGludGVydmFsICsgXCIgaXMgbm90IGEgdmFsaWQgc3luYyBpbnRlcnZhbFwiO1xuICAgICAgfVxuICAgICAgdmFyIG9sZFZhbHVlID0gY29uZmlnLmJhY2tncm91bmRTeW5jSW50ZXJ2YWw7XG4gICAgICBjb25maWcuYmFja2dyb3VuZFN5bmNJbnRlcnZhbCA9IHBhcnNlSW50KGludGVydmFsLCAxMCk7XG4gICAgICB0aGlzLl9lbWl0KCdzeW5jLWludGVydmFsLWNoYW5nZScsIHtvbGRWYWx1ZTogb2xkVmFsdWUsIG5ld1ZhbHVlOiBpbnRlcnZhbH0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNZXRob2Q6IGdldEN1cnJlbnRTeW5jSW50ZXJ2YWxcbiAgICAgKlxuICAgICAqIEdldCB0aGUgdmFsdWUgb2YgdGhlIGN1cnJlbnQgc3luYyBpbnRlcnZhbFxuICAgICAqXG4gICAgICogUmV0dXJucyBhIG51bWJlciBvZiBtaWxsaXNlY29uZHNcbiAgICAgKlxuICAgICAqL1xuICAgIGdldEN1cnJlbnRTeW5jSW50ZXJ2YWw6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBjb25maWcuaXNCYWNrZ3JvdW5kID8gY29uZmlnLmJhY2tncm91bmRTeW5jSW50ZXJ2YWwgOiBjb25maWcuc3luY0ludGVydmFsO1xuICAgIH0sXG5cblxuXG4gICAgc3luY0N5Y2xlOiBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAodGhpcy5zeW5jLnN0b3BwZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnN5bmMub24oJ2RvbmUnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGxvZygnW1N5bmNdIFN5bmMgZG9uZS4gU2V0dGluZyB0aW1lciB0bycsIHRoaXMuZ2V0Q3VycmVudFN5bmNJbnRlcnZhbCgpKTtcbiAgICAgICAgaWYgKCF0aGlzLnN5bmMuc3RvcHBlZCkge1xuICAgICAgICAgIGlmICh0aGlzLl9zeW5jVGltZXIpIHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLl9zeW5jVGltZXIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLl9zeW5jVGltZXIgPSBzZXRUaW1lb3V0KHRoaXMuc3luYy5zeW5jLmJpbmQodGhpcy5zeW5jKSwgdGhpcy5nZXRDdXJyZW50U3luY0ludGVydmFsKCkpO1xuICAgICAgICB9XG4gICAgICB9LmJpbmQodGhpcykpO1xuXG4gICAgICB0aGlzLnN5bmMuc3luYygpO1xuICAgIH0sXG5cbiAgICBzdG9wU3luYzogZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKHRoaXMuc3luYykge1xuICAgICAgICBsb2coJ1tTeW5jXSBTdG9wcGluZyBzeW5jJyk7XG4gICAgICAgIHRoaXMuc3luYy5zdG9wcGVkID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFRPRE8gV2hlbiBpcyB0aGlzIGV2ZXIgdGhlIGNhc2UgYW5kIHdoYXQgaXMgc3luY1N0b3BwZWQgZm9yIHRoZW4/XG4gICAgICAgIGxvZygnW1N5bmNdIFdpbGwgaW5zdGFudGlhdGUgc3luYyBzdG9wcGVkJyk7XG4gICAgICAgIHRoaXMuc3luY1N0b3BwZWQgPSB0cnVlO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBzdGFydFN5bmM6IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICghY29uZmlnLmNhY2hlKSByZXR1cm5cbiAgICAgIHRoaXMuc3luYy5zdG9wcGVkID0gZmFsc2U7XG4gICAgICB0aGlzLnN5bmNTdG9wcGVkID0gZmFsc2U7XG4gICAgICB0aGlzLnN5bmMuc3luYygpO1xuICAgIH1cblxuICB9O1xuXG5cbiAgICAvKipcbiAgICogQ2hlY2sgaWYgaW50ZXJ2YWwgaXMgdmFsaWQ6IG51bWVyaWMgYW5kIGJldHdlZW4gMTAwMG1zIGFuZCAzNjAwMDAwbXNcbiAgICpcbiAgICovXG4gIGZ1bmN0aW9uIGlzVmFsaWRJbnRlcnZhbChpbnRlcnZhbCkge1xuICAgIHJldHVybiAodHlwZW9mIGludGVydmFsID09PSAnbnVtYmVyJyAmJiBpbnRlcnZhbCA+IDEwMDAgJiYgaW50ZXJ2YWwgPCAzNjAwMDAwKTtcbiAgfVxuXG5cbiAgUmVtb3RlU3RvcmFnZS51dGlsID0gdXRpbDtcbiAgLy8gUmVtb3RlU3RvcmFnZS5kZWZpbmVNb2R1bGUgPSBtb2R1bGVzLmRlZmluZU1vZHVsZTtcblxuICAvKipcbiAgICogUHJvcGVydHk6IGNvbm5lY3RlZFxuICAgKlxuICAgKiBCb29sZWFuIHByb3BlcnR5IGluZGljYXRpbmcgaWYgcmVtb3RlU3RvcmFnZSBpcyBjdXJyZW50bHkgY29ubmVjdGVkLlxuICAgKi9cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFJlbW90ZVN0b3JhZ2UucHJvdG90eXBlLCAnY29ubmVjdGVkJywge1xuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMucmVtb3RlLmNvbm5lY3RlZDtcbiAgICB9XG4gIH0pO1xuXG4gIC8qKlxuICAgKiBQcm9wZXJ0eTogYWNjZXNzXG4gICAqXG4gICAqIFRyYWNraW5nIGNsYWltZWQgYWNjZXNzIHNjb3Blcy4gQSA8UmVtb3RlU3RvcmFnZS5BY2Nlc3M+IGluc3RhbmNlLlxuICAqL1xuICB2YXIgQWNjZXNzID0gcmVxdWlyZSgnLi9hY2Nlc3MnKTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFJlbW90ZVN0b3JhZ2UucHJvdG90eXBlLCAnYWNjZXNzJywge1xuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgYWNjZXNzID0gbmV3IEFjY2VzcygpO1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdhY2Nlc3MnLCB7XG4gICAgICAgIHZhbHVlOiBhY2Nlc3NcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGFjY2VzcztcbiAgICB9LFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcblxuXG4gICAgLyogVE9GSVggKGluIHN5bmMuanMgYWxzby4uLiBoYXMgdG8gYmUgYSBzaGFyZWQgcHJvcGVydHkpICovXG4gICAgY29uZmlnLnN5bmNJbnRlcnZhbCA9IDEwMDAwLFxuICAgIGNvbmZpZy5iYWNrZ3JvdW5kU3luY0ludGVydmFsID0gNjAwMDAsXG4gICAgY29uZmlnLmlzQmFja2dyb3VuZCA9IGZhbHNlO1xuXG5cblxuXG5cblxuICAvLyBUT0RPIGNsZWFuIHVwL2hhcm1vbml6ZSBob3cgbW9kdWxlcyBhcmUgbG9hZGVkIGFuZC9vciBkb2N1bWVudCB0aGlzIGFyY2hpdGVjdHVyZSBwcm9wZXJseVxuICAvL1xuICAvLyBBdCB0aGlzIHBvaW50IHRoZSByZW1vdGVTdG9yYWdlIG9iamVjdCBoYXMgbm90IGJlZW4gY3JlYXRlZCB5ZXQuXG4gIC8vIE9ubHkgaXRzIHByb3RvdHlwZSBleGlzdHMgc28gZmFyLCBzbyB3ZSBkZWZpbmUgYSBzZWxmLWNvbnN0cnVjdGluZ1xuICAvLyBwcm9wZXJ0eSBvbiB0aGVyZTpcbiAgLyoqXG4gICAqXG4gICAqIFByb3BlcnR5OiBjYWNoaW5nXG4gICAqXG4gICAqIENhY2hpbmcgc2V0dGluZ3MuIEEgPFJlbW90ZVN0b3JhZ2UuQ2FjaGluZz4gaW5zdGFuY2UuXG4gICAqXG4gICAqIE5vdCBhdmFpbGFibGUgaW4gbm8tY2FjaGUgYnVpbGRzLlxuICAgKlxuICAgKi9cbiAgdmFyIENhY2hpbmcgPSByZXF1aXJlKCcuL2NhY2hpbmcnKTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFJlbW90ZVN0b3JhZ2UucHJvdG90eXBlLCAnY2FjaGluZycsIHtcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgY2FjaGluZyA9IG5ldyBDYWNoaW5nKCk7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ2NhY2hpbmcnLCB7XG4gICAgICAgIHZhbHVlOiBjYWNoaW5nXG4gICAgICB9KTtcbiAgICAgIHJldHVybiBjYWNoaW5nO1xuICAgIH1cbiAgfSk7XG5cbiAgIC8qXG4gICAqIFByb3BlcnR5OiByZW1vdGVcbiAgICpcbiAgICogQWNjZXNzIHRvIHRoZSByZW1vdGUgYmFja2VuZCB1c2VkLiBVc3VhbGx5IGEgPFJlbW90ZVN0b3JhZ2UuV2lyZUNsaWVudD4uXG4gICAqXG4gICAqXG4gICAqIFByb3BlcnR5OiBsb2NhbFxuICAgKlxuICAgKiBBY2Nlc3MgdG8gdGhlIGxvY2FsIGNhY2hpbmcgYmFja2VuZCB1c2VkLiBVc3VhbGx5IGVpdGhlciBhXG4gICAqIDxSZW1vdGVTdG9yYWdlLkluZGV4ZWREQj4gb3IgPFJlbW90ZVN0b3JhZ2UuTG9jYWxTdG9yYWdlPiBpbnN0YW5jZS5cbiAgICpcbiAgICogTm90IGF2YWlsYWJsZSBpbiBuby1jYWNoZSBidWlsZHMuXG4gICAqL1xuXG5cbm1vZHVsZS5leHBvcnRzID0gUmVtb3RlU3RvcmFnZTtcbnJlcXVpcmUoJy4vbW9kdWxlcycpXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL3JlbW90ZXN0b3JhZ2UuanMiXSwic291cmNlUm9vdCI6IiJ9");

/***/ },
/* 2 */
/***/ function(module, exports, __webpack_require__) {

	eval("/* WEBPACK VAR INJECTION */(function(global) {'use strict';\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\n// Reusable utility functions\n\n\nvar eventHandling = __webpack_require__(3);\n\n// wrapper to implement defer() functionality\nPromise.defer = function () {\n  var resolve, reject;\n  var promise = new Promise(function () {\n    resolve = arguments[0];\n    reject = arguments[1];\n  });\n  return {\n    resolve: resolve,\n    reject: reject,\n    promise: promise\n  };\n};\n\n/**\n * Function: fixArrayBuffers\n *\n * Takes an object and its copy as produced by the _deepClone function\n * below, and finds and fixes any ArrayBuffers that were cast to `{}` instead\n * of being cloned to new ArrayBuffers with the same content.\n *\n * It recurses into sub-objects, but skips arrays if they occur.\n */\nfunction fixArrayBuffers(srcObj, dstObj) {\n  var field, srcArr, dstArr;\n  if ((typeof srcObj === 'undefined' ? 'undefined' : _typeof(srcObj)) !== 'object' || Array.isArray(srcObj) || srcObj === null) {\n    return;\n  }\n  for (field in srcObj) {\n    if (_typeof(srcObj[field]) === 'object' && srcObj[field] !== null) {\n      if (srcObj[field].toString() === '[object ArrayBuffer]') {\n        dstObj[field] = new ArrayBuffer(srcObj[field].byteLength);\n        srcArr = new Int8Array(srcObj[field]);\n        dstArr = new Int8Array(dstObj[field]);\n        dstArr.set(srcArr);\n      } else {\n        fixArrayBuffers(srcObj[field], dstObj[field]);\n      }\n    }\n  }\n}\n\nvar util = {\n  logError: function logError(error) {\n    if (typeof error === 'string') {\n      console.error(error);\n    } else {\n      console.error(error.message, error.stack);\n    }\n  },\n\n\n  globalContext: typeof window !== 'undefined' ? window : global,\n\n  getGlobalContext: function getGlobalContext() {\n    return typeof window !== 'undefined' ? window : global;\n  },\n  extend: function extend(target) {\n    var sources = Array.prototype.slice.call(arguments, 1);\n    sources.forEach(function (source) {\n      for (var key in source) {\n        target[key] = source[key];\n      }\n    });\n    return target;\n  },\n  asyncEach: function asyncEach(array, callback) {\n    return this.asyncMap(array, callback).then(function () {\n      return array;\n    });\n  },\n  asyncMap: function asyncMap(array, callback) {\n    var pending = Promise.defer();\n    var n = array.length,\n        i = 0;\n    var results = [],\n        errors = [];\n\n    function oneDone() {\n      i++;\n      if (i === n) {\n        pending.resolve(results, errors);\n      }\n    }\n\n    array.forEach(function (item, index) {\n      var result;\n      try {\n        result = callback(item);\n      } catch (exc) {\n        oneDone();\n        errors[index] = exc;\n      }\n      if ((typeof result === 'undefined' ? 'undefined' : _typeof(result)) === 'object' && typeof result.then === 'function') {\n        result.then(function (res) {\n          results[index] = res;oneDone();\n        }, function (error) {\n          errors[index] = error;oneDone();\n        });\n      } else {\n        oneDone();\n        results[index] = result;\n      }\n    });\n\n    return pending.promise;\n  },\n  containingFolder: function containingFolder(path) {\n    if (path === '') {\n      return '/';\n    }\n    if (!path) {\n      throw \"Path not given!\";\n    }\n\n    return path.replace(/\\/+/g, '/').replace(/[^\\/]+\\/?$/, '');\n  },\n  isFolder: function isFolder(path) {\n    return path.substr(-1) === '/';\n  },\n  isDocument: function isDocument(path) {\n    return !util.isFolder(path);\n  },\n  baseName: function baseName(path) {\n    var parts = path.split('/');\n    if (util.isFolder(path)) {\n      return parts[parts.length - 2] + '/';\n    } else {\n      return parts[parts.length - 1];\n    }\n  },\n  cleanPath: function cleanPath(path) {\n    return path.replace(/\\/+/g, '/').split('/').map(encodeURIComponent).join('/').replace(/'/g, '%27');\n  },\n  bindAll: function bindAll(object) {\n    for (var key in this) {\n      if (typeof object[key] === 'function') {\n        object[key] = object[key].bind(object);\n      }\n    }\n  },\n  equal: function equal(a, b, seen) {\n    var key;\n    seen = seen || [];\n\n    if ((typeof a === 'undefined' ? 'undefined' : _typeof(a)) !== (typeof b === 'undefined' ? 'undefined' : _typeof(b))) {\n      return false;\n    }\n\n    if (typeof a === 'number' || typeof a === 'boolean' || typeof a === 'string') {\n      return a === b;\n    }\n\n    if (typeof a === 'function') {\n      return a.toString() === b.toString();\n    }\n\n    if (a instanceof ArrayBuffer && b instanceof ArrayBuffer) {\n      // Without the following conversion the browsers wouldn't be able to\n      // tell the ArrayBuffer instances apart.\n      a = new Uint8Array(a);\n      b = new Uint8Array(b);\n    }\n\n    // If this point has been reached, a and b are either arrays or objects.\n\n    if (a instanceof Array) {\n      if (a.length !== b.length) {\n        return false;\n      }\n\n      for (var i = 0, c = a.length; i < c; i++) {\n        if (!util.equal(a[i], b[i], seen)) {\n          return false;\n        }\n      }\n    } else {\n      // Check that keys from a exist in b\n      for (key in a) {\n        if (a.hasOwnProperty(key) && !(key in b)) {\n          return false;\n        }\n      }\n\n      // Check that keys from b exist in a, and compare the values\n      for (key in b) {\n        if (!b.hasOwnProperty(key)) {\n          continue;\n        }\n\n        if (!(key in a)) {\n          return false;\n        }\n\n        var seenArg;\n\n        if (_typeof(b[key]) === 'object') {\n          if (seen.indexOf(b[key]) >= 0) {\n            // Circular reference, don't attempt to compare this object.\n            // If nothing else returns false, the objects match.\n            continue;\n          }\n\n          seenArg = seen.slice();\n          seenArg.push(b[key]);\n        }\n\n        if (!util.equal(a[key], b[key], seenArg)) {\n          return false;\n        }\n      }\n    }\n\n    return true;\n  },\n  equalObj: function equalObj(obj1, obj2) {\n    console.warn('DEPRECATION WARNING: util.equalObj has been replaced by util.equal.');\n    return util.equal(obj1, obj2);\n  },\n  deepClone: function deepClone(obj) {\n    var clone;\n    if (obj === undefined) {\n      return undefined;\n    } else {\n      clone = JSON.parse(JSON.stringify(obj));\n      fixArrayBuffers(obj, clone);\n      return clone;\n    }\n  },\n  pathsFromRoot: function pathsFromRoot(path) {\n    var paths = [path];\n    var parts = path.replace(/\\/$/, '').split('/');\n\n    while (parts.length > 1) {\n      parts.pop();\n      paths.push(parts.join('/') + '/');\n    }\n    return paths;\n  },\n\n\n  /* jshint ignore:start */\n  md5sum: function md5sum(str) {\n    //\n    // http://www.myersdaily.org/joseph/javascript/md5.js\n    //\n    function md5cycle(x, k) {\n      var a = x[0],\n          b = x[1],\n          c = x[2],\n          d = x[3];\n\n      a = ff(a, b, c, d, k[0], 7, -680876936);\n      d = ff(d, a, b, c, k[1], 12, -389564586);\n      c = ff(c, d, a, b, k[2], 17, 606105819);\n      b = ff(b, c, d, a, k[3], 22, -1044525330);\n      a = ff(a, b, c, d, k[4], 7, -176418897);\n      d = ff(d, a, b, c, k[5], 12, 1200080426);\n      c = ff(c, d, a, b, k[6], 17, -1473231341);\n      b = ff(b, c, d, a, k[7], 22, -45705983);\n      a = ff(a, b, c, d, k[8], 7, 1770035416);\n      d = ff(d, a, b, c, k[9], 12, -1958414417);\n      c = ff(c, d, a, b, k[10], 17, -42063);\n      b = ff(b, c, d, a, k[11], 22, -1990404162);\n      a = ff(a, b, c, d, k[12], 7, 1804603682);\n      d = ff(d, a, b, c, k[13], 12, -40341101);\n      c = ff(c, d, a, b, k[14], 17, -1502002290);\n      b = ff(b, c, d, a, k[15], 22, 1236535329);\n\n      a = gg(a, b, c, d, k[1], 5, -165796510);\n      d = gg(d, a, b, c, k[6], 9, -1069501632);\n      c = gg(c, d, a, b, k[11], 14, 643717713);\n      b = gg(b, c, d, a, k[0], 20, -373897302);\n      a = gg(a, b, c, d, k[5], 5, -701558691);\n      d = gg(d, a, b, c, k[10], 9, 38016083);\n      c = gg(c, d, a, b, k[15], 14, -660478335);\n      b = gg(b, c, d, a, k[4], 20, -405537848);\n      a = gg(a, b, c, d, k[9], 5, 568446438);\n      d = gg(d, a, b, c, k[14], 9, -1019803690);\n      c = gg(c, d, a, b, k[3], 14, -187363961);\n      b = gg(b, c, d, a, k[8], 20, 1163531501);\n      a = gg(a, b, c, d, k[13], 5, -1444681467);\n      d = gg(d, a, b, c, k[2], 9, -51403784);\n      c = gg(c, d, a, b, k[7], 14, 1735328473);\n      b = gg(b, c, d, a, k[12], 20, -1926607734);\n\n      a = hh(a, b, c, d, k[5], 4, -378558);\n      d = hh(d, a, b, c, k[8], 11, -2022574463);\n      c = hh(c, d, a, b, k[11], 16, 1839030562);\n      b = hh(b, c, d, a, k[14], 23, -35309556);\n      a = hh(a, b, c, d, k[1], 4, -1530992060);\n      d = hh(d, a, b, c, k[4], 11, 1272893353);\n      c = hh(c, d, a, b, k[7], 16, -155497632);\n      b = hh(b, c, d, a, k[10], 23, -1094730640);\n      a = hh(a, b, c, d, k[13], 4, 681279174);\n      d = hh(d, a, b, c, k[0], 11, -358537222);\n      c = hh(c, d, a, b, k[3], 16, -722521979);\n      b = hh(b, c, d, a, k[6], 23, 76029189);\n      a = hh(a, b, c, d, k[9], 4, -640364487);\n      d = hh(d, a, b, c, k[12], 11, -421815835);\n      c = hh(c, d, a, b, k[15], 16, 530742520);\n      b = hh(b, c, d, a, k[2], 23, -995338651);\n\n      a = ii(a, b, c, d, k[0], 6, -198630844);\n      d = ii(d, a, b, c, k[7], 10, 1126891415);\n      c = ii(c, d, a, b, k[14], 15, -1416354905);\n      b = ii(b, c, d, a, k[5], 21, -57434055);\n      a = ii(a, b, c, d, k[12], 6, 1700485571);\n      d = ii(d, a, b, c, k[3], 10, -1894986606);\n      c = ii(c, d, a, b, k[10], 15, -1051523);\n      b = ii(b, c, d, a, k[1], 21, -2054922799);\n      a = ii(a, b, c, d, k[8], 6, 1873313359);\n      d = ii(d, a, b, c, k[15], 10, -30611744);\n      c = ii(c, d, a, b, k[6], 15, -1560198380);\n      b = ii(b, c, d, a, k[13], 21, 1309151649);\n      a = ii(a, b, c, d, k[4], 6, -145523070);\n      d = ii(d, a, b, c, k[11], 10, -1120210379);\n      c = ii(c, d, a, b, k[2], 15, 718787259);\n      b = ii(b, c, d, a, k[9], 21, -343485551);\n\n      x[0] = add32(a, x[0]);\n      x[1] = add32(b, x[1]);\n      x[2] = add32(c, x[2]);\n      x[3] = add32(d, x[3]);\n    }\n\n    function cmn(q, a, b, x, s, t) {\n      a = add32(add32(a, q), add32(x, t));\n      return add32(a << s | a >>> 32 - s, b);\n    }\n\n    function ff(a, b, c, d, x, s, t) {\n      return cmn(b & c | ~b & d, a, b, x, s, t);\n    }\n\n    function gg(a, b, c, d, x, s, t) {\n      return cmn(b & d | c & ~d, a, b, x, s, t);\n    }\n\n    function hh(a, b, c, d, x, s, t) {\n      return cmn(b ^ c ^ d, a, b, x, s, t);\n    }\n\n    function ii(a, b, c, d, x, s, t) {\n      return cmn(c ^ (b | ~d), a, b, x, s, t);\n    }\n\n    function md51(s) {\n      txt = '';\n      var n = s.length,\n          state = [1732584193, -271733879, -1732584194, 271733878],\n          i;\n      for (i = 64; i <= s.length; i += 64) {\n        md5cycle(state, md5blk(s.substring(i - 64, i)));\n      }\n      s = s.substring(i - 64);\n      var tail = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];\n      for (i = 0; i < s.length; i++) {\n        tail[i >> 2] |= s.charCodeAt(i) << (i % 4 << 3);\n      }tail[i >> 2] |= 0x80 << (i % 4 << 3);\n      if (i > 55) {\n        md5cycle(state, tail);\n        for (i = 0; i < 16; i++) {\n          tail[i] = 0;\n        }\n      }\n      tail[14] = n * 8;\n      md5cycle(state, tail);\n      return state;\n    }\n\n    function md5blk(s) {\n      var md5blks = [],\n          i;\n      for (i = 0; i < 64; i += 4) {\n        md5blks[i >> 2] = s.charCodeAt(i) + (s.charCodeAt(i + 1) << 8) + (s.charCodeAt(i + 2) << 16) + (s.charCodeAt(i + 3) << 24);\n      }\n      return md5blks;\n    }\n\n    var hex_chr = '0123456789abcdef'.split('');\n\n    function rhex(n) {\n      var s = '',\n          j = 0;\n      for (; j < 4; j++) {\n        s += hex_chr[n >> j * 8 + 4 & 0x0F] + hex_chr[n >> j * 8 & 0x0F];\n      }return s;\n    }\n\n    function hex(x) {\n      for (var i = 0; i < x.length; i++) {\n        x[i] = rhex(x[i]);\n      }return x.join('');\n    }\n\n    function md5(s) {\n      return hex(md51(s));\n    }\n\n    var add32 = function add32(a, b) {\n      return a + b & 0xFFFFFFFF;\n    };\n\n    if (md5('hello') !== '5d41402abc4b2a76b9719d911017c592') {\n      add32 = function add32(x, y) {\n        var lsw = (x & 0xFFFF) + (y & 0xFFFF),\n            msw = (x >> 16) + (y >> 16) + (lsw >> 16);\n        return msw << 16 | lsw & 0xFFFF;\n      };\n    }\n\n    return md5(str);\n  },\n\n  /* jshint ignore:end */\n\n  localStorageAvailable: function localStorageAvailable() {\n    var context = util.getGlobalContext();\n\n    if (!('localStorage' in context)) {\n      return false;\n    }\n\n    try {\n      context.localStorage.setItem('rs-check', 1);\n      context.localStorage.removeItem('rs-check');\n      return true;\n    } catch (error) {\n      return false;\n    }\n  }\n};\n\nmodule.exports = util;\n/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvdXRpbC5qcz9hZDAwIl0sIm5hbWVzIjpbImV2ZW50SGFuZGxpbmciLCJyZXF1aXJlIiwiUHJvbWlzZSIsImRlZmVyIiwicmVzb2x2ZSIsInJlamVjdCIsInByb21pc2UiLCJhcmd1bWVudHMiLCJmaXhBcnJheUJ1ZmZlcnMiLCJzcmNPYmoiLCJkc3RPYmoiLCJmaWVsZCIsInNyY0FyciIsImRzdEFyciIsIkFycmF5IiwiaXNBcnJheSIsInRvU3RyaW5nIiwiQXJyYXlCdWZmZXIiLCJieXRlTGVuZ3RoIiwiSW50OEFycmF5Iiwic2V0IiwidXRpbCIsImxvZ0Vycm9yIiwiZXJyb3IiLCJjb25zb2xlIiwibWVzc2FnZSIsInN0YWNrIiwiZ2xvYmFsQ29udGV4dCIsIndpbmRvdyIsImdsb2JhbCIsImdldEdsb2JhbENvbnRleHQiLCJleHRlbmQiLCJ0YXJnZXQiLCJzb3VyY2VzIiwicHJvdG90eXBlIiwic2xpY2UiLCJjYWxsIiwiZm9yRWFjaCIsInNvdXJjZSIsImtleSIsImFzeW5jRWFjaCIsImFycmF5IiwiY2FsbGJhY2siLCJhc3luY01hcCIsInRoZW4iLCJwZW5kaW5nIiwibiIsImxlbmd0aCIsImkiLCJyZXN1bHRzIiwiZXJyb3JzIiwib25lRG9uZSIsIml0ZW0iLCJpbmRleCIsInJlc3VsdCIsImV4YyIsInJlcyIsImNvbnRhaW5pbmdGb2xkZXIiLCJwYXRoIiwicmVwbGFjZSIsImlzRm9sZGVyIiwic3Vic3RyIiwiaXNEb2N1bWVudCIsImJhc2VOYW1lIiwicGFydHMiLCJzcGxpdCIsImNsZWFuUGF0aCIsIm1hcCIsImVuY29kZVVSSUNvbXBvbmVudCIsImpvaW4iLCJiaW5kQWxsIiwib2JqZWN0IiwiYmluZCIsImVxdWFsIiwiYSIsImIiLCJzZWVuIiwiVWludDhBcnJheSIsImMiLCJoYXNPd25Qcm9wZXJ0eSIsInNlZW5BcmciLCJpbmRleE9mIiwicHVzaCIsImVxdWFsT2JqIiwib2JqMSIsIm9iajIiLCJ3YXJuIiwiZGVlcENsb25lIiwib2JqIiwiY2xvbmUiLCJ1bmRlZmluZWQiLCJKU09OIiwicGFyc2UiLCJzdHJpbmdpZnkiLCJwYXRoc0Zyb21Sb290IiwicGF0aHMiLCJwb3AiLCJtZDVzdW0iLCJzdHIiLCJtZDVjeWNsZSIsIngiLCJrIiwiZCIsImZmIiwiZ2ciLCJoaCIsImlpIiwiYWRkMzIiLCJjbW4iLCJxIiwicyIsInQiLCJtZDUxIiwidHh0Iiwic3RhdGUiLCJtZDVibGsiLCJzdWJzdHJpbmciLCJ0YWlsIiwiY2hhckNvZGVBdCIsIm1kNWJsa3MiLCJoZXhfY2hyIiwicmhleCIsImoiLCJoZXgiLCJtZDUiLCJ5IiwibHN3IiwibXN3IiwibG9jYWxTdG9yYWdlQXZhaWxhYmxlIiwiY29udGV4dCIsImxvY2FsU3RvcmFnZSIsInNldEl0ZW0iLCJyZW1vdmVJdGVtIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJtYXBwaW5ncyI6Ijs7OztBQUFBOzs7QUFHQSxJQUFNQSxnQkFBZ0IsbUJBQUFDLENBQVEsQ0FBUixDQUF0Qjs7QUFHQTtBQUNBQyxRQUFRQyxLQUFSLEdBQWdCLFlBQVk7QUFDMUIsTUFBSUMsT0FBSixFQUFhQyxNQUFiO0FBQ0EsTUFBSUMsVUFBVSxJQUFJSixPQUFKLENBQVksWUFBVztBQUNuQ0UsY0FBVUcsVUFBVSxDQUFWLENBQVY7QUFDQUYsYUFBU0UsVUFBVSxDQUFWLENBQVQ7QUFDRCxHQUhhLENBQWQ7QUFJQSxTQUFPO0FBQ0hILGFBQVNBLE9BRE47QUFFTEMsWUFBUUEsTUFGSDtBQUdMQyxhQUFTQTtBQUhKLEdBQVA7QUFLRCxDQVhEOztBQWNFOzs7Ozs7Ozs7QUFTQSxTQUFTRSxlQUFULENBQXlCQyxNQUF6QixFQUFpQ0MsTUFBakMsRUFBeUM7QUFDdkMsTUFBSUMsS0FBSixFQUFXQyxNQUFYLEVBQW1CQyxNQUFuQjtBQUNBLE1BQUksUUFBT0osTUFBUCx5Q0FBT0EsTUFBUCxPQUFtQixRQUFuQixJQUErQkssTUFBTUMsT0FBTixDQUFjTixNQUFkLENBQS9CLElBQXdEQSxXQUFXLElBQXZF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SUUsT0FBTTdHLEtBQU4sRUFBYTtBQUNiLGFBQU8sS0FBUDtBQUNEO0FBQ0Y7QUFwWVEsQ0FBWDs7QUF3WUE4RyxPQUFPQyxPQUFQLEdBQWlCakgsSUFBakIsQyIsImZpbGUiOiIyLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gUmV1c2FibGUgdXRpbGl0eSBmdW5jdGlvbnNcblxuXG5jb25zdCBldmVudEhhbmRsaW5nID0gcmVxdWlyZSgnLi9ldmVudGhhbmRsaW5nJyk7XG5cblxuLy8gd3JhcHBlciB0byBpbXBsZW1lbnQgZGVmZXIoKSBmdW5jdGlvbmFsaXR5XG5Qcm9taXNlLmRlZmVyID0gZnVuY3Rpb24gKCkge1xuICB2YXIgcmVzb2x2ZSwgcmVqZWN0O1xuICB2YXIgcHJvbWlzZSA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uKCkge1xuICAgIHJlc29sdmUgPSBhcmd1bWVudHNbMF07XG4gICAgcmVqZWN0ID0gYXJndW1lbnRzWzFdO1xuICB9KTtcbiAgcmV0dXJuIHtcbiAgICAgIHJlc29sdmU6IHJlc29sdmUsXG4gICAgcmVqZWN0OiByZWplY3QsXG4gICAgcHJvbWlzZTogcHJvbWlzZVxuICB9O1xufTtcblxuXG4gIC8qKlxuICAgKiBGdW5jdGlvbjogZml4QXJyYXlCdWZmZXJzXG4gICAqXG4gICAqIFRha2VzIGFuIG9iamVjdCBhbmQgaXRzIGNvcHkgYXMgcHJvZHVjZWQgYnkgdGhlIF9kZWVwQ2xvbmUgZnVuY3Rpb25cbiAgICogYmVsb3csIGFuZCBmaW5kcyBhbmQgZml4ZXMgYW55IEFycmF5QnVmZmVycyB0aGF0IHdlcmUgY2FzdCB0byBge31gIGluc3RlYWRcbiAgICogb2YgYmVpbmcgY2xvbmVkIHRvIG5ldyBBcnJheUJ1ZmZlcnMgd2l0aCB0aGUgc2FtZSBjb250ZW50LlxuICAgKlxuICAgKiBJdCByZWN1cnNlcyBpbnRvIHN1Yi1vYmplY3RzLCBidXQgc2tpcHMgYXJyYXlzIGlmIHRoZXkgb2NjdXIuXG4gICAqL1xuICBmdW5jdGlvbiBmaXhBcnJheUJ1ZmZlcnMoc3JjT2JqLCBkc3RPYmopIHtcbiAgICB2YXIgZmllbGQsIHNyY0FyciwgZHN0QXJyO1xuICAgIGlmICh0eXBlb2Yoc3JjT2JqKSAhPT0gJ29iamVjdCcgfHwgQXJyYXkuaXNBcnJheShzcmNPYmopIHx8IHNyY09iaiA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBmb3IgKGZpZWxkIGluIHNyY09iaikge1xuICAgICAgaWYgKHR5cGVvZihzcmNPYmpbZmllbGRdKSA9PT0gJ29iamVjdCcgJiYgc3JjT2JqW2ZpZWxkXSAhPT0gbnVsbCkge1xuICAgICAgICBpZiAoc3JjT2JqW2ZpZWxkXS50b1N0cmluZygpID09PSAnW29iamVjdCBBcnJheUJ1ZmZlcl0nKSB7XG4gICAgICAgICAgZHN0T2JqW2ZpZWxkXSA9IG5ldyBBcnJheUJ1ZmZlcihzcmNPYmpbZmllbGRdLmJ5dGVMZW5ndGgpO1xuICAgICAgICAgIHNyY0FyciA9IG5ldyBJbnQ4QXJyYXkoc3JjT2JqW2ZpZWxkXSk7XG4gICAgICAgICAgZHN0QXJyID0gbmV3IEludDhBcnJheShkc3RPYmpbZmllbGRdKTtcbiAgICAgICAgICBkc3RBcnIuc2V0KHNyY0Fycik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZml4QXJyYXlCdWZmZXJzKHNyY09ialtmaWVsZF0sIGRzdE9ialtmaWVsZF0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdmFyIHV0aWwgPSB7XG4gICAgbG9nRXJyb3IoZXJyb3IpIHtcbiAgICAgIGlmICh0eXBlb2YoZXJyb3IpID09PSAnc3RyaW5nJykge1xuICAgICAgICBjb25zb2xlLmVycm9yKGVycm9yKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyb3IubWVzc2FnZSwgZXJyb3Iuc3RhY2spO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBnbG9iYWxDb250ZXh0OiAodHlwZW9mKHdpbmRvdykgIT09ICd1bmRlZmluZWQnID8gd2luZG93IDogZ2xvYmFsKSxcblxuICAgIGdldEdsb2JhbENvbnRleHQgKCkge1xuICAgICAgcmV0dXJuICh0eXBlb2Yod2luZG93KSAhPT0gJ3VuZGVmaW5lZCcgPyB3aW5kb3cgOiBnbG9iYWwpXG4gICAgfSxcblxuICAgIGV4dGVuZCAodGFyZ2V0KSB7XG4gICAgICB2YXIgc291cmNlcyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gICAgICBzb3VyY2VzLmZvckVhY2goZnVuY3Rpb24gKHNvdXJjZSkge1xuICAgICAgICBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7XG4gICAgICAgICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gdGFyZ2V0O1xuICAgIH0sXG5cbiAgICBhc3luY0VhY2ggKGFycmF5LCBjYWxsYmFjaykge1xuICAgICAgcmV0dXJuIHRoaXMuYXN5bmNNYXAoYXJyYXksIGNhbGxiYWNrKS5cbiAgICAgICAgdGhlbihmdW5jdGlvbiAoKSB7IHJldHVybiBhcnJheTsgfSk7XG4gICAgfSxcblxuICAgIGFzeW5jTWFwIChhcnJheSwgY2FsbGJhY2spIHtcbiAgICAgIHZhciBwZW5kaW5nID0gUHJvbWlzZS5kZWZlcigpO1xuICAgICAgdmFyIG4gPSBhcnJheS5sZW5ndGgsIGkgPSAwO1xuICAgICAgdmFyIHJlc3VsdHMgPSBbXSwgZXJyb3JzID0gW107XG5cbiAgICAgIGZ1bmN0aW9uIG9uZURvbmUoKSB7XG4gICAgICAgIGkrKztcbiAgICAgICAgaWYgKGkgPT09IG4pIHtcbiAgICAgICAgICBwZW5kaW5nLnJlc29sdmUocmVzdWx0cywgZXJyb3JzKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBhcnJheS5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtLCBpbmRleCkge1xuICAgICAgICB2YXIgcmVzdWx0O1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHJlc3VsdCA9IGNhbGxiYWNrKGl0ZW0pO1xuICAgICAgICB9IGNhdGNoKGV4Yykge1xuICAgICAgICAgIG9uZURvbmUoKTtcbiAgICAgICAgICBlcnJvcnNbaW5kZXhdID0gZXhjO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YocmVzdWx0KSA9PT0gJ29iamVjdCcgJiYgdHlwZW9mKHJlc3VsdC50aGVuKSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIHJlc3VsdC50aGVuKGZ1bmN0aW9uIChyZXMpIHsgcmVzdWx0c1tpbmRleF0gPSByZXM7IG9uZURvbmUoKTsgfSxcbiAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiAoZXJyb3IpIHsgZXJyb3JzW2luZGV4XSA9IGVycm9yOyBvbmVEb25lKCk7IH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG9uZURvbmUoKTtcbiAgICAgICAgICByZXN1bHRzW2luZGV4XSA9IHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIHJldHVybiBwZW5kaW5nLnByb21pc2U7XG4gICAgfSxcblxuICAgIGNvbnRhaW5pbmdGb2xkZXIgKHBhdGgpIHtcbiAgICAgIGlmIChwYXRoID09PSAnJykge1xuICAgICAgICByZXR1cm4gJy8nO1xuICAgICAgfVxuICAgICAgaWYgKCEgcGF0aCkge1xuICAgICAgICB0aHJvdyBcIlBhdGggbm90IGdpdmVuIVwiO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcGF0aC5yZXBsYWNlKC9cXC8rL2csICcvJykucmVwbGFjZSgvW15cXC9dK1xcLz8kLywgJycpO1xuICAgIH0sXG5cbiAgICBpc0ZvbGRlciAocGF0aCkge1xuICAgICAgcmV0dXJuIHBhdGguc3Vic3RyKC0xKSA9PT0gJy8nO1xuICAgIH0sXG5cbiAgICBpc0RvY3VtZW50IChwYXRoKSB7XG4gICAgICByZXR1cm4gIXV0aWwuaXNGb2xkZXIocGF0aCk7XG4gICAgfSxcblxuICAgIGJhc2VOYW1lIChwYXRoKSB7XG4gICAgICB2YXIgcGFydHMgPSBwYXRoLnNwbGl0KCcvJyk7XG4gICAgICBpZiAodXRpbC5pc0ZvbGRlcihwYXRoKSkge1xuICAgICAgICByZXR1cm4gcGFydHNbcGFydHMubGVuZ3RoLTJdKycvJztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBwYXJ0c1twYXJ0cy5sZW5ndGgtMV07XG4gICAgICB9XG4gICAgfSxcblxuICAgIGNsZWFuUGF0aCAocGF0aCkge1xuICAgICAgcmV0dXJuIHBhdGgucmVwbGFjZSgvXFwvKy9nLCAnLycpXG4gICAgICAgICAgICAgICAgIC5zcGxpdCgnLycpLm1hcChlbmNvZGVVUklDb21wb25lbnQpLmpvaW4oJy8nKVxuICAgICAgICAgICAgICAgICAucmVwbGFjZSgvJy9nLCAnJTI3Jyk7XG4gICAgfSxcblxuICAgIGJpbmRBbGwgKG9iamVjdCkge1xuICAgICAgZm9yICh2YXIga2V5IGluIHRoaXMpIHtcbiAgICAgICAgaWYgKHR5cGVvZihvYmplY3Rba2V5XSkgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICBvYmplY3Rba2V5XSA9IG9iamVjdFtrZXldLmJpbmQob2JqZWN0KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBlcXVhbCAoYSwgYiwgc2Vlbikge1xuICAgICAgdmFyIGtleTtcbiAgICAgIHNlZW4gPSBzZWVuIHx8IFtdO1xuXG4gICAgICBpZiAodHlwZW9mKGEpICE9PSB0eXBlb2YoYikpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mKGEpID09PSAnbnVtYmVyJyB8fCB0eXBlb2YoYSkgPT09ICdib29sZWFuJyB8fCB0eXBlb2YoYSkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiBhID09PSBiO1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mKGEpID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiBhLnRvU3RyaW5nKCkgPT09IGIudG9TdHJpbmcoKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGEgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlciAmJiBiIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICAgICAgLy8gV2l0aG91dCB0aGUgZm9sbG93aW5nIGNvbnZlcnNpb24gdGhlIGJyb3dzZXJzIHdvdWxkbid0IGJlIGFibGUgdG9cbiAgICAgICAgLy8gdGVsbCB0aGUgQXJyYXlCdWZmZXIgaW5zdGFuY2VzIGFwYXJ0LlxuICAgICAgICBhID0gbmV3IFVpbnQ4QXJyYXkoYSk7XG4gICAgICAgIGIgPSBuZXcgVWludDhBcnJheShiKTtcbiAgICAgIH1cblxuICAgICAgLy8gSWYgdGhpcyBwb2ludCBoYXMgYmVlbiByZWFjaGVkLCBhIGFuZCBiIGFyZSBlaXRoZXIgYXJyYXlzIG9yIG9iamVjdHMuXG5cbiAgICAgIGlmIChhIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgICAgaWYgKGEubGVuZ3RoICE9PSBiLmxlbmd0aCkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBjID0gYS5sZW5ndGg7IGkgPCBjOyBpKyspIHtcbiAgICAgICAgICBpZiAoIXV0aWwuZXF1YWwoYVtpXSwgYltpXSwgc2VlbikpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIENoZWNrIHRoYXQga2V5cyBmcm9tIGEgZXhpc3QgaW4gYlxuICAgICAgICBmb3IgKGtleSBpbiBhKSB7XG4gICAgICAgICAgaWYgKGEuaGFzT3duUHJvcGVydHkoa2V5KSAmJiAhKGtleSBpbiBiKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENoZWNrIHRoYXQga2V5cyBmcm9tIGIgZXhpc3QgaW4gYSwgYW5kIGNvbXBhcmUgdGhlIHZhbHVlc1xuICAgICAgICBmb3IgKGtleSBpbiBiKSB7XG4gICAgICAgICAgaWYgKCFiLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICghKGtleSBpbiBhKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBzZWVuQXJnO1xuXG4gICAgICAgICAgaWYgKHR5cGVvZihiW2tleV0pID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgaWYgKHNlZW4uaW5kZXhPZihiW2tleV0pID49IDApIHtcbiAgICAgICAgICAgICAgLy8gQ2lyY3VsYXIgcmVmZXJlbmNlLCBkb24ndCBhdHRlbXB0IHRvIGNvbXBhcmUgdGhpcyBvYmplY3QuXG4gICAgICAgICAgICAgIC8vIElmIG5vdGhpbmcgZWxzZSByZXR1cm5zIGZhbHNlLCB0aGUgb2JqZWN0cyBtYXRjaC5cbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHNlZW5BcmcgPSBzZWVuLnNsaWNlKCk7XG4gICAgICAgICAgICBzZWVuQXJnLnB1c2goYltrZXldKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoIXV0aWwuZXF1YWwoYVtrZXldLCBiW2tleV0sIHNlZW5BcmcpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0sXG5cbiAgICBlcXVhbE9iaiAob2JqMSwgb2JqMikge1xuICAgICAgY29uc29sZS53YXJuKCdERVBSRUNBVElPTiBXQVJOSU5HOiB1dGlsLmVxdWFsT2JqIGhhcyBiZWVuIHJlcGxhY2VkIGJ5IHV0aWwuZXF1YWwuJyk7XG4gICAgICByZXR1cm4gdXRpbC5lcXVhbChvYmoxLCBvYmoyKTtcbiAgICB9LFxuXG4gICAgZGVlcENsb25lIChvYmopIHtcbiAgICAgIHZhciBjbG9uZTtcbiAgICAgIGlmIChvYmogPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2xvbmUgPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KG9iaikpO1xuICAgICAgICBmaXhBcnJheUJ1ZmZlcnMob2JqLCBjbG9uZSk7XG4gICAgICAgIHJldHVybiBjbG9uZTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgcGF0aHNGcm9tUm9vdCAocGF0aCkge1xuICAgICAgdmFyIHBhdGhzID0gW3BhdGhdO1xuICAgICAgdmFyIHBhcnRzID0gcGF0aC5yZXBsYWNlKC9cXC8kLywgJycpLnNwbGl0KCcvJyk7XG5cbiAgICAgIHdoaWxlIChwYXJ0cy5sZW5ndGggPiAxKSB7XG4gICAgICAgIHBhcnRzLnBvcCgpO1xuICAgICAgICBwYXRocy5wdXNoKHBhcnRzLmpvaW4oJy8nKSsnLycpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHBhdGhzO1xuICAgIH0sXG5cbiAgICAvKiBqc2hpbnQgaWdub3JlOnN0YXJ0ICovXG4gICAgbWQ1c3VtIChzdHIpIHtcbiAgICAgIC8vXG4gICAgICAvLyBodHRwOi8vd3d3Lm15ZXJzZGFpbHkub3JnL2pvc2VwaC9qYXZhc2NyaXB0L21kNS5qc1xuICAgICAgLy9cbiAgICAgIGZ1bmN0aW9uIG1kNWN5Y2xlKHgsIGspIHtcbiAgICAgICAgdmFyIGEgPSB4WzBdLCBiID0geFsxXSwgYyA9IHhbMl0sIGQgPSB4WzNdO1xuXG4gICAgICAgIGEgPSBmZihhLCBiLCBjLCBkLCBrWzBdLCA3LCAtNjgwODc2OTM2KTtcbiAgICAgICAgZCA9IGZmKGQsIGEsIGIsIGMsIGtbMV0sIDEyLCAtMzg5NTY0NTg2KTtcbiAgICAgICAgYyA9IGZmKGMsIGQsIGEsIGIsIGtbMl0sIDE3LCAgNjA2MTA1ODE5KTtcbiAgICAgICAgYiA9IGZmKGIsIGMsIGQsIGEsIGtbM10sIDIyLCAtMTA0NDUyNTMzMCk7XG4gICAgICAgIGEgPSBmZihhLCBiLCBjLCBkLCBrWzRdLCA3LCAtMTc2NDE4ODk3KTtcbiAgICAgICAgZCA9IGZmKGQsIGEsIGIsIGMsIGtbNV0sIDEyLCAgMTIwMDA4MDQyNik7XG4gICAgICAgIGMgPSBmZihjLCBkLCBhLCBiLCBrWzZdLCAxNywgLTE0NzMyMzEzNDEpO1xuICAgICAgICBiID0gZmYoYiwgYywgZCwgYSwga1s3XSwgMjIsIC00NTcwNTk4Myk7XG4gICAgICAgIGEgPSBmZihhLCBiLCBjLCBkLCBrWzhdLCA3LCAgMTc3MDAzNTQxNik7XG4gICAgICAgIGQgPSBmZihkLCBhLCBiLCBjLCBrWzldLCAxMiwgLTE5NTg0MTQ0MTcpO1xuICAgICAgICBjID0gZmYoYywgZCwgYSwgYiwga1sxMF0sIDE3LCAtNDIwNjMpO1xuICAgICAgICBiID0gZmYoYiwgYywgZCwgYSwga1sxMV0sIDIyLCAtMTk5MDQwNDE2Mik7XG4gICAgICAgIGEgPSBmZihhLCBiLCBjLCBkLCBrWzEyXSwgNywgIDE4MDQ2MDM2ODIpO1xuICAgICAgICBkID0gZmYoZCwgYSwgYiwgYywga1sxM10sIDEyLCAtNDAzNDExMDEpO1xuICAgICAgICBjID0gZmYoYywgZCwgYSwgYiwga1sxNF0sIDE3LCAtMTUwMjAwMjI5MCk7XG4gICAgICAgIGIgPSBmZihiLCBjLCBkLCBhLCBrWzE1XSwgMjIsICAxMjM2NTM1MzI5KTtcblxuICAgICAgICBhID0gZ2coYSwgYiwgYywgZCwga1sxXSwgNSwgLTE2NTc5NjUxMCk7XG4gICAgICAgIGQgPSBnZyhkLCBhLCBiLCBjLCBrWzZdLCA5LCAtMTA2OTUwMTYzMik7XG4gICAgICAgIGMgPSBnZyhjLCBkLCBhLCBiLCBrWzExXSwgMTQsICA2NDM3MTc3MTMpO1xuICAgICAgICBiID0gZ2coYiwgYywgZCwgYSwga1swXSwgMjAsIC0zNzM4OTczMDIpO1xuICAgICAgICBhID0gZ2coYSwgYiwgYywgZCwga1s1XSwgNSwgLTcwMTU1ODY5MSk7XG4gICAgICAgIGQgPSBnZyhkLCBhLCBiLCBjLCBrWzEwXSwgOSwgIDM4MDE2MDgzKTtcbiAgICAgICAgYyA9IGdnKGMsIGQsIGEsIGIsIGtbMTVdLCAxNCwgLTY2MDQ3ODMzNSk7XG4gICAgICAgIGIgPSBnZyhiLCBjLCBkLCBhLCBrWzRdLCAyMCwgLTQwNTUzNzg0OCk7XG4gICAgICAgIGEgPSBnZyhhLCBiLCBjLCBkLCBrWzldLCA1LCAgNTY4NDQ2NDM4KTtcbiAgICAgICAgZCA9IGdnKGQsIGEsIGIsIGMsIGtbMTRdLCA5LCAtMTAxOTgwMzY5MCk7XG4gICAgICAgIGMgPSBnZyhjLCBkLCBhLCBiLCBrWzNdLCAxNCwgLTE4NzM2Mzk2MSk7XG4gICAgICAgIGIgPSBnZyhiLCBjLCBkLCBhLCBrWzhdLCAyMCwgIDExNjM1MzE1MDEpO1xuICAgICAgICBhID0gZ2coYSwgYiwgYywgZCwga1sxM10sIDUsIC0xNDQ0NjgxNDY3KTtcbiAgICAgICAgZCA9IGdnKGQsIGEsIGIsIGMsIGtbMl0sIDksIC01MTQwMzc4NCk7XG4gICAgICAgIGMgPSBnZyhjLCBkLCBhLCBiLCBrWzddLCAxNCwgIDE3MzUzMjg0NzMpO1xuICAgICAgICBiID0gZ2coYiwgYywgZCwgYSwga1sxMl0sIDIwLCAtMTkyNjYwNzczNCk7XG5cbiAgICAgICAgYSA9IGhoKGEsIGIsIGMsIGQsIGtbNV0sIDQsIC0zNzg1NTgpO1xuICAgICAgICBkID0gaGgoZCwgYSwgYiwgYywga1s4XSwgMTEsIC0yMDIyNTc0NDYzKTtcbiAgICAgICAgYyA9IGhoKGMsIGQsIGEsIGIsIGtbMTFdLCAxNiwgIDE4MzkwMzA1NjIpO1xuICAgICAgICBiID0gaGgoYiwgYywgZCwgYSwga1sxNF0sIDIzLCAtMzUzMDk1NTYpO1xuICAgICAgICBhID0gaGgoYSwgYiwgYywgZCwga1sxXSwgNCwgLTE1MzA5OTIwNjApO1xuICAgICAgICBkID0gaGgoZCwgYSwgYiwgYywga1s0XSwgMTEsICAxMjcyODkzMzUzKTtcbiAgICAgICAgYyA9IGhoKGMsIGQsIGEsIGIsIGtbN10sIDE2LCAtMTU1NDk3NjMyKTtcbiAgICAgICAgYiA9IGhoKGIsIGMsIGQsIGEsIGtbMTBdLCAyMywgLTEwOTQ3MzA2NDApO1xuICAgICAgICBhID0gaGgoYSwgYiwgYywgZCwga1sxM10sIDQsICA2ODEyNzkxNzQpO1xuICAgICAgICBkID0gaGgoZCwgYSwgYiwgYywga1swXSwgMTEsIC0zNTg1MzcyMjIpO1xuICAgICAgICBjID0gaGgoYywgZCwgYSwgYiwga1szXSwgMTYsIC03MjI1MjE5NzkpO1xuICAgICAgICBiID0gaGgoYiwgYywgZCwgYSwga1s2XSwgMjMsICA3NjAyOTE4OSk7XG4gICAgICAgIGEgPSBoaChhLCBiLCBjLCBkLCBrWzldLCA0LCAtNjQwMzY0NDg3KTtcbiAgICAgICAgZCA9IGhoKGQsIGEsIGIsIGMsIGtbMTJdLCAxMSwgLTQyMTgxNTgzNSk7XG4gICAgICAgIGMgPSBoaChjLCBkLCBhLCBiLCBrWzE1XSwgMTYsICA1MzA3NDI1MjApO1xuICAgICAgICBiID0gaGgoYiwgYywgZCwgYSwga1syXSwgMjMsIC05OTUzMzg2NTEpO1xuXG4gICAgICAgIGEgPSBpaShhLCBiLCBjLCBkLCBrWzBdLCA2LCAtMTk4NjMwODQ0KTtcbiAgICAgICAgZCA9IGlpKGQsIGEsIGIsIGMsIGtbN10sIDEwLCAgMTEyNjg5MTQxNSk7XG4gICAgICAgIGMgPSBpaShjLCBkLCBhLCBiLCBrWzE0XSwgMTUsIC0xNDE2MzU0OTA1KTtcbiAgICAgICAgYiA9IGlpKGIsIGMsIGQsIGEsIGtbNV0sIDIxLCAtNTc0MzQwNTUpO1xuICAgICAgICBhID0gaWkoYSwgYiwgYywgZCwga1sxMl0sIDYsICAxNzAwNDg1NTcxKTtcbiAgICAgICAgZCA9IGlpKGQsIGEsIGIsIGMsIGtbM10sIDEwLCAtMTg5NDk4NjYwNik7XG4gICAgICAgIGMgPSBpaShjLCBkLCBhLCBiLCBrWzEwXSwgMTUsIC0xMDUxNTIzKTtcbiAgICAgICAgYiA9IGlpKGIsIGMsIGQsIGEsIGtbMV0sIDIxLCAtMjA1NDkyMjc5OSk7XG4gICAgICAgIGEgPSBpaShhLCBiLCBjLCBkLCBrWzhdLCA2LCAgMTg3MzMxMzM1OSk7XG4gICAgICAgIGQgPSBpaShkLCBhLCBiLCBjLCBrWzE1XSwgMTAsIC0zMDYxMTc0NCk7XG4gICAgICAgIGMgPSBpaShjLCBkLCBhLCBiLCBrWzZdLCAxNSwgLTE1NjAxOTgzODApO1xuICAgICAgICBiID0gaWkoYiwgYywgZCwgYSwga1sxM10sIDIxLCAgMTMwOTE1MTY0OSk7XG4gICAgICAgIGEgPSBpaShhLCBiLCBjLCBkLCBrWzRdLCA2LCAtMTQ1NTIzMDcwKTtcbiAgICAgICAgZCA9IGlpKGQsIGEsIGIsIGMsIGtbMTFdLCAxMCwgLTExMjAyMTAzNzkpO1xuICAgICAgICBjID0gaWkoYywgZCwgYSwgYiwga1syXSwgMTUsICA3MTg3ODcyNTkpO1xuICAgICAgICBiID0gaWkoYiwgYywgZCwgYSwga1s5XSwgMjEsIC0zNDM0ODU1NTEpO1xuXG4gICAgICAgIHhbMF0gPSBhZGQzMihhLCB4WzBdKTtcbiAgICAgICAgeFsxXSA9IGFkZDMyKGIsIHhbMV0pO1xuICAgICAgICB4WzJdID0gYWRkMzIoYywgeFsyXSk7XG4gICAgICAgIHhbM10gPSBhZGQzMihkLCB4WzNdKTtcblxuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBjbW4ocSwgYSwgYiwgeCwgcywgdCkge1xuICAgICAgICBhID0gYWRkMzIoYWRkMzIoYSwgcSksIGFkZDMyKHgsIHQpKTtcbiAgICAgICAgcmV0dXJuIGFkZDMyKChhIDw8IHMpIHwgKGEgPj4+ICgzMiAtIHMpKSwgYik7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGZmKGEsIGIsIGMsIGQsIHgsIHMsIHQpIHtcbiAgICAgICAgcmV0dXJuIGNtbigoYiAmIGMpIHwgKCh+YikgJiBkKSwgYSwgYiwgeCwgcywgdCk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGdnKGEsIGIsIGMsIGQsIHgsIHMsIHQpIHtcbiAgICAgICAgcmV0dXJuIGNtbigoYiAmIGQpIHwgKGMgJiAofmQpKSwgYSwgYiwgeCwgcywgdCk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGhoKGEsIGIsIGMsIGQsIHgsIHMsIHQpIHtcbiAgICAgICAgcmV0dXJuIGNtbihiIF4gYyBeIGQsIGEsIGIsIHgsIHMsIHQpO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBpaShhLCBiLCBjLCBkLCB4LCBzLCB0KSB7XG4gICAgICAgIHJldHVybiBjbW4oYyBeIChiIHwgKH5kKSksIGEsIGIsIHgsIHMsIHQpO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBtZDUxKHMpIHtcbiAgICAgICAgdHh0ID0gJyc7XG4gICAgICAgIHZhciBuID0gcy5sZW5ndGgsXG4gICAgICAgICAgICBzdGF0ZSA9IFsxNzMyNTg0MTkzLCAtMjcxNzMzODc5LCAtMTczMjU4NDE5NCwgMjcxNzMzODc4XSwgaTtcbiAgICAgICAgZm9yIChpPTY0OyBpPD1zLmxlbmd0aDsgaSs9NjQpIHtcbiAgICAgICAgICBtZDVjeWNsZShzdGF0ZSwgbWQ1YmxrKHMuc3Vic3RyaW5nKGktNjQsIGkpKSk7XG4gICAgICAgIH1cbiAgICAgICAgcyA9IHMuc3Vic3RyaW5nKGktNjQpO1xuICAgICAgICB2YXIgdGFpbCA9IFswLDAsMCwwLCAwLDAsMCwwLCAwLDAsMCwwLCAwLDAsMCwwXTtcbiAgICAgICAgZm9yIChpPTA7IGk8cy5sZW5ndGg7IGkrKylcbiAgICAgICAgICB0YWlsW2k+PjJdIHw9IHMuY2hhckNvZGVBdChpKSA8PCAoKGklNCkgPDwgMyk7XG4gICAgICAgIHRhaWxbaT4+Ml0gfD0gMHg4MCA8PCAoKGklNCkgPDwgMyk7XG4gICAgICAgIGlmIChpID4gNTUpIHtcbiAgICAgICAgICBtZDVjeWNsZShzdGF0ZSwgdGFpbCk7XG4gICAgICAgICAgZm9yIChpPTA7IGk8MTY7IGkrKykgdGFpbFtpXSA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgdGFpbFsxNF0gPSBuKjg7XG4gICAgICAgIG1kNWN5Y2xlKHN0YXRlLCB0YWlsKTtcbiAgICAgICAgcmV0dXJuIHN0YXRlO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBtZDVibGsocykge1xuICAgICAgICB2YXIgbWQ1YmxrcyA9IFtdLCBpO1xuICAgICAgICBmb3IgKGk9MDsgaTw2NDsgaSs9NCkge1xuICAgICAgICAgIG1kNWJsa3NbaT4+Ml0gPSBzLmNoYXJDb2RlQXQoaSkgKyAocy5jaGFyQ29kZUF0KGkrMSkgPDwgOCkgKyAocy5jaGFyQ29kZUF0KGkrMikgPDwgMTYpICsgKHMuY2hhckNvZGVBdChpKzMpIDw8IDI0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWQ1YmxrcztcbiAgICAgIH1cblxuICAgICAgdmFyIGhleF9jaHIgPSAnMDEyMzQ1Njc4OWFiY2RlZicuc3BsaXQoJycpO1xuXG4gICAgICBmdW5jdGlvbiByaGV4KG4pXG4gICAgICB7XG4gICAgICAgIHZhciBzPScnLCBqPTA7XG4gICAgICAgIGZvcig7IGo8NDsgaisrKVxuICAgICAgICAgIHMgKz0gaGV4X2NoclsobiA+PiAoaiAqIDggKyA0KSkgJiAweDBGXSArIGhleF9jaHJbKG4gPj4gKGogKiA4KSkgJiAweDBGXTtcbiAgICAgICAgcmV0dXJuIHM7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGhleCh4KSB7XG4gICAgICAgIGZvciAodmFyIGk9MDsgaTx4Lmxlbmd0aDsgaSsrKVxuICAgICAgICAgIHhbaV0gPSByaGV4KHhbaV0pO1xuICAgICAgICByZXR1cm4geC5qb2luKCcnKTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gbWQ1KHMpIHtcbiAgICAgICAgcmV0dXJuIGhleChtZDUxKHMpKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGFkZDMyID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIChhICsgYikgJiAweEZGRkZGRkZGO1xuICAgICAgfTtcblxuICAgICAgaWYgKG1kNSgnaGVsbG8nKSAhPT0gJzVkNDE0MDJhYmM0YjJhNzZiOTcxOWQ5MTEwMTdjNTkyJykge1xuICAgICAgICBhZGQzMiA9IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAgICAgdmFyIGxzdyA9ICh4ICYgMHhGRkZGKSArICh5ICYgMHhGRkZGKSxcbiAgICAgICAgICAgICAgbXN3ID0gKHggPj4gMTYpICsgKHkgPj4gMTYpICsgKGxzdyA+PiAxNik7XG4gICAgICAgICAgcmV0dXJuIChtc3cgPDwgMTYpIHwgKGxzdyAmIDB4RkZGRik7XG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBtZDUoc3RyKTtcbiAgICB9LFxuICAgIC8qIGpzaGludCBpZ25vcmU6ZW5kICovXG5cblxuICAgIGxvY2FsU3RvcmFnZUF2YWlsYWJsZSAoKSB7XG4gICAgICBjb25zdCBjb250ZXh0ID0gdXRpbC5nZXRHbG9iYWxDb250ZXh0KCk7XG5cbiAgICAgIGlmICghKCdsb2NhbFN0b3JhZ2UnIGluIGNvbnRleHQpKSB7IHJldHVybiBmYWxzZSB9XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnRleHQubG9jYWxTdG9yYWdlLnNldEl0ZW0oJ3JzLWNoZWNrJywgMSk7XG4gICAgICAgIGNvbnRleHQubG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0oJ3JzLWNoZWNrJyk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfSBjYXRjaChlcnJvcikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuXG4gIH07XG5cbiAgbW9kdWxlLmV4cG9ydHMgPSB1dGlsXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL3V0aWwuanMiXSwic291cmNlUm9vdCI6IiJ9");

/***/ },
/* 3 */
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';\n\nvar log = __webpack_require__(4);\n\n/**\n * Interface: eventhandling\n */\nvar methods = {\n  /**\n   * Method: addEventListener\n   *\n   * Install an event handler for the given event name\n   */\n  addEventListener: function addEventListener(eventName, handler) {\n    if (typeof eventName !== 'string') {\n      throw new Error('Argument eventName should be a string');\n    }\n    if (typeof handler !== 'function') {\n      throw new Error('Argument handler should be a function');\n    }\n    log('[Eventhandling] Adding event listener', eventName);\n    this._validateEvent(eventName);\n    this._handlers[eventName].push(handler);\n  },\n\n  /**\n   * Method: removeEventListener\n   *\n   * Remove a previously installed event handler\n   */\n  removeEventListener: function removeEventListener(eventName, handler) {\n    this._validateEvent(eventName);\n    var hl = this._handlers[eventName].length;\n    for (var i = 0; i < hl; i++) {\n      if (this._handlers[eventName][i] === handler) {\n        this._handlers[eventName].splice(i, 1);\n        return;\n      }\n    }\n  },\n\n  _emit: function _emit(eventName) {\n    this._validateEvent(eventName);\n    var args = Array.prototype.slice.call(arguments, 1);\n    this._handlers[eventName].slice().forEach(function (handler) {\n      handler.apply(this, args);\n    });\n  },\n\n  _validateEvent: function _validateEvent(eventName) {\n    if (!(eventName in this._handlers)) {\n      throw new Error(\"Unknown event: \" + eventName);\n    }\n  },\n\n  _delegateEvent: function _delegateEvent(eventName, target) {\n    target.on(eventName, function (event) {\n      this._emit(eventName, event);\n    }.bind(this));\n  },\n\n  _addEvent: function _addEvent(eventName) {\n    this._handlers[eventName] = [];\n  }\n};\n\n/**\n * Method: eventhandling.on\n *\n * Alias for <addEventListener>\n **/\nmethods.on = methods.addEventListener;\n\n/**\n * Function: eventHandling\n *\n * Mixes event handling functionality into an object.\n *\n * The first parameter is always the object to be extended.\n * All remaining parameter are expected to be strings, interpreted as valid event\n * names.\n *\n * Example:\n *   (start code)\n *   var MyConstructor = function () {\n *     eventHandling(this, 'connected', 'disconnected');\n *\n *     this._emit('connected');\n *     this._emit('disconnected');\n *     // This would throw an exception:\n *     // this._emit('something-else');\n *   };\n *\n *   var myObject = new MyConstructor();\n *   myObject.on('connected', function () { console.log('connected'); });\n *   myObject.on('disconnected', function () { console.log('disconnected'); });\n *   // This would throw an exception as well:\n *   // myObject.on('something-else', function () {});\n *   (end code)\n */\nmodule.exports = function (object) {\n  var eventNames = Array.prototype.slice.call(arguments, 1);\n  for (var key in methods) {\n    object[key] = methods[key];\n  }\n  object._handlers = {};\n  eventNames.forEach(function (eventName) {\n    object._addEvent(eventName);\n  });\n};\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvZXZlbnRoYW5kbGluZy5qcz83NjIzIl0sIm5hbWVzIjpbImxvZyIsInJlcXVpcmUiLCJtZXRob2RzIiwiYWRkRXZlbnRMaXN0ZW5lciIsImV2ZW50TmFtZSIsImhhbmRsZXIiLCJFcnJvciIsIl92YWxpZGF0ZUV2ZW50IiwiX2hhbmRsZXJzIiwicHVzaCIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJobCIsImxlbmd0aCIsImkiLCJzcGxpY2UiLCJfZW1pdCIsImFyZ3MiLCJBcnJheSIsInByb3RvdHlwZSIsInNsaWNlIiwiY2FsbCIsImFyZ3VtZW50cyIsImZvckVhY2giLCJhcHBseSIsIl9kZWxlZ2F0ZUV2ZW50IiwidGFyZ2V0Iiwib24iLCJldmVudCIsImJpbmQiLCJfYWRkRXZlbnQiLCJtb2R1bGUiLCJleHBvcnRzIiwib2JqZWN0IiwiZXZlbnROYW1lcyIsImtleSJdLCJtYXBwaW5ncyI6Ijs7QUFBRSxJQUFJQSxNQUFNLG1CQUFBQyxDQUFRLENBQVIsQ0FBVjs7QUFFQTs7O0FBR0EsSUFBSUMsVUFBVTtBQUNaOzs7OztBQUtBQyxvQkFBa0IsMEJBQVVDLFNBQVYsRUFBcUJDLE9BQXJCLEVBQThCO0FBQzlDLFFBQUksT0FBT0QsU0FBUCxLQUFzQixRQUExQixFQUFvQztBQUNsQyxZQUFNLElBQUlFLEtBQUosQ0FBVSx1Q0FBVixDQUFOO0FBQ0Q7QUFDRCxRQUFJLE9BQU9ELE9BQVAsS0FBb0IsVUFBeEIsRUFBb0M7QUFDbEMsWUFBTSxJQUFJQyxLQUFKLENBQVUsdUNBQVYsQ0FBTjtBQUNEO0FBQ0ROLFFBQUksdUNBQUosRUFBNkNJLFNBQTdDO0FBQ0EsU0FBS0csY0FBTCxDQUFvQkgsU0FBcEI7QUFDQSxTQUFLSSxTQUFMLENBQWVKLFNBQWYsRUFBMEJLLElBQTFCLENBQStCSixPQUEvQjtBQUNELEdBaEJXOztBQWtCWjs7Ozs7QUFLQUssdUJBQXFCLDZCQUFVTixTQUFWLEVBQXFCQyxPQUFyQixFQUE4QjtBQUNqRCxTQUFLRSxjQUFMLENBQW9CSCxTQUFwQjtBQUNBLFFBQUlPLEtBQUssS0FBS0gsU0FBTCxDQUFlSixTQUFmLEVBQTBCUSxNQUFuQztBQUNBLFNBQUssSUFBSUMsSUFBRSxDQUFYLEVBQWFBLElBQUVGLEVBQWYsRUFBa0JFLEdBQWxCLEVBQXVCO0FBQ3JCLFVBQUksS0FBS0wsU0FBTCxDQUFlSixTQUFmLEVBQTBCUyxDQUExQixNQUFpQ1IsT0FBckMsRUFBOEM7QUFDNUMsYUFBS0csU0FBTCxDQUFlSixTQUFmLEVBQTBCVSxNQUExQixDQUFpQ0QsQ0FBakMsRUFBb0MsQ0FBcEM7QUFDQTtBQUNEO0FBQ0Y7QUFDRixHQWhDVzs7QUFrQ1pFLFNBQU8sZUFBVVgsU0FBVixFQUFxQjtBQUMxQixTQUFLRyxjQUFMLENBQW9CSCxTQUFwQjtBQUNBLFFBQUlZLE9BQU9DLE1BQU1DLFNBQU4sQ0FBZ0JDLEtBQWhCLENBQXNCQyxJQUF0QixDQUEyQkMsU0FBM0IsRUFBc0MsQ0FBdEMsQ0FBWDtBQUNBLFNBQUtiLFNBQUwsQ0FBZUosU0FBZixFQUEwQmUsS0FBMUIsR0FBa0NHLE9BQWxDLENBQTBDLFVBQVVqQixPQUFWLEVBQW1CO0FBQzNEQSxjQUFRa0IsS0FBUixDQUFjLElBQWQsRUFBb0JQLElBQXBCO0FBQ0QsS0FGRDtBQUdELEdBeENXOztBQTBDWlQsa0JBQWdCLHdCQUFVSCxTQUFWLEVBQXFCO0FBQ25DLFFBQUksRUFBR0EsYUFBYSxLQUFLSSxTQUFyQixDQUFKLEVBQXFDO0FBQ25DLFlBQU0sSUFBSUYsS0FBSixDQUFVLG9CQUFvQkYsU0FBOUIsQ0FBTjtBQUNEO0FBQ0YsR0E5Q1c7O0FBZ0Rab0Isa0JBQWdCLHdCQUFVcEIsU0FBVixFQUFxQnFCLE1BQXJCLEVBQTZCO0FBQzNDQSxXQUFPQyxFQUFQLENBQVV0QixTQUFWLEVBQXFCLFVBQVV1QixLQUFWLEVBQWlCO0FBQ3BDLFdBQUtaLEtBQUwsQ0FBV1gsU0FBWCxFQUFzQnVCLEtBQXRCO0FBQ0QsS0FGb0IsQ0FFbkJDLElBRm1CLENBRWQsSUFGYyxDQUFyQjtBQUdELEdBcERXOztBQXNEWkMsYUFBVyxtQkFBVXpCLFNBQVYsRUFBcUI7QUFDOUIsU0FBS0ksU0FBTCxDQUFlSixTQUFmLElBQTRCLEVBQTVCO0FBQ0Q7QUF4RFcsQ0FBZDs7QUEyREE7Ozs7O0FBS0FGLFFBQVF3QixFQUFSLEdBQWF4QixRQUFRQyxnQkFBckI7O0FBRUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQTJCRDJCLE9BQU9DLE9BQVAsR0FBaUIsVUFBVUMsTUFBVixFQUFrQjtBQUNoQyxNQUFJQyxhQUFhaEIsTUFBTUMsU0FBTixDQUFnQkMsS0FBaEIsQ0FBc0JDLElBQXRCLENBQTJCQyxTQUEzQixFQUFzQyxDQUF0QyxDQUFqQjtBQUNBLE9BQUssSUFBSWEsR0FBVCxJQUFnQmhDLE9BQWhCLEVBQXlCO0FBQ3ZCOEIsV0FBT0UsR0FBUCxJQUFjaEMsUUFBUWdDLEdBQVIsQ0FBZDtBQUNEO0FBQ0RGLFNBQU94QixTQUFQLEdBQW1CLEVBQW5CO0FBQ0F5QixhQUFXWCxPQUFYLENBQW1CLFVBQVVsQixTQUFWLEVBQXFCO0FBQ3RDNEIsV0FBT0gsU0FBUCxDQUFpQnpCLFNBQWpCO0FBQ0QsR0FGRDtBQUdELENBVEYiLCJmaWxlIjoiMy5qcyIsInNvdXJjZXNDb250ZW50IjpbIiAgdmFyIGxvZyA9IHJlcXVpcmUoJy4vbG9nJyk7XG4gIFxuICAvKipcbiAgICogSW50ZXJmYWNlOiBldmVudGhhbmRsaW5nXG4gICAqL1xuICB2YXIgbWV0aG9kcyA9IHtcbiAgICAvKipcbiAgICAgKiBNZXRob2Q6IGFkZEV2ZW50TGlzdGVuZXJcbiAgICAgKlxuICAgICAqIEluc3RhbGwgYW4gZXZlbnQgaGFuZGxlciBmb3IgdGhlIGdpdmVuIGV2ZW50IG5hbWVcbiAgICAgKi9cbiAgICBhZGRFdmVudExpc3RlbmVyOiBmdW5jdGlvbiAoZXZlbnROYW1lLCBoYW5kbGVyKSB7XG4gICAgICBpZiAodHlwZW9mKGV2ZW50TmFtZSkgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQXJndW1lbnQgZXZlbnROYW1lIHNob3VsZCBiZSBhIHN0cmluZycpO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZihoYW5kbGVyKSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0FyZ3VtZW50IGhhbmRsZXIgc2hvdWxkIGJlIGEgZnVuY3Rpb24nKTtcbiAgICAgIH1cbiAgICAgIGxvZygnW0V2ZW50aGFuZGxpbmddIEFkZGluZyBldmVudCBsaXN0ZW5lcicsIGV2ZW50TmFtZSk7XG4gICAgICB0aGlzLl92YWxpZGF0ZUV2ZW50KGV2ZW50TmFtZSk7XG4gICAgICB0aGlzLl9oYW5kbGVyc1tldmVudE5hbWVdLnB1c2goaGFuZGxlcik7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1ldGhvZDogcmVtb3ZlRXZlbnRMaXN0ZW5lclxuICAgICAqXG4gICAgICogUmVtb3ZlIGEgcHJldmlvdXNseSBpbnN0YWxsZWQgZXZlbnQgaGFuZGxlclxuICAgICAqL1xuICAgIHJlbW92ZUV2ZW50TGlzdGVuZXI6IGZ1bmN0aW9uIChldmVudE5hbWUsIGhhbmRsZXIpIHtcbiAgICAgIHRoaXMuX3ZhbGlkYXRlRXZlbnQoZXZlbnROYW1lKTtcbiAgICAgIHZhciBobCA9IHRoaXMuX2hhbmRsZXJzW2V2ZW50TmFtZV0ubGVuZ3RoO1xuICAgICAgZm9yICh2YXIgaT0wO2k8aGw7aSsrKSB7XG4gICAgICAgIGlmICh0aGlzLl9oYW5kbGVyc1tldmVudE5hbWVdW2ldID09PSBoYW5kbGVyKSB7XG4gICAgICAgICAgdGhpcy5faGFuZGxlcnNbZXZlbnROYW1lXS5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIF9lbWl0OiBmdW5jdGlvbiAoZXZlbnROYW1lKSB7XG4gICAgICB0aGlzLl92YWxpZGF0ZUV2ZW50KGV2ZW50TmFtZSk7XG4gICAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gICAgICB0aGlzLl9oYW5kbGVyc1tldmVudE5hbWVdLnNsaWNlKCkuZm9yRWFjaChmdW5jdGlvbiAoaGFuZGxlcikge1xuICAgICAgICBoYW5kbGVyLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgICAgfSk7XG4gICAgfSxcblxuICAgIF92YWxpZGF0ZUV2ZW50OiBmdW5jdGlvbiAoZXZlbnROYW1lKSB7XG4gICAgICBpZiAoISAoZXZlbnROYW1lIGluIHRoaXMuX2hhbmRsZXJzKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIGV2ZW50OiBcIiArIGV2ZW50TmFtZSk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIF9kZWxlZ2F0ZUV2ZW50OiBmdW5jdGlvbiAoZXZlbnROYW1lLCB0YXJnZXQpIHtcbiAgICAgIHRhcmdldC5vbihldmVudE5hbWUsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICB0aGlzLl9lbWl0KGV2ZW50TmFtZSwgZXZlbnQpO1xuICAgICAgfS5iaW5kKHRoaXMpKTtcbiAgICB9LFxuXG4gICAgX2FkZEV2ZW50OiBmdW5jdGlvbiAoZXZlbnROYW1lKSB7XG4gICAgICB0aGlzLl9oYW5kbGVyc1tldmVudE5hbWVdID0gW107XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBNZXRob2Q6IGV2ZW50aGFuZGxpbmcub25cbiAgICpcbiAgICogQWxpYXMgZm9yIDxhZGRFdmVudExpc3RlbmVyPlxuICAgKiovXG4gIG1ldGhvZHMub24gPSBtZXRob2RzLmFkZEV2ZW50TGlzdGVuZXI7XG5cbiAgLyoqXG4gICAqIEZ1bmN0aW9uOiBldmVudEhhbmRsaW5nXG4gICAqXG4gICAqIE1peGVzIGV2ZW50IGhhbmRsaW5nIGZ1bmN0aW9uYWxpdHkgaW50byBhbiBvYmplY3QuXG4gICAqXG4gICAqIFRoZSBmaXJzdCBwYXJhbWV0ZXIgaXMgYWx3YXlzIHRoZSBvYmplY3QgdG8gYmUgZXh0ZW5kZWQuXG4gICAqIEFsbCByZW1haW5pbmcgcGFyYW1ldGVyIGFyZSBleHBlY3RlZCB0byBiZSBzdHJpbmdzLCBpbnRlcnByZXRlZCBhcyB2YWxpZCBldmVudFxuICAgKiBuYW1lcy5cbiAgICpcbiAgICogRXhhbXBsZTpcbiAgICogICAoc3RhcnQgY29kZSlcbiAgICogICB2YXIgTXlDb25zdHJ1Y3RvciA9IGZ1bmN0aW9uICgpIHtcbiAgICogICAgIGV2ZW50SGFuZGxpbmcodGhpcywgJ2Nvbm5lY3RlZCcsICdkaXNjb25uZWN0ZWQnKTtcbiAgICpcbiAgICogICAgIHRoaXMuX2VtaXQoJ2Nvbm5lY3RlZCcpO1xuICAgKiAgICAgdGhpcy5fZW1pdCgnZGlzY29ubmVjdGVkJyk7XG4gICAqICAgICAvLyBUaGlzIHdvdWxkIHRocm93IGFuIGV4Y2VwdGlvbjpcbiAgICogICAgIC8vIHRoaXMuX2VtaXQoJ3NvbWV0aGluZy1lbHNlJyk7XG4gICAqICAgfTtcbiAgICpcbiAgICogICB2YXIgbXlPYmplY3QgPSBuZXcgTXlDb25zdHJ1Y3RvcigpO1xuICAgKiAgIG15T2JqZWN0Lm9uKCdjb25uZWN0ZWQnLCBmdW5jdGlvbiAoKSB7IGNvbnNvbGUubG9nKCdjb25uZWN0ZWQnKTsgfSk7XG4gICAqICAgbXlPYmplY3Qub24oJ2Rpc2Nvbm5lY3RlZCcsIGZ1bmN0aW9uICgpIHsgY29uc29sZS5sb2coJ2Rpc2Nvbm5lY3RlZCcpOyB9KTtcbiAgICogICAvLyBUaGlzIHdvdWxkIHRocm93IGFuIGV4Y2VwdGlvbiBhcyB3ZWxsOlxuICAgKiAgIC8vIG15T2JqZWN0Lm9uKCdzb21ldGhpbmctZWxzZScsIGZ1bmN0aW9uICgpIHt9KTtcbiAgICogICAoZW5kIGNvZGUpXG4gICAqL1xuIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG9iamVjdCkge1xuICAgIHZhciBldmVudE5hbWVzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcbiAgICBmb3IgKHZhciBrZXkgaW4gbWV0aG9kcykge1xuICAgICAgb2JqZWN0W2tleV0gPSBtZXRob2RzW2tleV07XG4gICAgfVxuICAgIG9iamVjdC5faGFuZGxlcnMgPSB7fTtcbiAgICBldmVudE5hbWVzLmZvckVhY2goZnVuY3Rpb24gKGV2ZW50TmFtZSkge1xuICAgICAgb2JqZWN0Ll9hZGRFdmVudChldmVudE5hbWUpO1xuICAgIH0pO1xuICB9O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2V2ZW50aGFuZGxpbmcuanMiXSwic291cmNlUm9vdCI6IiJ9");

/***/ },
/* 4 */
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';\n\nvar config = __webpack_require__(5);\n\n/**\n * Method: log\n *\n * Log using console.log, when remoteStorage logging is enabled.\n *\n * You can enable logging with <enableLog>.\n *\n * (In node.js you can also enable logging during remoteStorage object\n * creation. See: <RemoteStorage>).\n */\nfunction log() {\n  if (config.logging) {\n    console.log.apply(console, arguments);\n  }\n};\n\nmodule.exports = log;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvbG9nLmpzPzkzMjAiXSwibmFtZXMiOlsiY29uZmlnIiwicmVxdWlyZSIsImxvZyIsImxvZ2dpbmciLCJjb25zb2xlIiwiYXBwbHkiLCJhcmd1bWVudHMiLCJtb2R1bGUiLCJleHBvcnRzIl0sIm1hcHBpbmdzIjoiOztBQUFBLElBQUlBLFNBQVMsbUJBQUFDLENBQVEsQ0FBUixDQUFiOztBQUVBOzs7Ozs7Ozs7O0FBVUEsU0FBU0MsR0FBVCxHQUFlO0FBQ2IsTUFBSUYsT0FBT0csT0FBWCxFQUFvQjtBQUNsQkMsWUFBUUYsR0FBUixDQUFZRyxLQUFaLENBQWtCRCxPQUFsQixFQUEyQkUsU0FBM0I7QUFDRDtBQUNGOztBQUVEQyxPQUFPQyxPQUFQLEdBQWlCTixHQUFqQiIsImZpbGUiOiI0LmpzIiwic291cmNlc0NvbnRlbnQiOlsidmFyIGNvbmZpZyA9IHJlcXVpcmUoJy4vY29uZmlnJyk7XG5cbi8qKlxuICogTWV0aG9kOiBsb2dcbiAqXG4gKiBMb2cgdXNpbmcgY29uc29sZS5sb2csIHdoZW4gcmVtb3RlU3RvcmFnZSBsb2dnaW5nIGlzIGVuYWJsZWQuXG4gKlxuICogWW91IGNhbiBlbmFibGUgbG9nZ2luZyB3aXRoIDxlbmFibGVMb2c+LlxuICpcbiAqIChJbiBub2RlLmpzIHlvdSBjYW4gYWxzbyBlbmFibGUgbG9nZ2luZyBkdXJpbmcgcmVtb3RlU3RvcmFnZSBvYmplY3RcbiAqIGNyZWF0aW9uLiBTZWU6IDxSZW1vdGVTdG9yYWdlPikuXG4gKi9cbmZ1bmN0aW9uIGxvZygpIHtcbiAgaWYgKGNvbmZpZy5sb2dnaW5nKSB7XG4gICAgY29uc29sZS5sb2cuYXBwbHkoY29uc29sZSwgYXJndW1lbnRzKTtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBsb2c7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2xvZy5qcyJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ },
/* 5 */
/***/ function(module, exports) {

	eval("\"use strict\";\n\nvar config = {\n     logging: false,\n     changeEvents: {\n          local: true,\n          window: false,\n          remote: true,\n          conflict: true\n     },\n     cache: true,\n     discoveryTimeout: 10000,\n     cordovaRedirectUri: undefined\n};\n\nmodule.exports = config;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvY29uZmlnLmpzPzQyNjQiXSwibmFtZXMiOlsiY29uZmlnIiwibG9nZ2luZyIsImNoYW5nZUV2ZW50cyIsImxvY2FsIiwid2luZG93IiwicmVtb3RlIiwiY29uZmxpY3QiLCJjYWNoZSIsImRpc2NvdmVyeVRpbWVvdXQiLCJjb3Jkb3ZhUmVkaXJlY3RVcmkiLCJ1bmRlZmluZWQiLCJtb2R1bGUiLCJleHBvcnRzIl0sIm1hcHBpbmdzIjoiOztBQUFBLElBQUlBLFNBQVM7QUFDWkMsY0FBUyxLQURHO0FBRVpDLG1CQUFjO0FBQ1RDLGlCQUFVLElBREQ7QUFFVEMsa0JBQVUsS0FGRDtBQUdUQyxrQkFBVSxJQUhEO0FBSVRDLG9CQUFVO0FBSkQsTUFGRjtBQVFYQyxZQUFPLElBUkk7QUFTWEMsdUJBQWtCLEtBVFA7QUFVWEMseUJBQW9CQztBQVZULENBQWI7O0FBYUFDLE9BQU9DLE9BQVAsR0FBaUJaLE1BQWpCIiwiZmlsZSI6IjUuanMiLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgY29uZmlnID0ge1xuXHRsb2dnaW5nOiBmYWxzZSxcblx0Y2hhbmdlRXZlbnRzOiB7XG4gICAgICBsb2NhbDogICAgdHJ1ZSxcbiAgICAgIHdpbmRvdzogICBmYWxzZSxcbiAgICAgIHJlbW90ZTogICB0cnVlLFxuICAgICAgY29uZmxpY3Q6IHRydWVcbiAgfSxcbiAgY2FjaGU6IHRydWUsXG4gIGRpc2NvdmVyeVRpbWVvdXQ6IDEwMDAwLFxuICBjb3Jkb3ZhUmVkaXJlY3RVcmk6IHVuZGVmaW5lZFxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBjb25maWc7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2NvbmZpZy5qcyJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ },
/* 6 */
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';\n\nvar Authorize = __webpack_require__(7);\nvar BaseClient = __webpack_require__(8);\nvar WireClient = __webpack_require__(12);\nvar util = __webpack_require__(2);\nvar eventHandling = __webpack_require__(3);\nvar Sync = __webpack_require__(17);\n\n// var RemoteStorage = require('./remotestorage');\n\n/**\n * File: Dropbox\n *\n * WORK IN PROGRESS, NOT RECOMMENDED FOR PRODUCTION USE\n *\n * Dropbox backend for RemoteStorage.js\n * This file exposes a get/put/delete interface which is compatible with\n * <RemoteStorage.WireClient>.\n *\n * When remoteStorage.backend is set to 'dropbox', this backend will\n * initialize and replace remoteStorage.remote with remoteStorage.dropbox.\n *\n * In order to ensure compatibility with the public folder, <BaseClient.getItemURL>\n * gets hijacked to return the Dropbox public share URL.\n *\n * To use this backend, you need to specify the Dropbox app key like so:\n *\n * (start code)\n *\n * remoteStorage.setApiKeys('dropbox', {\n *   appKey: 'your-app-key'\n * });\n *\n * (end code)\n *\n * An app key can be obtained by registering your app at https://www.dropbox.com/developers/apps\n *\n * Known issues:\n *\n *   - Storing files larger than 150MB is not yet supported\n *   - Listing and deleting folders with more than 10'000 files will cause problems\n *   - Content-Type is not fully supported due to limitations of the Dropbox API\n *   - Dropbox preserves cases but is not case-sensitive\n *   - getItemURL is asynchronous which means getIetmURL returns useful values\n *     after the syncCycle\n */\n\nvar hasLocalStorage;\nvar AUTH_URL = 'https://www.dropbox.com/1/oauth2/authorize';\nvar SETTINGS_KEY = 'remotestorage:dropbox';\nvar PATH_PREFIX = '/remotestorage';\n\nvar isFolder = util.isFolder;\n\n/**\n * Function: getDropboxPath(path)\n *\n * Map a local path to a path in DropBox.\n */\nvar getDropboxPath = function getDropboxPath(path) {\n  return WireClient.cleanPath(PATH_PREFIX + '/' + path);\n};\n\nvar encodeQuery = function encodeQuery(obj) {\n  var pairs = [];\n\n  for (var key in obj) {\n    if (obj.hasOwnProperty(key)) {\n      pairs.push(encodeURIComponent(key) + '=' + encodeURIComponent(obj[key]));\n    }\n  }\n\n  return pairs.join('&');\n};\n\n/**\n * class: LowerCaseCache\n *\n * A cache which automatically converts all keys to lower case and can\n * propagate changes up to parent folders.\n *\n * By default the set and delete methods are aliased to justSet and justDelete.\n *\n * Parameters:\n *\n *   defaultValue - the value that is returned for all keys that don't exist\n *                  in the cache\n */\nfunction LowerCaseCache(defaultValue) {\n  this.defaultValue = defaultValue;\n  this._storage = {};\n  this.set = this.justSet;\n  this.delete = this.justDelete;\n}\n\nLowerCaseCache.prototype = {\n  /**\n   * Method: get\n   *\n   * Get a value from the cache or defaultValue, if the key is not in the\n   * cache.\n   */\n  get: function get(key) {\n    key = key.toLowerCase();\n    var stored = this._storage[key];\n    if (typeof stored === 'undefined') {\n      stored = this.defaultValue;\n      this._storage[key] = stored;\n    }\n    return stored;\n  },\n\n  /**\n   * Method: propagateSet\n   *\n   * Set a value and also update the parent folders with that value.\n   */\n  propagateSet: function propagateSet(key, value) {\n    key = key.toLowerCase();\n    if (this._storage[key] === value) {\n      return value;\n    }\n    this._propagate(key, value);\n    this._storage[key] = value;\n    return value;\n  },\n\n  /**\n   * Method: propagateDelete\n   *\n   * Delete a value and propagate the changes to the parent folders.\n   */\n  propagateDelete: function propagateDelete(key) {\n    key = key.toLowerCase();\n    this._propagate(key, this._storage[key]);\n    return delete this._storage[key];\n  },\n\n  _activatePropagation: function _activatePropagation() {\n    this.set = this.propagateSet;\n    this.delete = this.propagateDelete;\n    return true;\n  },\n\n  /**\n   * Method: justSet\n   *\n   * Set a value without propagating.\n   */\n  justSet: function justSet(key, value) {\n    key = key.toLowerCase();\n    this._storage[key] = value;\n    return value;\n  },\n\n  /**\n   * Method: justDelete\n   *\n   * Delete a value without propagating.\n   */\n  justDelete: function justDelete(key, value) {\n    key = key.toLowerCase();\n    return delete this._storage[key];\n  },\n\n  _propagate: function _propagate(key, rev) {\n    var folders = key.split('/').slice(0, -1);\n    var path = '';\n\n    for (var i = 0, len = folders.length; i < len; i++) {\n      path += folders[i] + '/';\n      if (!rev) {\n        rev = this._storage[path] + 1;\n      }\n      this._storage[path] = rev;\n    }\n  }\n};\n\nvar onErrorCb;\n\n/**\n * Class: RemoteStorage.Dropbox\n */\nvar Dropbox = function Dropbox(rs) {\n\n  this.rs = rs;\n  this.connected = false;\n  this.rs = rs;\n  var self = this;\n\n  onErrorCb = function onErrorCb(error) {\n    if (error instanceof Authorize.Unauthorized) {\n      // Delete all the settings - see the documentation of wireclient.configure\n      self.configure({\n        userAddress: null,\n        href: null,\n        storageApi: null,\n        token: null,\n        options: null\n      });\n    }\n  };\n\n  eventHandling(this, 'change', 'connected', 'wire-busy', 'wire-done', 'not-connected');\n  rs.on('error', onErrorCb);\n\n  this.clientId = rs.apiKeys.dropbox.appKey;\n  this._revCache = new LowerCaseCache('rev');\n  this._itemRefs = {};\n  this._metadataCache = {};\n\n  if (hasLocalStorage) {\n    var settings;\n    try {\n      settings = JSON.parse(localStorage[SETTINGS_KEY]);\n    } catch (e) {}\n    if (settings) {\n      this.configure(settings);\n    }\n    try {\n      this._itemRefs = JSON.parse(localStorage[SETTINGS_KEY + ':shares']);\n    } catch (e) {}\n  }\n  if (this.connected) {\n    setTimeout(this._emit.bind(this), 0, 'connected');\n  }\n};\n\nDropbox.prototype = {\n  online: true,\n\n  /**\n   * Method: connect\n   *\n   * Set the backed to 'dropbox' and start the authentication flow in order\n   * to obtain an API token from Dropbox.\n   */\n  connect: function connect() {\n    // TODO handling when token is already present\n    this.rs.setBackend('dropbox');\n    if (this.token) {\n      hookIt(this.rs);\n    } else {\n      Authorize(this.rs, AUTH_URL, '', String(Authorize.getLocation()), this.clientId);\n    }\n  },\n\n  /**\n   * Method : configure(settings)\n   * Accepts its parameters according to the <RemoteStorage.WireClient>.\n   * Sets the connected flag\n   **/\n  configure: function configure(settings) {\n    // We only update this.userAddress if settings.userAddress is set to a string or to null:\n    if (typeof settings.userAddress !== 'undefined') {\n      this.userAddress = settings.userAddress;\n    }\n    // Same for this.token. If only one of these two is set, we leave the other one at its existing value:\n    if (typeof settings.token !== 'undefined') {\n      this.token = settings.token;\n    }\n\n    if (this.token) {\n      this.connected = true;\n      if (!this.userAddress) {\n        this.info().then(function (info) {\n          this.userAddress = info.display_name;\n          this._emit('connected');\n        }.bind(this));\n      }\n    } else {\n      this.connected = false;\n    }\n    if (hasLocalStorage) {\n      localStorage[SETTINGS_KEY] = JSON.stringify({\n        userAddress: this.userAddress,\n        token: this.token\n      });\n    }\n  },\n\n  /**\n   * Method: stopWaitingForToken\n   *\n   * Stop waiting for the token and emit not-connected\n   */\n  stopWaitingForToken: function stopWaitingForToken() {\n    if (!this.connected) {\n      this._emit('not-connected');\n    }\n  },\n\n  /**\n   * Method: _getFolder\n   *\n   * Get all items in a folder.\n   *\n   * Parameters:\n   *\n   *   path - path of the folder to get, with leading slash\n   *   options - not used\n   *\n   * Returns:\n   *\n   *  statusCode - HTTP status code\n   *  body - array of the items found\n   *  contentType - 'application/json; charset=UTF-8'\n   *  revision - revision of the folder\n   */\n  _getFolder: function _getFolder(path, options) {\n    // FIXME simplify promise handling\n    var url = 'https://api.dropbox.com/1/metadata/auto' + getDropboxPath(path);\n    var revCache = this._revCache;\n    var self = this;\n\n    return this._request('GET', url, {}).then(function (resp) {\n      var status = resp.status;\n      if (status === 304) {\n        return Promise.resolve({ statusCode: status });\n      }\n      var listing, body, mime, rev;\n      try {\n        body = JSON.parse(resp.responseText);\n      } catch (e) {\n        return Promise.reject(e);\n      }\n      rev = self._revCache.get(path);\n      mime = 'application/json; charset=UTF-8';\n      if (body.contents) {\n        listing = body.contents.reduce(function (m, item) {\n          var itemName = item.path.split('/').slice(-1)[0] + (item.is_dir ? '/' : '');\n          if (item.is_dir) {\n            m[itemName] = { ETag: revCache.get(path + itemName) };\n          } else {\n            m[itemName] = { ETag: item.rev };\n          }\n          return m;\n        }, {});\n      }\n      return Promise.resolve({ statusCode: status, body: listing, contentType: mime, revision: rev });\n    });\n  },\n\n  /**\n   * Method: get\n   *\n   * Compatible with <RemoteStorage.WireClient.get>\n   *\n   * Checks for the path in _revCache and decides based on that if file has\n   * changed. Calls _getFolder is the path points to a folder.\n   *\n   * Calls <RemoteStorage.Dropbox.share> afterwards to fill _itemRefs.\n   */\n  get: function get(path, options) {\n    if (!this.connected) {\n      return Promise.reject(\"not connected (path: \" + path + \")\");\n    }\n    var url = 'https://api-content.dropbox.com/1/files/auto' + getDropboxPath(path);\n    var self = this;\n\n    var savedRev = this._revCache.get(path);\n    if (savedRev === null) {\n      // file was deleted server side\n      return Promise.resolve({ statusCode: 404 });\n    }\n    if (options && options.ifNoneMatch && savedRev && savedRev === options.ifNoneMatch) {\n      // nothing changed.\n      return Promise.resolve({ statusCode: 304 });\n    }\n\n    //use _getFolder for folders\n    if (path.substr(-1) === '/') {\n      return this._getFolder(path, options);\n    }\n\n    return this._request('GET', url, {}).then(function (resp) {\n      var status = resp.status;\n      var meta, body, mime, rev;\n      if (status !== 200) {\n        return Promise.resolve({ statusCode: status });\n      }\n\n      body = resp.responseText;\n      try {\n        meta = JSON.parse(resp.getResponseHeader('x-dropbox-metadata'));\n      } catch (e) {\n        return Promise.reject(e);\n      }\n\n      mime = meta.mime_type; //resp.getResponseHeader('Content-Type');\n      rev = meta.rev;\n      self._revCache.set(path, rev);\n      self._shareIfNeeded(path); // The shared link expires every 4 hours\n\n      // handling binary\n      if (!resp.getResponseHeader('Content-Type') || resp.getResponseHeader('Content-Type').match(/charset=binary/)) {\n        var pending = Promise.defer();\n\n        WireClient.readBinaryData(resp.response, mime, function (result) {\n          pending.resolve({\n            statusCode: status,\n            body: result,\n            contentType: mime,\n            revision: rev\n          });\n        });\n\n        return pending.promise;\n      }\n\n      // handling json (always try)\n      if (mime && mime.search('application/json') >= 0 || true) {\n        try {\n          body = JSON.parse(body);\n          mime = 'application/json; charset=UTF-8';\n        } catch (e) {\n          //Failed parsing Json, assume it is something else then\n        }\n      }\n\n      return Promise.resolve({ statusCode: status, body: body, contentType: mime, revision: rev });\n    });\n  },\n\n  /**\n   * Method: put\n   *\n   * Compatible with <RemoteStorage.WireClient>\n   *\n   * Checks for the path in _revCache and decides based on that if file has\n   * changed.\n   *\n   * Calls <RemoteStorage.Dropbox.share> afterwards to fill _itemRefs.\n   */\n  put: function put(path, body, contentType, options) {\n    var self = this;\n\n    if (!this.connected) {\n      throw new Error(\"not connected (path: \" + path + \")\");\n    }\n\n    //check if file has changed and return 412\n    var savedRev = this._revCache.get(path);\n    if (options && options.ifMatch && savedRev && savedRev !== options.ifMatch) {\n      return Promise.resolve({ statusCode: 412, revision: savedRev });\n    }\n    if (options && options.ifNoneMatch === '*' && savedRev && savedRev !== 'rev') {\n      return Promise.resolve({ statusCode: 412, revision: savedRev });\n    }\n\n    if (!contentType.match(/charset=/) && (body instanceof ArrayBuffer || WireClient.isArrayBufferView(body))) {\n      contentType += '; charset=binary';\n    }\n\n    if (body.length > 150 * 1024 * 1024) {\n      //https://www.dropbox.com/developers/core/docs#chunked-upload\n      return Promise.reject(new Error(\"Cannot upload file larger than 150MB\"));\n    }\n\n    var result;\n    var needsMetadata = options && (options.ifMatch || options.ifNoneMatch === '*');\n    var uploadParams = {\n      body: body,\n      contentType: contentType,\n      path: path\n    };\n\n    if (needsMetadata) {\n      result = this._getMetadata(path).then(function (metadata) {\n        if (options && options.ifNoneMatch === '*' && metadata) {\n          // if !!metadata === true, the file exists\n          return Promise.resolve({\n            statusCode: 412,\n            revision: metadata.rev\n          });\n        }\n\n        if (options && options.ifMatch && metadata && metadata.rev !== options.ifMatch) {\n          return Promise.resolve({\n            statusCode: 412,\n            revision: metadata.rev\n          });\n        }\n\n        return self._uploadSimple(uploadParams);\n      });\n    } else {\n      result = self._uploadSimple(uploadParams);\n    }\n\n    return result.then(function (ret) {\n      self._shareIfNeeded(path);\n      return ret;\n    });\n  },\n\n  /**\n   * Method: delete\n   *\n   * Compatible with <RemoteStorage.WireClient.delete>\n   *\n   * Checks for the path in _revCache and decides based on that if file has\n   * changed.\n   *\n   * Calls <RemoteStorage.Dropbox.share> afterwards to fill _itemRefs.\n   */\n  'delete': function _delete(path, options) {\n    var self = this;\n\n    if (!this.connected) {\n      throw new Error(\"not connected (path: \" + path + \")\");\n    }\n\n    //check if file has changed and return 412\n    var savedRev = this._revCache.get(path);\n    if (options && options.ifMatch && savedRev && options.ifMatch !== savedRev) {\n      return Promise.resolve({ statusCode: 412, revision: savedRev });\n    }\n\n    if (options && options.ifMatch) {\n      return this._getMetadata(path).then(function (metadata) {\n        if (options && options.ifMatch && metadata && metadata.rev !== options.ifMatch) {\n          return Promise.resolve({\n            statusCode: 412,\n            revision: metadata.rev\n          });\n        }\n\n        return self._deleteSimple(path);\n      });\n    }\n\n    return self._deleteSimple(path);\n  },\n\n  /**\n   * Method: _shareIfNeeded\n   *\n   * Calls share, if the provided path resides in a public folder.\n   */\n  _shareIfNeeded: function _shareIfNeeded(path) {\n    if (path.match(/^\\/public\\/.*[^\\/]$/) && this._itemRefs[path] === undefined) {\n      this.share(path);\n    }\n  },\n\n  /**\n   * Method: share\n   *\n   * Gets a publicly-accessible URL for the path from Dropbox and stores it\n   * in _itemRefs.\n   *\n   * Returns:\n   *\n   *   A promise for the URL\n   */\n  share: function share(path) {\n    var self = this;\n    var url = 'https://api.dropbox.com/1/media/auto' + getDropboxPath(path);\n\n    return this._request('POST', url, {}).then(function (response) {\n      if (response.status !== 200) {\n        return Promise.reject(new Error('Invalid Dropbox API response status when sharing \"' + path + '\":' + response.status));\n      }\n\n      try {\n        response = JSON.parse(response.responseText);\n      } catch (e) {\n        return Promise.reject(new Error('Invalid Dropbox API response when sharing \"' + path + '\": ' + response.responseText));\n      }\n\n      self._itemRefs[path] = response.url;\n\n      if (hasLocalStorage) {\n        localStorage[SETTINGS_KEY + ':shares'] = JSON.stringify(self._itemRefs);\n      }\n\n      return Promise.resolve(url);\n    }, function (error) {\n      err.message = 'Sharing dropbox file or folder (\"' + path + '\") failed.' + err.message;\n      return Promise.reject(error);\n    });\n  },\n\n  /**\n   * Method: info\n   *\n   * Fetches the user's info from dropbox and returns a promise for it.\n   *\n   * Returns:\n   *\n   *   A promise to the user's info\n   */\n  info: function info() {\n    var url = 'https://api.dropbox.com/1/account/info';\n    // requesting user info(mainly for userAdress)\n    return this._request('GET', url, {}).then(function (resp) {\n      try {\n        var info = JSON.parse(resp.responseText);\n        return Promise.resolve(info);\n      } catch (e) {\n        return Promise.reject(e);\n      }\n    });\n  },\n\n  /**\n   * Method: _request\n   *\n   * Make a HTTP request.\n   *\n   * Options:\n   *\n   *   headers - an object containing the request headers\n   *\n   * Parameters:\n   *\n   *   method - the method to use\n   *   url - the URL to make the request to\n   *   options - see above\n   */\n  _request: function _request(method, url, options) {\n    var self = this;\n\n    if (!options.headers) {\n      options.headers = {};\n    }\n    options.headers['Authorization'] = 'Bearer ' + this.token;\n\n    this._emit('wire-busy', {\n      method: method,\n      isFolder: isFolder(url)\n    });\n\n    return WireClient.request.call(this, method, url, options).then(function (xhr) {\n      // 503 means retry this later\n      if (xhr && xhr.status === 503) {\n        if (self.online) {\n          self.online = false;\n          self.rs._emit('network-offline');\n        }\n        return setTimeout(self._request(method, url, options), 3210);\n      } else {\n        if (!self.online) {\n          self.online = true;\n          self.rs._emit('network-online');\n        }\n        self._emit('wire-done', {\n          method: method,\n          isFolder: isFolder(url),\n          success: true\n        });\n\n        return Promise.resolve(xhr);\n      }\n    }, function (error) {\n      if (self.online) {\n        self.online = false;\n        self.rs._emit('network-offline');\n      }\n      self._emit('wire-done', {\n        method: method,\n        isFolder: isFolder(url),\n        success: false\n      });\n\n      return Promise.reject(error);\n    });\n  },\n\n  /**\n   * Method: fetchDelta\n   *\n   * Fetches the revision of all the files from dropbox API and puts them\n   * into _revCache. These values can then be used to determine if something\n   * has changed.\n   */\n  fetchDelta: function fetchDelta() {\n    // TODO: Handle `has_more`\n\n    var args = Array.prototype.slice.call(arguments);\n    var self = this;\n    var body = { path_prefix: PATH_PREFIX };\n\n    if (self._deltaCursor) {\n      body.cursor = self._deltaCursor;\n    }\n\n    return self._request('POST', 'https://api.dropbox.com/1/delta', {\n      body: encodeQuery(body),\n      headers: {\n        'Content-Type': 'application/x-www-form-urlencoded'\n      }\n    }).then(function (response) {\n      // break if status != 200\n      if (response.status !== 200) {\n        if (response.status === 400) {\n          self.rs._emit('error', new Authorize.Unauthorized());\n          return Promise.resolve(args);\n        } else {\n          return Promise.reject(\"dropbox.fetchDelta returned \" + response.status + response.responseText);\n        }\n        return;\n      }\n\n      var delta;\n      try {\n        delta = JSON.parse(response.responseText);\n      } catch (error) {\n        log('fetchDeltas can not parse response', error);\n        return Promise.reject(\"can not parse response of fetchDelta : \" + error.message);\n      }\n      // break if no entries found\n      if (!delta.entries) {\n        return Promise.reject('dropbox.fetchDeltas failed, no entries found');\n      }\n\n      // Dropbox sends the complete state\n      if (delta.reset) {\n        self._revCache = new LowerCaseCache('rev');\n      }\n\n      //saving the cursor for requesting further deltas in relation to the cursor position\n      if (delta.cursor) {\n        self._deltaCursor = delta.cursor;\n      }\n\n      //updating revCache\n      delta.entries.forEach(function (entry) {\n        var path = entry[0].substr(PATH_PREFIX.length);\n        var rev;\n        if (!entry[1]) {\n          rev = null;\n        } else {\n          if (entry[1].is_dir) {\n            return;\n          }\n          rev = entry[1].rev;\n        }\n        self._revCache.set(path, rev);\n      });\n      return Promise.resolve(args);\n    }, function (err) {\n      this.rs.log('fetchDeltas', err);\n      this.rs._emit('error', new Sync.SyncError('fetchDeltas failed.' + err));\n      return Promise.resolve(args);\n    }.bind(this)).then(function () {\n      if (self._revCache) {\n        var args = Array.prototype.slice.call(arguments);\n        self._revCache._activatePropagation();\n        return Promise.resolve(args);\n      }\n    });\n  },\n\n  /**\n   * Method: _getMetadata\n   *\n   * Gets metadata for a path (can point to either a file or a folder).\n   *\n   * Options:\n   *\n   *   list - if path points to a folder, specifies whether to list the\n   *          metadata of the folder's children. False by default.\n   *\n   * Parameters:\n   *\n   *   path - the path to get metadata for\n   *   options - see above\n   *\n   * Returns:\n   *\n   *   A promise for the metadata\n   */\n  _getMetadata: function _getMetadata(path, options) {\n    var self = this;\n    var cached = this._metadataCache[path];\n    var url = 'https://api.dropbox.com/1/metadata/auto' + getDropboxPath(path);\n    url += '?list=' + (options && options.list ? 'true' : 'false');\n    if (cached && cached.hash) {\n      url += '&hash=' + encodeURIComponent(cached.hash);\n    }\n    return this._request('GET', url, {}).then(function (resp) {\n      if (resp.status === 304) {\n        return Promise.resolve(cached);\n      } else if (resp.status === 200) {\n        var response = JSON.parse(resp.responseText);\n        self._metadataCache[path] = response;\n        return Promise.resolve(response);\n      } else {\n        // The file doesn't exist\n        return Promise.resolve();\n      }\n    });\n  },\n\n  /**\n   * Method: _uploadSimple\n   *\n   * Upload a simple file (the size is no more than 150MB).\n   *\n   * Parameters:\n   *\n   *   ifMatch - same as for get\n   *   path - path of the file\n   *   body - contents of the file to upload\n   *   contentType - mime type of the file\n   *\n   * Returns:\n   *\n   *   statusCode - HTTP status code\n   *   revision - revision of the newly-created file, if any\n   */\n  _uploadSimple: function _uploadSimple(params) {\n    var self = this;\n    var url = 'https://api-content.dropbox.com/1/files_put/auto' + getDropboxPath(params.path) + '?';\n\n    if (params && params.ifMatch) {\n      url += \"parent_rev=\" + encodeURIComponent(params.ifMatch);\n    }\n\n    return self._request('PUT', url, {\n      body: params.body,\n      headers: {\n        'Content-Type': params.contentType\n      }\n    }).then(function (resp) {\n      if (resp.status !== 200) {\n        return Promise.resolve({ statusCode: resp.status });\n      }\n\n      var response;\n\n      try {\n        response = JSON.parse(resp.responseText);\n      } catch (e) {\n        return Promise.reject(e);\n      }\n\n      // Conflict happened. Delete the copy created by dropbox\n      if (response.path !== getDropboxPath(params.path)) {\n        var deleteUrl = 'https://api.dropbox.com/1/fileops/delete?root=auto&path=' + encodeURIComponent(response.path);\n        self._request('POST', deleteUrl, {});\n\n        return self._getMetadata(params.path).then(function (metadata) {\n          return Promise.resolve({\n            statusCode: 412,\n            revision: metadata.rev\n          });\n        });\n      }\n\n      self._revCache.propagateSet(params.path, response.rev);\n      return Promise.resolve({ statusCode: resp.status });\n    });\n  },\n\n  /**\n   * Method: _deleteSimple\n   *\n   * Deletes a file or a folder. If the folder contains more than 10'000 items\n   * (recursively) then the operation may not complete successfully. If that\n   * is the case, an Error gets thrown.\n   *\n   * Parameters:\n   *\n   *   path - the path to delete\n   *\n   * Returns:\n   *\n   *   statusCode - HTTP status code\n   */\n  _deleteSimple: function _deleteSimple(path) {\n    var self = this;\n    var url = 'https://api.dropbox.com/1/fileops/delete?root=auto&path=' + encodeURIComponent(getDropboxPath(path));\n\n    return self._request('POST', url, {}).then(function (resp) {\n      if (resp.status === 406) {\n        // Too many files would be involved in the operation for it to\n        // complete successfully.\n        // TODO: Handle this somehow\n        return Promise.reject(new Error(\"Cannot delete '\" + path + \"': too many files involved\"));\n      }\n\n      if (resp.status === 200 || resp.status === 404) {\n        self._revCache.delete(path);\n        delete self._itemRefs[path];\n      }\n\n      return Promise.resolve({ statusCode: resp.status });\n    });\n  }\n};\n\n// Hooking and unhooking the sync\n\nfunction hookSync(rs) {\n  if (rs._dropboxOrigSync) {\n    return;\n  } // already hooked\n  rs._dropboxOrigSync = rs.sync.sync.bind(rs.sync);\n  rs.sync.sync = function () {\n    return this.dropbox.fetchDelta.apply(this.dropbox, arguments).then(rs._dropboxOrigSync, function (err) {\n      rs._emit('error', new Sync.SyncError(err));\n      return Promise.reject(err);\n    });\n  }.bind(rs);\n}\n\nfunction unHookSync(rs) {\n  if (!rs._dropboxOrigSync) {\n    return;\n  } // not hooked\n  rs.sync.sync = rs._dropboxOrigSync;\n  delete rs._dropboxOrigSync;\n}\n\n// Hooking and unhooking getItemURL\n\nfunction hookGetItemURL(rs) {\n  if (rs._origBaseClientGetItemURL) {\n    return;\n  }\n  rs._origBaseClientGetItemURL = BaseClient.prototype.getItemURL;\n  BaseClient.prototype.getItemURL = function (path) {\n    var ret = rs.dropbox._itemRefs[path];\n    return ret ? ret : '';\n  };\n}\n\nfunction unHookGetItemURL(rs) {\n  if (!rs._origBaseClientGetItemURL) {\n    return;\n  }\n  BaseClient.prototype.getItemURL = rs._origBaseClientGetItemURL;\n  delete rs._origBaseClientGetItemURL;\n}\n\nfunction hookRemote(rs) {\n  if (rs._origRemote) {\n    return;\n  }\n  rs._origRemote = rs.remote;\n  rs.remote = rs.dropbox;\n}\n\nfunction unHookRemote(rs) {\n  if (rs._origRemote) {\n    rs.remote = rs._origRemote;\n    delete rs._origRemote;\n  }\n}\n\nfunction hookIt(rs) {\n  hookRemote(rs);\n  if (rs.sync) {\n    hookSync(rs);\n  } else {\n    // when sync is not available yet, we wait for the remote to be connected,\n    // at which point sync should be available as well\n    rs.on('connected', function () {\n      if (rs.sync) {\n        hookSync(rs);\n      }\n    });\n  }\n  hookGetItemURL(rs);\n}\n\nfunction unHookIt(rs) {\n  unHookRemote(rs);\n  unHookSync(rs);\n  unHookGetItemURL(rs);\n}\n\nDropbox._rs_init = function (rs) {\n  hasLocalStorage = util.localStorageAvailable();\n  if (rs.apiKeys.dropbox) {\n    rs.dropbox = new Dropbox(rs);\n  }\n  if (rs.backend === 'dropbox') {\n    hookIt(rs);\n  }\n};\n\nDropbox._rs_supported = function () {\n  return true;\n};\n\nDropbox._rs_cleanup = function (rs) {\n  unHookIt(rs);\n  if (hasLocalStorage) {\n    delete localStorage[SETTINGS_KEY];\n  }\n  rs.removeEventListener('error', onErrorCb);\n  rs.setBackend(undefined);\n};\n\nmodule.exports = Dropbox;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvZHJvcGJveC5qcz9mYzg5Il0sIm5hbWVzIjpbIkF1dGhvcml6ZSIsInJlcXVpcmUiLCJCYXNlQ2xpZW50IiwiV2lyZUNsaWVudCIsInV0aWwiLCJldmVudEhhbmRsaW5nIiwiU3luYyIsImhhc0xvY2FsU3RvcmFnZSIsIkFVVEhfVVJMIiwiU0VUVElOR1NfS0VZIiwiUEFUSF9QUkVGSVgiLCJpc0ZvbGRlciIsImdldERyb3Bib3hQYXRoIiwicGF0aCIsImNsZWFuUGF0aCIsImVuY29kZVF1ZXJ5Iiwib2JqIiwicGFpcnMiLCJrZXkiLCJoYXNPd25Qcm9wZXJ0eSIsInB1c2giLCJlbmNvZGVVUklDb21wb25lbnQiLCJqb2luIiwiTG93ZXJDYXNlQ2FjaGUiLCJkZWZhdWx0VmFsdWUiLCJfc3RvcmFnZSIsInNldCIsImp1c3RTZXQiLCJkZWxldGUiLCJqdXN0RGVsZXRlIiwicHJvdG90eXBlIiwiZ2V0IiwidG9Mb3dlckNhc2UiLCJzdG9yZWQiLCJwcm9wYWdhdGVTZXQiLCJ2YWx1ZSIsIl9wcm9wYWdhdGUiLCJwcm9wYWdhdGVEZWxldGUiLCJfYWN0aXZhdGVQcm9wYWdhdGlvbiIsInJldiIsImZvbGRlcnMiLCJzcGxpdCIsInNsaWNlIiwiaSIsImxlbiIsImxlbmd0aCIsIm9uRXJyb3JDYiIsIkRyb3Bib3giLCJycyIsImNvbm5lY3RlZCIsInNlbGYiLCJlcnJvciIsIlVuYXV0aG9yaXplZCIsImNvbmZpZ3VyZSIsInVzZXJBZGRyZXNzIiwiaHJlZiIsInN0b3JhZ2VBcGkiLCJ0b2tlbiIsIm9wdGlvbnMiLCJvbiIsImNsaWVudElkIiwiYXBpS2V5cyIsImRyb3Bib3giLCJhcHBLZXkiLCJfcmV2Q2FjaGUiLCJfaXRlbVJlZnMiLCJfbWV0YWRhdGFDYWNoZSIsInNldHRpbmdzIiwiSlNPTiIsInBhcnNlIiwibG9jYWxTdG9yYWdlIiwiZSIsInNldFRpbWVvdXQiLCJfZW1pdCIsImJpbmQiLCJvbmxpbmUiLCJjb25uZWN0Iiwic2V0QmFja2VuZCIsImhvb2tJdCIsIlN0cmluZyIsImdldExvY2F0aW9uIiwiaW5mbyIsInRoZW4iLCJkaXNwbGF5X25hbWUiLCJzdHJpbmdpZnkiLCJzdG9wV2FpdGluZ0ZvclRva2VuIiwiX2dldEZvbGRlciIsInVybCIsInJldkNhY2hlIiwiX3JlcXVlc3QiLCJyZXNwIiwic3RhdHVzIiwiUHJvbWlzZSIsInJlc29sdmUiLCJzdGF0dXNDb2RlIiwibGlzdGluZyIsImJvZHkiLCJtaW1lIiwicmVzcG9uc2VUZXh0IiwicmVqZWN0IiwiY29udGVudHMiLCJyZWR1Y2UiLCJtIiwiaXRlbSIsIml0ZW1OYW1lIiwiaXNfZGlyIiwiRVRhZyIsImNvbnRlbnRUeXBlIiwicmV2aXNpb24iLCJzYXZlZFJldiIsImlmTm9uZU1hdGNoIiwic3Vic3RyIiwibWV0YSIsImdldFJlc3BvbnNlSGVhZGVyIiwibWltZV90eXBlIiwiX3NoYXJlSWZOZWVkZWQiLCJtYXRjaCIsInBlbmRpbmciLCJkZWZlciIsInJlYWRCaW5hcnlEYXRhIiwicmVzcG9uc2UiLCJyZXN1bHQiLCJwcm9taXNlIiwic2VhcmNoIiwicHV0IiwiRXJyb3IiLCJpZk1hdGNoIiwiQXJyYXlCdWZmZXIiLCJpc0FycmF5QnVmZmVyVmlldyIsIm5lZWRzTWV0YWRhdGEiLCJ1cGxvYWRQYXJhbXMiLCJfZ2V0TWV0YWRhdGEiLCJtZXRhZGF0YSIsIl91cGxvYWRTaW1wbGUiLCJyZXQiLCJfZGVsZXRlU2ltcGxlIiwidW5kZWZpbmVkIiwic2hhcmUiLCJlcnIiLCJtZXNzYWdlIiwibWV0aG9kIiwiaGVhZGVycyIsInJlcXVlc3QiLCJjYWxsIiwieGhyIiwic3VjY2VzcyIsImZldGNoRGVsdGEiLCJhcmdzIiwiQXJyYXkiLCJhcmd1bWVudHMiLCJwYXRoX3ByZWZpeCIsIl9kZWx0YUN1cnNvciIsImN1cnNvciIsImRlbHRhIiwibG9nIiwiZW50cmllcyIsInJlc2V0IiwiZm9yRWFjaCIsImVudHJ5IiwiU3luY0Vycm9yIiwiY2FjaGVkIiwibGlzdCIsImhhc2giLCJwYXJhbXMiLCJkZWxldGVVcmwiLCJob29rU3luYyIsIl9kcm9wYm94T3JpZ1N5bmMiLCJzeW5jIiwiYXBwbHkiLCJ1bkhvb2tTeW5jIiwiaG9va0dldEl0ZW1VUkwiLCJfb3JpZ0Jhc2VDbGllbnRHZXRJdGVtVVJMIiwiZ2V0SXRlbVVSTCIsInVuSG9va0dldEl0ZW1VUkwiLCJob29rUmVtb3RlIiwiX29yaWdSZW1vdGUiLCJyZW1vdGUiLCJ1bkhvb2tSZW1vdGUiLCJ1bkhvb2tJdCIsIl9yc19pbml0IiwibG9jYWxTdG9yYWdlQXZhaWxhYmxlIiwiYmFja2VuZCIsIl9yc19zdXBwb3J0ZWQiLCJfcnNfY2xlYW51cCIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJtb2R1bGUiLCJleHBvcnRzIl0sIm1hcHBpbmdzIjoiOztBQUFFLElBQUlBLFlBQVksbUJBQUFDLENBQVEsQ0FBUixDQUFoQjtBQUNBLElBQUlDLGFBQWEsbUJBQUFELENBQVEsQ0FBUixDQUFqQjtBQUNBLElBQUlFLGFBQWEsbUJBQUFGLENBQVEsRUFBUixDQUFqQjtBQUNBLElBQUlHLE9BQU8sbUJBQUFILENBQVEsQ0FBUixDQUFYO0FBQ0EsSUFBSUksZ0JBQWdCLG1CQUFBSixDQUFRLENBQVIsQ0FBcEI7QUFDQSxJQUFJSyxPQUFPLG1CQUFBTCxDQUFRLEVBQVIsQ0FBWDs7QUFFQTs7QUFFQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQXFDQSxJQUFJTSxlQUFKO0FBQ0EsSUFBSUMsV0FBVyw0Q0FBZjtBQUNBLElBQUlDLGVBQWUsdUJBQW5CO0FBQ0EsSUFBSUMsY0FBYyxnQkFBbEI7O0FBRUEsSUFBSUMsV0FBV1AsS0FBS08sUUFBcEI7O0FBRUE7Ozs7O0FBS0EsSUFBSUMsaUJBQWlCLFNBQWpCQSxjQUFpQixDQUFVQyxJQUFWLEVBQWdCO0FBQ25DLFNBQU9WLFdBQVdXLFNBQVgsQ0FBcUJKLGNBQWMsR0FBZCxHQUFvQkcsSUFBekMsQ0FBUDtBQUNELENBRkQ7O0FBSUEsSUFBSUUsY0FBYyxTQUFkQSxX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T0FBdkIsRUFBZ0MxSSxTQUFoQztBQUNBRSxLQUFHNkIsVUFBSCxDQUFjMkQsU0FBZDtBQUNELENBUEQ7O0FBVUFpRCxPQUFPQyxPQUFQLEdBQWlCM0ksT0FBakIiLCJmaWxlIjoiNi5qcyIsInNvdXJjZXNDb250ZW50IjpbIiAgdmFyIEF1dGhvcml6ZSA9IHJlcXVpcmUoJy4vYXV0aG9yaXplJyk7XG4gIHZhciBCYXNlQ2xpZW50ID0gcmVxdWlyZSgnLi9iYXNlY2xpZW50Jyk7XG4gIHZhciBXaXJlQ2xpZW50ID0gcmVxdWlyZSgnLi93aXJlY2xpZW50Jyk7XG4gIHZhciB1dGlsID0gcmVxdWlyZSgnLi91dGlsJyk7XG4gIHZhciBldmVudEhhbmRsaW5nID0gcmVxdWlyZSgnLi9ldmVudGhhbmRsaW5nJyk7XG4gIHZhciBTeW5jID0gcmVxdWlyZSgnLi9zeW5jJyk7XG4gIFxuICAvLyB2YXIgUmVtb3RlU3RvcmFnZSA9IHJlcXVpcmUoJy4vcmVtb3Rlc3RvcmFnZScpO1xuXG4gIC8qKlxuICAgKiBGaWxlOiBEcm9wYm94XG4gICAqXG4gICAqIFdPUksgSU4gUFJPR1JFU1MsIE5PVCBSRUNPTU1FTkRFRCBGT1IgUFJPRFVDVElPTiBVU0VcbiAgICpcbiAgICogRHJvcGJveCBiYWNrZW5kIGZvciBSZW1vdGVTdG9yYWdlLmpzXG4gICAqIFRoaXMgZmlsZSBleHBvc2VzIGEgZ2V0L3B1dC9kZWxldGUgaW50ZXJmYWNlIHdoaWNoIGlzIGNvbXBhdGlibGUgd2l0aFxuICAgKiA8UmVtb3RlU3RvcmFnZS5XaXJlQ2xpZW50Pi5cbiAgICpcbiAgICogV2hlbiByZW1vdGVTdG9yYWdlLmJhY2tlbmQgaXMgc2V0IHRvICdkcm9wYm94JywgdGhpcyBiYWNrZW5kIHdpbGxcbiAgICogaW5pdGlhbGl6ZSBhbmQgcmVwbGFjZSByZW1vdGVTdG9yYWdlLnJlbW90ZSB3aXRoIHJlbW90ZVN0b3JhZ2UuZHJvcGJveC5cbiAgICpcbiAgICogSW4gb3JkZXIgdG8gZW5zdXJlIGNvbXBhdGliaWxpdHkgd2l0aCB0aGUgcHVibGljIGZvbGRlciwgPEJhc2VDbGllbnQuZ2V0SXRlbVVSTD5cbiAgICogZ2V0cyBoaWphY2tlZCB0byByZXR1cm4gdGhlIERyb3Bib3ggcHVibGljIHNoYXJlIFVSTC5cbiAgICpcbiAgICogVG8gdXNlIHRoaXMgYmFja2VuZCwgeW91IG5lZWQgdG8gc3BlY2lmeSB0aGUgRHJvcGJveCBhcHAga2V5IGxpa2Ugc286XG4gICAqXG4gICAqIChzdGFydCBjb2RlKVxuICAgKlxuICAgKiByZW1vdGVTdG9yYWdlLnNldEFwaUtleXMoJ2Ryb3Bib3gnLCB7XG4gICAqICAgYXBwS2V5OiAneW91ci1hcHAta2V5J1xuICAgKiB9KTtcbiAgICpcbiAgICogKGVuZCBjb2RlKVxuICAgKlxuICAgKiBBbiBhcHAga2V5IGNhbiBiZSBvYnRhaW5lZCBieSByZWdpc3RlcmluZyB5b3VyIGFwcCBhdCBodHRwczovL3d3dy5kcm9wYm94LmNvbS9kZXZlbG9wZXJzL2FwcHNcbiAgICpcbiAgICogS25vd24gaXNzdWVzOlxuICAgKlxuICAgKiAgIC0gU3RvcmluZyBmaWxlcyBsYXJnZXIgdGhhbiAxNTBNQiBpcyBub3QgeWV0IHN1cHBvcnRlZFxuICAgKiAgIC0gTGlzdGluZyBhbmQgZGVsZXRpbmcgZm9sZGVycyB3aXRoIG1vcmUgdGhhbiAxMCcwMDAgZmlsZXMgd2lsbCBjYXVzZSBwcm9ibGVtc1xuICAgKiAgIC0gQ29udGVudC1UeXBlIGlzIG5vdCBmdWxseSBzdXBwb3J0ZWQgZHVlIHRvIGxpbWl0YXRpb25zIG9mIHRoZSBEcm9wYm94IEFQSVxuICAgKiAgIC0gRHJvcGJveCBwcmVzZXJ2ZXMgY2FzZXMgYnV0IGlzIG5vdCBjYXNlLXNlbnNpdGl2ZVxuICAgKiAgIC0gZ2V0SXRlbVVSTCBpcyBhc3luY2hyb25vdXMgd2hpY2ggbWVhbnMgZ2V0SWV0bVVSTCByZXR1cm5zIHVzZWZ1bCB2YWx1ZXNcbiAgICogICAgIGFmdGVyIHRoZSBzeW5jQ3ljbGVcbiAgICovXG5cbiAgdmFyIGhhc0xvY2FsU3RvcmFnZTtcbiAgdmFyIEFVVEhfVVJMID0gJ2h0dHBzOi8vd3d3LmRyb3Bib3guY29tLzEvb2F1dGgyL2F1dGhvcml6ZSc7XG4gIHZhciBTRVRUSU5HU19LRVkgPSAncmVtb3Rlc3RvcmFnZTpkcm9wYm94JztcbiAgdmFyIFBBVEhfUFJFRklYID0gJy9yZW1vdGVzdG9yYWdlJztcblxuICB2YXIgaXNGb2xkZXIgPSB1dGlsLmlzRm9sZGVyO1xuXG4gIC8qKlxuICAgKiBGdW5jdGlvbjogZ2V0RHJvcGJveFBhdGgocGF0aClcbiAgICpcbiAgICogTWFwIGEgbG9jYWwgcGF0aCB0byBhIHBhdGggaW4gRHJvcEJveC5cbiAgICovXG4gIHZhciBnZXREcm9wYm94UGF0aCA9IGZ1bmN0aW9uIChwYXRoKSB7XG4gICAgcmV0dXJuIFdpcmVDbGllbnQuY2xlYW5QYXRoKFBBVEhfUFJFRklYICsgJy8nICsgcGF0aCk7XG4gIH07XG5cbiAgdmFyIGVuY29kZVF1ZXJ5ID0gZnVuY3Rpb24gKG9iaikge1xuICAgIHZhciBwYWlycyA9IFtdO1xuXG4gICAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgIHBhaXJzLnB1c2goZW5jb2RlVVJJQ29tcG9uZW50KGtleSkgKyAnPScgKyBlbmNvZGVVUklDb21wb25lbnQob2JqW2tleV0pKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcGFpcnMuam9pbignJicpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBjbGFzczogTG93ZXJDYXNlQ2FjaGVcbiAgICpcbiAgICogQSBjYWNoZSB3aGljaCBhdXRvbWF0aWNhbGx5IGNvbnZlcnRzIGFsbCBrZXlzIHRvIGxvd2VyIGNhc2UgYW5kIGNhblxuICAgKiBwcm9wYWdhdGUgY2hhbmdlcyB1cCB0byBwYXJlbnQgZm9sZGVycy5cbiAgICpcbiAgICogQnkgZGVmYXVsdCB0aGUgc2V0IGFuZCBkZWxldGUgbWV0aG9kcyBhcmUgYWxpYXNlZCB0byBqdXN0U2V0IGFuZCBqdXN0RGVsZXRlLlxuICAgKlxuICAgKiBQYXJhbWV0ZXJzOlxuICAgKlxuICAgKiAgIGRlZmF1bHRWYWx1ZSAtIHRoZSB2YWx1ZSB0aGF0IGlzIHJldHVybmVkIGZvciBhbGwga2V5cyB0aGF0IGRvbid0IGV4aXN0XG4gICAqICAgICAgICAgICAgICAgICAgaW4gdGhlIGNhY2hlXG4gICAqL1xuICBmdW5jdGlvbiBMb3dlckNhc2VDYWNoZShkZWZhdWx0VmFsdWUpe1xuICAgIHRoaXMuZGVmYXVsdFZhbHVlID0gZGVmYXVsdFZhbHVlO1xuICAgIHRoaXMuX3N0b3JhZ2UgPSB7IH07XG4gICAgdGhpcy5zZXQgPSB0aGlzLmp1c3RTZXQ7XG4gICAgdGhpcy5kZWxldGUgPSB0aGlzLmp1c3REZWxldGU7XG4gIH1cblxuICBMb3dlckNhc2VDYWNoZS5wcm90b3R5cGUgPSB7XG4gICAgLyoqXG4gICAgICogTWV0aG9kOiBnZXRcbiAgICAgKlxuICAgICAqIEdldCBhIHZhbHVlIGZyb20gdGhlIGNhY2hlIG9yIGRlZmF1bHRWYWx1ZSwgaWYgdGhlIGtleSBpcyBub3QgaW4gdGhlXG4gICAgICogY2FjaGUuXG4gICAgICovXG4gICAgZ2V0IDogZnVuY3Rpb24gKGtleSkge1xuICAgICAga2V5ID0ga2V5LnRvTG93ZXJDYXNlKCk7XG4gICAgICB2YXIgc3RvcmVkID0gdGhpcy5fc3RvcmFnZVtrZXldO1xuICAgICAgaWYgKHR5cGVvZiBzdG9yZWQgPT09ICd1bmRlZmluZWQnKXtcbiAgICAgICAgc3RvcmVkID0gdGhpcy5kZWZhdWx0VmFsdWU7XG4gICAgICAgIHRoaXMuX3N0b3JhZ2Vba2V5XSA9IHN0b3JlZDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzdG9yZWQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1ldGhvZDogcHJvcGFnYXRlU2V0XG4gICAgICpcbiAgICAgKiBTZXQgYSB2YWx1ZSBhbmQgYWxzbyB1cGRhdGUgdGhlIHBhcmVudCBmb2xkZXJzIHdpdGggdGhhdCB2YWx1ZS5cbiAgICAgKi9cbiAgICBwcm9wYWdhdGVTZXQgOiBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICAgICAga2V5ID0ga2V5LnRvTG93ZXJDYXNlKCk7XG4gICAgICBpZiAodGhpcy5fc3RvcmFnZVtrZXldID09PSB2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9XG4gICAgICB0aGlzLl9wcm9wYWdhdGUoa2V5LCB2YWx1ZSk7XG4gICAgICB0aGlzLl9zdG9yYWdlW2tleV0gPSB2YWx1ZTtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTWV0aG9kOiBwcm9wYWdhdGVEZWxldGVcbiAgICAgKlxuICAgICAqIERlbGV0ZSBhIHZhbHVlIGFuZCBwcm9wYWdhdGUgdGhlIGNoYW5nZXMgdG8gdGhlIHBhcmVudCBmb2xkZXJzLlxuICAgICAqL1xuICAgIHByb3BhZ2F0ZURlbGV0ZSA6IGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgIGtleSA9IGtleS50b0xvd2VyQ2FzZSgpO1xuICAgICAgdGhpcy5fcHJvcGFnYXRlKGtleSwgdGhpcy5fc3RvcmFnZVtrZXldKTtcbiAgICAgIHJldHVybiBkZWxldGUgdGhpcy5fc3RvcmFnZVtrZXldO1xuICAgIH0sXG5cbiAgICBfYWN0aXZhdGVQcm9wYWdhdGlvbjogZnVuY3Rpb24gKCl7XG4gICAgICB0aGlzLnNldCA9IHRoaXMucHJvcGFnYXRlU2V0O1xuICAgICAgdGhpcy5kZWxldGUgPSB0aGlzLnByb3BhZ2F0ZURlbGV0ZTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNZXRob2Q6IGp1c3RTZXRcbiAgICAgKlxuICAgICAqIFNldCBhIHZhbHVlIHdpdGhvdXQgcHJvcGFnYXRpbmcuXG4gICAgICovXG4gICAganVzdFNldCA6IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gICAgICBrZXkgPSBrZXkudG9Mb3dlckNhc2UoKTtcbiAgICAgIHRoaXMuX3N0b3JhZ2Vba2V5XSA9IHZhbHVlO1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNZXRob2Q6IGp1c3REZWxldGVcbiAgICAgKlxuICAgICAqIERlbGV0ZSBhIHZhbHVlIHdpdGhvdXQgcHJvcGFnYXRpbmcuXG4gICAgICovXG4gICAganVzdERlbGV0ZSA6IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gICAgICBrZXkgPSBrZXkudG9Mb3dlckNhc2UoKTtcbiAgICAgIHJldHVybiBkZWxldGUgdGhpcy5fc3RvcmFnZVtrZXldO1xuICAgIH0sXG5cbiAgICBfcHJvcGFnYXRlOiBmdW5jdGlvbiAoa2V5LCByZXYpe1xuICAgICAgdmFyIGZvbGRlcnMgPSBrZXkuc3BsaXQoJy8nKS5zbGljZSgwLC0xKTtcbiAgICAgIHZhciBwYXRoID0gJyc7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBmb2xkZXJzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKXtcbiAgICAgICAgcGF0aCArPSBmb2xkZXJzW2ldKycvJztcbiAgICAgICAgaWYgKCFyZXYpIHtcbiAgICAgICAgICByZXYgPSB0aGlzLl9zdG9yYWdlW3BhdGhdKzE7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fc3RvcmFnZVtwYXRoXSA9ICByZXY7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIHZhciBvbkVycm9yQ2I7XG5cbiAgLyoqXG4gICAqIENsYXNzOiBSZW1vdGVTdG9yYWdlLkRyb3Bib3hcbiAgICovXG4gIHZhciBEcm9wYm94ID0gZnVuY3Rpb24gKHJzKSB7XG5cbiAgICB0aGlzLnJzID0gcnM7XG4gICAgdGhpcy5jb25uZWN0ZWQgPSBmYWxzZTtcbiAgICB0aGlzLnJzID0gcnM7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgb25FcnJvckNiID0gZnVuY3Rpb24gKGVycm9yKXtcbiAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEF1dGhvcml6ZS5VbmF1dGhvcml6ZWQpIHtcbiAgICAgICAgLy8gRGVsZXRlIGFsbCB0aGUgc2V0dGluZ3MgLSBzZWUgdGhlIGRvY3VtZW50YXRpb24gb2Ygd2lyZWNsaWVudC5jb25maWd1cmVcbiAgICAgICAgc2VsZi5jb25maWd1cmUoe1xuICAgICAgICAgIHVzZXJBZGRyZXNzOiBudWxsLFxuICAgICAgICAgIGhyZWY6IG51bGwsXG4gICAgICAgICAgc3RvcmFnZUFwaTogbnVsbCxcbiAgICAgICAgICB0b2tlbjogbnVsbCxcbiAgICAgICAgICBvcHRpb25zOiBudWxsXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBldmVudEhhbmRsaW5nKHRoaXMsICdjaGFuZ2UnLCAnY29ubmVjdGVkJywgJ3dpcmUtYnVzeScsICd3aXJlLWRvbmUnLCAnbm90LWNvbm5lY3RlZCcpO1xuICAgIHJzLm9uKCdlcnJvcicsIG9uRXJyb3JDYik7XG5cbiAgICB0aGlzLmNsaWVudElkID0gcnMuYXBpS2V5cy5kcm9wYm94LmFwcEtleTtcbiAgICB0aGlzLl9yZXZDYWNoZSA9IG5ldyBMb3dlckNhc2VDYWNoZSgncmV2Jyk7XG4gICAgdGhpcy5faXRlbVJlZnMgPSB7fTtcbiAgICB0aGlzLl9tZXRhZGF0YUNhY2hlID0ge307XG5cbiAgICBpZiAoaGFzTG9jYWxTdG9yYWdlKXtcbiAgICAgIHZhciBzZXR0aW5ncztcbiAgICAgIHRyeSB7XG4gICAgICAgIHNldHRpbmdzID0gSlNPTi5wYXJzZShsb2NhbFN0b3JhZ2VbU0VUVElOR1NfS0VZXSk7XG4gICAgICB9IGNhdGNoKGUpe31cbiAgICAgIGlmIChzZXR0aW5ncykge1xuICAgICAgICB0aGlzLmNvbmZpZ3VyZShzZXR0aW5ncyk7XG4gICAgICB9XG4gICAgICB0cnkge1xuICAgICAgICB0aGlzLl9pdGVtUmVmcyA9IEpTT04ucGFyc2UobG9jYWxTdG9yYWdlWyBTRVRUSU5HU19LRVkrJzpzaGFyZXMnIF0pO1xuICAgICAgfSBjYXRjaChlKSB7ICB9XG4gICAgfVxuICAgIGlmICh0aGlzLmNvbm5lY3RlZCkge1xuICAgICAgc2V0VGltZW91dCh0aGlzLl9lbWl0LmJpbmQodGhpcyksIDAsICdjb25uZWN0ZWQnKTtcbiAgICB9XG4gIH07XG5cbiAgRHJvcGJveC5wcm90b3R5cGUgPSB7XG4gICAgb25saW5lOiB0cnVlLFxuXG4gICAgLyoqXG4gICAgICogTWV0aG9kOiBjb25uZWN0XG4gICAgICpcbiAgICAgKiBTZXQgdGhlIGJhY2tlZCB0byAnZHJvcGJveCcgYW5kIHN0YXJ0IHRoZSBhdXRoZW50aWNhdGlvbiBmbG93IGluIG9yZGVyXG4gICAgICogdG8gb2J0YWluIGFuIEFQSSB0b2tlbiBmcm9tIERyb3Bib3guXG4gICAgICovXG4gICAgY29ubmVjdDogZnVuY3Rpb24gKCkge1xuICAgICAgLy8gVE9ETyBoYW5kbGluZyB3aGVuIHRva2VuIGlzIGFscmVhZHkgcHJlc2VudFxuICAgICAgdGhpcy5ycy5zZXRCYWNrZW5kKCdkcm9wYm94Jyk7XG4gICAgICBpZiAodGhpcy50b2tlbil7XG4gICAgICAgIGhvb2tJdCh0aGlzLnJzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIEF1dGhvcml6ZSh0aGlzLnJzLCBBVVRIX1VSTCwgJycsIFN0cmluZyhBdXRob3JpemUuZ2V0TG9jYXRpb24oKSksIHRoaXMuY2xpZW50SWQpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNZXRob2QgOiBjb25maWd1cmUoc2V0dGluZ3MpXG4gICAgICogQWNjZXB0cyBpdHMgcGFyYW1ldGVycyBhY2NvcmRpbmcgdG8gdGhlIDxSZW1vdGVTdG9yYWdlLldpcmVDbGllbnQ+LlxuICAgICAqIFNldHMgdGhlIGNvbm5lY3RlZCBmbGFnXG4gICAgICoqL1xuICAgIGNvbmZpZ3VyZTogZnVuY3Rpb24gKHNldHRpbmdzKSB7XG4gICAgICAvLyBXZSBvbmx5IHVwZGF0ZSB0aGlzLnVzZXJBZGRyZXNzIGlmIHNldHRpbmdzLnVzZXJBZGRyZXNzIGlzIHNldCB0byBhIHN0cmluZyBvciB0byBudWxsOlxuICAgICAgaWYgKHR5cGVvZiBzZXR0aW5ncy51c2VyQWRkcmVzcyAhPT0gJ3VuZGVmaW5lZCcpIHsgdGhpcy51c2VyQWRkcmVzcyA9IHNldHRpbmdzLnVzZXJBZGRyZXNzOyB9XG4gICAgICAvLyBTYW1lIGZvciB0aGlzLnRva2VuLiBJZiBvbmx5IG9uZSBvZiB0aGVzZSB0d28gaXMgc2V0LCB3ZSBsZWF2ZSB0aGUgb3RoZXIgb25lIGF0IGl0cyBleGlzdGluZyB2YWx1ZTpcbiAgICAgIGlmICh0eXBlb2Ygc2V0dGluZ3MudG9rZW4gIT09ICd1bmRlZmluZWQnKSB7IHRoaXMudG9rZW4gPSBzZXR0aW5ncy50b2tlbjsgfVxuXG4gICAgICBpZiAodGhpcy50b2tlbikge1xuICAgICAgICB0aGlzLmNvbm5lY3RlZCA9IHRydWU7XG4gICAgICAgIGlmICggIXRoaXMudXNlckFkZHJlc3MgKXtcbiAgICAgICAgICB0aGlzLmluZm8oKS50aGVuKGZ1bmN0aW9uIChpbmZvKXtcbiAgICAgICAgICAgIHRoaXMudXNlckFkZHJlc3MgPSBpbmZvLmRpc3BsYXlfbmFtZTtcbiAgICAgICAgICAgIHRoaXMuX2VtaXQoJ2Nvbm5lY3RlZCcpO1xuICAgICAgICAgIH0uYmluZCh0aGlzKSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuY29ubmVjdGVkID0gZmFsc2U7XG4gICAgICB9XG4gICAgICBpZiAoaGFzTG9jYWxTdG9yYWdlKXtcbiAgICAgICAgbG9jYWxTdG9yYWdlW1NFVFRJTkdTX0tFWV0gPSBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgdXNlckFkZHJlc3M6IHRoaXMudXNlckFkZHJlc3MsXG4gICAgICAgICAgdG9rZW46IHRoaXMudG9rZW5cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1ldGhvZDogc3RvcFdhaXRpbmdGb3JUb2tlblxuICAgICAqXG4gICAgICogU3RvcCB3YWl0aW5nIGZvciB0aGUgdG9rZW4gYW5kIGVtaXQgbm90LWNvbm5lY3RlZFxuICAgICAqL1xuICAgIHN0b3BXYWl0aW5nRm9yVG9rZW46IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICghdGhpcy5jb25uZWN0ZWQpIHtcbiAgICAgICAgdGhpcy5fZW1pdCgnbm90LWNvbm5lY3RlZCcpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNZXRob2Q6IF9nZXRGb2xkZXJcbiAgICAgKlxuICAgICAqIEdldCBhbGwgaXRlbXMgaW4gYSBmb2xkZXIuXG4gICAgICpcbiAgICAgKiBQYXJhbWV0ZXJzOlxuICAgICAqXG4gICAgICogICBwYXRoIC0gcGF0aCBvZiB0aGUgZm9sZGVyIHRvIGdldCwgd2l0aCBsZWFkaW5nIHNsYXNoXG4gICAgICogICBvcHRpb25zIC0gbm90IHVzZWRcbiAgICAgKlxuICAgICAqIFJldHVybnM6XG4gICAgICpcbiAgICAgKiAgc3RhdHVzQ29kZSAtIEhUVFAgc3RhdHVzIGNvZGVcbiAgICAgKiAgYm9keSAtIGFycmF5IG9mIHRoZSBpdGVtcyBmb3VuZFxuICAgICAqICBjb250ZW50VHlwZSAtICdhcHBsaWNhdGlvbi9qc29uOyBjaGFyc2V0PVVURi04J1xuICAgICAqICByZXZpc2lvbiAtIHJldmlzaW9uIG9mIHRoZSBmb2xkZXJcbiAgICAgKi9cbiAgICBfZ2V0Rm9sZGVyOiBmdW5jdGlvbiAocGF0aCwgb3B0aW9ucykge1xuICAgICAgLy8gRklYTUUgc2ltcGxpZnkgcHJvbWlzZSBoYW5kbGluZ1xuICAgICAgdmFyIHVybCA9ICdodHRwczovL2FwaS5kcm9wYm94LmNvbS8xL21ldGFkYXRhL2F1dG8nICsgZ2V0RHJvcGJveFBhdGgocGF0aCk7XG4gICAgICB2YXIgcmV2Q2FjaGUgPSB0aGlzLl9yZXZDYWNoZTtcbiAgICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgICAgcmV0dXJuIHRoaXMuX3JlcXVlc3QoJ0dFVCcsIHVybCwge30pLnRoZW4oZnVuY3Rpb24gKHJlc3ApIHtcbiAgICAgICAgdmFyIHN0YXR1cyA9IHJlc3Auc3RhdHVzO1xuICAgICAgICBpZiAoc3RhdHVzID09PSAzMDQpIHtcbiAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHtzdGF0dXNDb2RlOiBzdGF0dXN9KTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbGlzdGluZywgYm9keSwgbWltZSwgcmV2O1xuICAgICAgICB0cnl7XG4gICAgICAgICAgYm9keSA9IEpTT04ucGFyc2UocmVzcC5yZXNwb25zZVRleHQpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGUpO1xuICAgICAgICB9XG4gICAgICAgIHJldiA9IHNlbGYuX3JldkNhY2hlLmdldChwYXRoKTtcbiAgICAgICAgbWltZSA9ICdhcHBsaWNhdGlvbi9qc29uOyBjaGFyc2V0PVVURi04JztcbiAgICAgICAgaWYgKGJvZHkuY29udGVudHMpIHtcbiAgICAgICAgICBsaXN0aW5nID0gYm9keS5jb250ZW50cy5yZWR1Y2UoZnVuY3Rpb24gKG0sIGl0ZW0pIHtcbiAgICAgICAgICAgIHZhciBpdGVtTmFtZSA9IGl0ZW0ucGF0aC5zcGxpdCgnLycpLnNsaWNlKC0xKVswXSArICggaXRlbS5pc19kaXIgPyAnLycgOiAnJyApO1xuICAgICAgICAgICAgaWYgKGl0ZW0uaXNfZGlyKXtcbiAgICAgICAgICAgICAgbVtpdGVtTmFtZV0gPSB7IEVUYWc6IHJldkNhY2hlLmdldChwYXRoK2l0ZW1OYW1lKSB9O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgbVtpdGVtTmFtZV0gPSB7IEVUYWc6IGl0ZW0ucmV2IH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbTtcbiAgICAgICAgICB9LCB7fSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh7c3RhdHVzQ29kZTogc3RhdHVzLCBib2R5OiBsaXN0aW5nLCBjb250ZW50VHlwZTogbWltZSwgcmV2aXNpb246IHJldn0pO1xuICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1ldGhvZDogZ2V0XG4gICAgICpcbiAgICAgKiBDb21wYXRpYmxlIHdpdGggPFJlbW90ZVN0b3JhZ2UuV2lyZUNsaWVudC5nZXQ+XG4gICAgICpcbiAgICAgKiBDaGVja3MgZm9yIHRoZSBwYXRoIGluIF9yZXZDYWNoZSBhbmQgZGVjaWRlcyBiYXNlZCBvbiB0aGF0IGlmIGZpbGUgaGFzXG4gICAgICogY2hhbmdlZC4gQ2FsbHMgX2dldEZvbGRlciBpcyB0aGUgcGF0aCBwb2ludHMgdG8gYSBmb2xkZXIuXG4gICAgICpcbiAgICAgKiBDYWxscyA8UmVtb3RlU3RvcmFnZS5Ecm9wYm94LnNoYXJlPiBhZnRlcndhcmRzIHRvIGZpbGwgX2l0ZW1SZWZzLlxuICAgICAqL1xuICAgIGdldDogZnVuY3Rpb24gKHBhdGgsIG9wdGlvbnMpIHtcbiAgICAgIGlmICghIHRoaXMuY29ubmVjdGVkKSB7IHJldHVybiBQcm9taXNlLnJlamVjdChcIm5vdCBjb25uZWN0ZWQgKHBhdGg6IFwiICsgcGF0aCArIFwiKVwiKTsgfVxuICAgICAgdmFyIHVybCA9ICdodHRwczovL2FwaS1jb250ZW50LmRyb3Bib3guY29tLzEvZmlsZXMvYXV0bycgKyBnZXREcm9wYm94UGF0aChwYXRoKTtcbiAgICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgICAgdmFyIHNhdmVkUmV2ID0gdGhpcy5fcmV2Q2FjaGUuZ2V0KHBhdGgpO1xuICAgICAgaWYgKHNhdmVkUmV2ID09PSBudWxsKSB7XG4gICAgICAgIC8vIGZpbGUgd2FzIGRlbGV0ZWQgc2VydmVyIHNpZGVcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh7c3RhdHVzQ29kZTogNDA0fSk7XG4gICAgICB9XG4gICAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLmlmTm9uZU1hdGNoICYmXG4gICAgICAgICBzYXZlZFJldiAmJiAoc2F2ZWRSZXYgPT09IG9wdGlvbnMuaWZOb25lTWF0Y2gpKSB7XG4gICAgICAgIC8vIG5vdGhpbmcgY2hhbmdlZC5cbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh7c3RhdHVzQ29kZTogMzA0fSk7XG4gICAgICB9XG5cbiAgICAgIC8vdXNlIF9nZXRGb2xkZXIgZm9yIGZvbGRlcnNcbiAgICAgIGlmIChwYXRoLnN1YnN0cigtMSkgPT09ICcvJykgeyByZXR1cm4gdGhpcy5fZ2V0Rm9sZGVyKHBhdGgsIG9wdGlvbnMpOyB9XG5cbiAgICAgIHJldHVybiB0aGlzLl9yZXF1ZXN0KCdHRVQnLCB1cmwsIHt9KS50aGVuKGZ1bmN0aW9uIChyZXNwKSB7XG4gICAgICAgIHZhciBzdGF0dXMgPSByZXNwLnN0YXR1cztcbiAgICAgICAgdmFyIG1ldGEsIGJvZHksIG1pbWUsIHJldjtcbiAgICAgICAgaWYgKHN0YXR1cyAhPT0gMjAwKSB7XG4gICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh7c3RhdHVzQ29kZTogc3RhdHVzfSk7XG4gICAgICAgIH1cblxuICAgICAgICBib2R5ID0gcmVzcC5yZXNwb25zZVRleHQ7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgbWV0YSA9IEpTT04ucGFyc2UoIHJlc3AuZ2V0UmVzcG9uc2VIZWFkZXIoJ3gtZHJvcGJveC1tZXRhZGF0YScpICk7XG4gICAgICAgIH0gY2F0Y2goZSkge1xuICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIG1pbWUgPSBtZXRhLm1pbWVfdHlwZTsgLy9yZXNwLmdldFJlc3BvbnNlSGVhZGVyKCdDb250ZW50LVR5cGUnKTtcbiAgICAgICAgcmV2ID0gbWV0YS5yZXY7XG4gICAgICAgIHNlbGYuX3JldkNhY2hlLnNldChwYXRoLCByZXYpO1xuICAgICAgICBzZWxmLl9zaGFyZUlmTmVlZGVkKHBhdGgpOyAvLyBUaGUgc2hhcmVkIGxpbmsgZXhwaXJlcyBldmVyeSA0IGhvdXJzXG5cbiAgICAgICAgLy8gaGFuZGxpbmcgYmluYXJ5XG4gICAgICAgIGlmICghcmVzcC5nZXRSZXNwb25zZUhlYWRlcignQ29udGVudC1UeXBlJykgfHxcbiAgICAgICAgICAgIHJlc3AuZ2V0UmVzcG9uc2VIZWFkZXIoJ0NvbnRlbnQtVHlwZScpLm1hdGNoKC9jaGFyc2V0PWJpbmFyeS8pKSB7XG4gICAgICAgICAgdmFyIHBlbmRpbmcgPSBQcm9taXNlLmRlZmVyKCk7XG5cbiAgICAgICAgICBXaXJlQ2xpZW50LnJlYWRCaW5hcnlEYXRhKHJlc3AucmVzcG9uc2UsIG1pbWUsIGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICAgICAgICAgIHBlbmRpbmcucmVzb2x2ZSh7XG4gICAgICAgICAgICAgIHN0YXR1c0NvZGU6IHN0YXR1cyxcbiAgICAgICAgICAgICAgYm9keTogcmVzdWx0LFxuICAgICAgICAgICAgICBjb250ZW50VHlwZTogbWltZSxcbiAgICAgICAgICAgICAgcmV2aXNpb246IHJldlxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICByZXR1cm4gcGVuZGluZy5wcm9taXNlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gaGFuZGxpbmcganNvbiAoYWx3YXlzIHRyeSlcbiAgICAgICAgaWYgKG1pbWUgJiYgbWltZS5zZWFyY2goJ2FwcGxpY2F0aW9uL2pzb24nKSA+PSAwIHx8IHRydWUpIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgYm9keSA9IEpTT04ucGFyc2UoYm9keSk7XG4gICAgICAgICAgICBtaW1lID0gJ2FwcGxpY2F0aW9uL2pzb247IGNoYXJzZXQ9VVRGLTgnO1xuICAgICAgICAgIH0gY2F0Y2goZSkge1xuICAgICAgICAgICAgLy9GYWlsZWQgcGFyc2luZyBKc29uLCBhc3N1bWUgaXQgaXMgc29tZXRoaW5nIGVsc2UgdGhlblxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoe3N0YXR1c0NvZGU6IHN0YXR1cywgYm9keTogYm9keSwgY29udGVudFR5cGU6IG1pbWUsIHJldmlzaW9uOiByZXZ9KTtcbiAgICAgIH0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNZXRob2Q6IHB1dFxuICAgICAqXG4gICAgICogQ29tcGF0aWJsZSB3aXRoIDxSZW1vdGVTdG9yYWdlLldpcmVDbGllbnQ+XG4gICAgICpcbiAgICAgKiBDaGVja3MgZm9yIHRoZSBwYXRoIGluIF9yZXZDYWNoZSBhbmQgZGVjaWRlcyBiYXNlZCBvbiB0aGF0IGlmIGZpbGUgaGFzXG4gICAgICogY2hhbmdlZC5cbiAgICAgKlxuICAgICAqIENhbGxzIDxSZW1vdGVTdG9yYWdlLkRyb3Bib3guc2hhcmU+IGFmdGVyd2FyZHMgdG8gZmlsbCBfaXRlbVJlZnMuXG4gICAgICovXG4gICAgcHV0OiBmdW5jdGlvbiAocGF0aCwgYm9keSwgY29udGVudFR5cGUsIG9wdGlvbnMpIHtcbiAgICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgICAgaWYgKCF0aGlzLmNvbm5lY3RlZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJub3QgY29ubmVjdGVkIChwYXRoOiBcIiArIHBhdGggKyBcIilcIik7XG4gICAgICB9XG5cbiAgICAgIC8vY2hlY2sgaWYgZmlsZSBoYXMgY2hhbmdlZCBhbmQgcmV0dXJuIDQxMlxuICAgICAgdmFyIHNhdmVkUmV2ID0gdGhpcy5fcmV2Q2FjaGUuZ2V0KHBhdGgpO1xuICAgICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5pZk1hdGNoICYmXG4gICAgICAgICAgc2F2ZWRSZXYgJiYgKHNhdmVkUmV2ICE9PSBvcHRpb25zLmlmTWF0Y2gpKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoe3N0YXR1c0NvZGU6IDQxMiwgcmV2aXNpb246IHNhdmVkUmV2fSk7XG4gICAgICB9XG4gICAgICBpZiAob3B0aW9ucyAmJiAob3B0aW9ucy5pZk5vbmVNYXRjaCA9PT0gJyonKSAmJlxuICAgICAgICAgIHNhdmVkUmV2ICYmIChzYXZlZFJldiAhPT0gJ3JldicpKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoe3N0YXR1c0NvZGU6IDQxMiwgcmV2aXNpb246IHNhdmVkUmV2fSk7XG4gICAgICB9XG5cbiAgICAgIGlmICgoIWNvbnRlbnRUeXBlLm1hdGNoKC9jaGFyc2V0PS8pKSAmJlxuICAgICAgICAgIChib2R5IGluc3RhbmNlb2YgQXJyYXlCdWZmZXIgfHwgV2lyZUNsaWVudC5pc0FycmF5QnVmZmVyVmlldyhib2R5KSkpIHtcbiAgICAgICAgY29udGVudFR5cGUgKz0gJzsgY2hhcnNldD1iaW5hcnknO1xuICAgICAgfVxuXG4gICAgICBpZiAoYm9keS5sZW5ndGggPiAxNTAgKiAxMDI0ICogMTAyNCkge1xuICAgICAgICAvL2h0dHBzOi8vd3d3LmRyb3Bib3guY29tL2RldmVsb3BlcnMvY29yZS9kb2NzI2NodW5rZWQtdXBsb2FkXG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoXCJDYW5ub3QgdXBsb2FkIGZpbGUgbGFyZ2VyIHRoYW4gMTUwTUJcIikpO1xuICAgICAgfVxuXG4gICAgICB2YXIgcmVzdWx0O1xuICAgICAgdmFyIG5lZWRzTWV0YWRhdGEgPSBvcHRpb25zICYmIChvcHRpb25zLmlmTWF0Y2ggfHwgKG9wdGlvbnMuaWZOb25lTWF0Y2ggPT09ICcqJykpO1xuICAgICAgdmFyIHVwbG9hZFBhcmFtcyA9IHtcbiAgICAgICAgYm9keTogYm9keSxcbiAgICAgICAgY29udGVudFR5cGU6IGNvbnRlbnRUeXBlLFxuICAgICAgICBwYXRoOiBwYXRoXG4gICAgICB9O1xuXG4gICAgICBpZiAobmVlZHNNZXRhZGF0YSkge1xuICAgICAgICByZXN1bHQgPSB0aGlzLl9nZXRNZXRhZGF0YShwYXRoKS50aGVuKGZ1bmN0aW9uIChtZXRhZGF0YSkge1xuICAgICAgICAgIGlmIChvcHRpb25zICYmIChvcHRpb25zLmlmTm9uZU1hdGNoID09PSAnKicpICYmIG1ldGFkYXRhKSB7XG4gICAgICAgICAgICAvLyBpZiAhIW1ldGFkYXRhID09PSB0cnVlLCB0aGUgZmlsZSBleGlzdHNcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoe1xuICAgICAgICAgICAgICBzdGF0dXNDb2RlOiA0MTIsXG4gICAgICAgICAgICAgIHJldmlzaW9uOiBtZXRhZGF0YS5yZXZcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMuaWZNYXRjaCAmJiBtZXRhZGF0YSAmJiAobWV0YWRhdGEucmV2ICE9PSBvcHRpb25zLmlmTWF0Y2gpKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHtcbiAgICAgICAgICAgICAgc3RhdHVzQ29kZTogNDEyLFxuICAgICAgICAgICAgICByZXZpc2lvbjogbWV0YWRhdGEucmV2XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gc2VsZi5fdXBsb2FkU2ltcGxlKHVwbG9hZFBhcmFtcyk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzdWx0ID0gc2VsZi5fdXBsb2FkU2ltcGxlKHVwbG9hZFBhcmFtcyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXN1bHQudGhlbihmdW5jdGlvbiAocmV0KSB7XG4gICAgICAgIHNlbGYuX3NoYXJlSWZOZWVkZWQocGF0aCk7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgICB9KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTWV0aG9kOiBkZWxldGVcbiAgICAgKlxuICAgICAqIENvbXBhdGlibGUgd2l0aCA8UmVtb3RlU3RvcmFnZS5XaXJlQ2xpZW50LmRlbGV0ZT5cbiAgICAgKlxuICAgICAqIENoZWNrcyBmb3IgdGhlIHBhdGggaW4gX3JldkNhY2hlIGFuZCBkZWNpZGVzIGJhc2VkIG9uIHRoYXQgaWYgZmlsZSBoYXNcbiAgICAgKiBjaGFuZ2VkLlxuICAgICAqXG4gICAgICogQ2FsbHMgPFJlbW90ZVN0b3JhZ2UuRHJvcGJveC5zaGFyZT4gYWZ0ZXJ3YXJkcyB0byBmaWxsIF9pdGVtUmVmcy5cbiAgICAgKi9cbiAgICAnZGVsZXRlJzogZnVuY3Rpb24gKHBhdGgsIG9wdGlvbnMpIHtcbiAgICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgICAgaWYgKCF0aGlzLmNvbm5lY3RlZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJub3QgY29ubmVjdGVkIChwYXRoOiBcIiArIHBhdGggKyBcIilcIik7XG4gICAgICB9XG5cbiAgICAgIC8vY2hlY2sgaWYgZmlsZSBoYXMgY2hhbmdlZCBhbmQgcmV0dXJuIDQxMlxuICAgICAgdmFyIHNhdmVkUmV2ID0gdGhpcy5fcmV2Q2FjaGUuZ2V0KHBhdGgpO1xuICAgICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5pZk1hdGNoICYmIHNhdmVkUmV2ICYmIChvcHRpb25zLmlmTWF0Y2ggIT09IHNhdmVkUmV2KSkge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHsgc3RhdHVzQ29kZTogNDEyLCByZXZpc2lvbjogc2F2ZWRSZXYgfSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMuaWZNYXRjaCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZ2V0TWV0YWRhdGEocGF0aCkudGhlbihmdW5jdGlvbiAobWV0YWRhdGEpIHtcbiAgICAgICAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLmlmTWF0Y2ggJiYgbWV0YWRhdGEgJiYgKG1ldGFkYXRhLnJldiAhPT0gb3B0aW9ucy5pZk1hdGNoKSkge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh7XG4gICAgICAgICAgICAgIHN0YXR1c0NvZGU6IDQxMixcbiAgICAgICAgICAgICAgcmV2aXNpb246IG1ldGFkYXRhLnJldlxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHNlbGYuX2RlbGV0ZVNpbXBsZShwYXRoKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzZWxmLl9kZWxldGVTaW1wbGUocGF0aCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1ldGhvZDogX3NoYXJlSWZOZWVkZWRcbiAgICAgKlxuICAgICAqIENhbGxzIHNoYXJlLCBpZiB0aGUgcHJvdmlkZWQgcGF0aCByZXNpZGVzIGluIGEgcHVibGljIGZvbGRlci5cbiAgICAgKi9cbiAgICBfc2hhcmVJZk5lZWRlZDogZnVuY3Rpb24gKHBhdGgpIHtcbiAgICAgIGlmIChwYXRoLm1hdGNoKC9eXFwvcHVibGljXFwvLipbXlxcL10kLykgJiYgdGhpcy5faXRlbVJlZnNbcGF0aF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLnNoYXJlKHBhdGgpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNZXRob2Q6IHNoYXJlXG4gICAgICpcbiAgICAgKiBHZXRzIGEgcHVibGljbHktYWNjZXNzaWJsZSBVUkwgZm9yIHRoZSBwYXRoIGZyb20gRHJvcGJveCBhbmQgc3RvcmVzIGl0XG4gICAgICogaW4gX2l0ZW1SZWZzLlxuICAgICAqXG4gICAgICogUmV0dXJuczpcbiAgICAgKlxuICAgICAqICAgQSBwcm9taXNlIGZvciB0aGUgVVJMXG4gICAgICovXG4gICAgc2hhcmU6IGZ1bmN0aW9uIChwYXRoKSB7XG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICB2YXIgdXJsID0gJ2h0dHBzOi8vYXBpLmRyb3Bib3guY29tLzEvbWVkaWEvYXV0bycgKyBnZXREcm9wYm94UGF0aChwYXRoKTtcblxuICAgICAgcmV0dXJuIHRoaXMuX3JlcXVlc3QoJ1BPU1QnLCB1cmwsIHt9KS50aGVuKGZ1bmN0aW9uIChyZXNwb25zZSkge1xuICAgICAgICBpZiAocmVzcG9uc2Uuc3RhdHVzICE9PSAyMDApIHtcbiAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKCdJbnZhbGlkIERyb3Bib3ggQVBJIHJlc3BvbnNlIHN0YXR1cyB3aGVuIHNoYXJpbmcgXCInICsgcGF0aCArICdcIjonICsgcmVzcG9uc2Uuc3RhdHVzKSk7XG4gICAgICAgIH1cblxuICAgICAgICB0cnkge1xuICAgICAgICAgIHJlc3BvbnNlID0gSlNPTi5wYXJzZShyZXNwb25zZS5yZXNwb25zZVRleHQpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcignSW52YWxpZCBEcm9wYm94IEFQSSByZXNwb25zZSB3aGVuIHNoYXJpbmcgXCInICsgcGF0aCArICdcIjogJyArIHJlc3BvbnNlLnJlc3BvbnNlVGV4dCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgc2VsZi5faXRlbVJlZnNbcGF0aF0gPSByZXNwb25zZS51cmw7XG5cbiAgICAgICAgaWYgKGhhc0xvY2FsU3RvcmFnZSkge1xuICAgICAgICAgIGxvY2FsU3RvcmFnZVtTRVRUSU5HU19LRVkgKyAnOnNoYXJlcyddID0gSlNPTi5zdHJpbmdpZnkoc2VsZi5faXRlbVJlZnMpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh1cmwpO1xuICAgICAgfSwgZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgIGVyci5tZXNzYWdlID0gJ1NoYXJpbmcgZHJvcGJveCBmaWxlIG9yIGZvbGRlciAoXCInICsgcGF0aCArICdcIikgZmFpbGVkLicgKyBlcnIubWVzc2FnZTtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGVycm9yKTtcbiAgICAgIH0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNZXRob2Q6IGluZm9cbiAgICAgKlxuICAgICAqIEZldGNoZXMgdGhlIHVzZXIncyBpbmZvIGZyb20gZHJvcGJveCBhbmQgcmV0dXJucyBhIHByb21pc2UgZm9yIGl0LlxuICAgICAqXG4gICAgICogUmV0dXJuczpcbiAgICAgKlxuICAgICAqICAgQSBwcm9taXNlIHRvIHRoZSB1c2VyJ3MgaW5mb1xuICAgICAqL1xuICAgIGluZm86IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciB1cmwgPSAnaHR0cHM6Ly9hcGkuZHJvcGJveC5jb20vMS9hY2NvdW50L2luZm8nO1xuICAgICAgLy8gcmVxdWVzdGluZyB1c2VyIGluZm8obWFpbmx5IGZvciB1c2VyQWRyZXNzKVxuICAgICAgcmV0dXJuIHRoaXMuX3JlcXVlc3QoJ0dFVCcsIHVybCwge30pLnRoZW4oZnVuY3Rpb24gKHJlc3Ape1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHZhciBpbmZvID0gSlNPTi5wYXJzZShyZXNwLnJlc3BvbnNlVGV4dCk7XG4gICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShpbmZvKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1ldGhvZDogX3JlcXVlc3RcbiAgICAgKlxuICAgICAqIE1ha2UgYSBIVFRQIHJlcXVlc3QuXG4gICAgICpcbiAgICAgKiBPcHRpb25zOlxuICAgICAqXG4gICAgICogICBoZWFkZXJzIC0gYW4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIHJlcXVlc3QgaGVhZGVyc1xuICAgICAqXG4gICAgICogUGFyYW1ldGVyczpcbiAgICAgKlxuICAgICAqICAgbWV0aG9kIC0gdGhlIG1ldGhvZCB0byB1c2VcbiAgICAgKiAgIHVybCAtIHRoZSBVUkwgdG8gbWFrZSB0aGUgcmVxdWVzdCB0b1xuICAgICAqICAgb3B0aW9ucyAtIHNlZSBhYm92ZVxuICAgICAqL1xuICAgIF9yZXF1ZXN0OiBmdW5jdGlvbiAobWV0aG9kLCB1cmwsIG9wdGlvbnMpIHtcbiAgICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgICAgaWYgKCEgb3B0aW9ucy5oZWFkZXJzKSB7IG9wdGlvbnMuaGVhZGVycyA9IHt9OyB9XG4gICAgICBvcHRpb25zLmhlYWRlcnNbJ0F1dGhvcml6YXRpb24nXSA9ICdCZWFyZXIgJyArIHRoaXMudG9rZW47XG5cbiAgICAgIHRoaXMuX2VtaXQoJ3dpcmUtYnVzeScsIHtcbiAgICAgICAgbWV0aG9kOiBtZXRob2QsXG4gICAgICAgIGlzRm9sZGVyOiBpc0ZvbGRlcih1cmwpXG4gICAgICB9KTtcblxuICAgICAgcmV0dXJuIFdpcmVDbGllbnQucmVxdWVzdC5jYWxsKHRoaXMsIG1ldGhvZCwgdXJsLCBvcHRpb25zKS50aGVuKGZ1bmN0aW9uKHhocikge1xuICAgICAgICAvLyA1MDMgbWVhbnMgcmV0cnkgdGhpcyBsYXRlclxuICAgICAgICBpZiAoeGhyICYmIHhoci5zdGF0dXMgPT09IDUwMykge1xuICAgICAgICAgIGlmIChzZWxmLm9ubGluZSkge1xuICAgICAgICAgICAgc2VsZi5vbmxpbmUgPSBmYWxzZTtcbiAgICAgICAgICAgIHNlbGYucnMuX2VtaXQoJ25ldHdvcmstb2ZmbGluZScpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gc2V0VGltZW91dChzZWxmLl9yZXF1ZXN0KG1ldGhvZCwgdXJsLCBvcHRpb25zKSwgMzIxMCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKCFzZWxmLm9ubGluZSkge1xuICAgICAgICAgICAgc2VsZi5vbmxpbmUgPSB0cnVlO1xuICAgICAgICAgICAgc2VsZi5ycy5fZW1pdCgnbmV0d29yay1vbmxpbmUnKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgc2VsZi5fZW1pdCgnd2lyZS1kb25lJywge1xuICAgICAgICAgICAgbWV0aG9kOiBtZXRob2QsXG4gICAgICAgICAgICBpc0ZvbGRlcjogaXNGb2xkZXIodXJsKSxcbiAgICAgICAgICAgIHN1Y2Nlc3M6IHRydWVcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoeGhyKTtcbiAgICAgICAgfVxuICAgICAgfSwgZnVuY3Rpb24oZXJyb3IpIHtcbiAgICAgICAgaWYgKHNlbGYub25saW5lKSB7XG4gICAgICAgICAgc2VsZi5vbmxpbmUgPSBmYWxzZTtcbiAgICAgICAgICBzZWxmLnJzLl9lbWl0KCduZXR3b3JrLW9mZmxpbmUnKTtcbiAgICAgICAgfVxuICAgICAgICBzZWxmLl9lbWl0KCd3aXJlLWRvbmUnLCB7XG4gICAgICAgICAgbWV0aG9kOiBtZXRob2QsXG4gICAgICAgICAgaXNGb2xkZXI6IGlzRm9sZGVyKHVybCksXG4gICAgICAgICAgc3VjY2VzczogZmFsc2VcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGVycm9yKTtcbiAgICAgIH0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNZXRob2Q6IGZldGNoRGVsdGFcbiAgICAgKlxuICAgICAqIEZldGNoZXMgdGhlIHJldmlzaW9uIG9mIGFsbCB0aGUgZmlsZXMgZnJvbSBkcm9wYm94IEFQSSBhbmQgcHV0cyB0aGVtXG4gICAgICogaW50byBfcmV2Q2FjaGUuIFRoZXNlIHZhbHVlcyBjYW4gdGhlbiBiZSB1c2VkIHRvIGRldGVybWluZSBpZiBzb21ldGhpbmdcbiAgICAgKiBoYXMgY2hhbmdlZC5cbiAgICAgKi9cbiAgICBmZXRjaERlbHRhOiBmdW5jdGlvbiAoKSB7XG4gICAgICAvLyBUT0RPOiBIYW5kbGUgYGhhc19tb3JlYFxuXG4gICAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICB2YXIgYm9keSA9IHsgcGF0aF9wcmVmaXg6IFBBVEhfUFJFRklYIH07XG5cbiAgICAgIGlmIChzZWxmLl9kZWx0YUN1cnNvcikge1xuICAgICAgICBib2R5LmN1cnNvciA9IHNlbGYuX2RlbHRhQ3Vyc29yO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc2VsZi5fcmVxdWVzdCgnUE9TVCcsICdodHRwczovL2FwaS5kcm9wYm94LmNvbS8xL2RlbHRhJywge1xuICAgICAgICBib2R5OiBlbmNvZGVRdWVyeShib2R5KSxcbiAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkJ1xuICAgICAgICB9XG4gICAgICB9KS50aGVuKGZ1bmN0aW9uIChyZXNwb25zZSkge1xuICAgICAgICAvLyBicmVhayBpZiBzdGF0dXMgIT0gMjAwXG4gICAgICAgIGlmIChyZXNwb25zZS5zdGF0dXMgIT09IDIwMCApIHtcbiAgICAgICAgICBpZiAocmVzcG9uc2Uuc3RhdHVzID09PSA0MDApIHtcbiAgICAgICAgICAgIHNlbGYucnMuX2VtaXQoJ2Vycm9yJywgbmV3IEF1dGhvcml6ZS5VbmF1dGhvcml6ZWQoKSk7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGFyZ3MpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoXCJkcm9wYm94LmZldGNoRGVsdGEgcmV0dXJuZWQgXCIrcmVzcG9uc2Uuc3RhdHVzK3Jlc3BvbnNlLnJlc3BvbnNlVGV4dCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBkZWx0YTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBkZWx0YSA9IEpTT04ucGFyc2UocmVzcG9uc2UucmVzcG9uc2VUZXh0KTtcbiAgICAgICAgfSBjYXRjaChlcnJvcikge1xuICAgICAgICAgIGxvZygnZmV0Y2hEZWx0YXMgY2FuIG5vdCBwYXJzZSByZXNwb25zZScsZXJyb3IpO1xuICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChcImNhbiBub3QgcGFyc2UgcmVzcG9uc2Ugb2YgZmV0Y2hEZWx0YSA6IFwiK2Vycm9yLm1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGJyZWFrIGlmIG5vIGVudHJpZXMgZm91bmRcbiAgICAgICAgaWYgKCFkZWx0YS5lbnRyaWVzKSB7XG4gICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KCdkcm9wYm94LmZldGNoRGVsdGFzIGZhaWxlZCwgbm8gZW50cmllcyBmb3VuZCcpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRHJvcGJveCBzZW5kcyB0aGUgY29tcGxldGUgc3RhdGVcbiAgICAgICAgaWYgKGRlbHRhLnJlc2V0KSB7XG4gICAgICAgICAgc2VsZi5fcmV2Q2FjaGUgPSBuZXcgTG93ZXJDYXNlQ2FjaGUoJ3JldicpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy9zYXZpbmcgdGhlIGN1cnNvciBmb3IgcmVxdWVzdGluZyBmdXJ0aGVyIGRlbHRhcyBpbiByZWxhdGlvbiB0byB0aGUgY3Vyc29yIHBvc2l0aW9uXG4gICAgICAgIGlmIChkZWx0YS5jdXJzb3IpIHtcbiAgICAgICAgICBzZWxmLl9kZWx0YUN1cnNvciA9IGRlbHRhLmN1cnNvcjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vdXBkYXRpbmcgcmV2Q2FjaGVcbiAgICAgICAgZGVsdGEuZW50cmllcy5mb3JFYWNoKGZ1bmN0aW9uIChlbnRyeSkge1xuICAgICAgICAgIHZhciBwYXRoID0gZW50cnlbMF0uc3Vic3RyKFBBVEhfUFJFRklYLmxlbmd0aCk7XG4gICAgICAgICAgdmFyIHJldjtcbiAgICAgICAgICBpZiAoIWVudHJ5WzFdKXtcbiAgICAgICAgICAgIHJldiA9IG51bGw7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChlbnRyeVsxXS5pc19kaXIpIHtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV2ID0gZW50cnlbMV0ucmV2O1xuICAgICAgICAgIH1cbiAgICAgICAgICBzZWxmLl9yZXZDYWNoZS5zZXQocGF0aCwgcmV2KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoYXJncyk7XG4gICAgICB9LCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgIHRoaXMucnMubG9nKCdmZXRjaERlbHRhcycsIGVycik7XG4gICAgICAgIHRoaXMucnMuX2VtaXQoJ2Vycm9yJywgbmV3IFN5bmMuU3luY0Vycm9yKCdmZXRjaERlbHRhcyBmYWlsZWQuJyArIGVycikpO1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGFyZ3MpO1xuICAgICAgfS5iaW5kKHRoaXMpKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHNlbGYuX3JldkNhY2hlKSB7XG4gICAgICAgICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuICAgICAgICAgIHNlbGYuX3JldkNhY2hlLl9hY3RpdmF0ZVByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShhcmdzKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1ldGhvZDogX2dldE1ldGFkYXRhXG4gICAgICpcbiAgICAgKiBHZXRzIG1ldGFkYXRhIGZvciBhIHBhdGggKGNhbiBwb2ludCB0byBlaXRoZXIgYSBmaWxlIG9yIGEgZm9sZGVyKS5cbiAgICAgKlxuICAgICAqIE9wdGlvbnM6XG4gICAgICpcbiAgICAgKiAgIGxpc3QgLSBpZiBwYXRoIHBvaW50cyB0byBhIGZvbGRlciwgc3BlY2lmaWVzIHdoZXRoZXIgdG8gbGlzdCB0aGVcbiAgICAgKiAgICAgICAgICBtZXRhZGF0YSBvZiB0aGUgZm9sZGVyJ3MgY2hpbGRyZW4uIEZhbHNlIGJ5IGRlZmF1bHQuXG4gICAgICpcbiAgICAgKiBQYXJhbWV0ZXJzOlxuICAgICAqXG4gICAgICogICBwYXRoIC0gdGhlIHBhdGggdG8gZ2V0IG1ldGFkYXRhIGZvclxuICAgICAqICAgb3B0aW9ucyAtIHNlZSBhYm92ZVxuICAgICAqXG4gICAgICogUmV0dXJuczpcbiAgICAgKlxuICAgICAqICAgQSBwcm9taXNlIGZvciB0aGUgbWV0YWRhdGFcbiAgICAgKi9cbiAgICBfZ2V0TWV0YWRhdGE6IGZ1bmN0aW9uIChwYXRoLCBvcHRpb25zKSB7XG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICB2YXIgY2FjaGVkID0gdGhpcy5fbWV0YWRhdGFDYWNoZVtwYXRoXTtcbiAgICAgIHZhciB1cmwgPSAnaHR0cHM6Ly9hcGkuZHJvcGJveC5jb20vMS9tZXRhZGF0YS9hdXRvJyArIGdldERyb3Bib3hQYXRoKHBhdGgpO1xuICAgICAgdXJsICs9ICc/bGlzdD0nICsgKChvcHRpb25zICYmIG9wdGlvbnMubGlzdCkgPyAndHJ1ZScgOiAnZmFsc2UnKTtcbiAgICAgIGlmIChjYWNoZWQgJiYgY2FjaGVkLmhhc2gpIHtcbiAgICAgICAgdXJsICs9ICcmaGFzaD0nICsgZW5jb2RlVVJJQ29tcG9uZW50KGNhY2hlZC5oYXNoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLl9yZXF1ZXN0KCdHRVQnLCB1cmwsIHt9KS50aGVuKGZ1bmN0aW9uIChyZXNwKSB7XG4gICAgICAgIGlmIChyZXNwLnN0YXR1cyA9PT0gMzA0KSB7XG4gICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShjYWNoZWQpO1xuICAgICAgICB9IGVsc2UgaWYgKHJlc3Auc3RhdHVzID09PSAyMDApIHtcbiAgICAgICAgICB2YXIgcmVzcG9uc2UgPSBKU09OLnBhcnNlKHJlc3AucmVzcG9uc2VUZXh0KTtcbiAgICAgICAgICBzZWxmLl9tZXRhZGF0YUNhY2hlW3BhdGhdID0gcmVzcG9uc2U7XG4gICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShyZXNwb25zZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gVGhlIGZpbGUgZG9lc24ndCBleGlzdFxuICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1ldGhvZDogX3VwbG9hZFNpbXBsZVxuICAgICAqXG4gICAgICogVXBsb2FkIGEgc2ltcGxlIGZpbGUgKHRoZSBzaXplIGlzIG5vIG1vcmUgdGhhbiAxNTBNQikuXG4gICAgICpcbiAgICAgKiBQYXJhbWV0ZXJzOlxuICAgICAqXG4gICAgICogICBpZk1hdGNoIC0gc2FtZSBhcyBmb3IgZ2V0XG4gICAgICogICBwYXRoIC0gcGF0aCBvZiB0aGUgZmlsZVxuICAgICAqICAgYm9keSAtIGNvbnRlbnRzIG9mIHRoZSBmaWxlIHRvIHVwbG9hZFxuICAgICAqICAgY29udGVudFR5cGUgLSBtaW1lIHR5cGUgb2YgdGhlIGZpbGVcbiAgICAgKlxuICAgICAqIFJldHVybnM6XG4gICAgICpcbiAgICAgKiAgIHN0YXR1c0NvZGUgLSBIVFRQIHN0YXR1cyBjb2RlXG4gICAgICogICByZXZpc2lvbiAtIHJldmlzaW9uIG9mIHRoZSBuZXdseS1jcmVhdGVkIGZpbGUsIGlmIGFueVxuICAgICAqL1xuICAgIF91cGxvYWRTaW1wbGU6IGZ1bmN0aW9uIChwYXJhbXMpIHtcbiAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgIHZhciB1cmwgPSAnaHR0cHM6Ly9hcGktY29udGVudC5kcm9wYm94LmNvbS8xL2ZpbGVzX3B1dC9hdXRvJyArIGdldERyb3Bib3hQYXRoKHBhcmFtcy5wYXRoKSArICc/JztcblxuICAgICAgaWYgKHBhcmFtcyAmJiBwYXJhbXMuaWZNYXRjaCkge1xuICAgICAgICB1cmwgKz0gXCJwYXJlbnRfcmV2PVwiICsgZW5jb2RlVVJJQ29tcG9uZW50KHBhcmFtcy5pZk1hdGNoKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNlbGYuX3JlcXVlc3QoJ1BVVCcsIHVybCwge1xuICAgICAgICBib2R5OiBwYXJhbXMuYm9keSxcbiAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICdDb250ZW50LVR5cGUnOiBwYXJhbXMuY29udGVudFR5cGVcbiAgICAgICAgfVxuICAgICAgfSkudGhlbihmdW5jdGlvbiAocmVzcCkge1xuICAgICAgICBpZiAocmVzcC5zdGF0dXMgIT09IDIwMCkge1xuICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoeyBzdGF0dXNDb2RlOiByZXNwLnN0YXR1cyB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciByZXNwb25zZTtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgIHJlc3BvbnNlID0gSlNPTi5wYXJzZShyZXNwLnJlc3BvbnNlVGV4dCk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDb25mbGljdCBoYXBwZW5lZC4gRGVsZXRlIHRoZSBjb3B5IGNyZWF0ZWQgYnkgZHJvcGJveFxuICAgICAgICBpZiAocmVzcG9uc2UucGF0aCAhPT0gZ2V0RHJvcGJveFBhdGgocGFyYW1zLnBhdGgpKSB7XG4gICAgICAgICAgdmFyIGRlbGV0ZVVybCA9ICdodHRwczovL2FwaS5kcm9wYm94LmNvbS8xL2ZpbGVvcHMvZGVsZXRlP3Jvb3Q9YXV0byZwYXRoPScgKyBlbmNvZGVVUklDb21wb25lbnQocmVzcG9uc2UucGF0aCk7XG4gICAgICAgICAgc2VsZi5fcmVxdWVzdCgnUE9TVCcsIGRlbGV0ZVVybCwge30pO1xuXG4gICAgICAgICAgcmV0dXJuIHNlbGYuX2dldE1ldGFkYXRhKHBhcmFtcy5wYXRoKS50aGVuKGZ1bmN0aW9uIChtZXRhZGF0YSkge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh7XG4gICAgICAgICAgICAgIHN0YXR1c0NvZGU6IDQxMixcbiAgICAgICAgICAgICAgcmV2aXNpb246IG1ldGFkYXRhLnJldlxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBzZWxmLl9yZXZDYWNoZS5wcm9wYWdhdGVTZXQocGFyYW1zLnBhdGgsIHJlc3BvbnNlLnJldik7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoeyBzdGF0dXNDb2RlOiByZXNwLnN0YXR1cyB9KTtcbiAgICAgIH0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNZXRob2Q6IF9kZWxldGVTaW1wbGVcbiAgICAgKlxuICAgICAqIERlbGV0ZXMgYSBmaWxlIG9yIGEgZm9sZGVyLiBJZiB0aGUgZm9sZGVyIGNvbnRhaW5zIG1vcmUgdGhhbiAxMCcwMDAgaXRlbXNcbiAgICAgKiAocmVjdXJzaXZlbHkpIHRoZW4gdGhlIG9wZXJhdGlvbiBtYXkgbm90IGNvbXBsZXRlIHN1Y2Nlc3NmdWxseS4gSWYgdGhhdFxuICAgICAqIGlzIHRoZSBjYXNlLCBhbiBFcnJvciBnZXRzIHRocm93bi5cbiAgICAgKlxuICAgICAqIFBhcmFtZXRlcnM6XG4gICAgICpcbiAgICAgKiAgIHBhdGggLSB0aGUgcGF0aCB0byBkZWxldGVcbiAgICAgKlxuICAgICAqIFJldHVybnM6XG4gICAgICpcbiAgICAgKiAgIHN0YXR1c0NvZGUgLSBIVFRQIHN0YXR1cyBjb2RlXG4gICAgICovXG4gICAgX2RlbGV0ZVNpbXBsZTogZnVuY3Rpb24gKHBhdGgpIHtcbiAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgIHZhciB1cmwgPSAnaHR0cHM6Ly9hcGkuZHJvcGJveC5jb20vMS9maWxlb3BzL2RlbGV0ZT9yb290PWF1dG8mcGF0aD0nICsgZW5jb2RlVVJJQ29tcG9uZW50KGdldERyb3Bib3hQYXRoKHBhdGgpKTtcblxuICAgICAgcmV0dXJuIHNlbGYuX3JlcXVlc3QoJ1BPU1QnLCB1cmwsIHt9KS50aGVuKGZ1bmN0aW9uIChyZXNwKSB7XG4gICAgICAgIGlmIChyZXNwLnN0YXR1cyA9PT0gNDA2KSB7XG4gICAgICAgICAgLy8gVG9vIG1hbnkgZmlsZXMgd291bGQgYmUgaW52b2x2ZWQgaW4gdGhlIG9wZXJhdGlvbiBmb3IgaXQgdG9cbiAgICAgICAgICAvLyBjb21wbGV0ZSBzdWNjZXNzZnVsbHkuXG4gICAgICAgICAgLy8gVE9ETzogSGFuZGxlIHRoaXMgc29tZWhvd1xuICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoXCJDYW5ub3QgZGVsZXRlICdcIiArIHBhdGggKyBcIic6IHRvbyBtYW55IGZpbGVzIGludm9sdmVkXCIpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChyZXNwLnN0YXR1cyA9PT0gMjAwIHx8IHJlc3Auc3RhdHVzID09PSA0MDQpIHtcbiAgICAgICAgICBzZWxmLl9yZXZDYWNoZS5kZWxldGUocGF0aCk7XG4gICAgICAgICAgZGVsZXRlIHNlbGYuX2l0ZW1SZWZzW3BhdGhdO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh7IHN0YXR1c0NvZGU6IHJlc3Auc3RhdHVzIH0pO1xuICAgICAgfSk7XG4gICAgfVxuICB9O1xuXG4gIC8vIEhvb2tpbmcgYW5kIHVuaG9va2luZyB0aGUgc3luY1xuXG4gIGZ1bmN0aW9uIGhvb2tTeW5jKHJzKSB7XG4gICAgaWYgKHJzLl9kcm9wYm94T3JpZ1N5bmMpIHsgcmV0dXJuOyB9IC8vIGFscmVhZHkgaG9va2VkXG4gICAgcnMuX2Ryb3Bib3hPcmlnU3luYyA9IHJzLnN5bmMuc3luYy5iaW5kKHJzLnN5bmMpO1xuICAgIHJzLnN5bmMuc3luYyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLmRyb3Bib3guZmV0Y2hEZWx0YS5hcHBseSh0aGlzLmRyb3Bib3gsIGFyZ3VtZW50cykuXG4gICAgICAgIHRoZW4ocnMuX2Ryb3Bib3hPcmlnU3luYywgZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgIHJzLl9lbWl0KCdlcnJvcicsIG5ldyBTeW5jLlN5bmNFcnJvcihlcnIpKTtcbiAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZXJyKTtcbiAgICAgICAgfSk7XG4gICAgfS5iaW5kKHJzKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHVuSG9va1N5bmMocnMpIHtcbiAgICBpZiAoISBycy5fZHJvcGJveE9yaWdTeW5jKSB7IHJldHVybjsgfSAvLyBub3QgaG9va2VkXG4gICAgcnMuc3luYy5zeW5jID0gcnMuX2Ryb3Bib3hPcmlnU3luYztcbiAgICBkZWxldGUgcnMuX2Ryb3Bib3hPcmlnU3luYztcbiAgfVxuXG4gIC8vIEhvb2tpbmcgYW5kIHVuaG9va2luZyBnZXRJdGVtVVJMXG5cbiAgZnVuY3Rpb24gaG9va0dldEl0ZW1VUkwocnMpIHtcbiAgICBpZiAocnMuX29yaWdCYXNlQ2xpZW50R2V0SXRlbVVSTCkgeyByZXR1cm47IH1cbiAgICBycy5fb3JpZ0Jhc2VDbGllbnRHZXRJdGVtVVJMID0gQmFzZUNsaWVudC5wcm90b3R5cGUuZ2V0SXRlbVVSTDtcbiAgICBCYXNlQ2xpZW50LnByb3RvdHlwZS5nZXRJdGVtVVJMID0gZnVuY3Rpb24gKHBhdGgpe1xuICAgICAgdmFyIHJldCA9IHJzLmRyb3Bib3guX2l0ZW1SZWZzW3BhdGhdO1xuICAgICAgcmV0dXJuICByZXQgPyByZXQgOiAnJztcbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gdW5Ib29rR2V0SXRlbVVSTChycyl7XG4gICAgaWYgKCEgcnMuX29yaWdCYXNlQ2xpZW50R2V0SXRlbVVSTCkgeyByZXR1cm47IH1cbiAgICBCYXNlQ2xpZW50LnByb3RvdHlwZS5nZXRJdGVtVVJMID0gcnMuX29yaWdCYXNlQ2xpZW50R2V0SXRlbVVSTDtcbiAgICBkZWxldGUgcnMuX29yaWdCYXNlQ2xpZW50R2V0SXRlbVVSTDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGhvb2tSZW1vdGUocnMpe1xuICAgIGlmIChycy5fb3JpZ1JlbW90ZSkgeyByZXR1cm47IH1cbiAgICBycy5fb3JpZ1JlbW90ZSA9IHJzLnJlbW90ZTtcbiAgICBycy5yZW1vdGUgPSBycy5kcm9wYm94O1xuICB9XG5cbiAgZnVuY3Rpb24gdW5Ib29rUmVtb3RlKHJzKXtcbiAgICBpZiAocnMuX29yaWdSZW1vdGUpIHtcbiAgICAgIHJzLnJlbW90ZSA9IHJzLl9vcmlnUmVtb3RlO1xuICAgICAgZGVsZXRlIHJzLl9vcmlnUmVtb3RlO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGhvb2tJdChycyl7XG4gICAgaG9va1JlbW90ZShycyk7XG4gICAgaWYgKHJzLnN5bmMpIHtcbiAgICAgIGhvb2tTeW5jKHJzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gd2hlbiBzeW5jIGlzIG5vdCBhdmFpbGFibGUgeWV0LCB3ZSB3YWl0IGZvciB0aGUgcmVtb3RlIHRvIGJlIGNvbm5lY3RlZCxcbiAgICAgIC8vIGF0IHdoaWNoIHBvaW50IHN5bmMgc2hvdWxkIGJlIGF2YWlsYWJsZSBhcyB3ZWxsXG4gICAgICBycy5vbignY29ubmVjdGVkJywgZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmIChycy5zeW5jKSB7XG4gICAgICAgICAgaG9va1N5bmMocnMpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gICAgaG9va0dldEl0ZW1VUkwocnMpO1xuICB9XG5cbiAgZnVuY3Rpb24gdW5Ib29rSXQocnMpe1xuICAgIHVuSG9va1JlbW90ZShycyk7XG4gICAgdW5Ib29rU3luYyhycyk7XG4gICAgdW5Ib29rR2V0SXRlbVVSTChycyk7XG4gIH1cblxuICBEcm9wYm94Ll9yc19pbml0ID0gZnVuY3Rpb24gKHJzKSB7XG4gICAgaGFzTG9jYWxTdG9yYWdlID0gdXRpbC5sb2NhbFN0b3JhZ2VBdmFpbGFibGUoKTtcbiAgICBpZiAoIHJzLmFwaUtleXMuZHJvcGJveCApIHtcbiAgICAgIHJzLmRyb3Bib3ggPSBuZXcgRHJvcGJveChycyk7XG4gICAgfVxuICAgIGlmIChycy5iYWNrZW5kID09PSAnZHJvcGJveCcpIHtcbiAgICAgIGhvb2tJdChycyk7XG4gICAgfVxuICB9O1xuXG4gIERyb3Bib3guX3JzX3N1cHBvcnRlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcblxuICBEcm9wYm94Ll9yc19jbGVhbnVwID0gZnVuY3Rpb24gKHJzKSB7XG4gICAgdW5Ib29rSXQocnMpO1xuICAgIGlmIChoYXNMb2NhbFN0b3JhZ2Upe1xuICAgICAgZGVsZXRlIGxvY2FsU3RvcmFnZVtTRVRUSU5HU19LRVldO1xuICAgIH1cbiAgICBycy5yZW1vdmVFdmVudExpc3RlbmVyKCdlcnJvcicsIG9uRXJyb3JDYik7XG4gICAgcnMuc2V0QmFja2VuZCh1bmRlZmluZWQpO1xuICB9O1xuXG5cbiAgbW9kdWxlLmV4cG9ydHMgPSBEcm9wYm94O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2Ryb3Bib3guanMiXSwic291cmNlUm9vdCI6IiJ9");

/***/ },
/* 7 */
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar log = __webpack_require__(4);\nvar util = __webpack_require__(2);\n\nfunction extractParams(url) {\n  //FF already decodes the URL fragment in document.location.hash, so use this instead:\n  var location = url || Authorize.getLocation().href,\n      hashPos = location.indexOf('#'),\n      hash;\n  if (hashPos === -1) {\n    return;\n  }\n  hash = location.substring(hashPos + 1);\n  // if hash is not of the form #key=val&key=val, it's probably not for us\n  if (hash.indexOf('=') === -1) {\n    return;\n  }\n  return hash.split('&').reduce(function (params, kvs) {\n    var kv = kvs.split('=');\n\n    if (kv[0] === 'state' && kv[1].match(/rsDiscovery/)) {\n      // extract rsDiscovery data from the state param\n      var stateValue = decodeURIComponent(kv[1]);\n      var encodedData = stateValue.substr(stateValue.indexOf('rsDiscovery=')).split('&')[0].split('=')[1];\n\n      params['rsDiscovery'] = JSON.parse(atob(encodedData));\n\n      // remove rsDiscovery param\n      stateValue = stateValue.replace(new RegExp('\\&?rsDiscovery=' + encodedData), '');\n\n      if (stateValue.length > 0) {\n        params['state'] = stateValue;\n      }\n    } else {\n      params[decodeURIComponent(kv[0])] = decodeURIComponent(kv[1]);\n    }\n\n    return params;\n  }, {});\n}\n\n// RemoteStorage.ImpliedAuth = function (storageApi, redirectUri) {\n//   log('ImpliedAuth proceeding due to absent authURL; storageApi = ' + storageApi + ' redirectUri = ' + redirectUri);\n//   // Set a fixed access token, signalling to not send it as Bearer\n//   remoteStorage.remote.configure({\n//     token: Authorize.IMPLIED_FAKE_TOKEN\n//   });\n//   document.location = redirectUri;\n// };\n\nvar Authorize = function Authorize(remoteStorage, authURL, scope, redirectUri, clientId) {\n  log('[Authorize] authURL = ', authURL, 'scope = ', scope, 'redirectUri = ', redirectUri, 'clientId = ', clientId);\n\n  // keep track of the discovery data during redirect if we can't save it in localStorage\n  if (!util.localStorageAvailable() && remoteStorage.backend === 'remotestorage') {\n    redirectUri += redirectUri.indexOf('#') > 0 ? '&' : '#';\n\n    var discoveryData = {\n      userAddress: remoteStorage.remote.userAddress,\n      href: remoteStorage.remote.href,\n      storageApi: remoteStorage.remote.storageApi,\n      properties: remoteStorage.remote.properties\n    };\n\n    redirectUri += 'rsDiscovery=' + btoa(JSON.stringify(discoveryData));\n  }\n\n  var url = authURL,\n      hashPos = redirectUri.indexOf('#');\n  url += authURL.indexOf('?') > 0 ? '&' : '?';\n  url += 'redirect_uri=' + encodeURIComponent(redirectUri.replace(/#.*$/, ''));\n  url += '&scope=' + encodeURIComponent(scope);\n  url += '&client_id=' + encodeURIComponent(clientId);\n  if (hashPos !== -1 && hashPos + 1 !== redirectUri.length) {\n    url += '&state=' + encodeURIComponent(redirectUri.substring(hashPos + 1));\n  }\n  url += '&response_type=token';\n\n  if (util.globalContext.cordova) {\n    return Authorize.openWindow(url, redirectUri, 'location=yes,clearsessioncache=yes,clearcache=yes').then(function (authResult) {\n      remoteStorage.remote.configure({\n        token: authResult.access_token\n      });\n    });\n  }\n\n  Authorize.setLocation(url);\n};\n\nAuthorize.IMPLIED_FAKE_TOKEN = false;\n\n// RemoteStorage.prototype.authorize = function (authURL, cordovaRedirectUri) {\n//   this.access.setStorageType(this.remote.storageType);\n//   var scope = this.access.scopeParameter;\n\n//   var redirectUri = global.cordova ?\n//     cordovaRedirectUri :\n//     String(Authorize.getLocation());\n\n//   var clientId = redirectUri.match(/^(https?:\\/\\/[^\\/]+)/)[0];\n\n//   Authorize(this, authURL, scope, redirectUri, clientId);\n// };\n// \n// \nAuthorize.Unauthorized = function () {\n  Error.apply(this, arguments);\n};\nAuthorize.Unauthorized.prototype = Object.create(Error.prototype);\n\n/**\n * Get current document location\n *\n * Override this method if access to document.location is forbidden\n */\nAuthorize.getLocation = function () {\n  return document.location;\n};\n\n/**\n * Set current document location\n *\n * Override this method if access to document.location is forbidden\n */\nAuthorize.setLocation = function (location) {\n  if (typeof location === 'string') {\n    document.location.href = location;\n  } else if ((typeof location === 'undefined' ? 'undefined' : _typeof(location)) === 'object') {\n    document.location = location;\n  } else {\n    throw \"Invalid location \" + location;\n  }\n};\n\n/**\n * Open new InAppBrowser window for OAuth in Cordova\n */\nAuthorize.openWindow = function (url, redirectUri, options) {\n  var pending = Promise.defer();\n  var newWindow = open(url, '_blank', options);\n\n  if (!newWindow || newWindow.closed) {\n    pending.reject('Authorization popup was blocked');\n    return pending.promise;\n  }\n\n  var handleExit = function handleExit() {\n    pending.reject('Authorization was canceled');\n  };\n\n  var handleLoadstart = function handleLoadstart(event) {\n    if (event.url.indexOf(redirectUri) !== 0) {\n      return;\n    }\n\n    newWindow.removeEventListener('exit', handleExit);\n    newWindow.close();\n\n    var authResult = extractParams(event.url);\n\n    if (!authResult) {\n      return pending.reject('Authorization error');\n    }\n\n    return pending.resolve(authResult);\n  };\n\n  newWindow.addEventListener('loadstart', handleLoadstart);\n  newWindow.addEventListener('exit', handleExit);\n\n  return pending.promise;\n};\n\n// RS.prototype.impliedauth = function () {\n//   RS.ImpliedAuth(this.remote.storageApi, String(document.location));\n// };\n\nAuthorize._rs_supported = function () {\n  return typeof document !== 'undefined';\n};\n\nvar onFeaturesLoaded;\nAuthorize._rs_init = function (remoteStorage) {\n\n  onFeaturesLoaded = function onFeaturesLoaded() {\n    var authParamsUsed = false;\n    if (params) {\n      if (params.error) {\n        throw \"Authorization server errored: \" + params.error;\n      }\n\n      // rsDiscovery came with the redirect, because it couldn't be\n      // saved in localStorage\n      if (params.rsDiscovery) {\n        remoteStorage.remote.configure(params.rsDiscovery);\n      }\n\n      if (params.access_token) {\n        remoteStorage.remote.configure({\n          token: params.access_token\n        });\n        authParamsUsed = true;\n      }\n      if (params.remotestorage) {\n        remoteStorage.connect(params.remotestorage);\n        authParamsUsed = true;\n      }\n      if (params.state) {\n        location = Authorize.getLocation();\n        Authorize.setLocation(location.href.split('#')[0] + '#' + params.state);\n      }\n    }\n    if (!authParamsUsed) {\n      remoteStorage.remote.stopWaitingForToken();\n    }\n  };\n  var params = extractParams(),\n      location;\n  if (params) {\n    location = Authorize.getLocation();\n    location.hash = '';\n  }\n  remoteStorage.on('features-loaded', onFeaturesLoaded);\n};\n\nAuthorize._rs_cleanup = function (remoteStorage) {\n  remoteStorage.removeEventListener('features-loaded', onFeaturesLoaded);\n};\n\nmodule.exports = Authorize;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvYXV0aG9yaXplLmpzPzI4NTEiXSwibmFtZXMiOlsibG9nIiwicmVxdWlyZSIsInV0aWwiLCJleHRyYWN0UGFyYW1zIiwidXJsIiwibG9jYXRpb24iLCJBdXRob3JpemUiLCJnZXRMb2NhdGlvbiIsImhyZWYiLCJoYXNoUG9zIiwiaW5kZXhPZiIsImhhc2giLCJzdWJzdHJpbmciLCJzcGxpdCIsInJlZHVjZSIsInBhcmFtcyIsImt2cyIsImt2IiwibWF0Y2giLCJzdGF0ZVZhbHVlIiwiZGVjb2RlVVJJQ29tcG9uZW50IiwiZW5jb2RlZERhdGEiLCJzdWJzdHIiLCJKU09OIiwicGFyc2UiLCJhdG9iIiwicmVwbGFjZSIsIlJlZ0V4cCIsImxlbmd0aCIsInJlbW90ZVN0b3JhZ2UiLCJhdXRoVVJMIiwic2NvcGUiLCJyZWRpcmVjdFVyaSIsImNsaWVudElkIiwibG9jYWxTdG9yYWdlQXZhaWxhYmxlIiwiYmFja2VuZCIsImRpc2NvdmVyeURhdGEiLCJ1c2VyQWRkcmVzcyIsInJlbW90ZSIsInN0b3JhZ2VBcGkiLCJwcm9wZXJ0aWVzIiwiYnRvYSIsInN0cmluZ2lmeSIsImVuY29kZVVSSUNvbXBvbmVudCIsImdsb2JhbENvbnRleHQiLCJjb3Jkb3ZhIiwib3BlbldpbmRvdyIsInRoZW4iLCJhdXRoUmVzdWx0IiwiY29uZmlndXJlIiwidG9rZW4iLCJhY2Nlc3NfdG9rZW4iLCJzZXRMb2NhdGlvbiIsIklNUExJRURfRkFLRV9UT0tFTiIsIlVuYXV0aG9yaXplZCIsIkVycm9yIiwiYXBwbHkiLCJhcmd1bWVudHMiLCJwcm90b3R5cGUiLCJPYmplY3QiLCJjcmVhdGUiLCJkb2N1bWVudCIsIm9wdGlvbnMiLCJwZW5kaW5nIiwiUHJvbWlzZSIsImRlZmVyIiwibmV3V2luZG93Iiwib3BlbiIsImNsb3NlZCIsInJlamVjdCIsInByb21pc2UiLCJoYW5kbGVFeGl0IiwiaGFuZGxlTG9hZHN0YXJ0IiwiZXZlbnQiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwiY2xvc2UiLCJyZXNvbHZlIiwiYWRkRXZlbnRMaXN0ZW5lciIsIl9yc19zdXBwb3J0ZWQiLCJvbkZlYXR1cmVzTG9hZGVkIiwiX3JzX2luaXQiLCJhdXRoUGFyYW1zVXNlZCIsImVycm9yIiwicnNEaXNjb3ZlcnkiLCJyZW1vdGVzdG9yYWdlIiwiY29ubmVjdCIsInN0YXRlIiwic3RvcFdhaXRpbmdGb3JUb2tlbiIsIm9uIiwiX3JzX2NsZWFudXAiLCJtb2R1bGUiLCJleHBvcnRzIl0sIm1hcHBpbmdzIjoiOzs7O0FBQUEsSUFBSUEsTUFBTSxtQkFBQUMsQ0FBUSxDQUFSLENBQVY7QUFDQSxJQUFJQyxPQUFPLG1CQUFBRCxDQUFRLENBQVIsQ0FBWDs7QUFFRSxTQUFTRSxhQUFULENBQXVCQyxHQUF2QixFQUE0QjtBQUMxQjtBQUNBLE1BQUlDLFdBQVdELE9BQU9FLFVBQVVDLFdBQVYsR0FBd0JDLElBQTlDO0FBQUEsTUFDSUMsVUFBV0osU0FBU0ssT0FBVCxDQUFpQixHQUFqQixDQURmO0FBQUEsTUFFSUMsSUFGSjtBQUdBLE1BQUlGLFlBQVksQ0FBQyxDQUFqQixFQUFvQjtBQUFFO0FBQVM7QUFDL0JFLFNBQU9OLFNBQVNPLFNBQVQsQ0FBbUJILFVBQVEsQ0FBM0IsQ0FBUDtBQUNBO0FBQ0EsTUFBSUUsS0FBS0QsT0FBTCxDQUFhLEdBQWIsTUFBc0IsQ0FBQyxDQUEzQixFQUE4QjtBQUFFO0FBQVM7QUFDekMsU0FBT0MsS0FBS0UsS0FBTCxDQUFXLEdBQVgsRUFBZ0JDLE1BQWhCLENBQXVCLFVBQVVDLE1BQVYsRUFBa0JDLEdBQWxCLEVBQXVCO0FBQ25ELFFBQUlDLEtBQUtELElBQUlILEtBQUosQ0FBVSxHQUFWLENBQVQ7O0FBRUEsUUFBSUksR0FBRyxDQUFILE1BQVUsT0FBVixJQUFxQkEsR0FBRyxDQUFILEVBQU1DLEtBQU4sQ0FBWSxhQUFaLENBQXpCLEVBQXFEO0FBQ25EO0FBQ0EsVUFBSUMsYUFBYUMsbUJBQW1CSCxHQUFHLENBQUgsQ0FBbkIsQ0FBakI7QUFDQSxVQUFJSSxj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IiwiZmlsZSI6IjcuanMiLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgbG9nID0gcmVxdWlyZSgnLi9sb2cnKTtcbnZhciB1dGlsID0gcmVxdWlyZSgnLi91dGlsJyk7XG4gIFxuICBmdW5jdGlvbiBleHRyYWN0UGFyYW1zKHVybCkge1xuICAgIC8vRkYgYWxyZWFkeSBkZWNvZGVzIHRoZSBVUkwgZnJhZ21lbnQgaW4gZG9jdW1lbnQubG9jYXRpb24uaGFzaCwgc28gdXNlIHRoaXMgaW5zdGVhZDpcbiAgICB2YXIgbG9jYXRpb24gPSB1cmwgfHwgQXV0aG9yaXplLmdldExvY2F0aW9uKCkuaHJlZixcbiAgICAgICAgaGFzaFBvcyAgPSBsb2NhdGlvbi5pbmRleE9mKCcjJyksXG4gICAgICAgIGhhc2g7XG4gICAgaWYgKGhhc2hQb3MgPT09IC0xKSB7IHJldHVybjsgfVxuICAgIGhhc2ggPSBsb2NhdGlvbi5zdWJzdHJpbmcoaGFzaFBvcysxKTtcbiAgICAvLyBpZiBoYXNoIGlzIG5vdCBvZiB0aGUgZm9ybSAja2V5PXZhbCZrZXk9dmFsLCBpdCdzIHByb2JhYmx5IG5vdCBmb3IgdXNcbiAgICBpZiAoaGFzaC5pbmRleE9mKCc9JykgPT09IC0xKSB7IHJldHVybjsgfVxuICAgIHJldHVybiBoYXNoLnNwbGl0KCcmJykucmVkdWNlKGZ1bmN0aW9uIChwYXJhbXMsIGt2cykge1xuICAgICAgdmFyIGt2ID0ga3ZzLnNwbGl0KCc9Jyk7XG5cbiAgICAgIGlmIChrdlswXSA9PT0gJ3N0YXRlJyAmJiBrdlsxXS5tYXRjaCgvcnNEaXNjb3ZlcnkvKSkge1xuICAgICAgICAvLyBleHRyYWN0IHJzRGlzY292ZXJ5IGRhdGEgZnJvbSB0aGUgc3RhdGUgcGFyYW1cbiAgICAgICAgdmFyIHN0YXRlVmFsdWUgPSBkZWNvZGVVUklDb21wb25lbnQoa3ZbMV0pO1xuICAgICAgICB2YXIgZW5jb2RlZERhdGEgPSBzdGF0ZVZhbHVlLnN1YnN0cihzdGF0ZVZhbHVlLmluZGV4T2YoJ3JzRGlzY292ZXJ5PScpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnNwbGl0KCcmJylbMF1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5zcGxpdCgnPScpWzFdO1xuXG4gICAgICAgIHBhcmFtc1sncnNEaXNjb3ZlcnknXSA9IEpTT04ucGFyc2UoYXRvYihlbmNvZGVkRGF0YSkpO1xuXG4gICAgICAgIC8vIHJlbW92ZSByc0Rpc2NvdmVyeSBwYXJhbVxuICAgICAgICBzdGF0ZVZhbHVlID0gc3RhdGVWYWx1ZS5yZXBsYWNlKG5ldyBSZWdFeHAoJ1xcJj9yc0Rpc2NvdmVyeT0nICsgZW5jb2RlZERhdGEpLCAnJyk7XG5cbiAgICAgICAgaWYgKHN0YXRlVmFsdWUubGVuZ3RoID4gMCkge1xuICAgICAgICAgIHBhcmFtc1snc3RhdGUnXSA9IHN0YXRlVmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBhcmFtc1tkZWNvZGVVUklDb21wb25lbnQoa3ZbMF0pXSA9IGRlY29kZVVSSUNvbXBvbmVudChrdlsxXSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBwYXJhbXM7XG4gICAgfSwge30pO1xuICB9XG5cbiAgLy8gUmVtb3RlU3RvcmFnZS5JbXBsaWVkQXV0aCA9IGZ1bmN0aW9uIChzdG9yYWdlQXBpLCByZWRpcmVjdFVyaSkge1xuICAvLyAgIGxvZygnSW1wbGllZEF1dGggcHJvY2VlZGluZyBkdWUgdG8gYWJzZW50IGF1dGhVUkw7IHN0b3JhZ2VBcGkgPSAnICsgc3RvcmFnZUFwaSArICcgcmVkaXJlY3RVcmkgPSAnICsgcmVkaXJlY3RVcmkpO1xuICAvLyAgIC8vIFNldCBhIGZpeGVkIGFjY2VzcyB0b2tlbiwgc2lnbmFsbGluZyB0byBub3Qgc2VuZCBpdCBhcyBCZWFyZXJcbiAgLy8gICByZW1vdGVTdG9yYWdlLnJlbW90ZS5jb25maWd1cmUoe1xuICAvLyAgICAgdG9rZW46IEF1dGhvcml6ZS5JTVBMSUVEX0ZBS0VfVE9LRU5cbiAgLy8gICB9KTtcbiAgLy8gICBkb2N1bWVudC5sb2NhdGlvbiA9IHJlZGlyZWN0VXJpO1xuICAvLyB9O1xuXG4gIHZhciBBdXRob3JpemUgPSBmdW5jdGlvbiAocmVtb3RlU3RvcmFnZSwgYXV0aFVSTCwgc2NvcGUsIHJlZGlyZWN0VXJpLCBjbGllbnRJZCkge1xuICAgIGxvZygnW0F1dGhvcml6ZV0gYXV0aFVSTCA9ICcsIGF1dGhVUkwsICdzY29wZSA9ICcsIHNjb3BlLCAncmVkaXJlY3RVcmkgPSAnLCByZWRpcmVjdFVyaSwgJ2NsaWVudElkID0gJywgY2xpZW50SWQpO1xuXG4gICAgLy8ga2VlcCB0cmFjayBvZiB0aGUgZGlzY292ZXJ5IGRhdGEgZHVyaW5nIHJlZGlyZWN0IGlmIHdlIGNhbid0IHNhdmUgaXQgaW4gbG9jYWxTdG9yYWdlXG4gICAgaWYgKCF1dGlsLmxvY2FsU3RvcmFnZUF2YWlsYWJsZSgpICYmXG4gICAgICAgIHJlbW90ZVN0b3JhZ2UuYmFja2VuZCA9PT0gJ3JlbW90ZXN0b3JhZ2UnKSB7XG4gICAgICByZWRpcmVjdFVyaSArPSByZWRpcmVjdFVyaS5pbmRleE9mKCcjJykgPiAwID8gJyYnIDogJyMnO1xuXG4gICAgICB2YXIgZGlzY292ZXJ5RGF0YSA9IHtcbiAgICAgICAgdXNlckFkZHJlc3M6IHJlbW90ZVN0b3JhZ2UucmVtb3RlLnVzZXJBZGRyZXNzLFxuICAgICAgICBocmVmOiByZW1vdGVTdG9yYWdlLnJlbW90ZS5ocmVmLFxuICAgICAgICBzdG9yYWdlQXBpOiByZW1vdGVTdG9yYWdlLnJlbW90ZS5zdG9yYWdlQXBpLFxuICAgICAgICBwcm9wZXJ0aWVzOiByZW1vdGVTdG9yYWdlLnJlbW90ZS5wcm9wZXJ0aWVzXG4gICAgICB9O1xuXG4gICAgICByZWRpcmVjdFVyaSArPSAncnNEaXNjb3Zlcnk9JyArIGJ0b2EoSlNPTi5zdHJpbmdpZnkoZGlzY292ZXJ5RGF0YSkpO1xuICAgIH1cblxuICAgIHZhciB1cmwgPSBhdXRoVVJMLCBoYXNoUG9zID0gcmVkaXJlY3RVcmkuaW5kZXhPZignIycpO1xuICAgIHVybCArPSBhdXRoVVJMLmluZGV4T2YoJz8nKSA+IDAgPyAnJicgOiAnPyc7XG4gICAgdXJsICs9ICdyZWRpcmVjdF91cmk9JyArIGVuY29kZVVSSUNvbXBvbmVudChyZWRpcmVjdFVyaS5yZXBsYWNlKC8jLiokLywgJycpKTtcbiAgICB1cmwgKz0gJyZzY29wZT0nICsgZW5jb2RlVVJJQ29tcG9uZW50KHNjb3BlKTtcbiAgICB1cmwgKz0gJyZjbGllbnRfaWQ9JyArIGVuY29kZVVSSUNvbXBvbmVudChjbGllbnRJZCk7XG4gICAgaWYgKGhhc2hQb3MgIT09IC0gMSAmJiBoYXNoUG9zKzEgIT09IHJlZGlyZWN0VXJpLmxlbmd0aCkge1xuICAgICAgdXJsICs9ICcmc3RhdGU9JyArIGVuY29kZVVSSUNvbXBvbmVudChyZWRpcmVjdFVyaS5zdWJzdHJpbmcoaGFzaFBvcysxKSk7XG4gICAgfVxuICAgIHVybCArPSAnJnJlc3BvbnNlX3R5cGU9dG9rZW4nO1xuXG4gICAgaWYgKHV0aWwuZ2xvYmFsQ29udGV4dC5jb3Jkb3ZhKSB7XG4gICAgICByZXR1cm4gQXV0aG9yaXplLm9wZW5XaW5kb3coXG4gICAgICAgICAgdXJsLFxuICAgICAgICAgIHJlZGlyZWN0VXJpLFxuICAgICAgICAgICdsb2NhdGlvbj15ZXMsY2xlYXJzZXNzaW9uY2FjaGU9eWVzLGNsZWFyY2FjaGU9eWVzJ1xuICAgICAgICApXG4gICAgICAgIC50aGVuKGZ1bmN0aW9uKGF1dGhSZXN1bHQpIHtcbiAgICAgICAgICByZW1vdGVTdG9yYWdlLnJlbW90ZS5jb25maWd1cmUoe1xuICAgICAgICAgICAgdG9rZW46IGF1dGhSZXN1bHQuYWNjZXNzX3Rva2VuXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pXG4gICAgfVxuXG4gICAgQXV0aG9yaXplLnNldExvY2F0aW9uKHVybCk7XG4gIH07XG5cbiAgQXV0aG9yaXplLklNUExJRURfRkFLRV9UT0tFTiA9IGZhbHNlO1xuICBcbiAgLy8gUmVtb3RlU3RvcmFnZS5wcm90b3R5cGUuYXV0aG9yaXplID0gZnVuY3Rpb24gKGF1dGhVUkwsIGNvcmRvdmFSZWRpcmVjdFVyaSkge1xuICAvLyAgIHRoaXMuYWNjZXNzLnNldFN0b3JhZ2VUeXBlKHRoaXMucmVtb3RlLnN0b3JhZ2VUeXBlKTtcbiAgLy8gICB2YXIgc2NvcGUgPSB0aGlzLmFjY2Vzcy5zY29wZVBhcmFtZXRlcjtcblxuICAvLyAgIHZhciByZWRpcmVjdFVyaSA9IGdsb2JhbC5jb3Jkb3ZhID9cbiAgLy8gICAgIGNvcmRvdmFSZWRpcmVjdFVyaSA6XG4gIC8vICAgICBTdHJpbmcoQXV0aG9yaXplLmdldExvY2F0aW9uKCkpO1xuXG4gIC8vICAgdmFyIGNsaWVudElkID0gcmVkaXJlY3RVcmkubWF0Y2goL14oaHR0cHM/OlxcL1xcL1teXFwvXSspLylbMF07XG5cbiAgLy8gICBBdXRob3JpemUodGhpcywgYXV0aFVSTCwgc2NvcGUsIHJlZGlyZWN0VXJpLCBjbGllbnRJZCk7XG4gIC8vIH07XG4gIC8vIFxuICAvLyBcbiAgQXV0aG9yaXplLlVuYXV0aG9yaXplZCA9IGZ1bmN0aW9uICgpIHsgRXJyb3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfTtcbiAgQXV0aG9yaXplLlVuYXV0aG9yaXplZC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEVycm9yLnByb3RvdHlwZSk7XG5cblxuICAvKipcbiAgICogR2V0IGN1cnJlbnQgZG9jdW1lbnQgbG9jYXRpb25cbiAgICpcbiAgICogT3ZlcnJpZGUgdGhpcyBtZXRob2QgaWYgYWNjZXNzIHRvIGRvY3VtZW50LmxvY2F0aW9uIGlzIGZvcmJpZGRlblxuICAgKi9cbiAgQXV0aG9yaXplLmdldExvY2F0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBkb2N1bWVudC5sb2NhdGlvbjtcbiAgfTtcblxuICAvKipcbiAgICogU2V0IGN1cnJlbnQgZG9jdW1lbnQgbG9jYXRpb25cbiAgICpcbiAgICogT3ZlcnJpZGUgdGhpcyBtZXRob2QgaWYgYWNjZXNzIHRvIGRvY3VtZW50LmxvY2F0aW9uIGlzIGZvcmJpZGRlblxuICAgKi9cbiAgQXV0aG9yaXplLnNldExvY2F0aW9uID0gZnVuY3Rpb24gKGxvY2F0aW9uKSB7XG4gICAgaWYgKHR5cGVvZiBsb2NhdGlvbiA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGRvY3VtZW50LmxvY2F0aW9uLmhyZWYgPSBsb2NhdGlvbjtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBsb2NhdGlvbiA9PT0gJ29iamVjdCcpIHtcbiAgICAgIGRvY3VtZW50LmxvY2F0aW9uID0gbG9jYXRpb247XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IFwiSW52YWxpZCBsb2NhdGlvbiBcIiArIGxvY2F0aW9uO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogT3BlbiBuZXcgSW5BcHBCcm93c2VyIHdpbmRvdyBmb3IgT0F1dGggaW4gQ29yZG92YVxuICAgKi9cbiAgQXV0aG9yaXplLm9wZW5XaW5kb3cgPSBmdW5jdGlvbiAodXJsLCByZWRpcmVjdFVyaSwgb3B0aW9ucykge1xuICAgIHZhciBwZW5kaW5nID0gUHJvbWlzZS5kZWZlcigpO1xuICAgIHZhciBuZXdXaW5kb3cgPSBvcGVuKHVybCwgJ19ibGFuaycsIG9wdGlvbnMpO1xuXG4gICAgaWYgKCFuZXdXaW5kb3cgfHwgbmV3V2luZG93LmNsb3NlZCkge1xuICAgICAgcGVuZGluZy5yZWplY3QoJ0F1dGhvcml6YXRpb24gcG9wdXAgd2FzIGJsb2NrZWQnKTtcbiAgICAgIHJldHVybiBwZW5kaW5nLnByb21pc2U7XG4gICAgfVxuXG4gICAgdmFyIGhhbmRsZUV4aXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBwZW5kaW5nLnJlamVjdCgnQXV0aG9yaXphdGlvbiB3YXMgY2FuY2VsZWQnKTtcbiAgICB9O1xuXG4gICAgdmFyIGhhbmRsZUxvYWRzdGFydCA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgaWYgKGV2ZW50LnVybC5pbmRleE9mKHJlZGlyZWN0VXJpKSAhPT0gMCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIG5ld1dpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdleGl0JywgaGFuZGxlRXhpdCk7XG4gICAgICBuZXdXaW5kb3cuY2xvc2UoKTtcblxuICAgICAgdmFyIGF1dGhSZXN1bHQgPSBleHRyYWN0UGFyYW1zKGV2ZW50LnVybCk7XG5cbiAgICAgIGlmICghYXV0aFJlc3VsdCkge1xuICAgICAgICByZXR1cm4gcGVuZGluZy5yZWplY3QoJ0F1dGhvcml6YXRpb24gZXJyb3InKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHBlbmRpbmcucmVzb2x2ZShhdXRoUmVzdWx0KTtcbiAgICB9O1xuXG4gICAgbmV3V2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2xvYWRzdGFydCcsIGhhbmRsZUxvYWRzdGFydCk7XG4gICAgbmV3V2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2V4aXQnLCBoYW5kbGVFeGl0KTtcblxuICAgIHJldHVybiBwZW5kaW5nLnByb21pc2U7XG4gIH07XG5cbiAgLy8gUlMucHJvdG90eXBlLmltcGxpZWRhdXRoID0gZnVuY3Rpb24gKCkge1xuICAvLyAgIFJTLkltcGxpZWRBdXRoKHRoaXMucmVtb3RlLnN0b3JhZ2VBcGksIFN0cmluZyhkb2N1bWVudC5sb2NhdGlvbikpO1xuICAvLyB9O1xuXG4gIEF1dGhvcml6ZS5fcnNfc3VwcG9ydGVkID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0eXBlb2YoZG9jdW1lbnQpICE9PSAndW5kZWZpbmVkJztcbiAgfTtcblxuICB2YXIgb25GZWF0dXJlc0xvYWRlZDtcbiAgQXV0aG9yaXplLl9yc19pbml0ID0gZnVuY3Rpb24gKHJlbW90ZVN0b3JhZ2UpIHtcblxuICAgIG9uRmVhdHVyZXNMb2FkZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgYXV0aFBhcmFtc1VzZWQgPSBmYWxzZTtcbiAgICAgIGlmIChwYXJhbXMpIHtcbiAgICAgICAgaWYgKHBhcmFtcy5lcnJvcikge1xuICAgICAgICAgIHRocm93IFwiQXV0aG9yaXphdGlvbiBzZXJ2ZXIgZXJyb3JlZDogXCIgKyBwYXJhbXMuZXJyb3I7XG4gICAgICAgIH1cblxuICAgICAgICAvLyByc0Rpc2NvdmVyeSBjYW1lIHdpdGggdGhlIHJlZGlyZWN0LCBiZWNhdXNlIGl0IGNvdWxkbid0IGJlXG4gICAgICAgIC8vIHNhdmVkIGluIGxvY2FsU3RvcmFnZVxuICAgICAgICBpZiAocGFyYW1zLnJzRGlzY292ZXJ5KSB7XG4gICAgICAgICAgcmVtb3RlU3RvcmFnZS5yZW1vdGUuY29uZmlndXJlKHBhcmFtcy5yc0Rpc2NvdmVyeSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocGFyYW1zLmFjY2Vzc190b2tlbikge1xuICAgICAgICAgIHJlbW90ZVN0b3JhZ2UucmVtb3RlLmNvbmZpZ3VyZSh7XG4gICAgICAgICAgICB0b2tlbjogcGFyYW1zLmFjY2Vzc190b2tlblxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGF1dGhQYXJhbXNVc2VkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGFyYW1zLnJlbW90ZXN0b3JhZ2UpIHtcbiAgICAgICAgICByZW1vdGVTdG9yYWdlLmNvbm5lY3QocGFyYW1zLnJlbW90ZXN0b3JhZ2UpO1xuICAgICAgICAgIGF1dGhQYXJhbXNVc2VkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGFyYW1zLnN0YXRlKSB7XG4gICAgICAgICAgbG9jYXRpb24gPSBBdXRob3JpemUuZ2V0TG9jYXRpb24oKTtcbiAgICAgICAgICBBdXRob3JpemUuc2V0TG9jYXRpb24obG9jYXRpb24uaHJlZi5zcGxpdCgnIycpWzBdKycjJytwYXJhbXMuc3RhdGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoIWF1dGhQYXJhbXNVc2VkKSB7XG4gICAgICAgIHJlbW90ZVN0b3JhZ2UucmVtb3RlLnN0b3BXYWl0aW5nRm9yVG9rZW4oKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHZhciBwYXJhbXMgPSBleHRyYWN0UGFyYW1zKCksXG4gICAgICAgIGxvY2F0aW9uO1xuICAgIGlmIChwYXJhbXMpIHtcbiAgICAgIGxvY2F0aW9uID0gQXV0aG9yaXplLmdldExvY2F0aW9uKCk7XG4gICAgICBsb2NhdGlvbi5oYXNoID0gJyc7XG4gICAgfVxuICAgIHJlbW90ZVN0b3JhZ2Uub24oJ2ZlYXR1cmVzLWxvYWRlZCcsIG9uRmVhdHVyZXNMb2FkZWQpO1xuICB9O1xuXG4gIEF1dGhvcml6ZS5fcnNfY2xlYW51cCA9IGZ1bmN0aW9uIChyZW1vdGVTdG9yYWdlKSB7XG4gICAgcmVtb3RlU3RvcmFnZS5yZW1vdmVFdmVudExpc3RlbmVyKCdmZWF0dXJlcy1sb2FkZWQnLCBvbkZlYXR1cmVzTG9hZGVkKTtcbiAgfTtcblxuICBtb2R1bGUuZXhwb3J0cyA9IEF1dGhvcml6ZTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9hdXRob3JpemUuanMiXSwic291cmNlUm9vdCI6IiJ9");

/***/ },
/* 8 */
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nfunction deprecate(thing, replacement) {\n  console.log('WARNING: ' + thing + ' is deprecated. Use ' + replacement + ' instead.');\n}\n\nvar eventHandling = __webpack_require__(3);\nvar util = __webpack_require__(2);\nvar config = __webpack_require__(5);\n__webpack_require__(9);\n\n/**\n * Class: RemoteStorage.BaseClient\n *\n * Provides a high-level interface to access data below a given root path.\n *\n * A BaseClient deals with three types of data: folders, objects and files.\n *\n * <getListing> returns a mapping of all items within a folder. Items that\n * end with a forward slash (\"/\") are child folders. For instance:\n * {\n *   'folder/': true,\n *   'document.txt': true\n * }\n *\n * <getObject> / <storeObject> operate on JSON objects. Each object has a type.\n *\n * <getFile> / <storeFile> operates on files. Each file has a MIME type.\n *\n * <remove> operates on either objects or files (but not folders, folders are\n * created and removed implictly).\n */\nvar BaseClient = function BaseClient(storage, base) {\n  if (base[base.length - 1] !== '/') {\n    throw \"Not a folder: \" + base;\n  }\n\n  if (base === '/') {\n    // allow absolute and relative paths for the root scope.\n    this.makePath = function (path) {\n      return (path[0] === '/' ? '' : '/') + path;\n    };\n  }\n\n  /**\n   * Property: storage\n   *\n   * The <RemoteStorage> instance this <BaseClient> operates on.\n   */\n  this.storage = storage;\n\n  /**\n   * Property: base\n   *\n   * Base path this <BaseClient> operates on.\n   *\n   * For the module's privateClient this would be /<moduleName>/, for the\n   * corresponding publicClient /public/<moduleName>/.\n   */\n  this.base = base;\n\n  var parts = this.base.split('/');\n  if (parts.length > 2) {\n    this.moduleName = parts[1];\n  } else {\n    this.moduleName = 'root';\n  }\n\n  // Defined in baseclient/types.js\n  /**\n   * Property: schemas\n   *\n   * Contains schema objects of all types known to the BaseClient instance\n   **/\n\n  /**\n   * Event: change\n   *\n   * Emitted when a node changes\n   *\n   * Arguments:\n   *   event - Event object containing information about the changed node\n   *\n   * (start code)\n   * {\n   *    path: path, // Absolute path of the changed node, from the storage root\n   *    relativePath: relativePath, // Path of the changed node, relative to this baseclient's scope root\n   *    origin: 'window', 'local', 'remote', or 'conflict' // emitted by user action within the app, local data store, remote sync, or versioning conflicts\n   *    oldValue: oldBody, // Old body of the changed node (local version in conflicts; undefined if creation)\n   *    newValue: newBody, // New body of the changed node (remote version in conflicts; undefined if deletion)\n   *    lastCommonValue: lastCommonValue, //most recent known common ancestor body of 'yours' and 'theirs' in case of conflict\n   *    oldContentType: oldContentType, // Old contentType of the changed node ('yours' for conflicts; undefined if creation)\n   *    newContentType: newContentType, // New contentType of the changed node ('theirs' for conflicts; undefined if deletion)\n   *    lastCommonContentType: lastCommonContentType // Most recent known common ancestor contentType of 'yours' and 'theirs' in case of conflict\n   *  }\n   * (end code)\n   *\n   * Example of an event with origin 'local' (fired on page load):\n   *\n   * (start code)\n   * {\n   *    path: '/public/design/color.txt',\n   *    relativePath: 'color.txt',\n   *    origin: 'local',\n   *    oldValue: undefined,\n   *    newValue: 'white',\n   *    oldContentType: undefined,\n   *    newContentType: 'text/plain'\n   *  }\n   * (end code)\n   *\n   * Example of a conflict:\n   * Say you changed 'color.txt' from 'white' to 'blue'; if you have set `RemoteStorage.config.changeEvents.window` to `true`,\n   * then you will receive:\n   *\n   * (start code)\n   * {\n   *    path: '/public/design/color.txt',\n   *    relativePath: 'color.txt',\n   *    origin: 'window',\n   *    oldValue: 'white',\n   *    newValue: 'blue',\n   *    oldContentType: 'text/plain',\n   *    newContentType: 'text/plain'\n   *  }\n   * (end code)\n   *\n   * But when this change is pushed out by asynchronous synchronization, this change may rejected by the\n   * server, if the remote version has in the meantime changed from 'white' to  for instance 'red'; this will then lead to a change\n   * event with origin 'conflict' (usually a few seconds after the event with origin 'window', if you had that activated). Note\n   * that since you already changed it from 'white' to 'blue' in the local version a few seconds ago, `oldValue` is now your local\n   * value of 'blue':\n   *\n   * (start code)\n   * {\n   *    path: '/public/design/color.txt',\n   *    relativePath: 'color.txt',\n   *    origin: 'conflict',\n   *    oldValue: 'blue',\n   *    newValue: 'red',\n   *    lastCommonValue: 'white',\n   *    oldContentType: 'text/plain,\n   *    newContentType: 'text/plain'\n   *    lastCommonContentType: 'text/plain'\n   *  }\n   * (end code)\n   *\n   * In practice, you should always redraw your views to display the content of the `newValue` field when a change event is received,\n   * regardless of its origin. Events with origin 'local' are fired conveniently during the page load, so that you can fill your views\n   * when the page loads. Events with origin 'window' are fired whenever you change a value by calling a method on the baseClient;\n   * these are disabled by default. Events with origin 'remote' are fired when remote changes are discovered during sync (only for caching\n   * startegies 'SEEN' and 'ALL'). Events with origin 'conflict' are fired when a conflict occurs while pushing out your local changes to\n   * the remote store in asynchronous synchronization (see example above).\n   **/\n\n  eventHandling(this, 'change');\n  this.on = this.on.bind(this);\n  storage.onChange(this.base, this._fireChange.bind(this));\n};\n\nBaseClient.prototype = {\n\n  extend: function extend(object) {\n    for (var key in object) {\n      this[key] = object[key];\n    }\n    return this;\n  },\n\n  /**\n   * Method: scope\n   *\n   * Returns a new <BaseClient> operating on a subpath of the current <base> path.\n   */\n  scope: function scope(path) {\n    return new BaseClient(this.storage, this.makePath(path));\n  },\n\n  // folder operations\n\n  /**\n   * Method: getListing\n   *\n   * Get a list of child nodes below a given path.\n   *\n   * The callback semantics of getListing are identical to those of getObject.\n   *\n   * Parameters:\n   *   path   - The path to query. It MUST end with a forward slash.\n   *   maxAge - Either false or the maximum age of cached listing in\n   *            milliseconds. Defaults to false in anonymous mode and to\n   *            2*syncInterval in connected mode.\n   *\n   * Returns:\n   *\n   *   A promise for an object, representing child nodes. If the maxAge\n   *   requirement cannot be met because of network problems, this promise\n   *   will be rejected. If the maxAge requirement is set to false or the\n   *   library is in offline state, the promise will always be fulfilled with\n   *   data from the local store.\n   *\n   *   Keys ending in a forward slash represent *folder nodes*, while all\n   *   other keys represent *data nodes*.\n   *\n   *   For spec versions <= 01, the data node information will contain only\n   *   the item's ETag. For later spec versions, it will also contain the\n   *   content type and -length of the item.\n   *\n   * Example:\n   *   (start code)\n   *   client.getListing('', false).then(function (listing) {\n   *     // listing is for instance:\n   *     // {\n   *     //   'folder/': true,\n   *     //   'document.txt': true\n   *     // }\n   *   });\n   *   (end code)\n   */\n  getListing: function getListing(path, maxAge) {\n    if (typeof path !== 'string') {\n      path = '';\n    } else if (path.length > 0 && path[path.length - 1] !== '/') {\n      return Promise.reject(\"Not a folder: \" + path);\n    }\n    return this.storage.get(this.makePath(path), maxAge).then(function (r) {\n      return r.statusCode === 404 ? {} : r.body;\n    });\n  },\n\n  /**\n   * Method: getAll\n   *\n   * Get all objects directly below a given path.\n   *\n   * Parameters:\n   *   path   - Path to the folder.\n   *   maxAge - Either false or the maximum age of cached objects in\n   *            milliseconds. Defaults to false in anonymous mode and to\n   *            2*syncInterval in connected mode.\n   *\n   * Returns:\n   *   A promise for an object in the form { path : object, ... }. If the\n   *   maxAge requirement cannot be met because of network problems, this\n   *   promise will be rejected. If the maxAge requirement is set to false,\n   *   the promise will always be fulfilled with data from the local store.\n   *\n   *   For items that are not JSON-stringified objects (e.g. stored using\n   *   `storeFile` instead of `storeObject`), the object's value is filled in\n   *   with `true`.\n   *\n   * Example:\n   *   (start code)\n   *   client.getAll('', false).then(function (objects) {\n   *     for (var key in objects) {\n   *       console.log('- ' + key + ': ', objects[key]);\n   *     }\n   *   });\n   *   (end code)\n   */\n  getAll: function getAll(path, maxAge) {\n    if (typeof path !== 'string') {\n      path = '';\n    } else if (path.length > 0 && path[path.length - 1] !== '/') {\n      return Promise.reject(\"Not a folder: \" + path);\n    }\n\n    return this.storage.get(this.makePath(path), maxAge).then(function (r) {\n      if (r.statusCode === 404) {\n        return {};\n      }\n      if (_typeof(r.body) === 'object') {\n        var keys = Object.keys(r.body);\n        if (keys.length === 0) {\n          // treat this like 404. it probably means a folder listing that\n          // has changes that haven't been pushed out yet.\n          return {};\n        }\n\n        var calls = keys.map(function (key) {\n          return this.storage.get(this.makePath(path + key), maxAge).then(function (o) {\n            if (typeof o.body === 'string') {\n              try {\n                o.body = JSON.parse(o.body);\n              } catch (e) {}\n            }\n            if (_typeof(o.body) === 'object') {\n              r.body[key] = o.body;\n            }\n          });\n        }.bind(this));\n        return Promise.all(calls).then(function () {\n          return r.body;\n        });\n      }\n    }.bind(this));\n  },\n\n  // file operations\n\n  /**\n   * Method: getFile\n   *\n   * Get the file at the given path. A file is raw data, as opposed to\n   * a JSON object (use <getObject> for that).\n   *\n   * Except for the return value structure, getFile works exactly like\n   * getObject.\n   *\n   * Parameters:\n   *   path   - See getObject.\n   *   maxAge - Either false or the maximum age of cached file in\n   *            milliseconds. Defaults to false in anonymous mode and to\n   *            2*syncInterval in connected mode.\n   *\n   * Returns:\n   *   A promise for an object:\n   *\n   *   mimeType - String representing the MIME Type of the document.\n   *   data     - Raw data of the document (either a string or an ArrayBuffer)\n   *\n   *   If the maxAge requirement cannot be met because of network problems, this\n   *   promise will be rejected. If the maxAge requirement is set to false, the\n   *   promise will always be fulfilled with data from the local store.\n   *\n   * Example:\n   *   (start code)\n   *   // Display an image:\n   *   client.getFile('path/to/some/image', false).then(function (file) {\n   *     var blob = new Blob([file.data], { type: file.mimeType });\n   *     var targetElement = document.findElementById('my-image-element');\n   *     targetElement.src = window.URL.createObjectURL(blob);\n   *   });\n   *   (end code)\n   */\n  getFile: function getFile(path, maxAge) {\n    if (typeof path !== 'string') {\n      return Promise.reject('Argument \\'path\\' of baseClient.getFile must be a string');\n    }\n    return this.storage.get(this.makePath(path), maxAge).then(function (r) {\n      return {\n        data: r.body,\n        contentType: r.contentType,\n        revision: r.revision // (this is new)\n      };\n    });\n  },\n\n  /**\n   * Method: storeFile\n   *\n   * Store raw data at a given path.\n   *\n   * Parameters:\n   *   mimeType - MIME media type of the data being stored\n   *   path     - path relative to the module root. MAY NOT end in a forward slash.\n   *   data     - string, ArrayBuffer or ArrayBufferView of raw data to store\n   *\n   * The given mimeType will later be returned, when retrieving the data\n   * using <getFile>.\n   *\n   * Example (UTF-8 data):\n   *   (start code)\n   *   client.storeFile('text/html', 'index.html', '<h1>Hello World!</h1>');\n   *   (end code)\n   *\n   * Example (Binary data):\n   *   (start code)\n   *   // MARKUP:\n   *   <input type=\"file\" id=\"file-input\">\n   *   // CODE:\n   *   var input = document.getElementById('file-input');\n   *   var file = input.files[0];\n   *   var fileReader = new FileReader();\n   *\n   *   fileReader.onload = function () {\n   *     client.storeFile(file.type, file.name, fileReader.result);\n   *   };\n   *\n   *   fileReader.readAsArrayBuffer(file);\n   *   (end code)\n   *\n   */\n  storeFile: function storeFile(mimeType, path, body) {\n    if (typeof mimeType !== 'string') {\n      return Promise.reject('Argument \\'mimeType\\' of baseClient.storeFile must be a string');\n    }\n    if (typeof path !== 'string') {\n      return Promise.reject('Argument \\'path\\' of baseClient.storeFile must be a string');\n    }\n    if (typeof body !== 'string' && (typeof body === 'undefined' ? 'undefined' : _typeof(body)) !== 'object') {\n      return Promise.reject('Argument \\'body\\' of baseClient.storeFile must be a string, ArrayBuffer, or ArrayBufferView');\n    }\n    if (!this.storage.access.checkPathPermission(this.makePath(path), 'rw')) {\n      console.warn('WARNING: Editing a document to which only read access (\\'r\\') was claimed');\n    }\n\n    return this.storage.put(this.makePath(path), body, mimeType).then(function (r) {\n      if (r.statusCode === 200 || r.statusCode === 201) {\n        return r.revision;\n      } else {\n        return Promise.reject(\"Request (PUT \" + this.makePath(path) + \") failed with status: \" + r.statusCode);\n      }\n    }.bind(this));\n  },\n\n  // object operations\n\n  /**\n   * Method: getObject\n   *\n   * Get a JSON object from given path.\n   *\n   * Parameters:\n   *   path   - Relative path from the module root (without leading slash).\n   *   maxAge - Either false or the maximum age of cached object in\n   *            milliseconds. Defaults to false in anonymous mode and to\n   *            2*syncInterval in connected mode.\n   *\n   * Returns:\n   *   A promise for the object. If the maxAge requirement cannot be met\n   *   because of network problems, this promise will be rejected. If the\n   *   maxAge requirement is set to false, the promise will always be\n   *   fulfilled with data from the local store.\n   *\n   * Example:\n   *   (start code)\n   *   client.getObject('/path/to/object', false).\n   *     then(function (object) {\n   *       // object is either an object or null\n   *     });\n   *   (end code)\n   */\n  getObject: function getObject(path, maxAge) {\n    if (typeof path !== 'string') {\n      return Promise.reject('Argument \\'path\\' of baseClient.getObject must be a string');\n    }\n    return this.storage.get(this.makePath(path), maxAge).then(function (r) {\n      if (_typeof(r.body) === 'object') {\n        // will be the case for documents stored with rs.js <= 0.10.0-beta2\n        return r.body;\n      } else if (typeof r.body === 'string') {\n        try {\n          return JSON.parse(r.body);\n        } catch (e) {\n          throw \"Not valid JSON: \" + this.makePath(path);\n        }\n      } else if (typeof r.body !== 'undefined' && r.statusCode === 200) {\n        return Promise.reject(\"Not an object: \" + this.makePath(path));\n      }\n    }.bind(this));\n  },\n\n  /**\n   * Method: storeObject\n   *\n   * Store object at given path. Triggers synchronization.\n   *\n   * Parameters:\n   *\n   *   type     - unique type of this object within this module. See description below.\n   *   path     - path relative to the module root.\n   *   object   - an object to be saved to the given node. It must be serializable as JSON.\n   *\n   * Returns:\n   *   A promise to store the object. The promise fails with a ValidationError, when validations fail.\n   *\n   *\n   * What about the type?:\n   *\n   *   A great thing about having data on the web, is to be able to link to\n   *   it and rearrange it to fit the current circumstances. To facilitate\n   *   that, eventually you need to know how the data at hand is structured.\n   *   For documents on the web, this is usually done via a MIME type. The\n   *   MIME type of JSON objects however, is always application/json.\n   *   To add that extra layer of \"knowing what this object is\", remoteStorage\n   *   aims to use <JSON-LD at http://json-ld.org/>.\n   *   A first step in that direction, is to add a *@context attribute* to all\n   *   JSON data put into remoteStorage.\n   *   Now that is what the *type* is for.\n   *\n   *   Within remoteStorage.js, @context values are built using three components:\n   *     http://remotestorage.io/spec/modules/ - A prefix to guarantee uniqueness\n   *     the module name     - module names should be unique as well\n   *     the type given here - naming this particular kind of object within this module\n   *\n   *   In retrospect that means, that whenever you introduce a new \"type\" in calls to\n   *   storeObject, you should make sure that once your code is in the wild, future\n   *   versions of the code are compatible with the same JSON structure.\n   *\n   * How to define types?:\n   *\n   *   See <declareType> for examples.\n   */\n  storeObject: function storeObject(typeAlias, path, object) {\n    if (typeof typeAlias !== 'string') {\n      return Promise.reject('Argument \\'typeAlias\\' of baseClient.storeObject must be a string');\n    }\n    if (typeof path !== 'string') {\n      return Promise.reject('Argument \\'path\\' of baseClient.storeObject must be a string');\n    }\n    if ((typeof object === 'undefined' ? 'undefined' : _typeof(object)) !== 'object') {\n      return Promise.reject('Argument \\'object\\' of baseClient.storeObject must be an object');\n    }\n\n    this._attachType(object, typeAlias);\n\n    try {\n      var validationResult = this.validate(object);\n      if (!validationResult.valid) {\n        return Promise.reject(validationResult);\n      }\n    } catch (exc) {\n      return Promise.reject(exc);\n    }\n\n    return this.storage.put(this.makePath(path), JSON.stringify(object), 'application/json; charset=UTF-8').then(function (r) {\n      if (r.statusCode === 200 || r.statusCode === 201) {\n        return r.revision;\n      } else {\n        return Promise.reject(\"Request (PUT \" + this.makePath(path) + \") failed with status: \" + r.statusCode);\n      }\n    }.bind(this));\n  },\n\n  // generic operations\n\n  /**\n   * Method: remove\n   *\n   * Remove node at given path from storage. Triggers synchronization.\n   *\n   * Parameters:\n   *   path     - Path relative to the module root.\n   */\n  remove: function remove(path) {\n    if (typeof path !== 'string') {\n      return Promise.reject('Argument \\'path\\' of baseClient.remove must be a string');\n    }\n    if (!this.storage.access.checkPathPermission(this.makePath(path), 'rw')) {\n      console.warn('WARNING: Removing a document to which only read access (\\'r\\') was claimed');\n    }\n\n    return this.storage.delete(this.makePath(path));\n  },\n\n  cache: function cache(path, strategy) {\n    if (typeof path !== 'string') {\n      throw 'Argument \\'path\\' of baseClient.cache must be a string';\n    }\n    if (strategy === false) {\n      deprecate('caching strategy <false>', '<\"FLUSH\">');\n      strategy = 'FLUSH';\n    } else if (strategy === undefined) {\n      strategy = 'ALL';\n    } else if (typeof strategy !== 'string') {\n      deprecate('that caching strategy', '<\"ALL\">');\n      strategy = 'ALL';\n    }\n    if (strategy !== 'FLUSH' && strategy !== 'SEEN' && strategy !== 'ALL') {\n      throw 'Argument \\'strategy\\' of baseclient.cache must be one of ' + '[\"FLUSH\", \"SEEN\", \"ALL\"]';\n    }\n    this.storage.caching.set(this.makePath(path), strategy);\n    return this;\n  },\n\n  flush: function flush(path) {\n    return this.storage.local.flush(path);\n  },\n\n  makePath: function makePath(path) {\n    return this.base + (path || '');\n  },\n\n  _fireChange: function _fireChange(event) {\n    if (config.changeEvents[event.origin]) {\n      ['new', 'old', 'lastCommon'].forEach(function (fieldNamePrefix) {\n        if (!event[fieldNamePrefix + 'ContentType'] || /^application\\/(.*)json(.*)/.exec(event[fieldNamePrefix + 'ContentType'])) {\n          if (typeof event[fieldNamePrefix + 'Value'] === 'string') {\n            try {\n              event[fieldNamePrefix + 'Value'] = JSON.parse(event[fieldNamePrefix + 'Value']);\n            } catch (e) {}\n          }\n        }\n      });\n      this._emit('change', event);\n    }\n  },\n\n  _cleanPath: util.cleanPath,\n\n  /**\n   * Method: getItemURL\n   *\n   * Retrieve full URL of item\n   *\n   * Parameters:\n   *   path     - Path relative to the module root.\n   */\n  getItemURL: function getItemURL(path) {\n    if (typeof path !== 'string') {\n      throw 'Argument \\'path\\' of baseClient.getItemURL must be a string';\n    }\n    if (this.storage.connected) {\n      path = this._cleanPath(this.makePath(path));\n      return this.storage.remote.href + path;\n    } else {\n      return undefined;\n    }\n  },\n\n  uuid: function uuid() {\n    return Math.uuid();\n  }\n\n};\n\n/**\n * Method: RS#scope\n *\n * Returns a new <RS.BaseClient> scoped to the given path.\n *\n * Parameters:\n *   path - Root path of new BaseClient.\n *\n *\n * Example:\n *   (start code)\n *\n *   var foo = remoteStorage.scope('/foo/');\n *\n *   // PUTs data \"baz\" to path /foo/bar\n *   foo.storeFile('text/plain', 'bar', 'baz');\n *\n *   var something = foo.scope('something/');\n *\n *   // GETs listing from path /foo/something/bla/\n *   something.getListing('bla/');\n *\n *   (end code)\n *\n */\nBaseClient._rs_init = function () {};\n\n/* e.g.:\nremoteStorage.defineModule('locations', function (priv, pub) {\n  return {\n    exports: {\n      features: priv.scope('features/').defaultType('feature'),\n      collections: priv.scope('collections/').defaultType('feature-collection');\n    }\n  };\n});\n*/\n\n// Defined in baseclient/types.js\n/**\n * Method: declareType\n *\n * Declare a remoteStorage object type using a JSON schema. See\n * <RemoteStorage.BaseClient.Types>\n **/\n\nmodule.exports = BaseClient;\n__webpack_require__(10);\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvYmFzZWNsaWVudC5qcz9jMDk1Il0sIm5hbWVzIjpbImRlcHJlY2F0ZSIsInRoaW5nIiwicmVwbGFjZW1lbnQiLCJjb25zb2xlIiwibG9nIiwiZXZlbnRIYW5kbGluZyIsInJlcXVpcmUiLCJ1dGlsIiwiY29uZmlnIiwiQmFzZUNsaWVudCIsInN0b3JhZ2UiLCJiYXNlIiwibGVuZ3RoIiwibWFrZVBhdGgiLCJwYXRoIiwicGFydHMiLCJzcGxpdCIsIm1vZHVsZU5hbWUiLCJvbiIsImJpbmQiLCJvbkNoYW5nZSIsIl9maXJlQ2hhbmdlIiwicHJvdG90eXBlIiwiZXh0ZW5kIiwib2JqZWN0Iiwia2V5Iiwic2NvcGUiLCJnZXRMaXN0aW5nIiwibWF4QWdlIiwiUHJvbWlzZSIsInJlamVjdCIsImdldCIsInRoZW4iLCJyIiwic3RhdHVzQ29kZSIsImJvZHkiLCJnZXRBbGwiLCJrZXlzIiwiT2JqZWN0IiwiY2FsbHMiLCJtYXAiLCJvIiwiSlNPTiIsInBhcnNlIiwiZSIsImFsbCIsImdldEZpbGUiLCJkYXRhIiwiY29udGVudFR5cGUiLCJyZXZpc2lvbiIsInN0b3JlRmlsZSIsIm1pbWVUeXBlIiwiYWNjZXNzIiwiY2hlY2tQYXRoUGVybWlzc2lvbiIsIndhcm4iLCJwdXQiLCJnZXRPYmplY3QiLCJzdG9yZU9iamVjdCIsInR5cGVBbGlhcyIsIl9hdHRhY2hUeXBlIiwidmFsaWRhdGlvblJlc3VsdCIsInZhbGlkYXRlIiwidmFsaWQiLCJleGMiLCJzdHJpbmdpZnkiLCJyZW1vdmUiLCJkZWxldGUiLCJjYWNoZSIsInN0cmF0ZWd5IiwidW5kZWZpbmVkIiwiY2FjaGluZyIsInNldCIsImZsdXNoIiwibG9jYWwiLCJldmVudCIsImNoYW5nZUV2ZW50cyIsIm9yaWdpbiIsImZvckVhY2giLCJmaWVsZE5hbWVQcmVmaXgiLCJleGVjIiwiX2VtaXQiLCJfY2xlYW5QYXRoIiwiY2xlYW5QYXRoIiwiZ2V0SXRlbVVSTCIsImNvbm5lY3RlZCIs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Q0Y7QUFDRjtBQUNGLE9BVkQ7QUFXQSxXQUFLb0MsS0FBTCxDQUFXLFFBQVgsRUFBcUJOLEtBQXJCO0FBQ0Q7QUFDRixHQWxib0I7O0FBb2JyQk8sY0FBWTFFLEtBQUsyRSxTQXBiSTs7QUFzYnJCOzs7Ozs7OztBQVFBQyxjQUFZLG9CQUFVckUsSUFBVixFQUFnQjtBQUMxQixRQUFJLE9BQU9BLElBQVAsS0FBaUIsUUFBckIsRUFBK0I7QUFDN0IsWUFBTSw2REFBTjtBQUNEO0FBQ0QsUUFBSSxLQUFLSixPQUFMLENBQWEwRSxTQUFqQixFQUE0QjtBQUMxQnRFLGFBQU8sS0FBS21FLFVBQUwsQ0FBaUIsS0FBS3BFLFFBQUwsQ0FBY0MsSUFBZCxDQUFqQixDQUFQO0FBQ0EsYUFBTyxLQUFLSixPQUFMLENBQWEyRSxNQUFiLENBQW9CQyxJQUFwQixHQUEyQnhFLElBQWxDO0FBQ0QsS0FIRCxNQUdPO0FBQ0wsYUFBT3VELFNBQVA7QUFDRDtBQUNGLEdBeGNvQjs7QUEwY3JCa0IsUUFBTSxnQkFBWTtBQUNoQixXQUFPQyxLQUFLRCxJQUFMLEVBQVA7QUFDRDs7QUE1Y29CLENBQXZCOztBQWdkQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQXlCQTlFLFdBQVdnRixRQUFYLEdBQXNCLFlBQVksQ0FFakMsQ0FGRDs7QUFJQTs7Ozs7Ozs7Ozs7QUFXQTtBQUNBOzs7Ozs7O0FBT0ZDLE9BQU9DLE9BQVAsR0FBaUJsRixVQUFqQjtBQUNBLG1CQUFBSCxDQUFRLEVBQVIiLCJmaWxlIjoiOC5qcyIsInNvdXJjZXNDb250ZW50IjpbIlxuICBmdW5jdGlvbiBkZXByZWNhdGUodGhpbmcsIHJlcGxhY2VtZW50KSB7XG4gICAgY29uc29sZS5sb2coJ1dBUk5JTkc6ICcgKyB0aGluZyArICcgaXMgZGVwcmVjYXRlZC4gVXNlICcgK1xuICAgICAgICAgICAgICAgIHJlcGxhY2VtZW50ICsgJyBpbnN0ZWFkLicpO1xuICB9XG5cbiAgdmFyIGV2ZW50SGFuZGxpbmcgPSByZXF1aXJlKCcuL2V2ZW50aGFuZGxpbmcnKTtcbiAgdmFyIHV0aWwgPSByZXF1aXJlKCcuL3V0aWwnKTtcbiAgdmFyIGNvbmZpZyA9IHJlcXVpcmUoJy4vY29uZmlnJyk7XG4gIHJlcXVpcmUoJy4uL2xpYi9NYXRoLnV1aWQnKTtcblxuXG4gIC8qKlxuICAgKiBDbGFzczogUmVtb3RlU3RvcmFnZS5CYXNlQ2xpZW50XG4gICAqXG4gICAqIFByb3ZpZGVzIGEgaGlnaC1sZXZlbCBpbnRlcmZhY2UgdG8gYWNjZXNzIGRhdGEgYmVsb3cgYSBnaXZlbiByb290IHBhdGguXG4gICAqXG4gICAqIEEgQmFzZUNsaWVudCBkZWFscyB3aXRoIHRocmVlIHR5cGVzIG9mIGRhdGE6IGZvbGRlcnMsIG9iamVjdHMgYW5kIGZpbGVzLlxuICAgKlxuICAgKiA8Z2V0TGlzdGluZz4gcmV0dXJucyBhIG1hcHBpbmcgb2YgYWxsIGl0ZW1zIHdpdGhpbiBhIGZvbGRlci4gSXRlbXMgdGhhdFxuICAgKiBlbmQgd2l0aCBhIGZvcndhcmQgc2xhc2ggKFwiL1wiKSBhcmUgY2hpbGQgZm9sZGVycy4gRm9yIGluc3RhbmNlOlxuICAgKiB7XG4gICAqICAgJ2ZvbGRlci8nOiB0cnVlLFxuICAgKiAgICdkb2N1bWVudC50eHQnOiB0cnVlXG4gICAqIH1cbiAgICpcbiAgICogPGdldE9iamVjdD4gLyA8c3RvcmVPYmplY3Q+IG9wZXJhdGUgb24gSlNPTiBvYmplY3RzLiBFYWNoIG9iamVjdCBoYXMgYSB0eXBlLlxuICAgKlxuICAgKiA8Z2V0RmlsZT4gLyA8c3RvcmVGaWxlPiBvcGVyYXRlcyBvbiBmaWxlcy4gRWFjaCBmaWxlIGhhcyBhIE1JTUUgdHlwZS5cbiAgICpcbiAgICogPHJlbW92ZT4gb3BlcmF0ZXMgb24gZWl0aGVyIG9iamVjdHMgb3IgZmlsZXMgKGJ1dCBub3QgZm9sZGVycywgZm9sZGVycyBhcmVcbiAgICogY3JlYXRlZCBhbmQgcmVtb3ZlZCBpbXBsaWN0bHkpLlxuICAgKi9cbiAgdmFyIEJhc2VDbGllbnQgPSBmdW5jdGlvbiAoc3RvcmFnZSwgYmFzZSkge1xuICAgIGlmIChiYXNlW2Jhc2UubGVuZ3RoIC0gMV0gIT09ICcvJykge1xuICAgICAgdGhyb3cgXCJOb3QgYSBmb2xkZXI6IFwiICsgYmFzZTtcbiAgICB9XG5cbiAgICBpZiAoYmFzZSA9PT0gJy8nKSB7XG4gICAgICAvLyBhbGxvdyBhYnNvbHV0ZSBhbmQgcmVsYXRpdmUgcGF0aHMgZm9yIHRoZSByb290IHNjb3BlLlxuICAgICAgdGhpcy5tYWtlUGF0aCA9IGZ1bmN0aW9uIChwYXRoKSB7XG4gICAgICAgIHJldHVybiAocGF0aFswXSA9PT0gJy8nID8gJycgOiAnLycpICsgcGF0aDtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUHJvcGVydHk6IHN0b3JhZ2VcbiAgICAgKlxuICAgICAqIFRoZSA8UmVtb3RlU3RvcmFnZT4gaW5zdGFuY2UgdGhpcyA8QmFzZUNsaWVudD4gb3BlcmF0ZXMgb24uXG4gICAgICovXG4gICAgdGhpcy5zdG9yYWdlID0gc3RvcmFnZTtcblxuICAgIC8qKlxuICAgICAqIFByb3BlcnR5OiBiYXNlXG4gICAgICpcbiAgICAgKiBCYXNlIHBhdGggdGhpcyA8QmFzZUNsaWVudD4gb3BlcmF0ZXMgb24uXG4gICAgICpcbiAgICAgKiBGb3IgdGhlIG1vZHVsZSdzIHByaXZhdGVDbGllbnQgdGhpcyB3b3VsZCBiZSAvPG1vZHVsZU5hbWU+LywgZm9yIHRoZVxuICAgICAqIGNvcnJlc3BvbmRpbmcgcHVibGljQ2xpZW50IC9wdWJsaWMvPG1vZHVsZU5hbWU+Ly5cbiAgICAgKi9cbiAgICB0aGlzLmJhc2UgPSBiYXNlO1xuXG4gICAgdmFyIHBhcnRzID0gdGhpcy5iYXNlLnNwbGl0KCcvJyk7XG4gICAgaWYgKHBhcnRzLmxlbmd0aCA+IDIpIHtcbiAgICAgIHRoaXMubW9kdWxlTmFtZSA9IHBhcnRzWzFdO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLm1vZHVsZU5hbWUgPSAncm9vdCc7XG4gICAgfVxuXG4gICAgLy8gRGVmaW5lZCBpbiBiYXNlY2xpZW50L3R5cGVzLmpzXG4gICAgLyoqXG4gICAgICogUHJvcGVydHk6IHNjaGVtYXNcbiAgICAgKlxuICAgICAqIENvbnRhaW5zIHNjaGVtYSBvYmplY3RzIG9mIGFsbCB0eXBlcyBrbm93biB0byB0aGUgQmFzZUNsaWVudCBpbnN0YW5jZVxuICAgICAqKi9cblxuICAgIC8qKlxuICAgICAqIEV2ZW50OiBjaGFuZ2VcbiAgICAgKlxuICAgICAqIEVtaXR0ZWQgd2hlbiBhIG5vZGUgY2hhbmdlc1xuICAgICAqXG4gICAgICogQXJndW1lbnRzOlxuICAgICAqICAgZXZlbnQgLSBFdmVudCBvYmplY3QgY29udGFpbmluZyBpbmZvcm1hdGlvbiBhYm91dCB0aGUgY2hhbmdlZCBub2RlXG4gICAgICpcbiAgICAgKiAoc3RhcnQgY29kZSlcbiAgICAgKiB7XG4gICAgICogICAgcGF0aDogcGF0aCwgLy8gQWJzb2x1dGUgcGF0aCBvZiB0aGUgY2hhbmdlZCBub2RlLCBmcm9tIHRoZSBzdG9yYWdlIHJvb3RcbiAgICAgKiAgICByZWxhdGl2ZVBhdGg6IHJlbGF0aXZlUGF0aCwgLy8gUGF0aCBvZiB0aGUgY2hhbmdlZCBub2RlLCByZWxhdGl2ZSB0byB0aGlzIGJhc2VjbGllbnQncyBzY29wZSByb290XG4gICAgICogICAgb3JpZ2luOiAnd2luZG93JywgJ2xvY2FsJywgJ3JlbW90ZScsIG9yICdjb25mbGljdCcgLy8gZW1pdHRlZCBieSB1c2VyIGFjdGlvbiB3aXRoaW4gdGhlIGFwcCwgbG9jYWwgZGF0YSBzdG9yZSwgcmVtb3RlIHN5bmMsIG9yIHZlcnNpb25pbmcgY29uZmxpY3RzXG4gICAgICogICAgb2xkVmFsdWU6IG9sZEJvZHksIC8vIE9sZCBib2R5IG9mIHRoZSBjaGFuZ2VkIG5vZGUgKGxvY2FsIHZlcnNpb24gaW4gY29uZmxpY3RzOyB1bmRlZmluZWQgaWYgY3JlYXRpb24pXG4gICAgICogICAgbmV3VmFsdWU6IG5ld0JvZHksIC8vIE5ldyBib2R5IG9mIHRoZSBjaGFuZ2VkIG5vZGUgKHJlbW90ZSB2ZXJzaW9uIGluIGNvbmZsaWN0czsgdW5kZWZpbmVkIGlmIGRlbGV0aW9uKVxuICAgICAqICAgIGxhc3RDb21tb25WYWx1ZTogbGFzdENvbW1vblZhbHVlLCAvL21vc3QgcmVjZW50IGtub3duIGNvbW1vbiBhbmNlc3RvciBib2R5IG9mICd5b3VycycgYW5kICd0aGVpcnMnIGluIGNhc2Ugb2YgY29uZmxpY3RcbiAgICAgKiAgICBvbGRDb250ZW50VHlwZTogb2xkQ29udGVudFR5cGUsIC8vIE9sZCBjb250ZW50VHlwZSBvZiB0aGUgY2hhbmdlZCBub2RlICgneW91cnMnIGZvciBjb25mbGljdHM7IHVuZGVmaW5lZCBpZiBjcmVhdGlvbilcbiAgICAgKiAgICBuZXdDb250ZW50VHlwZTogbmV3Q29udGVudFR5cGUsIC8vIE5ldyBjb250ZW50VHlwZSBvZiB0aGUgY2hhbmdlZCBub2RlICgndGhlaXJzJyBmb3IgY29uZmxpY3RzOyB1bmRlZmluZWQgaWYgZGVsZXRpb24pXG4gICAgICogICAgbGFzdENvbW1vbkNvbnRlbnRUeXBlOiBsYXN0Q29tbW9uQ29udGVudFR5cGUgLy8gTW9zdCByZWNlbnQga25vd24gY29tbW9uIGFuY2VzdG9yIGNvbnRlbnRUeXBlIG9mICd5b3VycycgYW5kICd0aGVpcnMnIGluIGNhc2Ugb2YgY29uZmxpY3RcbiAgICAgKiAgfVxuICAgICAqIChlbmQgY29kZSlcbiAgICAgKlxuICAgICAqIEV4YW1wbGUgb2YgYW4gZXZlbnQgd2l0aCBvcmlnaW4gJ2xvY2FsJyAoZmlyZWQgb24gcGFnZSBsb2FkKTpcbiAgICAgKlxuICAgICAqIChzdGFydCBjb2RlKVxuICAgICAqIHtcbiAgICAgKiAgICBwYXRoOiAnL3B1YmxpYy9kZXNpZ24vY29sb3IudHh0JyxcbiAgICAgKiAgICByZWxhdGl2ZVBhdGg6ICdjb2xvci50eHQnLFxuICAgICAqICAgIG9yaWdpbjogJ2xvY2FsJyxcbiAgICAgKiAgICBvbGRWYWx1ZTogdW5kZWZpbmVkLFxuICAgICAqICAgIG5ld1ZhbHVlOiAnd2hpdGUnLFxuICAgICAqICAgIG9sZENvbnRlbnRUeXBlOiB1bmRlZmluZWQsXG4gICAgICogICAgbmV3Q29udGVudFR5cGU6ICd0ZXh0L3BsYWluJ1xuICAgICAqICB9XG4gICAgICogKGVuZCBjb2RlKVxuICAgICAqXG4gICAgICogRXhhbXBsZSBvZiBhIGNvbmZsaWN0OlxuICAgICAqIFNheSB5b3UgY2hhbmdlZCAnY29sb3IudHh0JyBmcm9tICd3aGl0ZScgdG8gJ2JsdWUnOyBpZiB5b3UgaGF2ZSBzZXQgYFJlbW90ZVN0b3JhZ2UuY29uZmlnLmNoYW5nZUV2ZW50cy53aW5kb3dgIHRvIGB0cnVlYCxcbiAgICAgKiB0aGVuIHlvdSB3aWxsIHJlY2VpdmU6XG4gICAgICpcbiAgICAgKiAoc3RhcnQgY29kZSlcbiAgICAgKiB7XG4gICAgICogICAgcGF0aDogJy9wdWJsaWMvZGVzaWduL2NvbG9yLnR4dCcsXG4gICAgICogICAgcmVsYXRpdmVQYXRoOiAnY29sb3IudHh0JyxcbiAgICAgKiAgICBvcmlnaW46ICd3aW5kb3cnLFxuICAgICAqICAgIG9sZFZhbHVlOiAnd2hpdGUnLFxuICAgICAqICAgIG5ld1ZhbHVlOiAnYmx1ZScsXG4gICAgICogICAgb2xkQ29udGVudFR5cGU6ICd0ZXh0L3BsYWluJyxcbiAgICAgKiAgICBuZXdDb250ZW50VHlwZTogJ3RleHQvcGxhaW4nXG4gICAgICogIH1cbiAgICAgKiAoZW5kIGNvZGUpXG4gICAgICpcbiAgICAgKiBCdXQgd2hlbiB0aGlzIGNoYW5nZSBpcyBwdXNoZWQgb3V0IGJ5IGFzeW5jaHJvbm91cyBzeW5jaHJvbml6YXRpb24sIHRoaXMgY2hhbmdlIG1heSByZWplY3RlZCBieSB0aGVcbiAgICAgKiBzZXJ2ZXIsIGlmIHRoZSByZW1vdGUgdmVyc2lvbiBoYXMgaW4gdGhlIG1lYW50aW1lIGNoYW5nZWQgZnJvbSAnd2hpdGUnIHRvICBmb3IgaW5zdGFuY2UgJ3JlZCc7IHRoaXMgd2lsbCB0aGVuIGxlYWQgdG8gYSBjaGFuZ2VcbiAgICAgKiBldmVudCB3aXRoIG9yaWdpbiAnY29uZmxpY3QnICh1c3VhbGx5IGEgZmV3IHNlY29uZHMgYWZ0ZXIgdGhlIGV2ZW50IHdpdGggb3JpZ2luICd3aW5kb3cnLCBpZiB5b3UgaGFkIHRoYXQgYWN0aXZhdGVkKS4gTm90ZVxuICAgICAqIHRoYXQgc2luY2UgeW91IGFscmVhZHkgY2hhbmdlZCBpdCBmcm9tICd3aGl0ZScgdG8gJ2JsdWUnIGluIHRoZSBsb2NhbCB2ZXJzaW9uIGEgZmV3IHNlY29uZHMgYWdvLCBgb2xkVmFsdWVgIGlzIG5vdyB5b3VyIGxvY2FsXG4gICAgICogdmFsdWUgb2YgJ2JsdWUnOlxuICAgICAqXG4gICAgICogKHN0YXJ0IGNvZGUpXG4gICAgICoge1xuICAgICAqICAgIHBhdGg6ICcvcHVibGljL2Rlc2lnbi9jb2xvci50eHQnLFxuICAgICAqICAgIHJlbGF0aXZlUGF0aDogJ2NvbG9yLnR4dCcsXG4gICAgICogICAgb3JpZ2luOiAnY29uZmxpY3QnLFxuICAgICAqICAgIG9sZFZhbHVlOiAnYmx1ZScsXG4gICAgICogICAgbmV3VmFsdWU6ICdyZWQnLFxuICAgICAqICAgIGxhc3RDb21tb25WYWx1ZTogJ3doaXRlJyxcbiAgICAgKiAgICBvbGRDb250ZW50VHlwZTogJ3RleHQvcGxhaW4sXG4gICAgICogICAgbmV3Q29udGVudFR5cGU6ICd0ZXh0L3BsYWluJ1xuICAgICAqICAgIGxhc3RDb21tb25Db250ZW50VHlwZTogJ3RleHQvcGxhaW4nXG4gICAgICogIH1cbiAgICAgKiAoZW5kIGNvZGUpXG4gICAgICpcbiAgICAgKiBJbiBwcmFjdGljZSwgeW91IHNob3VsZCBhbHdheXMgcmVkcmF3IHlvdXIgdmlld3MgdG8gZGlzcGxheSB0aGUgY29udGVudCBvZiB0aGUgYG5ld1ZhbHVlYCBmaWVsZCB3aGVuIGEgY2hhbmdlIGV2ZW50IGlzIHJlY2VpdmVkLFxuICAgICAqIHJlZ2FyZGxlc3Mgb2YgaXRzIG9yaWdpbi4gRXZlbnRzIHdpdGggb3JpZ2luICdsb2NhbCcgYXJlIGZpcmVkIGNvbnZlbmllbnRseSBkdXJpbmcgdGhlIHBhZ2UgbG9hZCwgc28gdGhhdCB5b3UgY2FuIGZpbGwgeW91ciB2aWV3c1xuICAgICAqIHdoZW4gdGhlIHBhZ2UgbG9hZHMuIEV2ZW50cyB3aXRoIG9yaWdpbiAnd2luZG93JyBhcmUgZmlyZWQgd2hlbmV2ZXIgeW91IGNoYW5nZSBhIHZhbHVlIGJ5IGNhbGxpbmcgYSBtZXRob2Qgb24gdGhlIGJhc2VDbGllbnQ7XG4gICAgICogdGhlc2UgYXJlIGRpc2FibGVkIGJ5IGRlZmF1bHQuIEV2ZW50cyB3aXRoIG9yaWdpbiAncmVtb3RlJyBhcmUgZmlyZWQgd2hlbiByZW1vdGUgY2hhbmdlcyBhcmUgZGlzY292ZXJlZCBkdXJpbmcgc3luYyAob25seSBmb3IgY2FjaGluZ1xuICAgICAqIHN0YXJ0ZWdpZXMgJ1NFRU4nIGFuZCAnQUxMJykuIEV2ZW50cyB3aXRoIG9yaWdpbiAnY29uZmxpY3QnIGFyZSBmaXJlZCB3aGVuIGEgY29uZmxpY3Qgb2NjdXJzIHdoaWxlIHB1c2hpbmcgb3V0IHlvdXIgbG9jYWwgY2hhbmdlcyB0b1xuICAgICAqIHRoZSByZW1vdGUgc3RvcmUgaW4gYXN5bmNocm9ub3VzIHN5bmNocm9uaXphdGlvbiAoc2VlIGV4YW1wbGUgYWJvdmUpLlxuICAgICAqKi9cblxuICAgIGV2ZW50SGFuZGxpbmcodGhpcywgJ2NoYW5nZScpO1xuICAgIHRoaXMub24gPSB0aGlzLm9uLmJpbmQodGhpcyk7XG4gICAgc3RvcmFnZS5vbkNoYW5nZSh0aGlzLmJhc2UsIHRoaXMuX2ZpcmVDaGFuZ2UuYmluZCh0aGlzKSk7XG4gIH07XG5cbiAgQmFzZUNsaWVudC5wcm90b3R5cGUgPSB7XG5cbiAgICBleHRlbmQ6IGZ1bmN0aW9uIChvYmplY3QpIHtcbiAgICAgIGZvciAodmFyIGtleSBpbiBvYmplY3QpIHtcbiAgICAgICAgdGhpc1trZXldID0gb2JqZWN0W2tleV07XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTWV0aG9kOiBzY29wZVxuICAgICAqXG4gICAgICogUmV0dXJucyBhIG5ldyA8QmFzZUNsaWVudD4gb3BlcmF0aW5nIG9uIGEgc3VicGF0aCBvZiB0aGUgY3VycmVudCA8YmFzZT4gcGF0aC5cbiAgICAgKi9cbiAgICBzY29wZTogZnVuY3Rpb24gKHBhdGgpIHtcbiAgICAgIHJldHVybiBuZXcgQmFzZUNsaWVudCh0aGlzLnN0b3JhZ2UsIHRoaXMubWFrZVBhdGgocGF0aCkpO1xuICAgIH0sXG5cbiAgICAvLyBmb2xkZXIgb3BlcmF0aW9uc1xuXG4gICAgLyoqXG4gICAgICogTWV0aG9kOiBnZXRMaXN0aW5nXG4gICAgICpcbiAgICAgKiBHZXQgYSBsaXN0IG9mIGNoaWxkIG5vZGVzIGJlbG93IGEgZ2l2ZW4gcGF0aC5cbiAgICAgKlxuICAgICAqIFRoZSBjYWxsYmFjayBzZW1hbnRpY3Mgb2YgZ2V0TGlzdGluZyBhcmUgaWRlbnRpY2FsIHRvIHRob3NlIG9mIGdldE9iamVjdC5cbiAgICAgKlxuICAgICAqIFBhcmFtZXRlcnM6XG4gICAgICogICBwYXRoICAgLSBUaGUgcGF0aCB0byBxdWVyeS4gSXQgTVVTVCBlbmQgd2l0aCBhIGZvcndhcmQgc2xhc2guXG4gICAgICogICBtYXhBZ2UgLSBFaXRoZXIgZmFsc2Ugb3IgdGhlIG1heGltdW0gYWdlIG9mIGNhY2hlZCBsaXN0aW5nIGluXG4gICAgICogICAgICAgICAgICBtaWxsaXNlY29uZHMuIERlZmF1bHRzIHRvIGZhbHNlIGluIGFub255bW91cyBtb2RlIGFuZCB0b1xuICAgICAqICAgICAgICAgICAgMipzeW5jSW50ZXJ2YWwgaW4gY29ubmVjdGVkIG1vZGUuXG4gICAgICpcbiAgICAgKiBSZXR1cm5zOlxuICAgICAqXG4gICAgICogICBBIHByb21pc2UgZm9yIGFuIG9iamVjdCwgcmVwcmVzZW50aW5nIGNoaWxkIG5vZGVzLiBJZiB0aGUgbWF4QWdlXG4gICAgICogICByZXF1aXJlbWVudCBjYW5ub3QgYmUgbWV0IGJlY2F1c2Ugb2YgbmV0d29yayBwcm9ibGVtcywgdGhpcyBwcm9taXNlXG4gICAgICogICB3aWxsIGJlIHJlamVjdGVkLiBJZiB0aGUgbWF4QWdlIHJlcXVpcmVtZW50IGlzIHNldCB0byBmYWxzZSBvciB0aGVcbiAgICAgKiAgIGxpYnJhcnkgaXMgaW4gb2ZmbGluZSBzdGF0ZSwgdGhlIHByb21pc2Ugd2lsbCBhbHdheXMgYmUgZnVsZmlsbGVkIHdpdGhcbiAgICAgKiAgIGRhdGEgZnJvbSB0aGUgbG9jYWwgc3RvcmUuXG4gICAgICpcbiAgICAgKiAgIEtleXMgZW5kaW5nIGluIGEgZm9yd2FyZCBzbGFzaCByZXByZXNlbnQgKmZvbGRlciBub2RlcyosIHdoaWxlIGFsbFxuICAgICAqICAgb3RoZXIga2V5cyByZXByZXNlbnQgKmRhdGEgbm9kZXMqLlxuICAgICAqXG4gICAgICogICBGb3Igc3BlYyB2ZXJzaW9ucyA8PSAwMSwgdGhlIGRhdGEgbm9kZSBpbmZvcm1hdGlvbiB3aWxsIGNvbnRhaW4gb25seVxuICAgICAqICAgdGhlIGl0ZW0ncyBFVGFnLiBGb3IgbGF0ZXIgc3BlYyB2ZXJzaW9ucywgaXQgd2lsbCBhbHNvIGNvbnRhaW4gdGhlXG4gICAgICogICBjb250ZW50IHR5cGUgYW5kIC1sZW5ndGggb2YgdGhlIGl0ZW0uXG4gICAgICpcbiAgICAgKiBFeGFtcGxlOlxuICAgICAqICAgKHN0YXJ0IGNvZGUpXG4gICAgICogICBjbGllbnQuZ2V0TGlzdGluZygnJywgZmFsc2UpLnRoZW4oZnVuY3Rpb24gKGxpc3RpbmcpIHtcbiAgICAgKiAgICAgLy8gbGlzdGluZyBpcyBmb3IgaW5zdGFuY2U6XG4gICAgICogICAgIC8vIHtcbiAgICAgKiAgICAgLy8gICAnZm9sZGVyLyc6IHRydWUsXG4gICAgICogICAgIC8vICAgJ2RvY3VtZW50LnR4dCc6IHRydWVcbiAgICAgKiAgICAgLy8gfVxuICAgICAqICAgfSk7XG4gICAgICogICAoZW5kIGNvZGUpXG4gICAgICovXG4gICAgZ2V0TGlzdGluZzogZnVuY3Rpb24gKHBhdGgsIG1heEFnZSkge1xuICAgICAgaWYgKHR5cGVvZihwYXRoKSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgcGF0aCA9ICcnO1xuICAgICAgfSBlbHNlIGlmIChwYXRoLmxlbmd0aCA+IDAgJiYgcGF0aFtwYXRoLmxlbmd0aCAtIDFdICE9PSAnLycpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KFwiTm90IGEgZm9sZGVyOiBcIiArIHBhdGgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuc3RvcmFnZS5nZXQodGhpcy5tYWtlUGF0aChwYXRoKSwgbWF4QWdlKS50aGVuKFxuICAgICAgICBmdW5jdGlvbiAocikge1xuICAgICAgICAgIHJldHVybiAoci5zdGF0dXNDb2RlID09PSA0MDQpID8ge30gOiByLmJvZHk7XG4gICAgICAgIH1cbiAgICAgICk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1ldGhvZDogZ2V0QWxsXG4gICAgICpcbiAgICAgKiBHZXQgYWxsIG9iamVjdHMgZGlyZWN0bHkgYmVsb3cgYSBnaXZlbiBwYXRoLlxuICAgICAqXG4gICAgICogUGFyYW1ldGVyczpcbiAgICAgKiAgIHBhdGggICAtIFBhdGggdG8gdGhlIGZvbGRlci5cbiAgICAgKiAgIG1heEFnZSAtIEVpdGhlciBmYWxzZSBvciB0aGUgbWF4aW11bSBhZ2Ugb2YgY2FjaGVkIG9iamVjdHMgaW5cbiAgICAgKiAgICAgICAgICAgIG1pbGxpc2Vjb25kcy4gRGVmYXVsdHMgdG8gZmFsc2UgaW4gYW5vbnltb3VzIG1vZGUgYW5kIHRvXG4gICAgICogICAgICAgICAgICAyKnN5bmNJbnRlcnZhbCBpbiBjb25uZWN0ZWQgbW9kZS5cbiAgICAgKlxuICAgICAqIFJldHVybnM6XG4gICAgICogICBBIHByb21pc2UgZm9yIGFuIG9iamVjdCBpbiB0aGUgZm9ybSB7IHBhdGggOiBvYmplY3QsIC4uLiB9LiBJZiB0aGVcbiAgICAgKiAgIG1heEFnZSByZXF1aXJlbWVudCBjYW5ub3QgYmUgbWV0IGJlY2F1c2Ugb2YgbmV0d29yayBwcm9ibGVtcywgdGhpc1xuICAgICAqICAgcHJvbWlzZSB3aWxsIGJlIHJlamVjdGVkLiBJZiB0aGUgbWF4QWdlIHJlcXVpcmVtZW50IGlzIHNldCB0byBmYWxzZSxcbiAgICAgKiAgIHRoZSBwcm9taXNlIHdpbGwgYWx3YXlzIGJlIGZ1bGZpbGxlZCB3aXRoIGRhdGEgZnJvbSB0aGUgbG9jYWwgc3RvcmUuXG4gICAgICpcbiAgICAgKiAgIEZvciBpdGVtcyB0aGF0IGFyZSBub3QgSlNPTi1zdHJpbmdpZmllZCBvYmplY3RzIChlLmcuIHN0b3JlZCB1c2luZ1xuICAgICAqICAgYHN0b3JlRmlsZWAgaW5zdGVhZCBvZiBgc3RvcmVPYmplY3RgKSwgdGhlIG9iamVjdCdzIHZhbHVlIGlzIGZpbGxlZCBpblxuICAgICAqICAgd2l0aCBgdHJ1ZWAuXG4gICAgICpcbiAgICAgKiBFeGFtcGxlOlxuICAgICAqICAgKHN0YXJ0IGNvZGUpXG4gICAgICogICBjbGllbnQuZ2V0QWxsKCcnLCBmYWxzZSkudGhlbihmdW5jdGlvbiAob2JqZWN0cykge1xuICAgICAqICAgICBmb3IgKHZhciBrZXkgaW4gb2JqZWN0cykge1xuICAgICAqICAgICAgIGNvbnNvbGUubG9nKCctICcgKyBrZXkgKyAnOiAnLCBvYmplY3RzW2tleV0pO1xuICAgICAqICAgICB9XG4gICAgICogICB9KTtcbiAgICAgKiAgIChlbmQgY29kZSlcbiAgICAgKi9cbiAgICBnZXRBbGw6IGZ1bmN0aW9uIChwYXRoLCBtYXhBZ2UpIHtcbiAgICAgIGlmICh0eXBlb2YocGF0aCkgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHBhdGggPSAnJztcbiAgICAgIH0gZWxzZSBpZiAocGF0aC5sZW5ndGggPiAwICYmIHBhdGhbcGF0aC5sZW5ndGggLSAxXSAhPT0gJy8nKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChcIk5vdCBhIGZvbGRlcjogXCIgKyBwYXRoKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMuc3RvcmFnZS5nZXQodGhpcy5tYWtlUGF0aChwYXRoKSwgbWF4QWdlKS50aGVuKGZ1bmN0aW9uIChyKSB7XG4gICAgICAgIGlmIChyLnN0YXR1c0NvZGUgPT09IDQwNCkgeyByZXR1cm4ge307IH1cbiAgICAgICAgaWYgKHR5cGVvZihyLmJvZHkpID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMoci5ib2R5KTtcbiAgICAgICAgICBpZiAoa2V5cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIC8vIHRyZWF0IHRoaXMgbGlrZSA0MDQuIGl0IHByb2JhYmx5IG1lYW5zIGEgZm9sZGVyIGxpc3RpbmcgdGhhdFxuICAgICAgICAgICAgLy8gaGFzIGNoYW5nZXMgdGhhdCBoYXZlbid0IGJlZW4gcHVzaGVkIG91dCB5ZXQuXG4gICAgICAgICAgICByZXR1cm4ge307XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIGNhbGxzID0ga2V5cy5tYXAoZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3RvcmFnZS5nZXQodGhpcy5tYWtlUGF0aChwYXRoICsga2V5KSwgbWF4QWdlKVxuICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbiAobykge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2Yoby5ib2R5KSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIG8uYm9keSA9IEpTT04ucGFyc2Uoby5ib2R5KTtcbiAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZihvLmJvZHkpID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgICAgci5ib2R5W2tleV0gPSBvLmJvZHk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICB9LmJpbmQodGhpcykpO1xuICAgICAgICAgIHJldHVybiBQcm9taXNlLmFsbChjYWxscykudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gci5ib2R5O1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9LmJpbmQodGhpcykpO1xuICAgIH0sXG5cbiAgICAvLyBmaWxlIG9wZXJhdGlvbnNcblxuICAgIC8qKlxuICAgICAqIE1ldGhvZDogZ2V0RmlsZVxuICAgICAqXG4gICAgICogR2V0IHRoZSBmaWxlIGF0IHRoZSBnaXZlbiBwYXRoLiBBIGZpbGUgaXMgcmF3IGRhdGEsIGFzIG9wcG9zZWQgdG9cbiAgICAgKiBhIEpTT04gb2JqZWN0ICh1c2UgPGdldE9iamVjdD4gZm9yIHRoYXQpLlxuICAgICAqXG4gICAgICogRXhjZXB0IGZvciB0aGUgcmV0dXJuIHZhbHVlIHN0cnVjdHVyZSwgZ2V0RmlsZSB3b3JrcyBleGFjdGx5IGxpa2VcbiAgICAgKiBnZXRPYmplY3QuXG4gICAgICpcbiAgICAgKiBQYXJhbWV0ZXJzOlxuICAgICAqICAgcGF0aCAgIC0gU2VlIGdldE9iamVjdC5cbiAgICAgKiAgIG1heEFnZSAtIEVpdGhlciBmYWxzZSBvciB0aGUgbWF4aW11bSBhZ2Ugb2YgY2FjaGVkIGZpbGUgaW5cbiAgICAgKiAgICAgICAgICAgIG1pbGxpc2Vjb25kcy4gRGVmYXVsdHMgdG8gZmFsc2UgaW4gYW5vbnltb3VzIG1vZGUgYW5kIHRvXG4gICAgICogICAgICAgICAgICAyKnN5bmNJbnRlcnZhbCBpbiBjb25uZWN0ZWQgbW9kZS5cbiAgICAgKlxuICAgICAqIFJldHVybnM6XG4gICAgICogICBBIHByb21pc2UgZm9yIGFuIG9iamVjdDpcbiAgICAgKlxuICAgICAqICAgbWltZVR5cGUgLSBTdHJpbmcgcmVwcmVzZW50aW5nIHRoZSBNSU1FIFR5cGUgb2YgdGhlIGRvY3VtZW50LlxuICAgICAqICAgZGF0YSAgICAgLSBSYXcgZGF0YSBvZiB0aGUgZG9jdW1lbnQgKGVpdGhlciBhIHN0cmluZyBvciBhbiBBcnJheUJ1ZmZlcilcbiAgICAgKlxuICAgICAqICAgSWYgdGhlIG1heEFnZSByZXF1aXJlbWVudCBjYW5ub3QgYmUgbWV0IGJlY2F1c2Ugb2YgbmV0d29yayBwcm9ibGVtcywgdGhpc1xuICAgICAqICAgcHJvbWlzZSB3aWxsIGJlIHJlamVjdGVkLiBJZiB0aGUgbWF4QWdlIHJlcXVpcmVtZW50IGlzIHNldCB0byBmYWxzZSwgdGhlXG4gICAgICogICBwcm9taXNlIHdpbGwgYWx3YXlzIGJlIGZ1bGZpbGxlZCB3aXRoIGRhdGEgZnJvbSB0aGUgbG9jYWwgc3RvcmUuXG4gICAgICpcbiAgICAgKiBFeGFtcGxlOlxuICAgICAqICAgKHN0YXJ0IGNvZGUpXG4gICAgICogICAvLyBEaXNwbGF5IGFuIGltYWdlOlxuICAgICAqICAgY2xpZW50LmdldEZpbGUoJ3BhdGgvdG8vc29tZS9pbWFnZScsIGZhbHNlKS50aGVuKGZ1bmN0aW9uIChmaWxlKSB7XG4gICAgICogICAgIHZhciBibG9iID0gbmV3IEJsb2IoW2ZpbGUuZGF0YV0sIHsgdHlwZTogZmlsZS5taW1lVHlwZSB9KTtcbiAgICAgKiAgICAgdmFyIHRhcmdldEVsZW1lbnQgPSBkb2N1bWVudC5maW5kRWxlbWVudEJ5SWQoJ215LWltYWdlLWVsZW1lbnQnKTtcbiAgICAgKiAgICAgdGFyZ2V0RWxlbWVudC5zcmMgPSB3aW5kb3cuVVJMLmNyZWF0ZU9iamVjdFVSTChibG9iKTtcbiAgICAgKiAgIH0pO1xuICAgICAqICAgKGVuZCBjb2RlKVxuICAgICAqL1xuICAgIGdldEZpbGU6IGZ1bmN0aW9uIChwYXRoLCBtYXhBZ2UpIHtcbiAgICAgIGlmICh0eXBlb2YocGF0aCkgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdCgnQXJndW1lbnQgXFwncGF0aFxcJyBvZiBiYXNlQ2xpZW50LmdldEZpbGUgbXVzdCBiZSBhIHN0cmluZycpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuc3RvcmFnZS5nZXQodGhpcy5tYWtlUGF0aChwYXRoKSwgbWF4QWdlKS50aGVuKGZ1bmN0aW9uIChyKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgZGF0YTogci5ib2R5LFxuICAgICAgICAgIGNvbnRlbnRUeXBlOiByLmNvbnRlbnRUeXBlLFxuICAgICAgICAgIHJldmlzaW9uOiByLnJldmlzaW9uIC8vICh0aGlzIGlzIG5ldylcbiAgICAgICAgfTtcbiAgICAgIH0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNZXRob2Q6IHN0b3JlRmlsZVxuICAgICAqXG4gICAgICogU3RvcmUgcmF3IGRhdGEgYXQgYSBnaXZlbiBwYXRoLlxuICAgICAqXG4gICAgICogUGFyYW1ldGVyczpcbiAgICAgKiAgIG1pbWVUeXBlIC0gTUlNRSBtZWRpYSB0eXBlIG9mIHRoZSBkYXRhIGJlaW5nIHN0b3JlZFxuICAgICAqICAgcGF0aCAgICAgLSBwYXRoIHJlbGF0aXZlIHRvIHRoZSBtb2R1bGUgcm9vdC4gTUFZIE5PVCBlbmQgaW4gYSBmb3J3YXJkIHNsYXNoLlxuICAgICAqICAgZGF0YSAgICAgLSBzdHJpbmcsIEFycmF5QnVmZmVyIG9yIEFycmF5QnVmZmVyVmlldyBvZiByYXcgZGF0YSB0byBzdG9yZVxuICAgICAqXG4gICAgICogVGhlIGdpdmVuIG1pbWVUeXBlIHdpbGwgbGF0ZXIgYmUgcmV0dXJuZWQsIHdoZW4gcmV0cmlldmluZyB0aGUgZGF0YVxuICAgICAqIHVzaW5nIDxnZXRGaWxlPi5cbiAgICAgKlxuICAgICAqIEV4YW1wbGUgKFVURi04IGRhdGEpOlxuICAgICAqICAgKHN0YXJ0IGNvZGUpXG4gICAgICogICBjbGllbnQuc3RvcmVGaWxlKCd0ZXh0L2h0bWwnLCAnaW5kZXguaHRtbCcsICc8aDE+SGVsbG8gV29ybGQhPC9oMT4nKTtcbiAgICAgKiAgIChlbmQgY29kZSlcbiAgICAgKlxuICAgICAqIEV4YW1wbGUgKEJpbmFyeSBkYXRhKTpcbiAgICAgKiAgIChzdGFydCBjb2RlKVxuICAgICAqICAgLy8gTUFSS1VQOlxuICAgICAqICAgPGlucHV0IHR5cGU9XCJmaWxlXCIgaWQ9XCJmaWxlLWlucHV0XCI+XG4gICAgICogICAvLyBDT0RFOlxuICAgICAqICAgdmFyIGlucHV0ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2ZpbGUtaW5wdXQnKTtcbiAgICAgKiAgIHZhciBmaWxlID0gaW5wdXQuZmlsZXNbMF07XG4gICAgICogICB2YXIgZmlsZVJlYWRlciA9IG5ldyBGaWxlUmVhZGVyKCk7XG4gICAgICpcbiAgICAgKiAgIGZpbGVSZWFkZXIub25sb2FkID0gZnVuY3Rpb24gKCkge1xuICAgICAqICAgICBjbGllbnQuc3RvcmVGaWxlKGZpbGUudHlwZSwgZmlsZS5uYW1lLCBmaWxlUmVhZGVyLnJlc3VsdCk7XG4gICAgICogICB9O1xuICAgICAqXG4gICAgICogICBmaWxlUmVhZGVyLnJlYWRBc0FycmF5QnVmZmVyKGZpbGUpO1xuICAgICAqICAgKGVuZCBjb2RlKVxuICAgICAqXG4gICAgICovXG4gICAgc3RvcmVGaWxlOiBmdW5jdGlvbiAobWltZVR5cGUsIHBhdGgsIGJvZHkpIHtcbiAgICAgIGlmICh0eXBlb2YobWltZVR5cGUpICE9PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoJ0FyZ3VtZW50IFxcJ21pbWVUeXBlXFwnIG9mIGJhc2VDbGllbnQuc3RvcmVGaWxlIG11c3QgYmUgYSBzdHJpbmcnKTtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YocGF0aCkgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdCgnQXJndW1lbnQgXFwncGF0aFxcJyBvZiBiYXNlQ2xpZW50LnN0b3JlRmlsZSBtdXN0IGJlIGEgc3RyaW5nJyk7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mKGJvZHkpICE9PSAnc3RyaW5nJyAmJiB0eXBlb2YoYm9keSkgIT09ICdvYmplY3QnKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdCgnQXJndW1lbnQgXFwnYm9keVxcJyBvZiBiYXNlQ2xpZW50LnN0b3JlRmlsZSBtdXN0IGJlIGEgc3RyaW5nLCBBcnJheUJ1ZmZlciwgb3IgQXJyYXlCdWZmZXJWaWV3Jyk7XG4gICAgICB9XG4gICAgICBpZiAoIXRoaXMuc3RvcmFnZS5hY2Nlc3MuY2hlY2tQYXRoUGVybWlzc2lvbih0aGlzLm1ha2VQYXRoKHBhdGgpLCAncncnKSkge1xuICAgICAgICBjb25zb2xlLndhcm4oJ1dBUk5JTkc6IEVkaXRpbmcgYSBkb2N1bWVudCB0byB3aGljaCBvbmx5IHJlYWQgYWNjZXNzIChcXCdyXFwnKSB3YXMgY2xhaW1lZCcpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5zdG9yYWdlLnB1dCh0aGlzLm1ha2VQYXRoKHBhdGgpLCBib2R5LCBtaW1lVHlwZSkudGhlbihmdW5jdGlvbiAocikge1xuICAgICAgICBpZiAoci5zdGF0dXNDb2RlID09PSAyMDAgfHwgci5zdGF0dXNDb2RlID09PSAyMDEpIHtcbiAgICAgICAgICByZXR1cm4gci5yZXZpc2lvbjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoXCJSZXF1ZXN0IChQVVQgXCIgKyB0aGlzLm1ha2VQYXRoKHBhdGgpICsgXCIpIGZhaWxlZCB3aXRoIHN0YXR1czogXCIgKyByLnN0YXR1c0NvZGUpO1xuICAgICAgICB9XG4gICAgICB9LmJpbmQodGhpcykpO1xuICAgIH0sXG5cbiAgICAvLyBvYmplY3Qgb3BlcmF0aW9uc1xuXG4gICAgLyoqXG4gICAgICogTWV0aG9kOiBnZXRPYmplY3RcbiAgICAgKlxuICAgICAqIEdldCBhIEpTT04gb2JqZWN0IGZyb20gZ2l2ZW4gcGF0aC5cbiAgICAgKlxuICAgICAqIFBhcmFtZXRlcnM6XG4gICAgICogICBwYXRoICAgLSBSZWxhdGl2ZSBwYXRoIGZyb20gdGhlIG1vZHVsZSByb290ICh3aXRob3V0IGxlYWRpbmcgc2xhc2gpLlxuICAgICAqICAgbWF4QWdlIC0gRWl0aGVyIGZhbHNlIG9yIHRoZSBtYXhpbXVtIGFnZSBvZiBjYWNoZWQgb2JqZWN0IGluXG4gICAgICogICAgICAgICAgICBtaWxsaXNlY29uZHMuIERlZmF1bHRzIHRvIGZhbHNlIGluIGFub255bW91cyBtb2RlIGFuZCB0b1xuICAgICAqICAgICAgICAgICAgMipzeW5jSW50ZXJ2YWwgaW4gY29ubmVjdGVkIG1vZGUuXG4gICAgICpcbiAgICAgKiBSZXR1cm5zOlxuICAgICAqICAgQSBwcm9taXNlIGZvciB0aGUgb2JqZWN0LiBJZiB0aGUgbWF4QWdlIHJlcXVpcmVtZW50IGNhbm5vdCBiZSBtZXRcbiAgICAgKiAgIGJlY2F1c2Ugb2YgbmV0d29yayBwcm9ibGVtcywgdGhpcyBwcm9taXNlIHdpbGwgYmUgcmVqZWN0ZWQuIElmIHRoZVxuICAgICAqICAgbWF4QWdlIHJlcXVpcmVtZW50IGlzIHNldCB0byBmYWxzZSwgdGhlIHByb21pc2Ugd2lsbCBhbHdheXMgYmVcbiAgICAgKiAgIGZ1bGZpbGxlZCB3aXRoIGRhdGEgZnJvbSB0aGUgbG9jYWwgc3RvcmUuXG4gICAgICpcbiAgICAgKiBFeGFtcGxlOlxuICAgICAqICAgKHN0YXJ0IGNvZGUpXG4gICAgICogICBjbGllbnQuZ2V0T2JqZWN0KCcvcGF0aC90by9vYmplY3QnLCBmYWxzZSkuXG4gICAgICogICAgIHRoZW4oZnVuY3Rpb24gKG9iamVjdCkge1xuICAgICAqICAgICAgIC8vIG9iamVjdCBpcyBlaXRoZXIgYW4gb2JqZWN0IG9yIG51bGxcbiAgICAgKiAgICAgfSk7XG4gICAgICogICAoZW5kIGNvZGUpXG4gICAgICovXG4gICAgZ2V0T2JqZWN0OiBmdW5jdGlvbiAocGF0aCwgbWF4QWdlKSB7XG4gICAgICBpZiAodHlwZW9mKHBhdGgpICE9PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoJ0FyZ3VtZW50IFxcJ3BhdGhcXCcgb2YgYmFzZUNsaWVudC5nZXRPYmplY3QgbXVzdCBiZSBhIHN0cmluZycpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuc3RvcmFnZS5nZXQodGhpcy5tYWtlUGF0aChwYXRoKSwgbWF4QWdlKS50aGVuKGZ1bmN0aW9uIChyKSB7XG4gICAgICAgIGlmICh0eXBlb2Yoci5ib2R5KSA9PT0gJ29iamVjdCcpIHsgLy8gd2lsbCBiZSB0aGUgY2FzZSBmb3IgZG9jdW1lbnRzIHN0b3JlZCB3aXRoIHJzLmpzIDw9IDAuMTAuMC1iZXRhMlxuICAgICAgICAgIHJldHVybiByLmJvZHk7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mKHIuYm9keSkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBKU09OLnBhcnNlKHIuYm9keSk7XG4gICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgdGhyb3cgXCJOb3QgdmFsaWQgSlNPTjogXCIgKyB0aGlzLm1ha2VQYXRoKHBhdGgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2Yoci5ib2R5KSAhPT0gJ3VuZGVmaW5lZCcgJiYgci5zdGF0dXNDb2RlID09PSAyMDApIHtcbiAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoXCJOb3QgYW4gb2JqZWN0OiBcIiArIHRoaXMubWFrZVBhdGgocGF0aCkpO1xuICAgICAgICB9XG4gICAgICB9LmJpbmQodGhpcykpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNZXRob2Q6IHN0b3JlT2JqZWN0XG4gICAgICpcbiAgICAgKiBTdG9yZSBvYmplY3QgYXQgZ2l2ZW4gcGF0aC4gVHJpZ2dlcnMgc3luY2hyb25pemF0aW9uLlxuICAgICAqXG4gICAgICogUGFyYW1ldGVyczpcbiAgICAgKlxuICAgICAqICAgdHlwZSAgICAgLSB1bmlxdWUgdHlwZSBvZiB0aGlzIG9iamVjdCB3aXRoaW4gdGhpcyBtb2R1bGUuIFNlZSBkZXNjcmlwdGlvbiBiZWxvdy5cbiAgICAgKiAgIHBhdGggICAgIC0gcGF0aCByZWxhdGl2ZSB0byB0aGUgbW9kdWxlIHJvb3QuXG4gICAgICogICBvYmplY3QgICAtIGFuIG9iamVjdCB0byBiZSBzYXZlZCB0byB0aGUgZ2l2ZW4gbm9kZS4gSXQgbXVzdCBiZSBzZXJpYWxpemFibGUgYXMgSlNPTi5cbiAgICAgKlxuICAgICAqIFJldHVybnM6XG4gICAgICogICBBIHByb21pc2UgdG8gc3RvcmUgdGhlIG9iamVjdC4gVGhlIHByb21pc2UgZmFpbHMgd2l0aCBhIFZhbGlkYXRpb25FcnJvciwgd2hlbiB2YWxpZGF0aW9ucyBmYWlsLlxuICAgICAqXG4gICAgICpcbiAgICAgKiBXaGF0IGFib3V0IHRoZSB0eXBlPzpcbiAgICAgKlxuICAgICAqICAgQSBncmVhdCB0aGluZyBhYm91dCBoYXZpbmcgZGF0YSBvbiB0aGUgd2ViLCBpcyB0byBiZSBhYmxlIHRvIGxpbmsgdG9cbiAgICAgKiAgIGl0IGFuZCByZWFycmFuZ2UgaXQgdG8gZml0IHRoZSBjdXJyZW50IGNpcmN1bXN0YW5jZXMuIFRvIGZhY2lsaXRhdGVcbiAgICAgKiAgIHRoYXQsIGV2ZW50dWFsbHkgeW91IG5lZWQgdG8ga25vdyBob3cgdGhlIGRhdGEgYXQgaGFuZCBpcyBzdHJ1Y3R1cmVkLlxuICAgICAqICAgRm9yIGRvY3VtZW50cyBvbiB0aGUgd2ViLCB0aGlzIGlzIHVzdWFsbHkgZG9uZSB2aWEgYSBNSU1FIHR5cGUuIFRoZVxuICAgICAqICAgTUlNRSB0eXBlIG9mIEpTT04gb2JqZWN0cyBob3dldmVyLCBpcyBhbHdheXMgYXBwbGljYXRpb24vanNvbi5cbiAgICAgKiAgIFRvIGFkZCB0aGF0IGV4dHJhIGxheWVyIG9mIFwia25vd2luZyB3aGF0IHRoaXMgb2JqZWN0IGlzXCIsIHJlbW90ZVN0b3JhZ2VcbiAgICAgKiAgIGFpbXMgdG8gdXNlIDxKU09OLUxEIGF0IGh0dHA6Ly9qc29uLWxkLm9yZy8+LlxuICAgICAqICAgQSBmaXJzdCBzdGVwIGluIHRoYXQgZGlyZWN0aW9uLCBpcyB0byBhZGQgYSAqQGNvbnRleHQgYXR0cmlidXRlKiB0byBhbGxcbiAgICAgKiAgIEpTT04gZGF0YSBwdXQgaW50byByZW1vdGVTdG9yYWdlLlxuICAgICAqICAgTm93IHRoYXQgaXMgd2hhdCB0aGUgKnR5cGUqIGlzIGZvci5cbiAgICAgKlxuICAgICAqICAgV2l0aGluIHJlbW90ZVN0b3JhZ2UuanMsIEBjb250ZXh0IHZhbHVlcyBhcmUgYnVpbHQgdXNpbmcgdGhyZWUgY29tcG9uZW50czpcbiAgICAgKiAgICAgaHR0cDovL3JlbW90ZXN0b3JhZ2UuaW8vc3BlYy9tb2R1bGVzLyAtIEEgcHJlZml4IHRvIGd1YXJhbnRlZSB1bmlxdWVuZXNzXG4gICAgICogICAgIHRoZSBtb2R1bGUgbmFtZSAgICAgLSBtb2R1bGUgbmFtZXMgc2hvdWxkIGJlIHVuaXF1ZSBhcyB3ZWxsXG4gICAgICogICAgIHRoZSB0eXBlIGdpdmVuIGhlcmUgLSBuYW1pbmcgdGhpcyBwYXJ0aWN1bGFyIGtpbmQgb2Ygb2JqZWN0IHdpdGhpbiB0aGlzIG1vZHVsZVxuICAgICAqXG4gICAgICogICBJbiByZXRyb3NwZWN0IHRoYXQgbWVhbnMsIHRoYXQgd2hlbmV2ZXIgeW91IGludHJvZHVjZSBhIG5ldyBcInR5cGVcIiBpbiBjYWxscyB0b1xuICAgICAqICAgc3RvcmVPYmplY3QsIHlvdSBzaG91bGQgbWFrZSBzdXJlIHRoYXQgb25jZSB5b3VyIGNvZGUgaXMgaW4gdGhlIHdpbGQsIGZ1dHVyZVxuICAgICAqICAgdmVyc2lvbnMgb2YgdGhlIGNvZGUgYXJlIGNvbXBhdGlibGUgd2l0aCB0aGUgc2FtZSBKU09OIHN0cnVjdHVyZS5cbiAgICAgKlxuICAgICAqIEhvdyB0byBkZWZpbmUgdHlwZXM/OlxuICAgICAqXG4gICAgICogICBTZWUgPGRlY2xhcmVUeXBlPiBmb3IgZXhhbXBsZXMuXG4gICAgICovXG4gICAgc3RvcmVPYmplY3Q6IGZ1bmN0aW9uICh0eXBlQWxpYXMsIHBhdGgsIG9iamVjdCkge1xuICAgICAgaWYgKHR5cGVvZih0eXBlQWxpYXMpICE9PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoJ0FyZ3VtZW50IFxcJ3R5cGVBbGlhc1xcJyBvZiBiYXNlQ2xpZW50LnN0b3JlT2JqZWN0IG11c3QgYmUgYSBzdHJpbmcnKTtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YocGF0aCkgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdCgnQXJndW1lbnQgXFwncGF0aFxcJyBvZiBiYXNlQ2xpZW50LnN0b3JlT2JqZWN0IG11c3QgYmUgYSBzdHJpbmcnKTtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2Yob2JqZWN0KSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KCdBcmd1bWVudCBcXCdvYmplY3RcXCcgb2YgYmFzZUNsaWVudC5zdG9yZU9iamVjdCBtdXN0IGJlIGFuIG9iamVjdCcpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9hdHRhY2hUeXBlKG9iamVjdCwgdHlwZUFsaWFzKTtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgdmFyIHZhbGlkYXRpb25SZXN1bHQgPSB0aGlzLnZhbGlkYXRlKG9iamVjdCk7XG4gICAgICAgIGlmICghIHZhbGlkYXRpb25SZXN1bHQudmFsaWQpIHtcbiAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QodmFsaWRhdGlvblJlc3VsdCk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2goZXhjKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChleGMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5zdG9yYWdlLnB1dCh0aGlzLm1ha2VQYXRoKHBhdGgpLCBKU09OLnN0cmluZ2lmeShvYmplY3QpLCAnYXBwbGljYXRpb24vanNvbjsgY2hhcnNldD1VVEYtOCcpLnRoZW4oZnVuY3Rpb24gKHIpIHtcbiAgICAgICAgaWYgKHIuc3RhdHVzQ29kZSA9PT0gMjAwIHx8IHIuc3RhdHVzQ29kZSA9PT0gMjAxKSB7XG4gICAgICAgICAgcmV0dXJuIHIucmV2aXNpb247XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KFwiUmVxdWVzdCAoUFVUIFwiICsgdGhpcy5tYWtlUGF0aChwYXRoKSArIFwiKSBmYWlsZWQgd2l0aCBzdGF0dXM6IFwiICsgci5zdGF0dXNDb2RlKTtcbiAgICAgICAgfVxuICAgICAgfS5iaW5kKHRoaXMpKTtcbiAgICB9LFxuXG4gICAgLy8gZ2VuZXJpYyBvcGVyYXRpb25zXG5cbiAgICAvKipcbiAgICAgKiBNZXRob2Q6IHJlbW92ZVxuICAgICAqXG4gICAgICogUmVtb3ZlIG5vZGUgYXQgZ2l2ZW4gcGF0aCBmcm9tIHN0b3JhZ2UuIFRyaWdnZXJzIHN5bmNocm9uaXphdGlvbi5cbiAgICAgKlxuICAgICAqIFBhcmFtZXRlcnM6XG4gICAgICogICBwYXRoICAgICAtIFBhdGggcmVsYXRpdmUgdG8gdGhlIG1vZHVsZSByb290LlxuICAgICAqL1xuICAgIHJlbW92ZTogZnVuY3Rpb24gKHBhdGgpIHtcbiAgICAgIGlmICh0eXBlb2YocGF0aCkgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdCgnQXJndW1lbnQgXFwncGF0aFxcJyBvZiBiYXNlQ2xpZW50LnJlbW92ZSBtdXN0IGJlIGEgc3RyaW5nJyk7XG4gICAgICB9XG4gICAgICBpZiAoIXRoaXMuc3RvcmFnZS5hY2Nlc3MuY2hlY2tQYXRoUGVybWlzc2lvbih0aGlzLm1ha2VQYXRoKHBhdGgpLCAncncnKSkge1xuICAgICAgICBjb25zb2xlLndhcm4oJ1dBUk5JTkc6IFJlbW92aW5nIGEgZG9jdW1lbnQgdG8gd2hpY2ggb25seSByZWFkIGFjY2VzcyAoXFwnclxcJykgd2FzIGNsYWltZWQnKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMuc3RvcmFnZS5kZWxldGUodGhpcy5tYWtlUGF0aChwYXRoKSk7XG4gICAgfSxcblxuXG4gICAgY2FjaGU6IGZ1bmN0aW9uIChwYXRoLCBzdHJhdGVneSkge1xuICAgICAgaWYgKHR5cGVvZihwYXRoKSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgdGhyb3cgJ0FyZ3VtZW50IFxcJ3BhdGhcXCcgb2YgYmFzZUNsaWVudC5jYWNoZSBtdXN0IGJlIGEgc3RyaW5nJztcbiAgICAgIH1cbiAgICAgIGlmIChzdHJhdGVneSA9PT0gZmFsc2UpIHtcbiAgICAgICAgZGVwcmVjYXRlKCdjYWNoaW5nIHN0cmF0ZWd5IDxmYWxzZT4nLCAnPFwiRkxVU0hcIj4nKTtcbiAgICAgICAgc3RyYXRlZ3kgPSAnRkxVU0gnO1xuICAgICAgfSBlbHNlIGlmIChzdHJhdGVneSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHN0cmF0ZWd5ID0gJ0FMTCc7XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZihzdHJhdGVneSkgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGRlcHJlY2F0ZSgndGhhdCBjYWNoaW5nIHN0cmF0ZWd5JywgJzxcIkFMTFwiPicpO1xuICAgICAgICBzdHJhdGVneSA9ICdBTEwnO1xuICAgICAgfVxuICAgICAgaWYgKHN0cmF0ZWd5ICE9PSAnRkxVU0gnICYmXG4gICAgICAgICAgc3RyYXRlZ3kgIT09ICdTRUVOJyAmJlxuICAgICAgICAgIHN0cmF0ZWd5ICE9PSAnQUxMJykge1xuICAgICAgICB0aHJvdyAnQXJndW1lbnQgXFwnc3RyYXRlZ3lcXCcgb2YgYmFzZWNsaWVudC5jYWNoZSBtdXN0IGJlIG9uZSBvZiAnXG4gICAgICAgICAgICArICdbXCJGTFVTSFwiLCBcIlNFRU5cIiwgXCJBTExcIl0nO1xuICAgICAgfVxuICAgICAgdGhpcy5zdG9yYWdlLmNhY2hpbmcuc2V0KHRoaXMubWFrZVBhdGgocGF0aCksIHN0cmF0ZWd5KTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBmbHVzaDogZnVuY3Rpb24gKHBhdGgpIHtcbiAgICAgIHJldHVybiB0aGlzLnN0b3JhZ2UubG9jYWwuZmx1c2gocGF0aCk7XG4gICAgfSxcblxuICAgIG1ha2VQYXRoOiBmdW5jdGlvbiAocGF0aCkge1xuICAgICAgcmV0dXJuIHRoaXMuYmFzZSArIChwYXRoIHx8ICcnKTtcbiAgICB9LFxuXG4gICAgX2ZpcmVDaGFuZ2U6IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgaWYgKGNvbmZpZy5jaGFuZ2VFdmVudHNbZXZlbnQub3JpZ2luXSkge1xuICAgICAgICBbJ25ldycsICdvbGQnLCAnbGFzdENvbW1vbiddLmZvckVhY2goZnVuY3Rpb24gKGZpZWxkTmFtZVByZWZpeCkge1xuICAgICAgICAgIGlmICgoIWV2ZW50W2ZpZWxkTmFtZVByZWZpeCsnQ29udGVudFR5cGUnXSlcbiAgICAgICAgICAgICAgfHwgKC9eYXBwbGljYXRpb25cXC8oLiopanNvbiguKikvLmV4ZWMoZXZlbnRbZmllbGROYW1lUHJlZml4KydDb250ZW50VHlwZSddKSkpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YoZXZlbnRbZmllbGROYW1lUHJlZml4KydWYWx1ZSddKSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBldmVudFtmaWVsZE5hbWVQcmVmaXgrJ1ZhbHVlJ10gPSBKU09OLnBhcnNlKGV2ZW50W2ZpZWxkTmFtZVByZWZpeCsnVmFsdWUnXSk7XG4gICAgICAgICAgICAgIH0gY2F0Y2goZSkge1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5fZW1pdCgnY2hhbmdlJywgZXZlbnQpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBfY2xlYW5QYXRoOiB1dGlsLmNsZWFuUGF0aCxcblxuICAgIC8qKlxuICAgICAqIE1ldGhvZDogZ2V0SXRlbVVSTFxuICAgICAqXG4gICAgICogUmV0cmlldmUgZnVsbCBVUkwgb2YgaXRlbVxuICAgICAqXG4gICAgICogUGFyYW1ldGVyczpcbiAgICAgKiAgIHBhdGggICAgIC0gUGF0aCByZWxhdGl2ZSB0byB0aGUgbW9kdWxlIHJvb3QuXG4gICAgICovXG4gICAgZ2V0SXRlbVVSTDogZnVuY3Rpb24gKHBhdGgpIHtcbiAgICAgIGlmICh0eXBlb2YocGF0aCkgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRocm93ICdBcmd1bWVudCBcXCdwYXRoXFwnIG9mIGJhc2VDbGllbnQuZ2V0SXRlbVVSTCBtdXN0IGJlIGEgc3RyaW5nJztcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLnN0b3JhZ2UuY29ubmVjdGVkKSB7XG4gICAgICAgIHBhdGggPSB0aGlzLl9jbGVhblBhdGgoIHRoaXMubWFrZVBhdGgocGF0aCkgKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RvcmFnZS5yZW1vdGUuaHJlZiArIHBhdGg7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICB1dWlkOiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gTWF0aC51dWlkKCk7XG4gICAgfVxuXG4gIH07XG5cbiAgLyoqXG4gICAqIE1ldGhvZDogUlMjc2NvcGVcbiAgICpcbiAgICogUmV0dXJucyBhIG5ldyA8UlMuQmFzZUNsaWVudD4gc2NvcGVkIHRvIHRoZSBnaXZlbiBwYXRoLlxuICAgKlxuICAgKiBQYXJhbWV0ZXJzOlxuICAgKiAgIHBhdGggLSBSb290IHBhdGggb2YgbmV3IEJhc2VDbGllbnQuXG4gICAqXG4gICAqXG4gICAqIEV4YW1wbGU6XG4gICAqICAgKHN0YXJ0IGNvZGUpXG4gICAqXG4gICAqICAgdmFyIGZvbyA9IHJlbW90ZVN0b3JhZ2Uuc2NvcGUoJy9mb28vJyk7XG4gICAqXG4gICAqICAgLy8gUFVUcyBkYXRhIFwiYmF6XCIgdG8gcGF0aCAvZm9vL2JhclxuICAgKiAgIGZvby5zdG9yZUZpbGUoJ3RleHQvcGxhaW4nLCAnYmFyJywgJ2JheicpO1xuICAgKlxuICAgKiAgIHZhciBzb21ldGhpbmcgPSBmb28uc2NvcGUoJ3NvbWV0aGluZy8nKTtcbiAgICpcbiAgICogICAvLyBHRVRzIGxpc3RpbmcgZnJvbSBwYXRoIC9mb28vc29tZXRoaW5nL2JsYS9cbiAgICogICBzb21ldGhpbmcuZ2V0TGlzdGluZygnYmxhLycpO1xuICAgKlxuICAgKiAgIChlbmQgY29kZSlcbiAgICpcbiAgICovXG4gIEJhc2VDbGllbnQuX3JzX2luaXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgXG4gIH07XG5cbiAgLyogZS5nLjpcbiAgcmVtb3RlU3RvcmFnZS5kZWZpbmVNb2R1bGUoJ2xvY2F0aW9ucycsIGZ1bmN0aW9uIChwcml2LCBwdWIpIHtcbiAgICByZXR1cm4ge1xuICAgICAgZXhwb3J0czoge1xuICAgICAgICBmZWF0dXJlczogcHJpdi5zY29wZSgnZmVhdHVyZXMvJykuZGVmYXVsdFR5cGUoJ2ZlYXR1cmUnKSxcbiAgICAgICAgY29sbGVjdGlvbnM6IHByaXYuc2NvcGUoJ2NvbGxlY3Rpb25zLycpLmRlZmF1bHRUeXBlKCdmZWF0dXJlLWNvbGxlY3Rpb24nKTtcbiAgICAgIH1cbiAgICB9O1xuICB9KTtcbiAgKi9cblxuICAvLyBEZWZpbmVkIGluIGJhc2VjbGllbnQvdHlwZXMuanNcbiAgLyoqXG4gICAqIE1ldGhvZDogZGVjbGFyZVR5cGVcbiAgICpcbiAgICogRGVjbGFyZSBhIHJlbW90ZVN0b3JhZ2Ugb2JqZWN0IHR5cGUgdXNpbmcgYSBKU09OIHNjaGVtYS4gU2VlXG4gICAqIDxSZW1vdGVTdG9yYWdlLkJhc2VDbGllbnQuVHlwZXM+XG4gICAqKi9cblxubW9kdWxlLmV4cG9ydHMgPSBCYXNlQ2xpZW50O1xucmVxdWlyZSgnLi90eXBlcycpO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9iYXNlY2xpZW50LmpzIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ },
/* 9 */
/***/ function(module, exports) {

	eval("'use strict';\n\n/*!\n  Math.uuid.js (v1.4)\n  http://www.broofa.com\n  mailto:robert@broofa.com\n\n  Copyright (c) 2010 Robert Kieffer\n  Dual licensed under the MIT and GPL licenses.\n\n  ********\n\n  Changes within remoteStorage.js:\n  2012-10-31:\n  - added AMD wrapper <niklas@unhosted.org>\n  - moved extensions for Math object into exported object.\n*/\n\n/*\n * Generate a random uuid.\n *\n * USAGE: Math.uuid(length, radix)\n *   length - the desired number of characters\n *   radix  - the number of allowable values for each character.\n *\n * EXAMPLES:\n *   // No arguments  - returns RFC4122, version 4 ID\n *   >>> Math.uuid()\n *   \"92329D39-6F5C-4520-ABFC-AAB64544E172\"\n *\n *   // One argument - returns ID of the specified length\n *   >>> Math.uuid(15)     // 15 character ID (default base=62)\n *   \"VcydxgltxrVZSTV\"\n *\n *   // Two arguments - returns ID of the specified length, and radix. (Radix must be <= 62)\n *   >>> Math.uuid(8, 2)  // 8 character ID (base=2)\n *   \"01001010\"\n *   >>> Math.uuid(8, 10) // 8 character ID (base=10)\n *   \"47473046\"\n *   >>> Math.uuid(8, 16) // 8 character ID (base=16)\n *   \"098F4D35\"\n */\n// Private array of chars to use\nvar CHARS = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'.split('');\n\nMath.uuid = function (len, radix) {\n  var chars = CHARS,\n      uuid = [],\n      i;\n  radix = radix || chars.length;\n\n  if (len) {\n    // Compact form\n    for (i = 0; i < len; i++) {\n      uuid[i] = chars[0 | Math.random() * radix];\n    }\n  } else {\n    // rfc4122, version 4 form\n    var r;\n\n    // rfc4122 requires these characters\n    uuid[8] = uuid[13] = uuid[18] = uuid[23] = '-';\n    uuid[14] = '4';\n\n    // Fill in random data.  At i==19 set the high bits of clock sequence as\n    // per rfc4122, sec. 4.1.5\n    for (i = 0; i < 36; i++) {\n      if (!uuid[i]) {\n        r = 0 | Math.random() * 16;\n        uuid[i] = chars[i == 19 ? r & 0x3 | 0x8 : r];\n      }\n    }\n  }\n\n  return uuid.join('');\n};\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9saWIvTWF0aC51dWlkLmpzP2Y5NDEiXSwibmFtZXMiOlsiQ0hBUlMiLCJzcGxpdCIsIk1hdGgiLCJ1dWlkIiwibGVuIiwicmFkaXgiLCJjaGFycyIsImkiLCJsZW5ndGgiLCJyYW5kb20iLCJyIiwiam9pbiJdLCJtYXBwaW5ncyI6Ijs7QUFBQTs7Ozs7Ozs7Ozs7Ozs7OztBQWdCQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBd0JFO0FBQ0EsSUFBSUEsUUFBUSxpRUFBaUVDLEtBQWpFLENBQXVFLEVBQXZFLENBQVo7O0FBRUZDLEtBQUtDLElBQUwsR0FBWSxVQUFVQyxHQUFWLEVBQWVDLEtBQWYsRUFBc0I7QUFDaEMsTUFBSUMsUUFBUU4sS0FBWjtBQUFBLE1BQW1CRyxPQUFPLEVBQTFCO0FBQUEsTUFBOEJJLENBQTlCO0FBQ0FGLFVBQVFBLFNBQVNDLE1BQU1FLE1BQXZCOztBQUVBLE1BQUlKLEdBQUosRUFBUztBQUNQO0FBQ0EsU0FBS0csSUFBSSxDQUFULEVBQVlBLElBQUlILEdBQWhCLEVBQXFCRyxHQUFyQjtBQUEwQkosV0FBS0ksQ0FBTCxJQUFVRCxNQUFNLElBQUlKLEtBQUtPLE1BQUwsS0FBY0osS0FBeEIsQ0FBVjtBQUExQjtBQUNELEdBSEQsTUFHTztBQUNMO0FBQ0EsUUFBSUssQ0FBSjs7QUFFQTtBQUNBUCxTQUFLLENBQUwsSUFBVUEsS0FBSyxFQUFMLElBQVdBLEtBQUssRUFBTCxJQUFXQSxLQUFLLEVBQUwsSUFBVyxHQUEzQztBQUNBQSxTQUFLLEVBQUwsSUFBVyxHQUFYOztBQUVBO0FBQ0E7QUFDQSxTQUFLSSxJQUFJLENBQVQsRUFBWUEsSUFBSSxFQUFoQixFQUFvQkEsR0FBcEIsRUFBeUI7QUFDdkIsVUFBSSxDQUFDSixLQUFLSSxDQUFMLENBQUwsRUFBYztBQUNaRyxZQUFJLElBQUlSLEtBQUtPLE1BQUwsS0FBYyxFQUF0QjtBQUNBTixhQUFLSSxDQUFMLElBQVVELE1BQU9DLEtBQUssRUFBTixHQUFhRyxJQUFJLEdBQUwsR0FBWSxHQUF4QixHQUE4QkEsQ0FBcEMsQ0FBVjtBQUNEO0FBQ0Y7QUFDRjs7QUFFRCxTQUFPUCxLQUFLUSxJQUFMLENBQVUsRUFBVixDQUFQO0FBQ0QsQ0ExQkQiLCJmaWxlIjoiOS5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICBNYXRoLnV1aWQuanMgKHYxLjQpXG4gIGh0dHA6Ly93d3cuYnJvb2ZhLmNvbVxuICBtYWlsdG86cm9iZXJ0QGJyb29mYS5jb21cblxuICBDb3B5cmlnaHQgKGMpIDIwMTAgUm9iZXJ0IEtpZWZmZXJcbiAgRHVhbCBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGFuZCBHUEwgbGljZW5zZXMuXG5cbiAgKioqKioqKipcblxuICBDaGFuZ2VzIHdpdGhpbiByZW1vdGVTdG9yYWdlLmpzOlxuICAyMDEyLTEwLTMxOlxuICAtIGFkZGVkIEFNRCB3cmFwcGVyIDxuaWtsYXNAdW5ob3N0ZWQub3JnPlxuICAtIG1vdmVkIGV4dGVuc2lvbnMgZm9yIE1hdGggb2JqZWN0IGludG8gZXhwb3J0ZWQgb2JqZWN0LlxuKi9cblxuLypcbiAqIEdlbmVyYXRlIGEgcmFuZG9tIHV1aWQuXG4gKlxuICogVVNBR0U6IE1hdGgudXVpZChsZW5ndGgsIHJhZGl4KVxuICogICBsZW5ndGggLSB0aGUgZGVzaXJlZCBudW1iZXIgb2YgY2hhcmFjdGVyc1xuICogICByYWRpeCAgLSB0aGUgbnVtYmVyIG9mIGFsbG93YWJsZSB2YWx1ZXMgZm9yIGVhY2ggY2hhcmFjdGVyLlxuICpcbiAqIEVYQU1QTEVTOlxuICogICAvLyBObyBhcmd1bWVudHMgIC0gcmV0dXJucyBSRkM0MTIyLCB2ZXJzaW9uIDQgSURcbiAqICAgPj4+IE1hdGgudXVpZCgpXG4gKiAgIFwiOTIzMjlEMzktNkY1Qy00NTIwLUFCRkMtQUFCNjQ1NDRFMTcyXCJcbiAqXG4gKiAgIC8vIE9uZSBhcmd1bWVudCAtIHJldHVybnMgSUQgb2YgdGhlIHNwZWNpZmllZCBsZW5ndGhcbiAqICAgPj4+IE1hdGgudXVpZCgxNSkgICAgIC8vIDE1IGNoYXJhY3RlciBJRCAoZGVmYXVsdCBiYXNlPTYyKVxuICogICBcIlZjeWR4Z2x0eHJWWlNUVlwiXG4gKlxuICogICAvLyBUd28gYXJndW1lbnRzIC0gcmV0dXJucyBJRCBvZiB0aGUgc3BlY2lmaWVkIGxlbmd0aCwgYW5kIHJhZGl4LiAoUmFkaXggbXVzdCBiZSA8PSA2MilcbiAqICAgPj4+IE1hdGgudXVpZCg4LCAyKSAgLy8gOCBjaGFyYWN0ZXIgSUQgKGJhc2U9MilcbiAqICAgXCIwMTAwMTAxMFwiXG4gKiAgID4+PiBNYXRoLnV1aWQoOCwgMTApIC8vIDggY2hhcmFjdGVyIElEIChiYXNlPTEwKVxuICogICBcIjQ3NDczMDQ2XCJcbiAqICAgPj4+IE1hdGgudXVpZCg4LCAxNikgLy8gOCBjaGFyYWN0ZXIgSUQgKGJhc2U9MTYpXG4gKiAgIFwiMDk4RjREMzVcIlxuICovXG4gIC8vIFByaXZhdGUgYXJyYXkgb2YgY2hhcnMgdG8gdXNlXG4gIHZhciBDSEFSUyA9ICcwMTIzNDU2Nzg5QUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5eicuc3BsaXQoJycpO1xuXG5NYXRoLnV1aWQgPSBmdW5jdGlvbiAobGVuLCByYWRpeCkge1xuICB2YXIgY2hhcnMgPSBDSEFSUywgdXVpZCA9IFtdLCBpO1xuICByYWRpeCA9IHJhZGl4IHx8IGNoYXJzLmxlbmd0aDtcblxuICBpZiAobGVuKSB7XG4gICAgLy8gQ29tcGFjdCBmb3JtXG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB1dWlkW2ldID0gY2hhcnNbMCB8IE1hdGgucmFuZG9tKCkqcmFkaXhdO1xuICB9IGVsc2Uge1xuICAgIC8vIHJmYzQxMjIsIHZlcnNpb24gNCBmb3JtXG4gICAgdmFyIHI7XG5cbiAgICAvLyByZmM0MTIyIHJlcXVpcmVzIHRoZXNlIGNoYXJhY3RlcnNcbiAgICB1dWlkWzhdID0gdXVpZFsxM10gPSB1dWlkWzE4XSA9IHV1aWRbMjNdID0gJy0nO1xuICAgIHV1aWRbMTRdID0gJzQnO1xuXG4gICAgLy8gRmlsbCBpbiByYW5kb20gZGF0YS4gIEF0IGk9PTE5IHNldCB0aGUgaGlnaCBiaXRzIG9mIGNsb2NrIHNlcXVlbmNlIGFzXG4gICAgLy8gcGVyIHJmYzQxMjIsIHNlYy4gNC4xLjVcbiAgICBmb3IgKGkgPSAwOyBpIDwgMzY7IGkrKykge1xuICAgICAgaWYgKCF1dWlkW2ldKSB7XG4gICAgICAgIHIgPSAwIHwgTWF0aC5yYW5kb20oKSoxNjtcbiAgICAgICAgdXVpZFtpXSA9IGNoYXJzWyhpID09IDE5KSA/IChyICYgMHgzKSB8IDB4OCA6IHJdO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB1dWlkLmpvaW4oJycpO1xufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2xpYi9NYXRoLnV1aWQuanMiXSwic291cmNlUm9vdCI6IiJ9");

/***/ },
/* 10 */
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';\n\nvar tv4 = __webpack_require__(11);\nvar BaseClient = __webpack_require__(8);\n\n/**\n * Class: RemoteStorage.BaseClient.Types\n *\n * - Manages and validates types of remoteStorage objects, using JSON-LD and\n *   JSON Schema\n * - Adds schema declaration/validation methods to BaseClient instances.\n **/\nBaseClient.Types = {\n  // <alias> -> <uri>\n  uris: {},\n  // <uri> -> <schema>\n  schemas: {},\n  // <uri> -> <alias>\n  aliases: {},\n\n  declare: function declare(moduleName, alias, uri, schema) {\n    var fullAlias = moduleName + '/' + alias;\n\n    if (schema.extends) {\n      var extendedAlias;\n      var parts = schema.extends.split('/');\n      if (parts.length === 1) {\n        extendedAlias = moduleName + '/' + parts.shift();\n      } else {\n        extendedAlias = parts.join('/');\n      }\n      var extendedUri = this.uris[extendedAlias];\n      if (!extendedUri) {\n        throw \"Type '\" + fullAlias + \"' tries to extend unknown schema '\" + extendedAlias + \"'\";\n      }\n      schema.extends = this.schemas[extendedUri];\n    }\n\n    this.uris[fullAlias] = uri;\n    this.aliases[uri] = fullAlias;\n    this.schemas[uri] = schema;\n  },\n\n  resolveAlias: function resolveAlias(alias) {\n    return this.uris[alias];\n  },\n\n  getSchema: function getSchema(uri) {\n    return this.schemas[uri];\n  },\n\n  inScope: function inScope(moduleName) {\n    var ml = moduleName.length;\n    var schemas = {};\n    for (var alias in this.uris) {\n      if (alias.substr(0, ml + 1) === moduleName + '/') {\n        var uri = this.uris[alias];\n        schemas[uri] = this.schemas[uri];\n      }\n    }\n    return schemas;\n  }\n};\n\nvar SchemaNotFound = function SchemaNotFound(uri) {\n  var error = new Error(\"Schema not found: \" + uri);\n  error.name = \"SchemaNotFound\";\n  return error;\n};\n\nSchemaNotFound.prototype = Error.prototype;\n\nBaseClient.Types.SchemaNotFound = SchemaNotFound;\n\n/**\n * Class: RemoteStorage.BaseClient\n **/\nBaseClient.prototype.extend({\n  /**\n   * Method: declareType\n   *\n   * Declare a remoteStorage object type using a JSON schema.\n   *\n   * Parameters:\n   *   alias  - A type alias/shortname\n   *   uri    - (optional) JSON-LD URI of the schema. Automatically generated if none given\n   *   schema - A JSON Schema object describing the object type\n   *\n   * Example:\n   *\n   * (start code)\n   * client.declareType('todo-item', {\n   *   \"type\": \"object\",\n   *   \"properties\": {\n   *     \"id\": {\n   *       \"type\": \"string\"\n   *     },\n   *     \"title\": {\n   *       \"type\": \"string\"\n   *     },\n   *     \"finished\": {\n   *       \"type\": \"boolean\"\n   *       \"default\": false\n   *     },\n   *     \"createdAt\": {\n   *       \"type\": \"date\"\n   *     }\n   *   },\n   *   \"required\": [\"id\", \"title\"]\n   * })\n   * (end code)\n   *\n   * Visit <http://json-schema.org> for details on how to use JSON Schema.\n   **/\n  declareType: function declareType(alias, uri, schema) {\n    if (!schema) {\n      schema = uri;\n      uri = this._defaultTypeURI(alias);\n    }\n    BaseClient.Types.declare(this.moduleName, alias, uri, schema);\n  },\n\n  /**\n   * Method: validate\n   *\n   * Validate an object against the associated schema.\n   *\n   * Parameters:\n   *  object - Object to validate. Must have a @context property.\n   *\n   * Returns:\n   *   An object containing information about validation errors\n   **/\n  validate: function validate(object) {\n    var schema = BaseClient.Types.getSchema(object['@context']);\n    if (schema) {\n      return tv4.validateResult(object, schema);\n    } else {\n      throw new SchemaNotFound(object['@context']);\n    }\n  },\n\n  _defaultTypeURI: function _defaultTypeURI(alias) {\n    return 'http://remotestorage.io/spec/modules/' + encodeURIComponent(this.moduleName) + '/' + encodeURIComponent(alias);\n  },\n\n  _attachType: function _attachType(object, alias) {\n    object['@context'] = BaseClient.Types.resolveAlias(this.moduleName + '/' + alias) || this._defaultTypeURI(alias);\n  }\n});\n\n// Documented in baseclient.js\nObject.defineProperty(BaseClient.prototype, 'schemas', {\n  configurable: true,\n  get: function get() {\n    return BaseClient.Types.inScope(this.moduleName);\n  }\n});\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvdHlwZXMuanM/ODlhOCJdLCJuYW1lcyI6WyJ0djQiLCJyZXF1aXJlIiwiQmFzZUNsaWVudCIsIlR5cGVzIiwidXJpcyIsInNjaGVtYXMiLCJhbGlhc2VzIiwiZGVjbGFyZSIsIm1vZHVsZU5hbWUiLCJhbGlhcyIsInVyaSIsInNjaGVtYSIsImZ1bGxBbGlhcyIsImV4dGVuZHMiLCJleHRlbmRlZEFsaWFzIiwicGFydHMiLCJzcGxpdCIsImxlbmd0aCIsInNoaWZ0Iiwiam9pbiIsImV4dGVuZGVkVXJpIiwicmVzb2x2ZUFsaWFzIiwiZ2V0U2NoZW1hIiwiaW5TY29wZSIsIm1sIiwic3Vic3RyIiwiU2NoZW1hTm90Rm91bmQiLCJlcnJvciIsIkVycm9yIiwibmFtZSIsInByb3RvdHlwZSIsImV4dGVuZCIsImRlY2xhcmVUeXBlIiwiX2RlZmF1bHRUeXBlVVJJIiwidmFsaWRhdGUiLCJvYmplY3QiLCJ2YWxpZGF0ZVJlc3VsdCIsImVuY29kZVVSSUNvbXBvbmVudCIsIl9hdHRhY2hUeXBlIiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJjb25maWd1cmFibGUiLCJnZXQiXSwibWFwcGluZ3MiOiI7O0FBQUUsSUFBSUEsTUFBTSxtQkFBQUMsQ0FBUSxFQUFSLENBQVY7QUFDQSxJQUFJQyxhQUFhLG1CQUFBRCxDQUFRLENBQVIsQ0FBakI7O0FBRUE7Ozs7Ozs7QUFPQUMsV0FBV0MsS0FBWCxHQUFtQjtBQUNqQjtBQUNBQyxRQUFNLEVBRlc7QUFHakI7QUFDQUMsV0FBUyxFQUpRO0FBS2pCO0FBQ0FDLFdBQVMsRUFOUTs7QUFRakJDLFdBQVMsaUJBQVNDLFVBQVQsRUFBcUJDLEtBQXJCLEVBQTRCQyxHQUE1QixFQUFpQ0MsTUFBakMsRUFBeUM7QUFDaEQsUUFBSUMsWUFBWUosYUFBYSxHQUFiLEdBQW1CQyxLQUFuQzs7QUFFQSxRQUFJRSxPQUFPRSxPQUFYLEVBQW9CO0FBQ2xCLFVBQUlDLGFBQUo7QUFDQSxVQUFJQyxRQUFRSixP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Q0QsS0FGRCxNQUVPO0FBQ0wsWUFBTSxJQUFJZSxjQUFKLENBQW1CUyxPQUFPLFVBQVAsQ0FBbkIsQ0FBTjtBQUNEO0FBQ0YsR0EvRHlCOztBQWlFMUJGLG1CQUFpQix5QkFBU3hCLEtBQVQsRUFBZ0I7QUFDL0IsV0FBTywwQ0FBMEM0QixtQkFBbUIsS0FBSzdCLFVBQXhCLENBQTFDLEdBQWdGLEdBQWhGLEdBQXNGNkIsbUJBQW1CNUIsS0FBbkIsQ0FBN0Y7QUFDRCxHQW5FeUI7O0FBcUUxQjZCLGVBQWEscUJBQVNILE1BQVQsRUFBaUIxQixLQUFqQixFQUF3QjtBQUNuQzBCLFdBQU8sVUFBUCxJQUFxQmpDLFdBQVdDLEtBQVgsQ0FBaUJrQixZQUFqQixDQUE4QixLQUFLYixVQUFMLEdBQWtCLEdBQWxCLEdBQXdCQyxLQUF0RCxLQUFnRSxLQUFLd0IsZUFBTCxDQUFxQnhCLEtBQXJCLENBQXJGO0FBQ0Q7QUF2RXlCLENBQTVCOztBQTBFQTtBQUNBOEIsT0FBT0MsY0FBUCxDQUFzQnRDLFdBQVc0QixTQUFqQyxFQUE0QyxTQUE1QyxFQUF1RDtBQUNyRFcsZ0JBQWMsSUFEdUM7QUFFckRDLE9BQUssZUFBVztBQUNkLFdBQU94QyxXQUFXQyxLQUFYLENBQWlCb0IsT0FBakIsQ0FBeUIsS0FBS2YsVUFBOUIsQ0FBUDtBQUNEO0FBSm9ELENBQXZEIiwiZmlsZSI6IjEwLmpzIiwic291cmNlc0NvbnRlbnQiOlsiICB2YXIgdHY0ID0gcmVxdWlyZSgndHY0Jyk7XG4gIHZhciBCYXNlQ2xpZW50ID0gcmVxdWlyZSgnLi9iYXNlY2xpZW50JylcblxuICAvKipcbiAgICogQ2xhc3M6IFJlbW90ZVN0b3JhZ2UuQmFzZUNsaWVudC5UeXBlc1xuICAgKlxuICAgKiAtIE1hbmFnZXMgYW5kIHZhbGlkYXRlcyB0eXBlcyBvZiByZW1vdGVTdG9yYWdlIG9iamVjdHMsIHVzaW5nIEpTT04tTEQgYW5kXG4gICAqICAgSlNPTiBTY2hlbWFcbiAgICogLSBBZGRzIHNjaGVtYSBkZWNsYXJhdGlvbi92YWxpZGF0aW9uIG1ldGhvZHMgdG8gQmFzZUNsaWVudCBpbnN0YW5jZXMuXG4gICAqKi9cbiAgQmFzZUNsaWVudC5UeXBlcyA9IHtcbiAgICAvLyA8YWxpYXM+IC0+IDx1cmk+XG4gICAgdXJpczoge30sXG4gICAgLy8gPHVyaT4gLT4gPHNjaGVtYT5cbiAgICBzY2hlbWFzOiB7fSxcbiAgICAvLyA8dXJpPiAtPiA8YWxpYXM+XG4gICAgYWxpYXNlczoge30sXG5cbiAgICBkZWNsYXJlOiBmdW5jdGlvbihtb2R1bGVOYW1lLCBhbGlhcywgdXJpLCBzY2hlbWEpIHtcbiAgICAgIHZhciBmdWxsQWxpYXMgPSBtb2R1bGVOYW1lICsgJy8nICsgYWxpYXM7XG5cbiAgICAgIGlmIChzY2hlbWEuZXh0ZW5kcykge1xuICAgICAgICB2YXIgZXh0ZW5kZWRBbGlhcztcbiAgICAgICAgdmFyIHBhcnRzID0gc2NoZW1hLmV4dGVuZHMuc3BsaXQoJy8nKTtcbiAgICAgICAgaWYgKHBhcnRzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgIGV4dGVuZGVkQWxpYXMgPSBtb2R1bGVOYW1lICsgJy8nICsgcGFydHMuc2hpZnQoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBleHRlbmRlZEFsaWFzID0gcGFydHMuam9pbignLycpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBleHRlbmRlZFVyaSA9IHRoaXMudXJpc1tleHRlbmRlZEFsaWFzXTtcbiAgICAgICAgaWYgKCEgZXh0ZW5kZWRVcmkpIHtcbiAgICAgICAgICB0aHJvdyBcIlR5cGUgJ1wiICsgZnVsbEFsaWFzICsgXCInIHRyaWVzIHRvIGV4dGVuZCB1bmtub3duIHNjaGVtYSAnXCIgKyBleHRlbmRlZEFsaWFzICsgXCInXCI7XG4gICAgICAgIH1cbiAgICAgICAgc2NoZW1hLmV4dGVuZHMgPSB0aGlzLnNjaGVtYXNbZXh0ZW5kZWRVcmldO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnVyaXNbZnVsbEFsaWFzXSA9IHVyaTtcbiAgICAgIHRoaXMuYWxpYXNlc1t1cmldID0gZnVsbEFsaWFzO1xuICAgICAgdGhpcy5zY2hlbWFzW3VyaV0gPSBzY2hlbWE7XG4gICAgfSxcblxuICAgIHJlc29sdmVBbGlhczogZnVuY3Rpb24oYWxpYXMpIHtcbiAgICAgIHJldHVybiB0aGlzLnVyaXNbYWxpYXNdO1xuICAgIH0sXG5cbiAgICBnZXRTY2hlbWE6IGZ1bmN0aW9uKHVyaSkge1xuICAgICAgcmV0dXJuIHRoaXMuc2NoZW1hc1t1cmldO1xuICAgIH0sXG5cbiAgICBpblNjb3BlOiBmdW5jdGlvbihtb2R1bGVOYW1lKSB7XG4gICAgICB2YXIgbWwgPSBtb2R1bGVOYW1lLmxlbmd0aDtcbiAgICAgIHZhciBzY2hlbWFzID0ge307XG4gICAgICBmb3IgKHZhciBhbGlhcyBpbiB0aGlzLnVyaXMpIHtcbiAgICAgICAgaWYgKGFsaWFzLnN1YnN0cigwLCBtbCArIDEpID09PSBtb2R1bGVOYW1lICsgJy8nKSB7XG4gICAgICAgICAgdmFyIHVyaSA9IHRoaXMudXJpc1thbGlhc107XG4gICAgICAgICAgc2NoZW1hc1t1cmldID0gdGhpcy5zY2hlbWFzW3VyaV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBzY2hlbWFzO1xuICAgIH1cbiAgfTtcblxuICB2YXIgU2NoZW1hTm90Rm91bmQgPSBmdW5jdGlvbih1cmkpIHtcbiAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IoXCJTY2hlbWEgbm90IGZvdW5kOiBcIiArIHVyaSk7XG4gICAgZXJyb3IubmFtZSA9IFwiU2NoZW1hTm90Rm91bmRcIjtcbiAgICByZXR1cm4gZXJyb3I7XG4gIH07XG5cbiAgU2NoZW1hTm90Rm91bmQucHJvdG90eXBlID0gRXJyb3IucHJvdG90eXBlO1xuXG4gIEJhc2VDbGllbnQuVHlwZXMuU2NoZW1hTm90Rm91bmQgPSBTY2hlbWFOb3RGb3VuZDtcblxuICAvKipcbiAgICogQ2xhc3M6IFJlbW90ZVN0b3JhZ2UuQmFzZUNsaWVudFxuICAgKiovXG4gIEJhc2VDbGllbnQucHJvdG90eXBlLmV4dGVuZCh7XG4gICAgLyoqXG4gICAgICogTWV0aG9kOiBkZWNsYXJlVHlwZVxuICAgICAqXG4gICAgICogRGVjbGFyZSBhIHJlbW90ZVN0b3JhZ2Ugb2JqZWN0IHR5cGUgdXNpbmcgYSBKU09OIHNjaGVtYS5cbiAgICAgKlxuICAgICAqIFBhcmFtZXRlcnM6XG4gICAgICogICBhbGlhcyAgLSBBIHR5cGUgYWxpYXMvc2hvcnRuYW1lXG4gICAgICogICB1cmkgICAgLSAob3B0aW9uYWwpIEpTT04tTEQgVVJJIG9mIHRoZSBzY2hlbWEuIEF1dG9tYXRpY2FsbHkgZ2VuZXJhdGVkIGlmIG5vbmUgZ2l2ZW5cbiAgICAgKiAgIHNjaGVtYSAtIEEgSlNPTiBTY2hlbWEgb2JqZWN0IGRlc2NyaWJpbmcgdGhlIG9iamVjdCB0eXBlXG4gICAgICpcbiAgICAgKiBFeGFtcGxlOlxuICAgICAqXG4gICAgICogKHN0YXJ0IGNvZGUpXG4gICAgICogY2xpZW50LmRlY2xhcmVUeXBlKCd0b2RvLWl0ZW0nLCB7XG4gICAgICogICBcInR5cGVcIjogXCJvYmplY3RcIixcbiAgICAgKiAgIFwicHJvcGVydGllc1wiOiB7XG4gICAgICogICAgIFwiaWRcIjoge1xuICAgICAqICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiXG4gICAgICogICAgIH0sXG4gICAgICogICAgIFwidGl0bGVcIjoge1xuICAgICAqICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiXG4gICAgICogICAgIH0sXG4gICAgICogICAgIFwiZmluaXNoZWRcIjoge1xuICAgICAqICAgICAgIFwidHlwZVwiOiBcImJvb2xlYW5cIlxuICAgICAqICAgICAgIFwiZGVmYXVsdFwiOiBmYWxzZVxuICAgICAqICAgICB9LFxuICAgICAqICAgICBcImNyZWF0ZWRBdFwiOiB7XG4gICAgICogICAgICAgXCJ0eXBlXCI6IFwiZGF0ZVwiXG4gICAgICogICAgIH1cbiAgICAgKiAgIH0sXG4gICAgICogICBcInJlcXVpcmVkXCI6IFtcImlkXCIsIFwidGl0bGVcIl1cbiAgICAgKiB9KVxuICAgICAqIChlbmQgY29kZSlcbiAgICAgKlxuICAgICAqIFZpc2l0IDxodHRwOi8vanNvbi1zY2hlbWEub3JnPiBmb3IgZGV0YWlscyBvbiBob3cgdG8gdXNlIEpTT04gU2NoZW1hLlxuICAgICAqKi9cbiAgICBkZWNsYXJlVHlwZTogZnVuY3Rpb24oYWxpYXMsIHVyaSwgc2NoZW1hKSB7XG4gICAgICBpZiAoISBzY2hlbWEpIHtcbiAgICAgICAgc2NoZW1hID0gdXJpO1xuICAgICAgICB1cmkgPSB0aGlzLl9kZWZhdWx0VHlwZVVSSShhbGlhcyk7XG4gICAgICB9XG4gICAgICBCYXNlQ2xpZW50LlR5cGVzLmRlY2xhcmUodGhpcy5tb2R1bGVOYW1lLCBhbGlhcywgdXJpLCBzY2hlbWEpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNZXRob2Q6IHZhbGlkYXRlXG4gICAgICpcbiAgICAgKiBWYWxpZGF0ZSBhbiBvYmplY3QgYWdhaW5zdCB0aGUgYXNzb2NpYXRlZCBzY2hlbWEuXG4gICAgICpcbiAgICAgKiBQYXJhbWV0ZXJzOlxuICAgICAqICBvYmplY3QgLSBPYmplY3QgdG8gdmFsaWRhdGUuIE11c3QgaGF2ZSBhIEBjb250ZXh0IHByb3BlcnR5LlxuICAgICAqXG4gICAgICogUmV0dXJuczpcbiAgICAgKiAgIEFuIG9iamVjdCBjb250YWluaW5nIGluZm9ybWF0aW9uIGFib3V0IHZhbGlkYXRpb24gZXJyb3JzXG4gICAgICoqL1xuICAgIHZhbGlkYXRlOiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICAgIHZhciBzY2hlbWEgPSBCYXNlQ2xpZW50LlR5cGVzLmdldFNjaGVtYShvYmplY3RbJ0Bjb250ZXh0J10pO1xuICAgICAgaWYgKHNjaGVtYSkge1xuICAgICAgICByZXR1cm4gdHY0LnZhbGlkYXRlUmVzdWx0KG9iamVjdCwgc2NoZW1hKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBTY2hlbWFOb3RGb3VuZChvYmplY3RbJ0Bjb250ZXh0J10pO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBfZGVmYXVsdFR5cGVVUkk6IGZ1bmN0aW9uKGFsaWFzKSB7XG4gICAgICByZXR1cm4gJ2h0dHA6Ly9yZW1vdGVzdG9yYWdlLmlvL3NwZWMvbW9kdWxlcy8nICsgZW5jb2RlVVJJQ29tcG9uZW50KHRoaXMubW9kdWxlTmFtZSkgKyAnLycgKyBlbmNvZGVVUklDb21wb25lbnQoYWxpYXMpO1xuICAgIH0sXG5cbiAgICBfYXR0YWNoVHlwZTogZnVuY3Rpb24ob2JqZWN0LCBhbGlhcykge1xuICAgICAgb2JqZWN0WydAY29udGV4dCddID0gQmFzZUNsaWVudC5UeXBlcy5yZXNvbHZlQWxpYXModGhpcy5tb2R1bGVOYW1lICsgJy8nICsgYWxpYXMpIHx8IHRoaXMuX2RlZmF1bHRUeXBlVVJJKGFsaWFzKTtcbiAgICB9XG4gIH0pO1xuXG4gIC8vIERvY3VtZW50ZWQgaW4gYmFzZWNsaWVudC5qc1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQmFzZUNsaWVudC5wcm90b3R5cGUsICdzY2hlbWFzJywge1xuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIEJhc2VDbGllbnQuVHlwZXMuaW5TY29wZSh0aGlzLm1vZHVsZU5hbWUpO1xuICAgIH1cbiAgfSk7XG5cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy90eXBlcy5qcyJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ },
/* 11 */
/***/ function(module, exports, __webpack_require__) {

	eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*\nAuthor: Geraint Luff and others\nYear: 2013\n\nThis code is released into the \"public domain\" by its author(s).  Anybody may use, alter and distribute the code without restriction.  The author makes no guarantees, and takes no liability of any kind for use of this code.\n\nIf you find a bug or make an improvement, it would be courteous to let the author know, but it is not compulsory.\n*/\n(function (global, factory) {\n  if (true) {\n    // AMD. Register as an anonymous module.\n    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  } else if (typeof module !== 'undefined' && module.exports){\n    // CommonJS. Define export.\n    module.exports = factory();\n  } else {\n    // Browser globals\n    global.tv4 = factory();\n  }\n}(this, function () {\n\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/keys?redirectlocale=en-US&redirectslug=JavaScript%2FReference%2FGlobal_Objects%2FObject%2Fkeys\nif (!Object.keys) {\n\tObject.keys = (function () {\n\t\tvar hasOwnProperty = Object.prototype.hasOwnProperty,\n\t\t\thasDontEnumBug = !({toString: null}).propertyIsEnumerable('toString'),\n\t\t\tdontEnums = [\n\t\t\t\t'toString',\n\t\t\t\t'toLocaleString',\n\t\t\t\t'valueOf',\n\t\t\t\t'hasOwnProperty',\n\t\t\t\t'isPrototypeOf',\n\t\t\t\t'propertyIsEnumerable',\n\t\t\t\t'constructor'\n\t\t\t],\n\t\t\tdontEnumsLength = dontEnums.length;\n\n\t\treturn function (obj) {\n\t\t\tif (typeof obj !== 'object' && typeof obj !== 'function' || obj === null) {\n\t\t\t\tthrow new TypeError('Object.keys called on non-object');\n\t\t\t}\n\n\t\t\tvar result = [];\n\n\t\t\tfor (var prop in obj) {\n\t\t\t\tif (hasOwnProperty.call(obj, prop)) {\n\t\t\t\t\tresult.push(prop);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (hasDontEnumBug) {\n\t\t\t\tfor (var i=0; i < dontEnumsLength; i++) {\n\t\t\t\t\tif (hasOwnProperty.call(obj, dontEnums[i])) {\n\t\t\t\t\t\tresult.push(dontEnums[i]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn result;\n\t\t};\n\t})();\n}\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/create\nif (!Object.create) {\n\tObject.create = (function(){\n\t\tfunction F(){}\n\n\t\treturn function(o){\n\t\t\tif (arguments.length !== 1) {\n\t\t\t\tthrow new Error('Object.create implementation only accepts one parameter.');\n\t\t\t}\n\t\t\tF.prototype = o;\n\t\t\treturn new F();\n\t\t};\n\t})();\n}\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/isArray?redirectlocale=en-US&redirectslug=JavaScript%2FReference%2FGlobal_Objects%2FArray%2FisArray\nif(!Array.isArray) {\n\tArray.isArray = function (vArg) {\n\t\treturn Object.prototype.toString.call(vArg) === \"[object Array]\";\n\t};\n}\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/indexOf?redirectlocale=en-US&redirectslug=JavaScript%2FReference%2FGlobal_Objects%2FArray%2FindexOf\nif (!Array.prototype.indexOf) {\n\tArray.prototype.indexOf = function (searchElement /*, fromIndex */ ) {\n\t\tif (this === null) {\n\t\t\tthrow new TypeError();\n\t\t}\n\t\tvar t = Object(this);\n\t\tvar len = t.length >>> 0;\n\n\t\tif (len === 0) {\n\t\t\treturn -1;\n\t\t}\n\t\tvar n = 0;\n\t\tif (arguments.length > 1) {\n\t\t\tn = Number(arguments[1]);\n\t\t\tif (n !== n) { // shortcut for verifying if it's NaN\n\t\t\t\tn = 0;\n\t\t\t} else if (n !== 0 && n !== Infinity && n !== -Infinity) {\n\t\t\t\tn = (n > 0 || -1) * Math.floor(Math.abs(n));\n\t\t\t}\n\t\t}\n\t\tif (n >= len) {\n\t\t\treturn -1;\n\t\t}\n\t\tvar k = n >= 0 ? n : Math.max(len - Math.abs(n), 0);\n\t\tfor (; k < len; k++) {\n\t\t\tif (k in t && t[k] === searchElement) {\n\t\t\t\treturn k;\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t};\n}\n\n// Grungey Object.isFrozen hack\nif (!Object.isFrozen) {\n\tObject.isFrozen = function (obj) {\n\t\tvar key = \"tv4_test_frozen_key\";\n\t\twhile (obj.hasOwnProperty(key)) {\n\t\t\tkey += Math.random();\n\t\t}\n\t\ttry {\n\t\t\tobj[key] = true;\n\t\t\tdelete obj[key];\n\t\t\treturn false;\n\t\t} catch (e) {\n\t\t\treturn true;\n\t\t}\n\t};\n}\n// Based on: https://github.com/geraintluff/uri-templates, but with all the de-substitution stuff removed\n\nvar uriTemplateGlobalModifiers = {\n\t\"+\": true,\n\t\"#\": true,\n\t\".\": true,\n\t\"/\": true,\n\t\";\": true,\n\t\"?\": true,\n\t\"&\": true\n};\nvar uriTemplateSuffices = {\n\t\"*\": true\n};\n\nfunction notReallyPercentEncode(string) {\n\treturn encodeURI(string).replace(/%25[0-9][0-9]/g, function (doubleEncoded) {\n\t\treturn \"%\" + doubleEncoded.substring(3);\n\t});\n}\n\nfunction uriTemplateSubstitution(spec) {\n\tvar modifier = \"\";\n\tif (uriTemplateGlobalModifiers[spec.charAt(0)]) {\n\t\tmodifier = spec.charAt(0);\n\t\tspec = spec.substring(1);\n\t}\n\tvar separator = \"\";\n\tvar prefix = \"\";\n\tvar shouldEscape = true;\n\tvar showVariables = false;\n\tvar trimEmptyString = false;\n\tif (modifier === '+') {\n\t\tshouldEscape = false;\n\t} else if (modifier === \".\") {\n\t\tprefix = \".\";\n\t\tseparator = \".\";\n\t} else if (modifier === \"/\") {\n\t\tprefix = \"/\";\n\t\tseparator = \"/\";\n\t} else if (modifier === '#') {\n\t\tprefix = \"#\";\n\t\tshouldEscape = false;\n\t} else if (modifier === ';') {\n\t\tprefix = \";\";\n\t\tseparator = \";\";\n\t\tshowVariables = true;\n\t\ttrimEmptyString = true;\n\t} else if (modifier === '?') {\n\t\tprefix = \"?\";\n\t\tseparator = \"&\";\n\t\tshowVariables = true;\n\t} else if (modifier === '&') {\n\t\tprefix = \"&\";\n\t\tseparator = \"&\";\n\t\tshowVariables = true;\n\t}\n\n\tvar varNames = [];\n\tvar varList = spec.split(\",\");\n\tvar varSpecs = [];\n\tvar varSpecMap = {};\n\tfor (var i = 0; i < varList.length; i++) {\n\t\tvar varName = varList[i];\n\t\tvar truncate = null;\n\t\tif (varName.indexOf(\":\") !== -1) {\n\t\t\tvar parts = varName.split(\":\");\n\t\t\tvarName = parts[0];\n\t\t\ttruncate = parseInt(parts[1], 10);\n\t\t}\n\t\tvar suffices = {};\n\t\twhile (uriTemplateSuffices[varName.charAt(varName.length - 1)]) {\n\t\t\tsuffices[varName.charAt(varName.length - 1)] = true;\n\t\t\tvarName = varName.substring(0, varName.length - 1);\n\t\t}\n\t\tvar varSpec = {\n\t\t\ttruncate: truncate,\n\t\t\tname: varName,\n\t\t\tsuffices: suffices\n\t\t};\n\t\tvarSpecs.push(varSpec);\n\t\tvarSpecMap[varName] = varSpec;\n\t\tvarNames.push(varName);\n\t}\n\tvar subFunction = function (valueFunction) {\n\t\tvar result = \"\";\n\t\tvar startIndex = 0;\n\t\tfor (var i = 0; i < varSpecs.length; i++) {\n\t\t\tvar varSpec = varSpecs[i];\n\t\t\tvar value = valueFunction(varSpec.name);\n\t\t\tif (value === null || value === undefined || (Array.isArray(value) && value.length === 0) || (typeof value === 'object' && Object.keys(value).length === 0)) {\n\t\t\t\tstartIndex++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (i === startIndex) {\n\t\t\t\tresult += prefix;\n\t\t\t} else {\n\t\t\t\tresult += (separator || \",\");\n\t\t\t}\n\t\t\tif (Array.isArray(value)) {\n\t\t\t\tif (showVariables) {\n\t\t\t\t\tresult += varSpec.name + \"=\";\n\t\t\t\t}\n\t\t\t\tfor (var j = 0; j < value.length; j++) {\n\t\t\t\t\tif (j > 0) {\n\t\t\t\t\t\tresult += varSpec.suffices['*'] ? (separator || \",\") : \",\";\n\t\t\t\t\t\tif (varSpec.suffices['*'] && showVariables) {\n\t\t\t\t\t\t\tresult += varSpec.name + \"=\";\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tresult += shouldEscape ? encodeURIComponent(value[j]).replace(/!/g, \"%21\") : notReallyPercentEncode(value[j]);\n\t\t\t\t}\n\t\t\t} else if (typeof value === \"object\") {\n\t\t\t\tif (showVariables && !varSpec.suffices['*']) {\n\t\t\t\t\tresult += varSpec.name + \"=\";\n\t\t\t\t}\n\t\t\t\tvar first = true;\n\t\t\t\tfor (var key in value) {\n\t\t\t\t\tif (!first) {\n\t\t\t\t\t\tresult += varSpec.suffices['*'] ? (separator || \",\") : \",\";\n\t\t\t\t\t}\n\t\t\t\t\tfirst = false;\n\t\t\t\t\tresult += shouldEscape ? encodeURIComponent(key).replace(/!/g, \"%21\") : notReallyPercentEncode(key);\n\t\t\t\t\tresult += varSpec.suffices['*'] ? '=' : \",\";\n\t\t\t\t\tresult += shouldEscape ? encodeURIComponent(value[key]).replace(/!/g, \"%21\") : notReallyPercentEncode(value[key]);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (showVariables) {\n\t\t\t\t\tresult += varSpec.name;\n\t\t\t\t\tif (!trimEmptyString || value !== \"\") {\n\t\t\t\t\t\tresult += \"=\";\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (varSpec.truncate != null) {\n\t\t\t\t\tvalue = value.substring(0, varSpec.truncate);\n\t\t\t\t}\n\t\t\t\tresult += shouldEscape ? encodeURIComponent(value).replace(/!/g, \"%21\"): notReallyPercentEncode(value);\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t};\n\tsubFunction.varNames = varNames;\n\treturn {\n\t\tprefix: prefix,\n\t\tsubstitution: subFunction\n\t};\n}\n\nfunction UriTemplate(template) {\n\tif (!(this instanceof UriTemplate)) {\n\t\treturn new UriTemplate(template);\n\t}\n\tvar parts = template.split(\"{\");\n\tvar textParts = [parts.shift()];\n\tvar prefixes = [];\n\tvar substitutions = [];\n\tvar varNames = [];\n\twhile (parts.length > 0) {\n\t\tvar part = parts.shift();\n\t\tvar spec = part.split(\"}\")[0];\n\t\tvar remainder = part.substring(spec.length + 1);\n\t\tvar funcs = uriTemplateSubstitution(spec);\n\t\tsubstitutions.push(funcs.substitution);\n\t\tprefixes.push(funcs.prefix);\n\t\ttextParts.push(remainder);\n\t\tvarNames = varNames.concat(funcs.substitution.varNames);\n\t}\n\tthis.fill = function (valueFunction) {\n\t\tvar result = textParts[0];\n\t\tfor (var i = 0; i < substitutions.length; i++) {\n\t\t\tvar substitution = substitutions[i];\n\t\t\tresult += substitution(valueFunction);\n\t\t\tresult += textParts[i + 1];\n\t\t}\n\t\treturn result;\n\t};\n\tthis.varNames = varNames;\n\tthis.template = template;\n}\nUriTemplate.prototype = {\n\ttoString: function () {\n\t\treturn this.template;\n\t},\n\tfillFromObject: function (obj) {\n\t\treturn this.fill(function (varName) {\n\t\t\treturn obj[varName];\n\t\t});\n\t}\n};\nvar ValidatorContext = function ValidatorContext(parent, collectMultiple, errorReporter, checkRecursive, trackUnknownProperties) {\n\tthis.missing = [];\n\tthis.missingMap = {};\n\tthis.formatValidators = parent ? Object.create(parent.formatValidators) : {};\n\tthis.schemas = parent ? Object.create(parent.schemas) : {};\n\tthis.collectMultiple = collectMultiple;\n\tthis.errors = [];\n\tthis.handleError = collectMultiple ? this.collectError : this.returnError;\n\tif (checkRecursive) {\n\t\tthis.checkRecursive = true;\n\t\tthis.scanned = [];\n\t\tthis.scannedFrozen = [];\n\t\tthis.scannedFrozenSchemas = [];\n\t\tthis.scannedFrozenValidationErrors = [];\n\t\tthis.validatedSchemasKey = 'tv4_validation_id';\n\t\tthis.validationErrorsKey = 'tv4_validation_errors_id';\n\t}\n\tif (trackUnknownProperties) {\n\t\tthis.trackUnknownProperties = true;\n\t\tthis.knownPropertyPaths = {};\n\t\tthis.unknownPropertyPaths = {};\n\t}\n\tthis.errorReporter = errorReporter || defaultErrorReporter('en');\n\tif (typeof this.errorReporter === 'string') {\n\t\tthrow new Error('debug');\n\t}\n\tthis.definedKeywords = {};\n\tif (parent) {\n\t\tfor (var key in parent.definedKeywords) {\n\t\t\tthis.definedKeywords[key] = parent.definedKeywords[key].slice(0);\n\t\t}\n\t}\n};\nValidatorContext.prototype.defineKeyword = function (keyword, keywordFunction) {\n\tthis.definedKeywords[keyword] = this.definedKeywords[keyword] || [];\n\tthis.definedKeywords[keyword].push(keywordFunction);\n};\nValidatorContext.prototype.createError = function (code, messageParams, dataPath, schemaPath, subErrors, data, schema) {\n\tvar error = new ValidationError(code, messageParams, dataPath, schemaPath, subErrors);\n\terror.message = this.errorReporter(error, data, schema);\n\treturn error;\n};\nValidatorContext.prototype.returnError = function (error) {\n\treturn error;\n};\nValidatorContext.prototype.collectError = function (error) {\n\tif (error) {\n\t\tthis.errors.push(error);\n\t}\n\treturn null;\n};\nValidatorContext.prototype.prefixErrors = function (startIndex, dataPath, schemaPath) {\n\tfor (var i = startIndex; i < this.errors.length; i++) {\n\t\tthis.errors[i] = this.errors[i].prefixWith(dataPath, schemaPath);\n\t}\n\treturn this;\n};\nValidatorContext.prototype.banUnknownProperties = function (data, schema) {\n\tfor (var unknownPath in this.unknownPropertyPaths) {\n\t\tvar error = this.createError(ErrorCodes.UNKNOWN_PROPERTY, {path: unknownPath}, unknownPath, \"\", null, data, schema);\n\t\tvar result = this.handleError(error);\n\t\tif (result) {\n\t\t\treturn result;\n\t\t}\n\t}\n\treturn null;\n};\n\nValidatorContext.prototype.addFormat = function (format, validator) {\n\tif (typeof format === 'object') {\n\t\tfor (var key in format) {\n\t\t\tthis.addFormat(key, format[key]);\n\t\t}\n\t\treturn this;\n\t}\n\tthis.formatValidators[format] = validator;\n};\nValidatorContext.prototype.resolveRefs = function (schema, urlHistory) {\n\tif (schema['$ref'] !== undefined) {\n\t\turlHistory = urlHistory || {};\n\t\tif (urlHistory[schema['$ref']]) {\n\t\t\treturn this.createError(ErrorCodes.CIRCULAR_REFERENCE, {urls: Object.keys(urlHistory).join(', ')}, '', '', null, undefined, schema);\n\t\t}\n\t\turlHistory[schema['$ref']] = true;\n\t\tschema = this.getSchema(schema['$ref'], urlHistory);\n\t}\n\treturn schema;\n};\nValidatorContext.prototype.getSchema = function (url, urlHistory) {\n\tvar schema;\n\tif (this.schemas[url] !== undefined) {\n\t\tschema = this.schemas[url];\n\t\treturn this.resolveRefs(schema, urlHistory);\n\t}\n\tvar baseUrl = url;\n\tvar fragment = \"\";\n\tif (url.indexOf('#') !== -1) {\n\t\tfragment = url.substring(url.indexOf(\"#\") + 1);\n\t\tbaseUrl = url.substring(0, url.indexOf(\"#\"));\n\t}\n\tif (typeof this.schemas[baseUrl] === 'object') {\n\t\tschema = this.schemas[baseUrl];\n\t\tvar pointerPath = decodeURIComponent(fragment);\n\t\tif (pointerPath === \"\") {\n\t\t\treturn this.resolveRefs(schema, urlHistory);\n\t\t} else if (pointerPath.charAt(0) !== \"/\") {\n\t\t\treturn undefined;\n\t\t}\n\t\tvar parts = pointerPath.split(\"/\").slice(1);\n\t\tfor (var i = 0; i < parts.length; i++) {\n\t\t\tvar component = parts[i].replace(/~1/g, \"/\").replace(/~0/g, \"~\");\n\t\t\tif (schema[component] === undefined) {\n\t\t\t\tschema = undefined;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tschema = schema[component];\n\t\t}\n\t\tif (schema !== undefined) {\n\t\t\treturn this.resolveRefs(schema, urlHistory);\n\t\t}\n\t}\n\tif (this.missing[baseUrl] === undefined) {\n\t\tthis.missing.push(baseUrl);\n\t\tthis.missing[baseUrl] = baseUrl;\n\t\tthis.missingMap[baseUrl] = baseUrl;\n\t}\n};\nValidatorContext.prototype.searchSchemas = function (schema, url) {\n\tif (Array.isArray(schema)) {\n\t\tfor (var i = 0; i < schema.length; i++) {\n\t\t\tthis.searchSchemas(schema[i], url);\n\t\t}\n\t} else if (schema && typeof schema === \"object\") {\n\t\tif (typeof schema.id === \"string\") {\n\t\t\tif (isTrustedUrl(url, schema.id)) {\n\t\t\t\tif (this.schemas[schema.id] === undefined) {\n\t\t\t\t\tthis.schemas[schema.id] = schema;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (var key in schema) {\n\t\t\tif (key !== \"enum\") {\n\t\t\t\tif (typeof schema[key] === \"object\") {\n\t\t\t\t\tthis.searchSchemas(schema[key], url);\n\t\t\t\t} else if (key === \"$ref\") {\n\t\t\t\t\tvar uri = getDocumentUri(schema[key]);\n\t\t\t\t\tif (uri && this.schemas[uri] === undefined && this.missingMap[uri] === undefined) {\n\t\t\t\t\t\tthis.missingMap[uri] = uri;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n};\nValidatorContext.prototype.addSchema = function (url, schema) {\n\t//overload\n\tif (typeof url !== 'string' || typeof schema === 'undefined') {\n\t\tif (typeof url === 'object' && typeof url.id === 'string') {\n\t\t\tschema = url;\n\t\t\turl = schema.id;\n\t\t}\n\t\telse {\n\t\t\treturn;\n\t\t}\n\t}\n\tif (url === getDocumentUri(url) + \"#\") {\n\t\t// Remove empty fragment\n\t\turl = getDocumentUri(url);\n\t}\n\tthis.schemas[url] = schema;\n\tdelete this.missingMap[url];\n\tnormSchema(schema, url);\n\tthis.searchSchemas(schema, url);\n};\n\nValidatorContext.prototype.getSchemaMap = function () {\n\tvar map = {};\n\tfor (var key in this.schemas) {\n\t\tmap[key] = this.schemas[key];\n\t}\n\treturn map;\n};\n\nValidatorContext.prototype.getSchemaUris = function (filterRegExp) {\n\tvar list = [];\n\tfor (var key in this.schemas) {\n\t\tif (!filterRegExp || filterRegExp.test(key)) {\n\t\t\tlist.push(key);\n\t\t}\n\t}\n\treturn list;\n};\n\nValidatorContext.prototype.getMissingUris = function (filterRegExp) {\n\tvar list = [];\n\tfor (var key in this.missingMap) {\n\t\tif (!filterRegExp || filterRegExp.test(key)) {\n\t\t\tlist.push(key);\n\t\t}\n\t}\n\treturn list;\n};\n\nValidatorContext.prototype.dropSchemas = function () {\n\tthis.schemas = {};\n\tthis.reset();\n};\nValidatorContext.prototype.reset = function () {\n\tthis.missing = [];\n\tthis.missingMap = {};\n\tthis.errors = [];\n};\n\nValidatorContext.prototype.validateAll = function (data, schema, dataPathParts, schemaPathParts, dataPointerPath) {\n\tvar topLevel;\n\tschema = this.resolveRefs(schema);\n\tif (!schema) {\n\t\treturn null;\n\t} else if (schema instanceof ValidationError) {\n\t\tthis.errors.push(schema);\n\t\treturn schema;\n\t}\n\n\tvar startErrorCount = this.errors.length;\n\tvar frozenIndex, scannedFrozenSchemaIndex = null, scannedSchemasIndex = null;\n\tif (this.checkRecursive && data && typeof data === 'object') {\n\t\ttopLevel = !this.scanned.length;\n\t\tif (data[this.validatedSchemasKey]) {\n\t\t\tvar schemaIndex = data[this.validatedSchemasKey].indexOf(schema);\n\t\t\tif (schemaIndex !== -1) {\n\t\t\t\tthis.errors = this.errors.concat(data[this.validationErrorsKey][schemaIndex]);\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t\tif (Object.isFrozen(data)) {\n\t\t\tfrozenIndex = this.scannedFrozen.indexOf(data);\n\t\t\tif (frozenIndex !== -1) {\n\t\t\t\tvar frozenSchemaIndex = this.scannedFrozenSchemas[frozenIndex].indexOf(schema);\n\t\t\t\tif (frozenSchemaIndex !== -1) {\n\t\t\t\t\tthis.errors = this.errors.concat(this.scannedFrozenValidationErrors[frozenIndex][frozenSchemaIndex]);\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tthis.scanned.push(data);\n\t\tif (Object.isFrozen(data)) {\n\t\t\tif (frozenIndex === -1) {\n\t\t\t\tfrozenIndex = this.scannedFrozen.length;\n\t\t\t\tthis.scannedFrozen.push(data);\n\t\t\t\tthis.scannedFrozenSchemas.push([]);\n\t\t\t}\n\t\t\tscannedFrozenSchemaIndex = this.scannedFrozenSchemas[frozenIndex].length;\n\t\t\tthis.scannedFrozenSchemas[frozenIndex][scannedFrozenSchemaIndex] = schema;\n\t\t\tthis.scannedFrozenValidationErrors[frozenIndex][scannedFrozenSchemaIndex] = [];\n\t\t} else {\n\t\t\tif (!data[this.validatedSchemasKey]) {\n\t\t\t\ttry {\n\t\t\t\t\tObject.defineProperty(data, this.validatedSchemasKey, {\n\t\t\t\t\t\tvalue: [],\n\t\t\t\t\t\tconfigurable: true\n\t\t\t\t\t});\n\t\t\t\t\tObject.defineProperty(data, this.validationErrorsKey, {\n\t\t\t\t\t\tvalue: [],\n\t\t\t\t\t\tconfigurable: true\n\t\t\t\t\t});\n\t\t\t\t} catch (e) {\n\t\t\t\t\t//IE 7/8 workaround\n\t\t\t\t\tdata[this.validatedSchemasKey] = [];\n\t\t\t\t\tdata[this.validationErrorsKey] = [];\n\t\t\t\t}\n\t\t\t}\n\t\t\tscannedSchemasIndex = data[this.validatedSchemasKey].length;\n\t\t\tdata[this.validatedSchemasKey][scannedSchemasIndex] = schema;\n\t\t\tdata[this.validationErrorsKey][scannedSchemasIndex] = [];\n\t\t}\n\t}\n\n\tvar errorCount = this.errors.length;\n\tvar error = this.validateBasic(data, schema, dataPointerPath)\n\t\t|| this.validateNumeric(data, schema, dataPointerPath)\n\t\t|| this.validateString(data, schema, dataPointerPath)\n\t\t|| this.validateArray(data, schema, dataPointerPath)\n\t\t|| this.validateObject(data, schema, dataPointerPath)\n\t\t|| this.validateCombinations(data, schema, dataPointerPath)\n\t\t|| this.validateHypermedia(data, schema, dataPointerPath)\n\t\t|| this.validateFormat(data, schema, dataPointerPath)\n\t\t|| this.validateDefinedKeywords(data, schema, dataPointerPath)\n\t\t|| null;\n\n\tif (topLevel) {\n\t\twhile (this.scanned.length) {\n\t\t\tvar item = this.scanned.pop();\n\t\t\tdelete item[this.validatedSchemasKey];\n\t\t}\n\t\tthis.scannedFrozen = [];\n\t\tthis.scannedFrozenSchemas = [];\n\t}\n\n\tif (error || errorCount !== this.errors.length) {\n\t\twhile ((dataPathParts && dataPathParts.length) || (schemaPathParts && schemaPathParts.length)) {\n\t\t\tvar dataPart = (dataPathParts && dataPathParts.length) ? \"\" + dataPathParts.pop() : null;\n\t\t\tvar schemaPart = (schemaPathParts && schemaPathParts.length) ? \"\" + schemaPathParts.pop() : null;\n\t\t\tif (error) {\n\t\t\t\terror = error.prefixWith(dataPart, schemaPart);\n\t\t\t}\n\t\t\tthis.prefixErrors(errorCount, dataPart, schemaPart);\n\t\t}\n\t}\n\n\tif (scannedFrozenSchemaIndex !== null) {\n\t\tthis.scannedFrozenValidationErrors[frozenIndex][scannedFrozenSchemaIndex] = this.errors.slice(startErrorCount);\n\t} else if (scannedSchemasIndex !== null) {\n\t\tdata[this.validationErrorsKey][scannedSchemasIndex] = this.errors.slice(startErrorCount);\n\t}\n\n\treturn this.handleError(error);\n};\nValidatorContext.prototype.validateFormat = function (data, schema) {\n\tif (typeof schema.format !== 'string' || !this.formatValidators[schema.format]) {\n\t\treturn null;\n\t}\n\tvar errorMessage = this.formatValidators[schema.format].call(null, data, schema);\n\tif (typeof errorMessage === 'string' || typeof errorMessage === 'number') {\n\t\treturn this.createError(ErrorCodes.FORMAT_CUSTOM, {message: errorMessage}, '', '/format', null, data, schema);\n\t} else if (errorMessage && typeof errorMessage === 'object') {\n\t\treturn this.createError(ErrorCodes.FORMAT_CUSTOM, {message: errorMessage.message || \"?\"}, errorMessage.dataPath || '', errorMessage.schemaPath || \"/format\", null, data, schema);\n\t}\n\treturn null;\n};\nValidatorContext.prototype.validateDefinedKeywords = function (data, schema, dataPointerPath) {\n\tfor (var key in this.definedKeywords) {\n\t\tif (typeof schema[key] === 'undefined') {\n\t\t\tcontinue;\n\t\t}\n\t\tvar validationFunctions = this.definedKeywords[key];\n\t\tfor (var i = 0; i < validationFunctions.length; i++) {\n\t\t\tvar func = validationFunctions[i];\n\t\t\tvar result = func(data, schema[key], schema, dataPointerPath);\n\t\t\tif (typeof result === 'string' || typeof result === 'number') {\n\t\t\t\treturn this.createError(ErrorCodes.KEYWORD_CUSTOM, {key: key, message: result}, '', '', null, data, schema).prefixWith(null, key);\n\t\t\t} else if (result && typeof result === 'object') {\n\t\t\t\tvar code = result.code;\n\t\t\t\tif (typeof code === 'string') {\n\t\t\t\t\tif (!ErrorCodes[code]) {\n\t\t\t\t\t\tthrow new Error('Undefined error code (use defineError): ' + code);\n\t\t\t\t\t}\n\t\t\t\t\tcode = ErrorCodes[code];\n\t\t\t\t} else if (typeof code !== 'number') {\n\t\t\t\t\tcode = ErrorCodes.KEYWORD_CUSTOM;\n\t\t\t\t}\n\t\t\t\tvar messageParams = (typeof result.message === 'object') ? result.message : {key: key, message: result.message || \"?\"};\n\t\t\t\tvar schemaPath = result.schemaPath || (\"/\" + key.replace(/~/g, '~0').replace(/\\//g, '~1'));\n\t\t\t\treturn this.createError(code, messageParams, result.dataPath || null, schemaPath, null, data, schema);\n\t\t\t}\n\t\t}\n\t}\n\treturn null;\n};\n\nfunction recursiveCompare(A, B) {\n\tif (A === B) {\n\t\treturn true;\n\t}\n\tif (A && B && typeof A === \"object\" && typeof B === \"object\") {\n\t\tif (Array.isArray(A) !== Array.isArray(B)) {\n\t\t\treturn false;\n\t\t} else if (Array.isArray(A)) {\n\t\t\tif (A.length !== B.length) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tfor (var i = 0; i < A.length; i++) {\n\t\t\t\tif (!recursiveCompare(A[i], B[i])) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tvar key;\n\t\t\tfor (key in A) {\n\t\t\t\tif (B[key] === undefined && A[key] !== undefined) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (key in B) {\n\t\t\t\tif (A[key] === undefined && B[key] !== undefined) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (key in A) {\n\t\t\t\tif (!recursiveCompare(A[key], B[key])) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nValidatorContext.prototype.validateBasic = function validateBasic(data, schema, dataPointerPath) {\n\tvar error;\n\tif (error = this.validateType(data, schema, dataPointerPath)) {\n\t\treturn error.prefixWith(null, \"type\");\n\t}\n\tif (error = this.validateEnum(data, schema, dataPointerPath)) {\n\t\treturn error.prefixWith(null, \"type\");\n\t}\n\treturn null;\n};\n\nValidatorContext.prototype.validateType = function validateType(data, schema) {\n\tif (schema.type === undefined) {\n\t\treturn null;\n\t}\n\tvar dataType = typeof data;\n\tif (data === null) {\n\t\tdataType = \"null\";\n\t} else if (Array.isArray(data)) {\n\t\tdataType = \"array\";\n\t}\n\tvar allowedTypes = schema.type;\n\tif (!Array.isArray(allowedTypes)) {\n\t\tallowedTypes = [allowedTypes];\n\t}\n\n\tfor (var i = 0; i < allowedTypes.length; i++) {\n\t\tvar type = allowedTypes[i];\n\t\tif (type === dataType || (type === \"integer\" && dataType === \"number\" && (data % 1 === 0))) {\n\t\t\treturn null;\n\t\t}\n\t}\n\treturn this.createError(ErrorCodes.INVALID_TYPE, {type: dataType, expected: allowedTypes.join(\"/\")}, '', '', null, data, schema);\n};\n\nValidatorContext.prototype.validateEnum = function validateEnum(data, schema) {\n\tif (schema[\"enum\"] === undefined) {\n\t\treturn null;\n\t}\n\tfor (var i = 0; i < schema[\"enum\"].length; i++) {\n\t\tvar enumVal = schema[\"enum\"][i];\n\t\tif (recursiveCompare(data, enumVal)) {\n\t\t\treturn null;\n\t\t}\n\t}\n\treturn this.createError(ErrorCodes.ENUM_MISMATCH, {value: (typeof JSON !== 'undefined') ? JSON.stringify(data) : data}, '', '', null, data, schema);\n};\n\nValidatorContext.prototype.validateNumeric = function validateNumeric(data, schema, dataPointerPath) {\n\treturn this.validateMultipleOf(data, schema, dataPointerPath)\n\t\t|| this.validateMinMax(data, schema, dataPointerPath)\n\t\t|| this.validateNaN(data, schema, dataPointerPath)\n\t\t|| null;\n};\n\nvar CLOSE_ENOUGH_LOW = Math.pow(2, -51);\nvar CLOSE_ENOUGH_HIGH = 1 - CLOSE_ENOUGH_LOW;\nValidatorContext.prototype.validateMultipleOf = function validateMultipleOf(data, schema) {\n\tvar multipleOf = schema.multipleOf || schema.divisibleBy;\n\tif (multipleOf === undefined) {\n\t\treturn null;\n\t}\n\tif (typeof data === \"number\") {\n\t\tvar remainder = (data/multipleOf)%1;\n\t\tif (remainder >= CLOSE_ENOUGH_LOW && remainder < CLOSE_ENOUGH_HIGH) {\n\t\t\treturn this.createError(ErrorCodes.NUMBER_MULTIPLE_OF, {value: data, multipleOf: multipleOf}, '', '', null, data, schema);\n\t\t}\n\t}\n\treturn null;\n};\n\nValidatorContext.prototype.validateMinMax = function validateMinMax(data, schema) {\n\tif (typeof data !== \"number\") {\n\t\treturn null;\n\t}\n\tif (schema.minimum !== undefined) {\n\t\tif (data < schema.minimum) {\n\t\t\treturn this.createError(ErrorCodes.NUMBER_MINIMUM, {value: data, minimum: schema.minimum}, '', '/minimum', null, data, schema);\n\t\t}\n\t\tif (schema.exclusiveMinimum && data === schema.minimum) {\n\t\t\treturn this.createError(ErrorCodes.NUMBER_MINIMUM_EXCLUSIVE, {value: data, minimum: schema.minimum}, '', '/exclusiveMinimum', null, data, schema);\n\t\t}\n\t}\n\tif (schema.maximum !== undefined) {\n\t\tif (data > schema.maximum) {\n\t\t\treturn this.createError(ErrorCodes.NUMBER_MAXIMUM, {value: data, maximum: schema.maximum}, '', '/maximum', null, data, schema);\n\t\t}\n\t\tif (schema.exclusiveMaximum && data === schema.maximum) {\n\t\t\treturn this.createError(ErrorCodes.NUMBER_MAXIMUM_EXCLUSIVE, {value: data, maximum: schema.maximum}, '', '/exclusiveMaximum', null, data, schema);\n\t\t}\n\t}\n\treturn null;\n};\n\nValidatorContext.prototype.validateNaN = function validateNaN(data, schema) {\n\tif (typeof data !== \"number\") {\n\t\treturn null;\n\t}\n\tif (isNaN(data) === true || data === Infinity || data === -Infinity) {\n\t\treturn this.createError(ErrorCodes.NUMBER_NOT_A_NUMBER, {value: data}, '', '/type', null, data, schema);\n\t}\n\treturn null;\n};\n\nValidatorContext.prototype.validateString = function validateString(data, schema, dataPointerPath) {\n\treturn this.validateStringLength(data, schema, dataPointerPath)\n\t\t|| this.validateStringPattern(data, schema, dataPointerPath)\n\t\t|| null;\n};\n\nValidatorContext.prototype.validateStringLength = function validateStringLength(data, schema) {\n\tif (typeof data !== \"string\") {\n\t\treturn null;\n\t}\n\tif (schema.minLength !== undefined) {\n\t\tif (data.length < schema.minLength) {\n\t\t\treturn this.createError(ErrorCodes.STRING_LENGTH_SHORT, {length: data.length, minimum: schema.minLength}, '', '/minLength', null, data, schema);\n\t\t}\n\t}\n\tif (schema.maxLength !== undefined) {\n\t\tif (data.length > schema.maxLength) {\n\t\t\treturn this.createError(ErrorCodes.STRING_LENGTH_LONG, {length: data.length, maximum: schema.maxLength}, '', '/maxLength', null, data, schema);\n\t\t}\n\t}\n\treturn null;\n};\n\nValidatorContext.prototype.validateStringPattern = function validateStringPattern(data, schema) {\n\tif (typeof data !== \"string\" || (typeof schema.pattern !== \"string\" && !(schema.pattern instanceof RegExp))) {\n\t\treturn null;\n\t}\n\tvar regexp;\n\tif (schema.pattern instanceof RegExp) {\n\t  regexp = schema.pattern;\n\t}\n\telse {\n\t  var body, flags = '';\n\t  // Check for regular expression literals\n\t  // @see http://www.ecma-international.org/ecma-262/5.1/#sec-7.8.5\n\t  var literal = schema.pattern.match(/^\\/(.+)\\/([img]*)$/);\n\t  if (literal) {\n\t    body = literal[1];\n\t    flags = literal[2];\n\t  }\n\t  else {\n\t    body = schema.pattern;\n\t  }\n\t  regexp = new RegExp(body, flags);\n\t}\n\tif (!regexp.test(data)) {\n\t\treturn this.createError(ErrorCodes.STRING_PATTERN, {pattern: schema.pattern}, '', '/pattern', null, data, schema);\n\t}\n\treturn null;\n};\n\nValidatorContext.prototype.validateArray = function validateArray(data, schema, dataPointerPath) {\n\tif (!Array.isArray(data)) {\n\t\treturn null;\n\t}\n\treturn this.validateArrayLength(data, schema, dataPointerPath)\n\t\t|| this.validateArrayUniqueItems(data, schema, dataPointerPath)\n\t\t|| this.validateArrayItems(data, schema, dataPointerPath)\n\t\t|| null;\n};\n\nValidatorContext.prototype.validateArrayLength = function validateArrayLength(data, schema) {\n\tvar error;\n\tif (schema.minItems !== undefined) {\n\t\tif (data.length < schema.minItems) {\n\t\t\terror = this.createError(ErrorCodes.ARRAY_LENGTH_SHORT, {length: data.length, minimum: schema.minItems}, '', '/minItems', null, data, schema);\n\t\t\tif (this.handleError(error)) {\n\t\t\t\treturn error;\n\t\t\t}\n\t\t}\n\t}\n\tif (schema.maxItems !== undefined) {\n\t\tif (data.length > schema.maxItems) {\n\t\t\terror = this.createError(ErrorCodes.ARRAY_LENGTH_LONG, {length: data.length, maximum: schema.maxItems}, '', '/maxItems', null, data, schema);\n\t\t\tif (this.handleError(error)) {\n\t\t\t\treturn error;\n\t\t\t}\n\t\t}\n\t}\n\treturn null;\n};\n\nValidatorContext.prototype.validateArrayUniqueItems = function validateArrayUniqueItems(data, schema) {\n\tif (schema.uniqueItems) {\n\t\tfor (var i = 0; i < data.length; i++) {\n\t\t\tfor (var j = i + 1; j < data.length; j++) {\n\t\t\t\tif (recursiveCompare(data[i], data[j])) {\n\t\t\t\t\tvar error = this.createError(ErrorCodes.ARRAY_UNIQUE, {match1: i, match2: j}, '', '/uniqueItems', null, data, schema);\n\t\t\t\t\tif (this.handleError(error)) {\n\t\t\t\t\t\treturn error;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn null;\n};\n\nValidatorContext.prototype.validateArrayItems = function validateArrayItems(data, schema, dataPointerPath) {\n\tif (schema.items === undefined) {\n\t\treturn null;\n\t}\n\tvar error, i;\n\tif (Array.isArray(schema.items)) {\n\t\tfor (i = 0; i < data.length; i++) {\n\t\t\tif (i < schema.items.length) {\n\t\t\t\tif (error = this.validateAll(data[i], schema.items[i], [i], [\"items\", i], dataPointerPath + \"/\" + i)) {\n\t\t\t\t\treturn error;\n\t\t\t\t}\n\t\t\t} else if (schema.additionalItems !== undefined) {\n\t\t\t\tif (typeof schema.additionalItems === \"boolean\") {\n\t\t\t\t\tif (!schema.additionalItems) {\n\t\t\t\t\t\terror = (this.createError(ErrorCodes.ARRAY_ADDITIONAL_ITEMS, {}, '/' + i, '/additionalItems', null, data, schema));\n\t\t\t\t\t\tif (this.handleError(error)) {\n\t\t\t\t\t\t\treturn error;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else if (error = this.validateAll(data[i], schema.additionalItems, [i], [\"additionalItems\"], dataPointerPath + \"/\" + i)) {\n\t\t\t\t\treturn error;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} else {\n\t\tfor (i = 0; i < data.length; i++) {\n\t\t\tif (error = this.validateAll(data[i], schema.items, [i], [\"items\"], dataPointerPath + \"/\" + i)) {\n\t\t\t\treturn error;\n\t\t\t}\n\t\t}\n\t}\n\treturn null;\n};\n\nValidatorContext.prototype.validateObject = function validateObject(data, schema, dataPointerPath) {\n\tif (typeof data !== \"object\" || data === null || Array.isArray(data)) {\n\t\treturn null;\n\t}\n\treturn this.validateObjectMinMaxProperties(data, schema, dataPointerPath)\n\t\t|| this.validateObjectRequiredProperties(data, schema, dataPointerPath)\n\t\t|| this.validateObjectProperties(data, schema, dataPointerPath)\n\t\t|| this.validateObjectDependencies(data, schema, dataPointerPath)\n\t\t|| null;\n};\n\nValidatorContext.prototype.validateObjectMinMaxProperties = function validateObjectMinMaxProperties(data, schema) {\n\tvar keys = Object.keys(data);\n\tvar error;\n\tif (schema.minProperties !== undefined) {\n\t\tif (keys.length < schema.minProperties) {\n\t\t\terror = this.createError(ErrorCodes.OBJECT_PROPERTIES_MINIMUM, {propertyCount: keys.length, minimum: schema.minProperties}, '', '/minProperties', null, data, schema);\n\t\t\tif (this.handleError(error)) {\n\t\t\t\treturn error;\n\t\t\t}\n\t\t}\n\t}\n\tif (schema.maxProperties !== undefined) {\n\t\tif (keys.length > schema.maxProperties) {\n\t\t\terror = this.createError(ErrorCodes.OBJECT_PROPERTIES_MAXIMUM, {propertyCount: keys.length, maximum: schema.maxProperties}, '', '/maxProperties', null, data, schema);\n\t\t\tif (this.handleError(error)) {\n\t\t\t\treturn error;\n\t\t\t}\n\t\t}\n\t}\n\treturn null;\n};\n\nValidatorContext.prototype.validateObjectRequiredProperties = function validateObjectRequiredProperties(data, schema) {\n\tif (schema.required !== undefined) {\n\t\tfor (var i = 0; i < schema.required.length; i++) {\n\t\t\tvar key = schema.required[i];\n\t\t\tif (data[key] === undefined) {\n\t\t\t\tvar error = this.createError(ErrorCodes.OBJECT_REQUIRED, {key: key}, '', '/required/' + i, null, data, schema);\n\t\t\t\tif (this.handleError(error)) {\n\t\t\t\t\treturn error;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn null;\n};\n\nValidatorContext.prototype.validateObjectProperties = function validateObjectProperties(data, schema, dataPointerPath) {\n\tvar error;\n\tfor (var key in data) {\n\t\tvar keyPointerPath = dataPointerPath + \"/\" + key.replace(/~/g, '~0').replace(/\\//g, '~1');\n\t\tvar foundMatch = false;\n\t\tif (schema.properties !== undefined && schema.properties[key] !== undefined) {\n\t\t\tfoundMatch = true;\n\t\t\tif (error = this.validateAll(data[key], schema.properties[key], [key], [\"properties\", key], keyPointerPath)) {\n\t\t\t\treturn error;\n\t\t\t}\n\t\t}\n\t\tif (schema.patternProperties !== undefined) {\n\t\t\tfor (var patternKey in schema.patternProperties) {\n\t\t\t\tvar regexp = new RegExp(patternKey);\n\t\t\t\tif (regexp.test(key)) {\n\t\t\t\t\tfoundMatch = true;\n\t\t\t\t\tif (error = this.validateAll(data[key], schema.patternProperties[patternKey], [key], [\"patternProperties\", patternKey], keyPointerPath)) {\n\t\t\t\t\t\treturn error;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (!foundMatch) {\n\t\t\tif (schema.additionalProperties !== undefined) {\n\t\t\t\tif (this.trackUnknownProperties) {\n\t\t\t\t\tthis.knownPropertyPaths[keyPointerPath] = true;\n\t\t\t\t\tdelete this.unknownPropertyPaths[keyPointerPath];\n\t\t\t\t}\n\t\t\t\tif (typeof schema.additionalProperties === \"boolean\") {\n\t\t\t\t\tif (!schema.additionalProperties) {\n\t\t\t\t\t\terror = this.createError(ErrorCodes.OBJECT_ADDITIONAL_PROPERTIES, {key: key}, '', '/additionalProperties', null, data, schema).prefixWith(key, null);\n\t\t\t\t\t\tif (this.handleError(error)) {\n\t\t\t\t\t\t\treturn error;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (error = this.validateAll(data[key], schema.additionalProperties, [key], [\"additionalProperties\"], keyPointerPath)) {\n\t\t\t\t\t\treturn error;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (this.trackUnknownProperties && !this.knownPropertyPaths[keyPointerPath]) {\n\t\t\t\tthis.unknownPropertyPaths[keyPointerPath] = true;\n\t\t\t}\n\t\t} else if (this.trackUnknownProperties) {\n\t\t\tthis.knownPropertyPaths[keyPointerPath] = true;\n\t\t\tdelete this.unknownPropertyPaths[keyPointerPath];\n\t\t}\n\t}\n\treturn null;\n};\n\nValidatorContext.prototype.validateObjectDependencies = function validateObjectDependencies(data, schema, dataPointerPath) {\n\tvar error;\n\tif (schema.dependencies !== undefined) {\n\t\tfor (var depKey in schema.dependencies) {\n\t\t\tif (data[depKey] !== undefined) {\n\t\t\t\tvar dep = schema.dependencies[depKey];\n\t\t\t\tif (typeof dep === \"string\") {\n\t\t\t\t\tif (data[dep] === undefined) {\n\t\t\t\t\t\terror = this.createError(ErrorCodes.OBJECT_DEPENDENCY_KEY, {key: depKey, missing: dep}, '', '', null, data, schema).prefixWith(null, depKey).prefixWith(null, \"dependencies\");\n\t\t\t\t\t\tif (this.handleError(error)) {\n\t\t\t\t\t\t\treturn error;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else if (Array.isArray(dep)) {\n\t\t\t\t\tfor (var i = 0; i < dep.length; i++) {\n\t\t\t\t\t\tvar requiredKey = dep[i];\n\t\t\t\t\t\tif (data[requiredKey] === undefined) {\n\t\t\t\t\t\t\terror = this.createError(ErrorCodes.OBJECT_DEPENDENCY_KEY, {key: depKey, missing: requiredKey}, '', '/' + i, null, data, schema).prefixWith(null, depKey).prefixWith(null, \"dependencies\");\n\t\t\t\t\t\t\tif (this.handleError(error)) {\n\t\t\t\t\t\t\t\treturn error;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (error = this.validateAll(data, dep, [], [\"dependencies\", depKey], dataPointerPath)) {\n\t\t\t\t\t\treturn error;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn null;\n};\n\nValidatorContext.prototype.validateCombinations = function validateCombinations(data, schema, dataPointerPath) {\n\treturn this.validateAllOf(data, schema, dataPointerPath)\n\t\t|| this.validateAnyOf(data, schema, dataPointerPath)\n\t\t|| this.validateOneOf(data, schema, dataPointerPath)\n\t\t|| this.validateNot(data, schema, dataPointerPath)\n\t\t|| null;\n};\n\nValidatorContext.prototype.validateAllOf = function validateAllOf(data, schema, dataPointerPath) {\n\tif (schema.allOf === undefined) {\n\t\treturn null;\n\t}\n\tvar error;\n\tfor (var i = 0; i < schema.allOf.length; i++) {\n\t\tvar subSchema = schema.allOf[i];\n\t\tif (error = this.validateAll(data, subSchema, [], [\"allOf\", i], dataPointerPath)) {\n\t\t\treturn error;\n\t\t}\n\t}\n\treturn null;\n};\n\nValidatorContext.prototype.validateAnyOf = function validateAnyOf(data, schema, dataPointerPath) {\n\tif (schema.anyOf === undefined) {\n\t\treturn null;\n\t}\n\tvar errors = [];\n\tvar startErrorCount = this.errors.length;\n\tvar oldUnknownPropertyPaths, oldKnownPropertyPaths;\n\tif (this.trackUnknownProperties) {\n\t\toldUnknownPropertyPaths = this.unknownPropertyPaths;\n\t\toldKnownPropertyPaths = this.knownPropertyPaths;\n\t}\n\tvar errorAtEnd = true;\n\tfor (var i = 0; i < schema.anyOf.length; i++) {\n\t\tif (this.trackUnknownProperties) {\n\t\t\tthis.unknownPropertyPaths = {};\n\t\t\tthis.knownPropertyPaths = {};\n\t\t}\n\t\tvar subSchema = schema.anyOf[i];\n\n\t\tvar errorCount = this.errors.length;\n\t\tvar error = this.validateAll(data, subSchema, [], [\"anyOf\", i], dataPointerPath);\n\n\t\tif (error === null && errorCount === this.errors.length) {\n\t\t\tthis.errors = this.errors.slice(0, startErrorCount);\n\n\t\t\tif (this.trackUnknownProperties) {\n\t\t\t\tfor (var knownKey in this.knownPropertyPaths) {\n\t\t\t\t\toldKnownPropertyPaths[knownKey] = true;\n\t\t\t\t\tdelete oldUnknownPropertyPaths[knownKey];\n\t\t\t\t}\n\t\t\t\tfor (var unknownKey in this.unknownPropertyPaths) {\n\t\t\t\t\tif (!oldKnownPropertyPaths[unknownKey]) {\n\t\t\t\t\t\toldUnknownPropertyPaths[unknownKey] = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// We need to continue looping so we catch all the property definitions, but we don't want to return an error\n\t\t\t\terrorAtEnd = false;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\treturn null;\n\t\t}\n\t\tif (error) {\n\t\t\terrors.push(error.prefixWith(null, \"\" + i).prefixWith(null, \"anyOf\"));\n\t\t}\n\t}\n\tif (this.trackUnknownProperties) {\n\t\tthis.unknownPropertyPaths = oldUnknownPropertyPaths;\n\t\tthis.knownPropertyPaths = oldKnownPropertyPaths;\n\t}\n\tif (errorAtEnd) {\n\t\terrors = errors.concat(this.errors.slice(startErrorCount));\n\t\tthis.errors = this.errors.slice(0, startErrorCount);\n\t\treturn this.createError(ErrorCodes.ANY_OF_MISSING, {}, \"\", \"/anyOf\", errors, data, schema);\n\t}\n};\n\nValidatorContext.prototype.validateOneOf = function validateOneOf(data, schema, dataPointerPath) {\n\tif (schema.oneOf === undefined) {\n\t\treturn null;\n\t}\n\tvar validIndex = null;\n\tvar errors = [];\n\tvar startErrorCount = this.errors.length;\n\tvar oldUnknownPropertyPaths, oldKnownPropertyPaths;\n\tif (this.trackUnknownProperties) {\n\t\toldUnknownPropertyPaths = this.unknownPropertyPaths;\n\t\toldKnownPropertyPaths = this.knownPropertyPaths;\n\t}\n\tfor (var i = 0; i < schema.oneOf.length; i++) {\n\t\tif (this.trackUnknownProperties) {\n\t\t\tthis.unknownPropertyPaths = {};\n\t\t\tthis.knownPropertyPaths = {};\n\t\t}\n\t\tvar subSchema = schema.oneOf[i];\n\n\t\tvar errorCount = this.errors.length;\n\t\tvar error = this.validateAll(data, subSchema, [], [\"oneOf\", i], dataPointerPath);\n\n\t\tif (error === null && errorCount === this.errors.length) {\n\t\t\tif (validIndex === null) {\n\t\t\t\tvalidIndex = i;\n\t\t\t} else {\n\t\t\t\tthis.errors = this.errors.slice(0, startErrorCount);\n\t\t\t\treturn this.createError(ErrorCodes.ONE_OF_MULTIPLE, {index1: validIndex, index2: i}, \"\", \"/oneOf\", null, data, schema);\n\t\t\t}\n\t\t\tif (this.trackUnknownProperties) {\n\t\t\t\tfor (var knownKey in this.knownPropertyPaths) {\n\t\t\t\t\toldKnownPropertyPaths[knownKey] = true;\n\t\t\t\t\tdelete oldUnknownPropertyPaths[knownKey];\n\t\t\t\t}\n\t\t\t\tfor (var unknownKey in this.unknownPropertyPaths) {\n\t\t\t\t\tif (!oldKnownPropertyPaths[unknownKey]) {\n\t\t\t\t\t\toldUnknownPropertyPaths[unknownKey] = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (error) {\n\t\t\terrors.push(error);\n\t\t}\n\t}\n\tif (this.trackUnknownProperties) {\n\t\tthis.unknownPropertyPaths = oldUnknownPropertyPaths;\n\t\tthis.knownPropertyPaths = oldKnownPropertyPaths;\n\t}\n\tif (validIndex === null) {\n\t\terrors = errors.concat(this.errors.slice(startErrorCount));\n\t\tthis.errors = this.errors.slice(0, startErrorCount);\n\t\treturn this.createError(ErrorCodes.ONE_OF_MISSING, {}, \"\", \"/oneOf\", errors, data, schema);\n\t} else {\n\t\tthis.errors = this.errors.slice(0, startErrorCount);\n\t}\n\treturn null;\n};\n\nValidatorContext.prototype.validateNot = function validateNot(data, schema, dataPointerPath) {\n\tif (schema.not === undefined) {\n\t\treturn null;\n\t}\n\tvar oldErrorCount = this.errors.length;\n\tvar oldUnknownPropertyPaths, oldKnownPropertyPaths;\n\tif (this.trackUnknownProperties) {\n\t\toldUnknownPropertyPaths = this.unknownPropertyPaths;\n\t\toldKnownPropertyPaths = this.knownPropertyPaths;\n\t\tthis.unknownPropertyPaths = {};\n\t\tthis.knownPropertyPaths = {};\n\t}\n\tvar error = this.validateAll(data, schema.not, null, null, dataPointerPath);\n\tvar notErrors = this.errors.slice(oldErrorCount);\n\tthis.errors = this.errors.slice(0, oldErrorCount);\n\tif (this.trackUnknownProperties) {\n\t\tthis.unknownPropertyPaths = oldUnknownPropertyPaths;\n\t\tthis.knownPropertyPaths = oldKnownPropertyPaths;\n\t}\n\tif (error === null && notErrors.length === 0) {\n\t\treturn this.createError(ErrorCodes.NOT_PASSED, {}, \"\", \"/not\", null, data, schema);\n\t}\n\treturn null;\n};\n\nValidatorContext.prototype.validateHypermedia = function validateCombinations(data, schema, dataPointerPath) {\n\tif (!schema.links) {\n\t\treturn null;\n\t}\n\tvar error;\n\tfor (var i = 0; i < schema.links.length; i++) {\n\t\tvar ldo = schema.links[i];\n\t\tif (ldo.rel === \"describedby\") {\n\t\t\tvar template = new UriTemplate(ldo.href);\n\t\t\tvar allPresent = true;\n\t\t\tfor (var j = 0; j < template.varNames.length; j++) {\n\t\t\t\tif (!(template.varNames[j] in data)) {\n\t\t\t\t\tallPresent = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (allPresent) {\n\t\t\t\tvar schemaUrl = template.fillFromObject(data);\n\t\t\t\tvar subSchema = {\"$ref\": schemaUrl};\n\t\t\t\tif (error = this.validateAll(data, subSchema, [], [\"links\", i], dataPointerPath)) {\n\t\t\t\t\treturn error;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n};\n\n// parseURI() and resolveUrl() are from https://gist.github.com/1088850\n//   -  released as public domain by author (\"Yaffle\") - see comments on gist\n\nfunction parseURI(url) {\n\tvar m = String(url).replace(/^\\s+|\\s+$/g, '').match(/^([^:\\/?#]+:)?(\\/\\/(?:[^:@]*(?::[^:@]*)?@)?(([^:\\/?#]*)(?::(\\d*))?))?([^?#]*)(\\?[^#]*)?(#[\\s\\S]*)?/);\n\t// authority = '//' + user + ':' + pass '@' + hostname + ':' port\n\treturn (m ? {\n\t\thref     : m[0] || '',\n\t\tprotocol : m[1] || '',\n\t\tauthority: m[2] || '',\n\t\thost     : m[3] || '',\n\t\thostname : m[4] || '',\n\t\tport     : m[5] || '',\n\t\tpathname : m[6] || '',\n\t\tsearch   : m[7] || '',\n\t\thash     : m[8] || ''\n\t} : null);\n}\n\nfunction resolveUrl(base, href) {// RFC 3986\n\n\tfunction removeDotSegments(input) {\n\t\tvar output = [];\n\t\tinput.replace(/^(\\.\\.?(\\/|$))+/, '')\n\t\t\t.replace(/\\/(\\.(\\/|$))+/g, '/')\n\t\t\t.replace(/\\/\\.\\.$/, '/../')\n\t\t\t.replace(/\\/?[^\\/]*/g, function (p) {\n\t\t\t\tif (p === '/..') {\n\t\t\t\t\toutput.pop();\n\t\t\t\t} else {\n\t\t\t\t\toutput.push(p);\n\t\t\t\t}\n\t\t});\n\t\treturn output.join('').replace(/^\\//, input.charAt(0) === '/' ? '/' : '');\n\t}\n\n\thref = parseURI(href || '');\n\tbase = parseURI(base || '');\n\n\treturn !href || !base ? null : (href.protocol || base.protocol) +\n\t\t(href.protocol || href.authority ? href.authority : base.authority) +\n\t\tremoveDotSegments(href.protocol || href.authority || href.pathname.charAt(0) === '/' ? href.pathname : (href.pathname ? ((base.authority && !base.pathname ? '/' : '') + base.pathname.slice(0, base.pathname.lastIndexOf('/') + 1) + href.pathname) : base.pathname)) +\n\t\t(href.protocol || href.authority || href.pathname ? href.search : (href.search || base.search)) +\n\t\thref.hash;\n}\n\nfunction getDocumentUri(uri) {\n\treturn uri.split('#')[0];\n}\nfunction normSchema(schema, baseUri) {\n\tif (schema && typeof schema === \"object\") {\n\t\tif (baseUri === undefined) {\n\t\t\tbaseUri = schema.id;\n\t\t} else if (typeof schema.id === \"string\") {\n\t\t\tbaseUri = resolveUrl(baseUri, schema.id);\n\t\t\tschema.id = baseUri;\n\t\t}\n\t\tif (Array.isArray(schema)) {\n\t\t\tfor (var i = 0; i < schema.length; i++) {\n\t\t\t\tnormSchema(schema[i], baseUri);\n\t\t\t}\n\t\t} else {\n\t\t\tif (typeof schema['$ref'] === \"string\") {\n\t\t\t\tschema['$ref'] = resolveUrl(baseUri, schema['$ref']);\n\t\t\t}\n\t\t\tfor (var key in schema) {\n\t\t\t\tif (key !== \"enum\") {\n\t\t\t\t\tnormSchema(schema[key], baseUri);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunction defaultErrorReporter(language) {\n\tlanguage = language || 'en';\n\n\tvar errorMessages = languages[language];\n\n\treturn function (error) {\n\t\tvar messageTemplate = errorMessages[error.code] || ErrorMessagesDefault[error.code];\n\t\tif (typeof messageTemplate !== 'string') {\n\t\t\treturn \"Unknown error code \" + error.code + \": \" + JSON.stringify(error.messageParams);\n\t\t}\n\t\tvar messageParams = error.params;\n\t\t// Adapted from Crockford's supplant()\n\t\treturn messageTemplate.replace(/\\{([^{}]*)\\}/g, function (whole, varName) {\n\t\t\tvar subValue = messageParams[varName];\n\t\t\treturn typeof subValue === 'string' || typeof subValue === 'number' ? subValue : whole;\n\t\t});\n\t};\n}\n\nvar ErrorCodes = {\n\tINVALID_TYPE: 0,\n\tENUM_MISMATCH: 1,\n\tANY_OF_MISSING: 10,\n\tONE_OF_MISSING: 11,\n\tONE_OF_MULTIPLE: 12,\n\tNOT_PASSED: 13,\n\t// Numeric errors\n\tNUMBER_MULTIPLE_OF: 100,\n\tNUMBER_MINIMUM: 101,\n\tNUMBER_MINIMUM_EXCLUSIVE: 102,\n\tNUMBER_MAXIMUM: 103,\n\tNUMBER_MAXIMUM_EXCLUSIVE: 104,\n\tNUMBER_NOT_A_NUMBER: 105,\n\t// String errors\n\tSTRING_LENGTH_SHORT: 200,\n\tSTRING_LENGTH_LONG: 201,\n\tSTRING_PATTERN: 202,\n\t// Object errors\n\tOBJECT_PROPERTIES_MINIMUM: 300,\n\tOBJECT_PROPERTIES_MAXIMUM: 301,\n\tOBJECT_REQUIRED: 302,\n\tOBJECT_ADDITIONAL_PROPERTIES: 303,\n\tOBJECT_DEPENDENCY_KEY: 304,\n\t// Array errors\n\tARRAY_LENGTH_SHORT: 400,\n\tARRAY_LENGTH_LONG: 401,\n\tARRAY_UNIQUE: 402,\n\tARRAY_ADDITIONAL_ITEMS: 403,\n\t// Custom/user-defined errors\n\tFORMAT_CUSTOM: 500,\n\tKEYWORD_CUSTOM: 501,\n\t// Schema structure\n\tCIRCULAR_REFERENCE: 600,\n\t// Non-standard validation options\n\tUNKNOWN_PROPERTY: 1000\n};\nvar ErrorCodeLookup = {};\nfor (var key in ErrorCodes) {\n\tErrorCodeLookup[ErrorCodes[key]] = key;\n}\nvar ErrorMessagesDefault = {\n\tINVALID_TYPE: \"Invalid type: {type} (expected {expected})\",\n\tENUM_MISMATCH: \"No enum match for: {value}\",\n\tANY_OF_MISSING: \"Data does not match any schemas from \\\"anyOf\\\"\",\n\tONE_OF_MISSING: \"Data does not match any schemas from \\\"oneOf\\\"\",\n\tONE_OF_MULTIPLE: \"Data is valid against more than one schema from \\\"oneOf\\\": indices {index1} and {index2}\",\n\tNOT_PASSED: \"Data matches schema from \\\"not\\\"\",\n\t// Numeric errors\n\tNUMBER_MULTIPLE_OF: \"Value {value} is not a multiple of {multipleOf}\",\n\tNUMBER_MINIMUM: \"Value {value} is less than minimum {minimum}\",\n\tNUMBER_MINIMUM_EXCLUSIVE: \"Value {value} is equal to exclusive minimum {minimum}\",\n\tNUMBER_MAXIMUM: \"Value {value} is greater than maximum {maximum}\",\n\tNUMBER_MAXIMUM_EXCLUSIVE: \"Value {value} is equal to exclusive maximum {maximum}\",\n\tNUMBER_NOT_A_NUMBER: \"Value {value} is not a valid number\",\n\t// String errors\n\tSTRING_LENGTH_SHORT: \"String is too short ({length} chars), minimum {minimum}\",\n\tSTRING_LENGTH_LONG: \"String is too long ({length} chars), maximum {maximum}\",\n\tSTRING_PATTERN: \"String does not match pattern: {pattern}\",\n\t// Object errors\n\tOBJECT_PROPERTIES_MINIMUM: \"Too few properties defined ({propertyCount}), minimum {minimum}\",\n\tOBJECT_PROPERTIES_MAXIMUM: \"Too many properties defined ({propertyCount}), maximum {maximum}\",\n\tOBJECT_REQUIRED: \"Missing required property: {key}\",\n\tOBJECT_ADDITIONAL_PROPERTIES: \"Additional properties not allowed\",\n\tOBJECT_DEPENDENCY_KEY: \"Dependency failed - key must exist: {missing} (due to key: {key})\",\n\t// Array errors\n\tARRAY_LENGTH_SHORT: \"Array is too short ({length}), minimum {minimum}\",\n\tARRAY_LENGTH_LONG: \"Array is too long ({length}), maximum {maximum}\",\n\tARRAY_UNIQUE: \"Array items are not unique (indices {match1} and {match2})\",\n\tARRAY_ADDITIONAL_ITEMS: \"Additional items not allowed\",\n\t// Format errors\n\tFORMAT_CUSTOM: \"Format validation failed ({message})\",\n\tKEYWORD_CUSTOM: \"Keyword failed: {key} ({message})\",\n\t// Schema structure\n\tCIRCULAR_REFERENCE: \"Circular $refs: {urls}\",\n\t// Non-standard validation options\n\tUNKNOWN_PROPERTY: \"Unknown property (not in schema)\"\n};\n\nfunction ValidationError(code, params, dataPath, schemaPath, subErrors) {\n\tError.call(this);\n\tif (code === undefined) {\n\t\tthrow new Error (\"No error code supplied: \" + schemaPath);\n\t}\n\tthis.message = '';\n\tthis.params = params;\n\tthis.code = code;\n\tthis.dataPath = dataPath || \"\";\n\tthis.schemaPath = schemaPath || \"\";\n\tthis.subErrors = subErrors || null;\n\n\tvar err = new Error(this.message);\n\tthis.stack = err.stack || err.stacktrace;\n\tif (!this.stack) {\n\t\ttry {\n\t\t\tthrow err;\n\t\t}\n\t\tcatch(err) {\n\t\t\tthis.stack = err.stack || err.stacktrace;\n\t\t}\n\t}\n}\nValidationError.prototype = Object.create(Error.prototype);\nValidationError.prototype.constructor = ValidationError;\nValidationError.prototype.name = 'ValidationError';\n\nValidationError.prototype.prefixWith = function (dataPrefix, schemaPrefix) {\n\tif (dataPrefix !== null) {\n\t\tdataPrefix = dataPrefix.replace(/~/g, \"~0\").replace(/\\//g, \"~1\");\n\t\tthis.dataPath = \"/\" + dataPrefix + this.dataPath;\n\t}\n\tif (schemaPrefix !== null) {\n\t\tschemaPrefix = schemaPrefix.replace(/~/g, \"~0\").replace(/\\//g, \"~1\");\n\t\tthis.schemaPath = \"/\" + schemaPrefix + this.schemaPath;\n\t}\n\tif (this.subErrors !== null) {\n\t\tfor (var i = 0; i < this.subErrors.length; i++) {\n\t\t\tthis.subErrors[i].prefixWith(dataPrefix, schemaPrefix);\n\t\t}\n\t}\n\treturn this;\n};\n\nfunction isTrustedUrl(baseUrl, testUrl) {\n\tif(testUrl.substring(0, baseUrl.length) === baseUrl){\n\t\tvar remainder = testUrl.substring(baseUrl.length);\n\t\tif ((testUrl.length > 0 && testUrl.charAt(baseUrl.length - 1) === \"/\")\n\t\t\t|| remainder.charAt(0) === \"#\"\n\t\t\t|| remainder.charAt(0) === \"?\") {\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nvar languages = {};\nfunction createApi(language) {\n\tvar globalContext = new ValidatorContext();\n\tvar currentLanguage;\n\tvar customErrorReporter;\n\tvar api = {\n\t\tsetErrorReporter: function (reporter) {\n\t\t\tif (typeof reporter === 'string') {\n\t\t\t\treturn this.language(reporter);\n\t\t\t}\n\t\t\tcustomErrorReporter = reporter;\n\t\t\treturn true;\n\t\t},\n\t\taddFormat: function () {\n\t\t\tglobalContext.addFormat.apply(globalContext, arguments);\n\t\t},\n\t\tlanguage: function (code) {\n\t\t\tif (!code) {\n\t\t\t\treturn currentLanguage;\n\t\t\t}\n\t\t\tif (!languages[code]) {\n\t\t\t\tcode = code.split('-')[0]; // fall back to base language\n\t\t\t}\n\t\t\tif (languages[code]) {\n\t\t\t\tcurrentLanguage = code;\n\t\t\t\treturn code; // so you can tell if fall-back has happened\n\t\t\t}\n\t\t\treturn false;\n\t\t},\n\t\taddLanguage: function (code, messageMap) {\n\t\t\tvar key;\n\t\t\tfor (key in ErrorCodes) {\n\t\t\t\tif (messageMap[key] && !messageMap[ErrorCodes[key]]) {\n\t\t\t\t\tmessageMap[ErrorCodes[key]] = messageMap[key];\n\t\t\t\t}\n\t\t\t}\n\t\t\tvar rootCode = code.split('-')[0];\n\t\t\tif (!languages[rootCode]) { // use for base language if not yet defined\n\t\t\t\tlanguages[code] = messageMap;\n\t\t\t\tlanguages[rootCode] = messageMap;\n\t\t\t} else {\n\t\t\t\tlanguages[code] = Object.create(languages[rootCode]);\n\t\t\t\tfor (key in messageMap) {\n\t\t\t\t\tif (typeof languages[rootCode][key] === 'undefined') {\n\t\t\t\t\t\tlanguages[rootCode][key] = messageMap[key];\n\t\t\t\t\t}\n\t\t\t\t\tlanguages[code][key] = messageMap[key];\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn this;\n\t\t},\n\t\tfreshApi: function (language) {\n\t\t\tvar result = createApi();\n\t\t\tif (language) {\n\t\t\t\tresult.language(language);\n\t\t\t}\n\t\t\treturn result;\n\t\t},\n\t\tvalidate: function (data, schema, checkRecursive, banUnknownProperties) {\n\t\t\tvar def = defaultErrorReporter(currentLanguage);\n\t\t\tvar errorReporter = customErrorReporter ? function (error, data, schema) {\n\t\t\t\treturn customErrorReporter(error, data, schema) || def(error, data, schema);\n\t\t\t} : def;\n\t\t\tvar context = new ValidatorContext(globalContext, false, errorReporter, checkRecursive, banUnknownProperties);\n\t\t\tif (typeof schema === \"string\") {\n\t\t\t\tschema = {\"$ref\": schema};\n\t\t\t}\n\t\t\tcontext.addSchema(\"\", schema);\n\t\t\tvar error = context.validateAll(data, schema, null, null, \"\");\n\t\t\tif (!error && banUnknownProperties) {\n\t\t\t\terror = context.banUnknownProperties(data, schema);\n\t\t\t}\n\t\t\tthis.error = error;\n\t\t\tthis.missing = context.missing;\n\t\t\tthis.valid = (error === null);\n\t\t\treturn this.valid;\n\t\t},\n\t\tvalidateResult: function () {\n\t\t\tvar result = {};\n\t\t\tthis.validate.apply(result, arguments);\n\t\t\treturn result;\n\t\t},\n\t\tvalidateMultiple: function (data, schema, checkRecursive, banUnknownProperties) {\n\t\t\tvar def = defaultErrorReporter(currentLanguage);\n\t\t\tvar errorReporter = customErrorReporter ? function (error, data, schema) {\n\t\t\t\treturn customErrorReporter(error, data, schema) || def(error, data, schema);\n\t\t\t} : def;\n\t\t\tvar context = new ValidatorContext(globalContext, true, errorReporter, checkRecursive, banUnknownProperties);\n\t\t\tif (typeof schema === \"string\") {\n\t\t\t\tschema = {\"$ref\": schema};\n\t\t\t}\n\t\t\tcontext.addSchema(\"\", schema);\n\t\t\tcontext.validateAll(data, schema, null, null, \"\");\n\t\t\tif (banUnknownProperties) {\n\t\t\t\tcontext.banUnknownProperties(data, schema);\n\t\t\t}\n\t\t\tvar result = {};\n\t\t\tresult.errors = context.errors;\n\t\t\tresult.missing = context.missing;\n\t\t\tresult.valid = (result.errors.length === 0);\n\t\t\treturn result;\n\t\t},\n\t\taddSchema: function () {\n\t\t\treturn globalContext.addSchema.apply(globalContext, arguments);\n\t\t},\n\t\tgetSchema: function () {\n\t\t\treturn globalContext.getSchema.apply(globalContext, arguments);\n\t\t},\n\t\tgetSchemaMap: function () {\n\t\t\treturn globalContext.getSchemaMap.apply(globalContext, arguments);\n\t\t},\n\t\tgetSchemaUris: function () {\n\t\t\treturn globalContext.getSchemaUris.apply(globalContext, arguments);\n\t\t},\n\t\tgetMissingUris: function () {\n\t\t\treturn globalContext.getMissingUris.apply(globalContext, arguments);\n\t\t},\n\t\tdropSchemas: function () {\n\t\t\tglobalContext.dropSchemas.apply(globalContext, arguments);\n\t\t},\n\t\tdefineKeyword: function () {\n\t\t\tglobalContext.defineKeyword.apply(globalContext, arguments);\n\t\t},\n\t\tdefineError: function (codeName, codeNumber, defaultMessage) {\n\t\t\tif (typeof codeName !== 'string' || !/^[A-Z]+(_[A-Z]+)*$/.test(codeName)) {\n\t\t\t\tthrow new Error('Code name must be a string in UPPER_CASE_WITH_UNDERSCORES');\n\t\t\t}\n\t\t\tif (typeof codeNumber !== 'number' || codeNumber%1 !== 0 || codeNumber < 10000) {\n\t\t\t\tthrow new Error('Code number must be an integer > 10000');\n\t\t\t}\n\t\t\tif (typeof ErrorCodes[codeName] !== 'undefined') {\n\t\t\t\tthrow new Error('Error already defined: ' + codeName + ' as ' + ErrorCodes[codeName]);\n\t\t\t}\n\t\t\tif (typeof ErrorCodeLookup[codeNumber] !== 'undefined') {\n\t\t\t\tthrow new Error('Error code already used: ' + ErrorCodeLookup[codeNumber] + ' as ' + codeNumber);\n\t\t\t}\n\t\t\tErrorCodes[codeName] = codeNumber;\n\t\t\tErrorCodeLookup[codeNumber] = codeName;\n\t\t\tErrorMessagesDefault[codeName] = ErrorMessagesDefault[codeNumber] = defaultMessage;\n\t\t\tfor (var langCode in languages) {\n\t\t\t\tvar language = languages[langCode];\n\t\t\t\tif (language[codeName]) {\n\t\t\t\t\tlanguage[codeNumber] = language[codeNumber] || language[codeName];\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\treset: function () {\n\t\t\tglobalContext.reset();\n\t\t\tthis.error = null;\n\t\t\tthis.missing = [];\n\t\t\tthis.valid = true;\n\t\t},\n\t\tmissing: [],\n\t\terror: null,\n\t\tvalid: true,\n\t\tnormSchema: normSchema,\n\t\tresolveUrl: resolveUrl,\n\t\tgetDocumentUri: getDocumentUri,\n\t\terrorCodes: ErrorCodes\n\t};\n\tapi.language(language || 'en');\n\treturn api;\n}\n\nvar tv4 = createApi();\ntv4.addLanguage('en-gb', ErrorMessagesDefault);\n\n//legacy property\ntv4.tv4 = tv4;\n\nreturn tv4; // used by _header.js to globalise.\n\n}));\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3R2NC90djQuanM/NDViNSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixlQUFlO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUIscUJBQXFCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsU0FBUztBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGOztBQUVBO0FBQ0E7QUFDQTtBQUNB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQsc0JBQXNCO0FBQzNFLEVBQUU7QUFDRixxREFBcUQscUNBQXFD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LENBQUMiLCJmaWxlIjoiMTEuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuQXV0aG9yOiBHZXJhaW50IEx1ZmYgYW5kIG90aGVyc1xuWWVhcjogMjAxM1xuXG5UaGlzIGNvZGUgaXMgcmVsZWFzZWQgaW50byB0aGUgXCJwdWJsaWMgZG9tYWluXCIgYnkgaXRzIGF1dGhvcihzKS4gIEFueWJvZHkgbWF5IHVzZSwgYWx0ZXIgYW5kIGRpc3RyaWJ1dGUgdGhlIGNvZGUgd2l0aG91dCByZXN0cmljdGlvbi4gIFRoZSBhdXRob3IgbWFrZXMgbm8gZ3VhcmFudGVlcywgYW5kIHRha2VzIG5vIGxpYWJpbGl0eSBvZiBhbnkga2luZCBmb3IgdXNlIG9mIHRoaXMgY29kZS5cblxuSWYgeW91IGZpbmQgYSBidWcgb3IgbWFrZSBhbiBpbXByb3ZlbWVudCwgaXQgd291bGQgYmUgY291cnRlb3VzIHRvIGxldCB0aGUgYXV0aG9yIGtub3csIGJ1dCBpdCBpcyBub3QgY29tcHVsc29yeS5cbiovXG4oZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuICBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XG4gICAgLy8gQU1ELiBSZWdpc3RlciBhcyBhbiBhbm9ueW1vdXMgbW9kdWxlLlxuICAgIGRlZmluZShbXSwgZmFjdG9yeSk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgJiYgbW9kdWxlLmV4cG9ydHMpe1xuICAgIC8vIENvbW1vbkpTLiBEZWZpbmUgZXhwb3J0LlxuICAgIG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpO1xuICB9IGVsc2Uge1xuICAgIC8vIEJyb3dzZXIgZ2xvYmFsc1xuICAgIGdsb2JhbC50djQgPSBmYWN0b3J5KCk7XG4gIH1cbn0odGhpcywgZnVuY3Rpb24gKCkge1xuXG4vLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9PYmplY3Qva2V5cz9yZWRpcmVjdGxvY2FsZT1lbi1VUyZyZWRpcmVjdHNsdWc9SmF2YVNjcmlwdCUyRlJlZmVyZW5jZSUyRkdsb2JhbF9PYmplY3RzJTJGT2JqZWN0JTJGa2V5c1xuaWYgKCFPYmplY3Qua2V5cykge1xuXHRPYmplY3Qua2V5cyA9IChmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSxcblx0XHRcdGhhc0RvbnRFbnVtQnVnID0gISh7dG9TdHJpbmc6IG51bGx9KS5wcm9wZXJ0eUlzRW51bWVyYWJsZSgndG9TdHJpbmcnKSxcblx0XHRcdGRvbnRFbnVtcyA9IFtcblx0XHRcdFx0J3RvU3RyaW5nJyxcblx0XHRcdFx0J3RvTG9jYWxlU3RyaW5nJyxcblx0XHRcdFx0J3ZhbHVlT2YnLFxuXHRcdFx0XHQnaGFzT3duUHJvcGVydHknLFxuXHRcdFx0XHQnaXNQcm90b3R5cGVPZicsXG5cdFx0XHRcdCdwcm9wZXJ0eUlzRW51bWVyYWJsZScsXG5cdFx0XHRcdCdjb25zdHJ1Y3Rvcidcblx0XHRcdF0sXG5cdFx0XHRkb250RW51bXNMZW5ndGggPSBkb250RW51bXMubGVuZ3RoO1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uIChvYmopIHtcblx0XHRcdGlmICh0eXBlb2Ygb2JqICE9PSAnb2JqZWN0JyAmJiB0eXBlb2Ygb2JqICE9PSAnZnVuY3Rpb24nIHx8IG9iaiA9PT0gbnVsbCkge1xuXHRcdFx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCdPYmplY3Qua2V5cyBjYWxsZWQgb24gbm9uLW9iamVjdCcpO1xuXHRcdFx0fVxuXG5cdFx0XHR2YXIgcmVzdWx0ID0gW107XG5cblx0XHRcdGZvciAodmFyIHByb3AgaW4gb2JqKSB7XG5cdFx0XHRcdGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgcHJvcCkpIHtcblx0XHRcdFx0XHRyZXN1bHQucHVzaChwcm9wKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoaGFzRG9udEVudW1CdWcpIHtcblx0XHRcdFx0Zm9yICh2YXIgaT0wOyBpIDwgZG9udEVudW1zTGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0XHRpZiAoaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGRvbnRFbnVtc1tpXSkpIHtcblx0XHRcdFx0XHRcdHJlc3VsdC5wdXNoKGRvbnRFbnVtc1tpXSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcmVzdWx0O1xuXHRcdH07XG5cdH0pKCk7XG59XG4vLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9PYmplY3QvY3JlYXRlXG5pZiAoIU9iamVjdC5jcmVhdGUpIHtcblx0T2JqZWN0LmNyZWF0ZSA9IChmdW5jdGlvbigpe1xuXHRcdGZ1bmN0aW9uIEYoKXt9XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24obyl7XG5cdFx0XHRpZiAoYXJndW1lbnRzLmxlbmd0aCAhPT0gMSkge1xuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ09iamVjdC5jcmVhdGUgaW1wbGVtZW50YXRpb24gb25seSBhY2NlcHRzIG9uZSBwYXJhbWV0ZXIuJyk7XG5cdFx0XHR9XG5cdFx0XHRGLnByb3RvdHlwZSA9IG87XG5cdFx0XHRyZXR1cm4gbmV3IEYoKTtcblx0XHR9O1xuXHR9KSgpO1xufVxuLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvQXJyYXkvaXNBcnJheT9yZWRpcmVjdGxvY2FsZT1lbi1VUyZyZWRpcmVjdHNsdWc9SmF2YVNjcmlwdCUyRlJlZmVyZW5jZSUyRkdsb2JhbF9PYmplY3RzJTJGQXJyYXklMkZpc0FycmF5XG5pZighQXJyYXkuaXNBcnJheSkge1xuXHRBcnJheS5pc0FycmF5ID0gZnVuY3Rpb24gKHZBcmcpIHtcblx0XHRyZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZBcmcpID09PSBcIltvYmplY3QgQXJyYXldXCI7XG5cdH07XG59XG4vLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9BcnJheS9pbmRleE9mP3JlZGlyZWN0bG9jYWxlPWVuLVVTJnJlZGlyZWN0c2x1Zz1KYXZhU2NyaXB0JTJGUmVmZXJlbmNlJTJGR2xvYmFsX09iamVjdHMlMkZBcnJheSUyRmluZGV4T2ZcbmlmICghQXJyYXkucHJvdG90eXBlLmluZGV4T2YpIHtcblx0QXJyYXkucHJvdG90eXBlLmluZGV4T2YgPSBmdW5jdGlvbiAoc2VhcmNoRWxlbWVudCAvKiwgZnJvbUluZGV4ICovICkge1xuXHRcdGlmICh0aGlzID09PSBudWxsKSB7XG5cdFx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCk7XG5cdFx0fVxuXHRcdHZhciB0ID0gT2JqZWN0KHRoaXMpO1xuXHRcdHZhciBsZW4gPSB0Lmxlbmd0aCA+Pj4gMDtcblxuXHRcdGlmIChsZW4gPT09IDApIHtcblx0XHRcdHJldHVybiAtMTtcblx0XHR9XG5cdFx0dmFyIG4gPSAwO1xuXHRcdGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuXHRcdFx0biA9IE51bWJlcihhcmd1bWVudHNbMV0pO1xuXHRcdFx0aWYgKG4gIT09IG4pIHsgLy8gc2hvcnRjdXQgZm9yIHZlcmlmeWluZyBpZiBpdCdzIE5hTlxuXHRcdFx0XHRuID0gMDtcblx0XHRcdH0gZWxzZSBpZiAobiAhPT0gMCAmJiBuICE9PSBJbmZpbml0eSAmJiBuICE9PSAtSW5maW5pdHkpIHtcblx0XHRcdFx0biA9IChuID4gMCB8fCAtMSkgKiBNYXRoLmZsb29yKE1hdGguYWJzKG4pKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0aWYgKG4gPj0gbGVuKSB7XG5cdFx0XHRyZXR1cm4gLTE7XG5cdFx0fVxuXHRcdHZhciBrID0gbiA+PSAwID8gbiA6IE1hdGgubWF4KGxlbiAtIE1hdGguYWJzKG4pLCAwKTtcblx0XHRmb3IgKDsgayA8IGxlbjsgaysrKSB7XG5cdFx0XHRpZiAoayBpbiB0ICYmIHRba10gPT09IHNlYXJjaEVsZW1lbnQpIHtcblx0XHRcdFx0cmV0dXJuIGs7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiAtMTtcblx0fTtcbn1cblxuLy8gR3J1bmdleSBPYmplY3QuaXNGcm96ZW4gaGFja1xuaWYgKCFPYmplY3QuaXNGcm96ZW4pIHtcblx0T2JqZWN0LmlzRnJvemVuID0gZnVuY3Rpb24gKG9iaikge1xuXHRcdHZhciBrZXkgPSBcInR2NF90ZXN0X2Zyb3plbl9rZXlcIjtcblx0XHR3aGlsZSAob2JqLmhhc093blByb3BlcnR5KGtleSkpIHtcblx0XHRcdGtleSArPSBNYXRoLnJhbmRvbSgpO1xuXHRcdH1cblx0XHR0cnkge1xuXHRcdFx0b2JqW2tleV0gPSB0cnVlO1xuXHRcdFx0ZGVsZXRlIG9ialtrZXldO1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblx0fTtcbn1cbi8vIEJhc2VkIG9uOiBodHRwczovL2dpdGh1Yi5jb20vZ2VyYWludGx1ZmYvdXJpLXRlbXBsYXRlcywgYnV0IHdpdGggYWxsIHRoZSBkZS1zdWJzdGl0dXRpb24gc3R1ZmYgcmVtb3ZlZFxuXG52YXIgdXJpVGVtcGxhdGVHbG9iYWxNb2RpZmllcnMgPSB7XG5cdFwiK1wiOiB0cnVlLFxuXHRcIiNcIjogdHJ1ZSxcblx0XCIuXCI6IHRydWUsXG5cdFwiL1wiOiB0cnVlLFxuXHRcIjtcIjogdHJ1ZSxcblx0XCI/XCI6IHRydWUsXG5cdFwiJlwiOiB0cnVlXG59O1xudmFyIHVyaVRlbXBsYXRlU3VmZmljZXMgPSB7XG5cdFwiKlwiOiB0cnVlXG59O1xuXG5mdW5jdGlvbiBub3RSZWFsbHlQZXJjZW50RW5jb2RlKHN0cmluZykge1xuXHRyZXR1cm4gZW5jb2RlVVJJKHN0cmluZykucmVwbGFjZSgvJTI1WzAtOV1bMC05XS9nLCBmdW5jdGlvbiAoZG91YmxlRW5jb2RlZCkge1xuXHRcdHJldHVybiBcIiVcIiArIGRvdWJsZUVuY29kZWQuc3Vic3RyaW5nKDMpO1xuXHR9KTtcbn1cblxuZnVuY3Rpb24gdXJpVGVtcGxhdGVTdWJzdGl0dXRpb24oc3BlYykge1xuXHR2YXIgbW9kaWZpZXIgPSBcIlwiO1xuXHRpZiAodXJpVGVtcGxhdGVHbG9iYWxNb2RpZmllcnNbc3BlYy5jaGFyQXQoMCldKSB7XG5cdFx0bW9kaWZpZXIgPSBzcGVjLmNoYXJBdCgwKTtcblx0XHRzcGVjID0gc3BlYy5zdWJzdHJpbmcoMSk7XG5cdH1cblx0dmFyIHNlcGFyYXRvciA9IFwiXCI7XG5cdHZhciBwcmVmaXggPSBcIlwiO1xuXHR2YXIgc2hvdWxkRXNjYXBlID0gdHJ1ZTtcblx0dmFyIHNob3dWYXJpYWJsZXMgPSBmYWxzZTtcblx0dmFyIHRyaW1FbXB0eVN0cmluZyA9IGZhbHNlO1xuXHRpZiAobW9kaWZpZXIgPT09ICcrJykge1xuXHRcdHNob3VsZEVzY2FwZSA9IGZhbHNlO1xuXHR9IGVsc2UgaWYgKG1vZGlmaWVyID09PSBcIi5cIikge1xuXHRcdHByZWZpeCA9IFwiLlwiO1xuXHRcdHNlcGFyYXRvciA9IFwiLlwiO1xuXHR9IGVsc2UgaWYgKG1vZGlmaWVyID09PSBcIi9cIikge1xuXHRcdHByZWZpeCA9IFwiL1wiO1xuXHRcdHNlcGFyYXRvciA9IFwiL1wiO1xuXHR9IGVsc2UgaWYgKG1vZGlmaWVyID09PSAnIycpIHtcblx0XHRwcmVmaXggPSBcIiNcIjtcblx0XHRzaG91bGRFc2NhcGUgPSBmYWxzZTtcblx0fSBlbHNlIGlmIChtb2RpZmllciA9PT0gJzsnKSB7XG5cdFx0cHJlZml4ID0gXCI7XCI7XG5cdFx0c2VwYXJhdG9yID0gXCI7XCI7XG5cdFx0c2hvd1ZhcmlhYmxlcyA9IHRydWU7XG5cdFx0dHJpbUVtcHR5U3RyaW5nID0gdHJ1ZTtcblx0fSBlbHNlIGlmIChtb2RpZmllciA9PT0gJz8nKSB7XG5cdFx0cHJlZml4ID0gXCI/XCI7XG5cdFx0c2VwYXJhdG9yID0gXCImXCI7XG5cdFx0c2hvd1ZhcmlhYmxlcyA9IHRydWU7XG5cdH0gZWxzZSBpZiAobW9kaWZpZXIgPT09ICcmJykge1xuXHRcdHByZWZpeCA9IFwiJlwiO1xuXHRcdHNlcGFyYXRvciA9IFwiJlwiO1xuXHRcdHNob3dWYXJpYWJsZXMgPSB0cnVlO1xuXHR9XG5cblx0dmFyIHZhck5hbWVzID0gW107XG5cdHZhciB2YXJMaXN0ID0gc3BlYy5zcGxpdChcIixcIik7XG5cdHZhciB2YXJTcGVjcyA9IFtdO1xuXHR2YXIgdmFyU3BlY01hcCA9IHt9O1xuXHRmb3IgKHZhciBpID0gMDsgaSA8IHZhckxpc3QubGVuZ3RoOyBpKyspIHtcblx0XHR2YXIgdmFyTmFtZSA9IHZhckxpc3RbaV07XG5cdFx0dmFyIHRydW5jYXRlID0gbnVsbDtcblx0XHRpZiAodmFyTmFtZS5pbmRleE9mKFwiOlwiKSAhPT0gLTEpIHtcblx0XHRcdHZhciBwYXJ0cyA9IHZhck5hbWUuc3BsaXQoXCI6XCIpO1xuXHRcdFx0dmFyTmFtZSA9IHBhcnRzWzBdO1xuXHRcdFx0dHJ1bmNhdGUgPSBwYXJzZUludChwYXJ0c1sxXSwgMTApO1xuXHRcdH1cblx0XHR2YXIgc3VmZmljZXMgPSB7fTtcblx0XHR3aGlsZSAodXJpVGVtcGxhdGVTdWZmaWNlc1t2YXJOYW1lLmNoYXJBdCh2YXJOYW1lLmxlbmd0aCAtIDEpXSkge1xuXHRcdFx0c3VmZmljZXNbdmFyTmFtZS5jaGFyQXQodmFyTmFtZS5sZW5ndGggLSAxKV0gPSB0cnVlO1xuXHRcdFx0dmFyTmFtZSA9IHZhck5hbWUuc3Vic3RyaW5nKDAsIHZhck5hbWUubGVuZ3RoIC0gMSk7XG5cdFx0fVxuXHRcdHZhciB2YXJTcGVjID0ge1xuXHRcdFx0dHJ1bmNhdGU6IHRydW5jYXRlLFxuXHRcdFx0bmFtZTogdmFyTmFtZSxcblx0XHRcdHN1ZmZpY2VzOiBzdWZmaWNlc1xuXHRcdH07XG5cdFx0dmFyU3BlY3MucHVzaCh2YXJTcGVjKTtcblx0XHR2YXJTcGVjTWFwW3Zhck5hbWVdID0gdmFyU3BlYztcblx0XHR2YXJOYW1lcy5wdXNoKHZhck5hbWUpO1xuXHR9XG5cdHZhciBzdWJGdW5jdGlvbiA9IGZ1bmN0aW9uICh2YWx1ZUZ1bmN0aW9uKSB7XG5cdFx0dmFyIHJlc3VsdCA9IFwiXCI7XG5cdFx0dmFyIHN0YXJ0SW5kZXggPSAwO1xuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgdmFyU3BlY3MubGVuZ3RoOyBpKyspIHtcblx0XHRcdHZhciB2YXJTcGVjID0gdmFyU3BlY3NbaV07XG5cdFx0XHR2YXIgdmFsdWUgPSB2YWx1ZUZ1bmN0aW9uKHZhclNwZWMubmFtZSk7XG5cdFx0XHRpZiAodmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09IHVuZGVmaW5lZCB8fCAoQXJyYXkuaXNBcnJheSh2YWx1ZSkgJiYgdmFsdWUubGVuZ3RoID09PSAwKSB8fCAodHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiBPYmplY3Qua2V5cyh2YWx1ZSkubGVuZ3RoID09PSAwKSkge1xuXHRcdFx0XHRzdGFydEluZGV4Kys7XG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fVxuXHRcdFx0aWYgKGkgPT09IHN0YXJ0SW5kZXgpIHtcblx0XHRcdFx0cmVzdWx0ICs9IHByZWZpeDtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHJlc3VsdCArPSAoc2VwYXJhdG9yIHx8IFwiLFwiKTtcblx0XHRcdH1cblx0XHRcdGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuXHRcdFx0XHRpZiAoc2hvd1ZhcmlhYmxlcykge1xuXHRcdFx0XHRcdHJlc3VsdCArPSB2YXJTcGVjLm5hbWUgKyBcIj1cIjtcblx0XHRcdFx0fVxuXHRcdFx0XHRmb3IgKHZhciBqID0gMDsgaiA8IHZhbHVlLmxlbmd0aDsgaisrKSB7XG5cdFx0XHRcdFx0aWYgKGogPiAwKSB7XG5cdFx0XHRcdFx0XHRyZXN1bHQgKz0gdmFyU3BlYy5zdWZmaWNlc1snKiddID8gKHNlcGFyYXRvciB8fCBcIixcIikgOiBcIixcIjtcblx0XHRcdFx0XHRcdGlmICh2YXJTcGVjLnN1ZmZpY2VzWycqJ10gJiYgc2hvd1ZhcmlhYmxlcykge1xuXHRcdFx0XHRcdFx0XHRyZXN1bHQgKz0gdmFyU3BlYy5uYW1lICsgXCI9XCI7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJlc3VsdCArPSBzaG91bGRFc2NhcGUgPyBlbmNvZGVVUklDb21wb25lbnQodmFsdWVbal0pLnJlcGxhY2UoLyEvZywgXCIlMjFcIikgOiBub3RSZWFsbHlQZXJjZW50RW5jb2RlKHZhbHVlW2pdKTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCIpIHtcblx0XHRcdFx0aWYgKHNob3dWYXJpYWJsZXMgJiYgIXZhclNwZWMuc3VmZmljZXNbJyonXSkge1xuXHRcdFx0XHRcdHJlc3VsdCArPSB2YXJTcGVjLm5hbWUgKyBcIj1cIjtcblx0XHRcdFx0fVxuXHRcdFx0XHR2YXIgZmlyc3QgPSB0cnVlO1xuXHRcdFx0XHRmb3IgKHZhciBrZXkgaW4gdmFsdWUpIHtcblx0XHRcdFx0XHRpZiAoIWZpcnN0KSB7XG5cdFx0XHRcdFx0XHRyZXN1bHQgKz0gdmFyU3BlYy5zdWZmaWNlc1snKiddID8gKHNlcGFyYXRvciB8fCBcIixcIikgOiBcIixcIjtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0Zmlyc3QgPSBmYWxzZTtcblx0XHRcdFx0XHRyZXN1bHQgKz0gc2hvdWxkRXNjYXBlID8gZW5jb2RlVVJJQ29tcG9uZW50KGtleSkucmVwbGFjZSgvIS9nLCBcIiUyMVwiKSA6IG5vdFJlYWxseVBlcmNlbnRFbmNvZGUoa2V5KTtcblx0XHRcdFx0XHRyZXN1bHQgKz0gdmFyU3BlYy5zdWZmaWNlc1snKiddID8gJz0nIDogXCIsXCI7XG5cdFx0XHRcdFx0cmVzdWx0ICs9IHNob3VsZEVzY2FwZSA/IGVuY29kZVVSSUNvbXBvbmVudCh2YWx1ZVtrZXldKS5yZXBsYWNlKC8hL2csIFwiJTIxXCIpIDogbm90UmVhbGx5UGVyY2VudEVuY29kZSh2YWx1ZVtrZXldKTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0aWYgKHNob3dWYXJpYWJsZXMpIHtcblx0XHRcdFx0XHRyZXN1bHQgKz0gdmFyU3BlYy5uYW1lO1xuXHRcdFx0XHRcdGlmICghdHJpbUVtcHR5U3RyaW5nIHx8IHZhbHVlICE9PSBcIlwiKSB7XG5cdFx0XHRcdFx0XHRyZXN1bHQgKz0gXCI9XCI7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICh2YXJTcGVjLnRydW5jYXRlICE9IG51bGwpIHtcblx0XHRcdFx0XHR2YWx1ZSA9IHZhbHVlLnN1YnN0cmluZygwLCB2YXJTcGVjLnRydW5jYXRlKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXN1bHQgKz0gc2hvdWxkRXNjYXBlID8gZW5jb2RlVVJJQ29tcG9uZW50KHZhbHVlKS5yZXBsYWNlKC8hL2csIFwiJTIxXCIpOiBub3RSZWFsbHlQZXJjZW50RW5jb2RlKHZhbHVlKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIHJlc3VsdDtcblx0fTtcblx0c3ViRnVuY3Rpb24udmFyTmFtZXMgPSB2YXJOYW1lcztcblx0cmV0dXJuIHtcblx0XHRwcmVmaXg6IHByZWZpeCxcblx0XHRzdWJzdGl0dXRpb246IHN1YkZ1bmN0aW9uXG5cdH07XG59XG5cbmZ1bmN0aW9uIFVyaVRlbXBsYXRlKHRlbXBsYXRlKSB7XG5cdGlmICghKHRoaXMgaW5zdGFuY2VvZiBVcmlUZW1wbGF0ZSkpIHtcblx0XHRyZXR1cm4gbmV3IFVyaVRlbXBsYXRlKHRlbXBsYXRlKTtcblx0fVxuXHR2YXIgcGFydHMgPSB0ZW1wbGF0ZS5zcGxpdChcIntcIik7XG5cdHZhciB0ZXh0UGFydHMgPSBbcGFydHMuc2hpZnQoKV07XG5cdHZhciBwcmVmaXhlcyA9IFtdO1xuXHR2YXIgc3Vic3RpdHV0aW9ucyA9IFtdO1xuXHR2YXIgdmFyTmFtZXMgPSBbXTtcblx0d2hpbGUgKHBhcnRzLmxlbmd0aCA+IDApIHtcblx0XHR2YXIgcGFydCA9IHBhcnRzLnNoaWZ0KCk7XG5cdFx0dmFyIHNwZWMgPSBwYXJ0LnNwbGl0KFwifVwiKVswXTtcblx0XHR2YXIgcmVtYWluZGVyID0gcGFydC5zdWJzdHJpbmcoc3BlYy5sZW5ndGggKyAxKTtcblx0XHR2YXIgZnVuY3MgPSB1cmlUZW1wbGF0ZVN1YnN0aXR1dGlvbihzcGVjKTtcblx0XHRzdWJzdGl0dXRpb25zLnB1c2goZnVuY3Muc3Vic3RpdHV0aW9uKTtcblx0XHRwcmVmaXhlcy5wdXNoKGZ1bmNzLnByZWZpeCk7XG5cdFx0dGV4dFBhcnRzLnB1c2gocmVtYWluZGVyKTtcblx0XHR2YXJOYW1lcyA9IHZhck5hbWVzLmNvbmNhdChmdW5jcy5zdWJzdGl0dXRpb24udmFyTmFtZXMpO1xuXHR9XG5cdHRoaXMuZmlsbCA9IGZ1bmN0aW9uICh2YWx1ZUZ1bmN0aW9uKSB7XG5cdFx0dmFyIHJlc3VsdCA9IHRleHRQYXJ0c1swXTtcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHN1YnN0aXR1dGlvbnMubGVuZ3RoOyBpKyspIHtcblx0XHRcdHZhciBzdWJzdGl0dXRpb24gPSBzdWJzdGl0dXRpb25zW2ldO1xuXHRcdFx0cmVzdWx0ICs9IHN1YnN0aXR1dGlvbih2YWx1ZUZ1bmN0aW9uKTtcblx0XHRcdHJlc3VsdCArPSB0ZXh0UGFydHNbaSArIDFdO1xuXHRcdH1cblx0XHRyZXR1cm4gcmVzdWx0O1xuXHR9O1xuXHR0aGlzLnZhck5hbWVzID0gdmFyTmFtZXM7XG5cdHRoaXMudGVtcGxhdGUgPSB0ZW1wbGF0ZTtcbn1cblVyaVRlbXBsYXRlLnByb3RvdHlwZSA9IHtcblx0dG9TdHJpbmc6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpcy50ZW1wbGF0ZTtcblx0fSxcblx0ZmlsbEZyb21PYmplY3Q6IGZ1bmN0aW9uIChvYmopIHtcblx0XHRyZXR1cm4gdGhpcy5maWxsKGZ1bmN0aW9uICh2YXJOYW1lKSB7XG5cdFx0XHRyZXR1cm4gb2JqW3Zhck5hbWVdO1xuXHRcdH0pO1xuXHR9XG59O1xudmFyIFZhbGlkYXRvckNvbnRleHQgPSBmdW5jdGlvbiBWYWxpZGF0b3JDb250ZXh0KHBhcmVudCwgY29sbGVjdE11bHRpcGxlLCBlcnJvclJlcG9ydGVyLCBjaGVja1JlY3Vyc2l2ZSwgdHJhY2tVbmtub3duUHJvcGVydGllcykge1xuXHR0aGlzLm1pc3NpbmcgPSBbXTtcblx0dGhpcy5taXNzaW5nTWFwID0ge307XG5cdHRoaXMuZm9ybWF0VmFsaWRhdG9ycyA9IHBhcmVudCA/IE9iamVjdC5jcmVhdGUocGFyZW50LmZvcm1hdFZhbGlkYXRvcnMpIDoge307XG5cdHRoaXMuc2NoZW1hcyA9IHBhcmVudCA/IE9iamVjdC5jcmVhdGUocGFyZW50LnNjaGVtYXMpIDoge307XG5cdHRoaXMuY29sbGVjdE11bHRpcGxlID0gY29sbGVjdE11bHRpcGxlO1xuXHR0aGlzLmVycm9ycyA9IFtdO1xuXHR0aGlzLmhhbmRsZUVycm9yID0gY29sbGVjdE11bHRpcGxlID8gdGhpcy5jb2xsZWN0RXJyb3IgOiB0aGlzLnJldHVybkVycm9yO1xuXHRpZiAoY2hlY2tSZWN1cnNpdmUpIHtcblx0XHR0aGlzLmNoZWNrUmVjdXJzaXZlID0gdHJ1ZTtcblx0XHR0aGlzLnNjYW5uZWQgPSBbXTtcblx0XHR0aGlzLnNjYW5uZWRGcm96ZW4gPSBbXTtcblx0XHR0aGlzLnNjYW5uZWRGcm96ZW5TY2hlbWFzID0gW107XG5cdFx0dGhpcy5zY2FubmVkRnJvemVuVmFsaWRhdGlvbkVycm9ycyA9IFtdO1xuXHRcdHRoaXMudmFsaWRhdGVkU2NoZW1hc0tleSA9ICd0djRfdmFsaWRhdGlvbl9pZCc7XG5cdFx0dGhpcy52YWxpZGF0aW9uRXJyb3JzS2V5ID0gJ3R2NF92YWxpZGF0aW9uX2Vycm9yc19pZCc7XG5cdH1cblx0aWYgKHRyYWNrVW5rbm93blByb3BlcnRpZXMpIHtcblx0XHR0aGlzLnRyYWNrVW5rbm93blByb3BlcnRpZXMgPSB0cnVlO1xuXHRcdHRoaXMua25vd25Qcm9wZXJ0eVBhdGhzID0ge307XG5cdFx0dGhpcy51bmtub3duUHJvcGVydHlQYXRocyA9IHt9O1xuXHR9XG5cdHRoaXMuZXJyb3JSZXBvcnRlciA9IGVycm9yUmVwb3J0ZXIgfHwgZGVmYXVsdEVycm9yUmVwb3J0ZXIoJ2VuJyk7XG5cdGlmICh0eXBlb2YgdGhpcy5lcnJvclJlcG9ydGVyID09PSAnc3RyaW5nJykge1xuXHRcdHRocm93IG5ldyBFcnJvcignZGVidWcnKTtcblx0fVxuXHR0aGlzLmRlZmluZWRLZXl3b3JkcyA9IHt9O1xuXHRpZiAocGFyZW50KSB7XG5cdFx0Zm9yICh2YXIga2V5IGluIHBhcmVudC5kZWZpbmVkS2V5d29yZHMpIHtcblx0XHRcdHRoaXMuZGVmaW5lZEtleXdvcmRzW2tleV0gPSBwYXJlbnQuZGVmaW5lZEtleXdvcmRzW2tleV0uc2xpY2UoMCk7XG5cdFx0fVxuXHR9XG59O1xuVmFsaWRhdG9yQ29udGV4dC5wcm90b3R5cGUuZGVmaW5lS2V5d29yZCA9IGZ1bmN0aW9uIChrZXl3b3JkLCBrZXl3b3JkRnVuY3Rpb24pIHtcblx0dGhpcy5kZWZpbmVkS2V5d29yZHNba2V5d29yZF0gPSB0aGlzLmRlZmluZWRLZXl3b3Jkc1trZXl3b3JkXSB8fCBbXTtcblx0dGhpcy5kZWZpbmVkS2V5d29yZHNba2V5d29yZF0ucHVzaChrZXl3b3JkRnVuY3Rpb24pO1xufTtcblZhbGlkYXRvckNvbnRleHQucHJvdG90eXBlLmNyZWF0ZUVycm9yID0gZnVuY3Rpb24gKGNvZGUsIG1lc3NhZ2VQYXJhbXMsIGRhdGFQYXRoLCBzY2hlbWFQYXRoLCBzdWJFcnJvcnMsIGRhdGEsIHNjaGVtYSkge1xuXHR2YXIgZXJyb3IgPSBuZXcgVmFsaWRhdGlvbkVycm9yKGNvZGUsIG1lc3NhZ2VQYXJhbXMsIGRhdGFQYXRoLCBzY2hlbWFQYXRoLCBzdWJFcnJvcnMpO1xuXHRlcnJvci5tZXNzYWdlID0gdGhpcy5lcnJvclJlcG9ydGVyKGVycm9yLCBkYXRhLCBzY2hlbWEpO1xuXHRyZXR1cm4gZXJyb3I7XG59O1xuVmFsaWRhdG9yQ29udGV4dC5wcm90b3R5cGUucmV0dXJuRXJyb3IgPSBmdW5jdGlvbiAoZXJyb3IpIHtcblx0cmV0dXJuIGVycm9yO1xufTtcblZhbGlkYXRvckNvbnRleHQucHJvdG90eXBlLmNvbGxlY3RFcnJvciA9IGZ1bmN0aW9uIChlcnJvcikge1xuXHRpZiAoZXJyb3IpIHtcblx0XHR0aGlzLmVycm9ycy5wdXNoKGVycm9yKTtcblx0fVxuXHRyZXR1cm4gbnVsbDtcbn07XG5WYWxpZGF0b3JDb250ZXh0LnByb3RvdHlwZS5wcmVmaXhFcnJvcnMgPSBmdW5jdGlvbiAoc3RhcnRJbmRleCwgZGF0YVBhdGgsIHNjaGVtYVBhdGgpIHtcblx0Zm9yICh2YXIgaSA9IHN0YXJ0SW5kZXg7IGkgPCB0aGlzLmVycm9ycy5sZW5ndGg7IGkrKykge1xuXHRcdHRoaXMuZXJyb3JzW2ldID0gdGhpcy5lcnJvcnNbaV0ucHJlZml4V2l0aChkYXRhUGF0aCwgc2NoZW1hUGF0aCk7XG5cdH1cblx0cmV0dXJuIHRoaXM7XG59O1xuVmFsaWRhdG9yQ29udGV4dC5wcm90b3R5cGUuYmFuVW5rbm93blByb3BlcnRpZXMgPSBmdW5jdGlvbiAoZGF0YSwgc2NoZW1hKSB7XG5cdGZvciAodmFyIHVua25vd25QYXRoIGluIHRoaXMudW5rbm93blByb3BlcnR5UGF0aHMpIHtcblx0XHR2YXIgZXJyb3IgPSB0aGlzLmNyZWF0ZUVycm9yKEVycm9yQ29kZXMuVU5LTk9XTl9QUk9QRVJUWSwge3BhdGg6IHVua25vd25QYXRofSwgdW5rbm93blBhdGgsIFwiXCIsIG51bGwsIGRhdGEsIHNjaGVtYSk7XG5cdFx0dmFyIHJlc3VsdCA9IHRoaXMuaGFuZGxlRXJyb3IoZXJyb3IpO1xuXHRcdGlmIChyZXN1bHQpIHtcblx0XHRcdHJldHVybiByZXN1bHQ7XG5cdFx0fVxuXHR9XG5cdHJldHVybiBudWxsO1xufTtcblxuVmFsaWRhdG9yQ29udGV4dC5wcm90b3R5cGUuYWRkRm9ybWF0ID0gZnVuY3Rpb24gKGZvcm1hdCwgdmFsaWRhdG9yKSB7XG5cdGlmICh0eXBlb2YgZm9ybWF0ID09PSAnb2JqZWN0Jykge1xuXHRcdGZvciAodmFyIGtleSBpbiBmb3JtYXQpIHtcblx0XHRcdHRoaXMuYWRkRm9ybWF0KGtleSwgZm9ybWF0W2tleV0pO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXHR0aGlzLmZvcm1hdFZhbGlkYXRvcnNbZm9ybWF0XSA9IHZhbGlkYXRvcjtcbn07XG5WYWxpZGF0b3JDb250ZXh0LnByb3RvdHlwZS5yZXNvbHZlUmVmcyA9IGZ1bmN0aW9uIChzY2hlbWEsIHVybEhpc3RvcnkpIHtcblx0aWYgKHNjaGVtYVsnJHJlZiddICE9PSB1bmRlZmluZWQpIHtcblx0XHR1cmxIaXN0b3J5ID0gdXJsSGlzdG9yeSB8fCB7fTtcblx0XHRpZiAodXJsSGlzdG9yeVtzY2hlbWFbJyRyZWYnXV0pIHtcblx0XHRcdHJldHVybiB0aGlzLmNyZWF0ZUVycm9yKEVycm9yQ29kZXMuQ0lSQ1VMQVJfUkVGRVJFTkNFLCB7dXJsczogT2JqZWN0LmtleXModXJsSGlzdG9yeSkuam9pbignLCAnKX0sICcnLCAnJywgbnVsbCwgdW5kZWZpbmVkLCBzY2hlbWEpO1xuXHRcdH1cblx0XHR1cmxIaXN0b3J5W3NjaGVtYVsnJHJlZiddXSA9IHRydWU7XG5cdFx0c2NoZW1hID0gdGhpcy5nZXRTY2hlbWEoc2NoZW1hWyckcmVmJ10sIHVybEhpc3RvcnkpO1xuXHR9XG5cdHJldHVybiBzY2hlbWE7XG59O1xuVmFsaWRhdG9yQ29udGV4dC5wcm90b3R5cGUuZ2V0U2NoZW1hID0gZnVuY3Rpb24gKHVybCwgdXJsSGlzdG9yeSkge1xuXHR2YXIgc2NoZW1hO1xuXHRpZiAodGhpcy5zY2hlbWFzW3VybF0gIT09IHVuZGVmaW5lZCkge1xuXHRcdHNjaGVtYSA9IHRoaXMuc2NoZW1hc1t1cmxdO1xuXHRcdHJldHVybiB0aGlzLnJlc29sdmVSZWZzKHNjaGVtYSwgdXJsSGlzdG9yeSk7XG5cdH1cblx0dmFyIGJhc2VVcmwgPSB1cmw7XG5cdHZhciBmcmFnbWVudCA9IFwiXCI7XG5cdGlmICh1cmwuaW5kZXhPZignIycpICE9PSAtMSkge1xuXHRcdGZyYWdtZW50ID0gdXJsLnN1YnN0cmluZyh1cmwuaW5kZXhPZihcIiNcIikgKyAxKTtcblx0XHRiYXNlVXJsID0gdXJsLnN1YnN0cmluZygwLCB1cmwuaW5kZXhPZihcIiNcIikpO1xuXHR9XG5cdGlmICh0eXBlb2YgdGhpcy5zY2hlbWFzW2Jhc2VVcmxdID09PSAnb2JqZWN0Jykge1xuXHRcdHNjaGVtYSA9IHRoaXMuc2NoZW1hc1tiYXNlVXJsXTtcblx0XHR2YXIgcG9pbnRlclBhdGggPSBkZWNvZGVVUklDb21wb25lbnQoZnJhZ21lbnQpO1xuXHRcdGlmIChwb2ludGVyUGF0aCA9PT0gXCJcIikge1xuXHRcdFx0cmV0dXJuIHRoaXMucmVzb2x2ZVJlZnMoc2NoZW1hLCB1cmxIaXN0b3J5KTtcblx0XHR9IGVsc2UgaWYgKHBvaW50ZXJQYXRoLmNoYXJBdCgwKSAhPT0gXCIvXCIpIHtcblx0XHRcdHJldHVybiB1bmRlZmluZWQ7XG5cdFx0fVxuXHRcdHZhciBwYXJ0cyA9IHBvaW50ZXJQYXRoLnNwbGl0KFwiL1wiKS5zbGljZSgxKTtcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHBhcnRzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR2YXIgY29tcG9uZW50ID0gcGFydHNbaV0ucmVwbGFjZSgvfjEvZywgXCIvXCIpLnJlcGxhY2UoL34wL2csIFwiflwiKTtcblx0XHRcdGlmIChzY2hlbWFbY29tcG9uZW50XSA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdHNjaGVtYSA9IHVuZGVmaW5lZDtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0XHRzY2hlbWEgPSBzY2hlbWFbY29tcG9uZW50XTtcblx0XHR9XG5cdFx0aWYgKHNjaGVtYSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5yZXNvbHZlUmVmcyhzY2hlbWEsIHVybEhpc3RvcnkpO1xuXHRcdH1cblx0fVxuXHRpZiAodGhpcy5taXNzaW5nW2Jhc2VVcmxdID09PSB1bmRlZmluZWQpIHtcblx0XHR0aGlzLm1pc3NpbmcucHVzaChiYXNlVXJsKTtcblx0XHR0aGlzLm1pc3NpbmdbYmFzZVVybF0gPSBiYXNlVXJsO1xuXHRcdHRoaXMubWlzc2luZ01hcFtiYXNlVXJsXSA9IGJhc2VVcmw7XG5cdH1cbn07XG5WYWxpZGF0b3JDb250ZXh0LnByb3RvdHlwZS5zZWFyY2hTY2hlbWFzID0gZnVuY3Rpb24gKHNjaGVtYSwgdXJsKSB7XG5cdGlmIChBcnJheS5pc0FycmF5KHNjaGVtYSkpIHtcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHNjaGVtYS5sZW5ndGg7IGkrKykge1xuXHRcdFx0dGhpcy5zZWFyY2hTY2hlbWFzKHNjaGVtYVtpXSwgdXJsKTtcblx0XHR9XG5cdH0gZWxzZSBpZiAoc2NoZW1hICYmIHR5cGVvZiBzY2hlbWEgPT09IFwib2JqZWN0XCIpIHtcblx0XHRpZiAodHlwZW9mIHNjaGVtYS5pZCA9PT0gXCJzdHJpbmdcIikge1xuXHRcdFx0aWYgKGlzVHJ1c3RlZFVybCh1cmwsIHNjaGVtYS5pZCkpIHtcblx0XHRcdFx0aWYgKHRoaXMuc2NoZW1hc1tzY2hlbWEuaWRdID09PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0XHR0aGlzLnNjaGVtYXNbc2NoZW1hLmlkXSA9IHNjaGVtYTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHRmb3IgKHZhciBrZXkgaW4gc2NoZW1hKSB7XG5cdFx0XHRpZiAoa2V5ICE9PSBcImVudW1cIikge1xuXHRcdFx0XHRpZiAodHlwZW9mIHNjaGVtYVtrZXldID09PSBcIm9iamVjdFwiKSB7XG5cdFx0XHRcdFx0dGhpcy5zZWFyY2hTY2hlbWFzKHNjaGVtYVtrZXldLCB1cmwpO1xuXHRcdFx0XHR9IGVsc2UgaWYgKGtleSA9PT0gXCIkcmVmXCIpIHtcblx0XHRcdFx0XHR2YXIgdXJpID0gZ2V0RG9jdW1lbnRVcmkoc2NoZW1hW2tleV0pO1xuXHRcdFx0XHRcdGlmICh1cmkgJiYgdGhpcy5zY2hlbWFzW3VyaV0gPT09IHVuZGVmaW5lZCAmJiB0aGlzLm1pc3NpbmdNYXBbdXJpXSA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdFx0XHR0aGlzLm1pc3NpbmdNYXBbdXJpXSA9IHVyaTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cbn07XG5WYWxpZGF0b3JDb250ZXh0LnByb3RvdHlwZS5hZGRTY2hlbWEgPSBmdW5jdGlvbiAodXJsLCBzY2hlbWEpIHtcblx0Ly9vdmVybG9hZFxuXHRpZiAodHlwZW9mIHVybCAhPT0gJ3N0cmluZycgfHwgdHlwZW9mIHNjaGVtYSA9PT0gJ3VuZGVmaW5lZCcpIHtcblx0XHRpZiAodHlwZW9mIHVybCA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIHVybC5pZCA9PT0gJ3N0cmluZycpIHtcblx0XHRcdHNjaGVtYSA9IHVybDtcblx0XHRcdHVybCA9IHNjaGVtYS5pZDtcblx0XHR9XG5cdFx0ZWxzZSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHR9XG5cdGlmICh1cmwgPT09IGdldERvY3VtZW50VXJpKHVybCkgKyBcIiNcIikge1xuXHRcdC8vIFJlbW92ZSBlbXB0eSBmcmFnbWVudFxuXHRcdHVybCA9IGdldERvY3VtZW50VXJpKHVybCk7XG5cdH1cblx0dGhpcy5zY2hlbWFzW3VybF0gPSBzY2hlbWE7XG5cdGRlbGV0ZSB0aGlzLm1pc3NpbmdNYXBbdXJsXTtcblx0bm9ybVNjaGVtYShzY2hlbWEsIHVybCk7XG5cdHRoaXMuc2VhcmNoU2NoZW1hcyhzY2hlbWEsIHVybCk7XG59O1xuXG5WYWxpZGF0b3JDb250ZXh0LnByb3RvdHlwZS5nZXRTY2hlbWFNYXAgPSBmdW5jdGlvbiAoKSB7XG5cdHZhciBtYXAgPSB7fTtcblx0Zm9yICh2YXIga2V5IGluIHRoaXMuc2NoZW1hcykge1xuXHRcdG1hcFtrZXldID0gdGhpcy5zY2hlbWFzW2tleV07XG5cdH1cblx0cmV0dXJuIG1hcDtcbn07XG5cblZhbGlkYXRvckNvbnRleHQucHJvdG90eXBlLmdldFNjaGVtYVVyaXMgPSBmdW5jdGlvbiAoZmlsdGVyUmVnRXhwKSB7XG5cdHZhciBsaXN0ID0gW107XG5cdGZvciAodmFyIGtleSBpbiB0aGlzLnNjaGVtYXMpIHtcblx0XHRpZiAoIWZpbHRlclJlZ0V4cCB8fCBmaWx0ZXJSZWdFeHAudGVzdChrZXkpKSB7XG5cdFx0XHRsaXN0LnB1c2goa2V5KTtcblx0XHR9XG5cdH1cblx0cmV0dXJuIGxpc3Q7XG59O1xuXG5WYWxpZGF0b3JDb250ZXh0LnByb3RvdHlwZS5nZXRNaXNzaW5nVXJpcyA9IGZ1bmN0aW9uIChmaWx0ZXJSZWdFeHApIHtcblx0dmFyIGxpc3QgPSBbXTtcblx0Zm9yICh2YXIga2V5IGluIHRoaXMubWlzc2luZ01hcCkge1xuXHRcdGlmICghZmlsdGVyUmVnRXhwIHx8IGZpbHRlclJlZ0V4cC50ZXN0KGtleSkpIHtcblx0XHRcdGxpc3QucHVzaChrZXkpO1xuXHRcdH1cblx0fVxuXHRyZXR1cm4gbGlzdDtcbn07XG5cblZhbGlkYXRvckNvbnRleHQucHJvdG90eXBlLmRyb3BTY2hlbWFzID0gZnVuY3Rpb24gKCkge1xuXHR0aGlzLnNjaGVtYXMgPSB7fTtcblx0dGhpcy5yZXNldCgpO1xufTtcblZhbGlkYXRvckNvbnRleHQucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24gKCkge1xuXHR0aGlzLm1pc3NpbmcgPSBbXTtcblx0dGhpcy5taXNzaW5nTWFwID0ge307XG5cdHRoaXMuZXJyb3JzID0gW107XG59O1xuXG5WYWxpZGF0b3JDb250ZXh0LnByb3RvdHlwZS52YWxpZGF0ZUFsbCA9IGZ1bmN0aW9uIChkYXRhLCBzY2hlbWEsIGRhdGFQYXRoUGFydHMsIHNjaGVtYVBhdGhQYXJ0cywgZGF0YVBvaW50ZXJQYXRoKSB7XG5cdHZhciB0b3BMZXZlbDtcblx0c2NoZW1hID0gdGhpcy5yZXNvbHZlUmVmcyhzY2hlbWEpO1xuXHRpZiAoIXNjaGVtYSkge1xuXHRcdHJldHVybiBudWxsO1xuXHR9IGVsc2UgaWYgKHNjaGVtYSBpbnN0YW5jZW9mIFZhbGlkYXRpb25FcnJvcikge1xuXHRcdHRoaXMuZXJyb3JzLnB1c2goc2NoZW1hKTtcblx0XHRyZXR1cm4gc2NoZW1hO1xuXHR9XG5cblx0dmFyIHN0YXJ0RXJyb3JDb3VudCA9IHRoaXMuZXJyb3JzLmxlbmd0aDtcblx0dmFyIGZyb3plbkluZGV4LCBzY2FubmVkRnJvemVuU2NoZW1hSW5kZXggPSBudWxsLCBzY2FubmVkU2NoZW1hc0luZGV4ID0gbnVsbDtcblx0aWYgKHRoaXMuY2hlY2tSZWN1cnNpdmUgJiYgZGF0YSAmJiB0eXBlb2YgZGF0YSA9PT0gJ29iamVjdCcpIHtcblx0XHR0b3BMZXZlbCA9ICF0aGlzLnNjYW5uZWQubGVuZ3RoO1xuXHRcdGlmIChkYXRhW3RoaXMudmFsaWRhdGVkU2NoZW1hc0tleV0pIHtcblx0XHRcdHZhciBzY2hlbWFJbmRleCA9IGRhdGFbdGhpcy52YWxpZGF0ZWRTY2hlbWFzS2V5XS5pbmRleE9mKHNjaGVtYSk7XG5cdFx0XHRpZiAoc2NoZW1hSW5kZXggIT09IC0xKSB7XG5cdFx0XHRcdHRoaXMuZXJyb3JzID0gdGhpcy5lcnJvcnMuY29uY2F0KGRhdGFbdGhpcy52YWxpZGF0aW9uRXJyb3JzS2V5XVtzY2hlbWFJbmRleF0pO1xuXHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdH1cblx0XHR9XG5cdFx0aWYgKE9iamVjdC5pc0Zyb3plbihkYXRhKSkge1xuXHRcdFx0ZnJvemVuSW5kZXggPSB0aGlzLnNjYW5uZWRGcm96ZW4uaW5kZXhPZihkYXRhKTtcblx0XHRcdGlmIChmcm96ZW5JbmRleCAhPT0gLTEpIHtcblx0XHRcdFx0dmFyIGZyb3plblNjaGVtYUluZGV4ID0gdGhpcy5zY2FubmVkRnJvemVuU2NoZW1hc1tmcm96ZW5JbmRleF0uaW5kZXhPZihzY2hlbWEpO1xuXHRcdFx0XHRpZiAoZnJvemVuU2NoZW1hSW5kZXggIT09IC0xKSB7XG5cdFx0XHRcdFx0dGhpcy5lcnJvcnMgPSB0aGlzLmVycm9ycy5jb25jYXQodGhpcy5zY2FubmVkRnJvemVuVmFsaWRhdGlvbkVycm9yc1tmcm96ZW5JbmRleF1bZnJvemVuU2NoZW1hSW5kZXhdKTtcblx0XHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHR0aGlzLnNjYW5uZWQucHVzaChkYXRhKTtcblx0XHRpZiAoT2JqZWN0LmlzRnJvemVuKGRhdGEpKSB7XG5cdFx0XHRpZiAoZnJvemVuSW5kZXggPT09IC0xKSB7XG5cdFx0XHRcdGZyb3plbkluZGV4ID0gdGhpcy5zY2FubmVkRnJvemVuLmxlbmd0aDtcblx0XHRcdFx0dGhpcy5zY2FubmVkRnJvemVuLnB1c2goZGF0YSk7XG5cdFx0XHRcdHRoaXMuc2Nhbm5lZEZyb3plblNjaGVtYXMucHVzaChbXSk7XG5cdFx0XHR9XG5cdFx0XHRzY2FubmVkRnJvemVuU2NoZW1hSW5kZXggPSB0aGlzLnNjYW5uZWRGcm96ZW5TY2hlbWFzW2Zyb3plbkluZGV4XS5sZW5ndGg7XG5cdFx0XHR0aGlzLnNjYW5uZWRGcm96ZW5TY2hlbWFzW2Zyb3plbkluZGV4XVtzY2FubmVkRnJvemVuU2NoZW1hSW5kZXhdID0gc2NoZW1hO1xuXHRcdFx0dGhpcy5zY2FubmVkRnJvemVuVmFsaWRhdGlvbkVycm9yc1tmcm96ZW5JbmRleF1bc2Nhbm5lZEZyb3plblNjaGVtYUluZGV4XSA9IFtdO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRpZiAoIWRhdGFbdGhpcy52YWxpZGF0ZWRTY2hlbWFzS2V5XSkge1xuXHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShkYXRhLCB0aGlzLnZhbGlkYXRlZFNjaGVtYXNLZXksIHtcblx0XHRcdFx0XHRcdHZhbHVlOiBbXSxcblx0XHRcdFx0XHRcdGNvbmZpZ3VyYWJsZTogdHJ1ZVxuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShkYXRhLCB0aGlzLnZhbGlkYXRpb25FcnJvcnNLZXksIHtcblx0XHRcdFx0XHRcdHZhbHVlOiBbXSxcblx0XHRcdFx0XHRcdGNvbmZpZ3VyYWJsZTogdHJ1ZVxuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9IGNhdGNoIChlKSB7XG5cdFx0XHRcdFx0Ly9JRSA3Lzggd29ya2Fyb3VuZFxuXHRcdFx0XHRcdGRhdGFbdGhpcy52YWxpZGF0ZWRTY2hlbWFzS2V5XSA9IFtdO1xuXHRcdFx0XHRcdGRhdGFbdGhpcy52YWxpZGF0aW9uRXJyb3JzS2V5XSA9IFtdO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRzY2FubmVkU2NoZW1hc0luZGV4ID0gZGF0YVt0aGlzLnZhbGlkYXRlZFNjaGVtYXNLZXldLmxlbmd0aDtcblx0XHRcdGRhdGFbdGhpcy52YWxpZGF0ZWRTY2hlbWFzS2V5XVtzY2FubmVkU2NoZW1hc0luZGV4XSA9IHNjaGVtYTtcblx0XHRcdGRhdGFbdGhpcy52YWxpZGF0aW9uRXJyb3JzS2V5XVtzY2FubmVkU2NoZW1hc0luZGV4XSA9IFtdO1xuXHRcdH1cblx0fVxuXG5cdHZhciBlcnJvckNvdW50ID0gdGhpcy5lcnJvcnMubGVuZ3RoO1xuXHR2YXIgZXJyb3IgPSB0aGlzLnZhbGlkYXRlQmFzaWMoZGF0YSwgc2NoZW1hLCBkYXRhUG9pbnRlclBhdGgpXG5cdFx0fHwgdGhpcy52YWxpZGF0ZU51bWVyaWMoZGF0YSwgc2NoZW1hLCBkYXRhUG9pbnRlclBhdGgpXG5cdFx0fHwgdGhpcy52YWxpZGF0ZVN0cmluZyhkYXRhLCBzY2hlbWEsIGRhdGFQb2ludGVyUGF0aClcblx0XHR8fCB0aGlzLnZhbGlkYXRlQXJyYXkoZGF0YSwgc2NoZW1hLCBkYXRhUG9pbnRlclBhdGgpXG5cdFx0fHwgdGhpcy52YWxpZGF0ZU9iamVjdChkYXRhLCBzY2hlbWEsIGRhdGFQb2ludGVyUGF0aClcblx0XHR8fCB0aGlzLnZhbGlkYXRlQ29tYmluYXRpb25zKGRhdGEsIHNjaGVtYSwgZGF0YVBvaW50ZXJQYXRoKVxuXHRcdHx8IHRoaXMudmFsaWRhdGVIeXBlcm1lZGlhKGRhdGEsIHNjaGVtYSwgZGF0YVBvaW50ZXJQYXRoKVxuXHRcdHx8IHRoaXMudmFsaWRhdGVGb3JtYXQoZGF0YSwgc2NoZW1hLCBkYXRhUG9pbnRlclBhdGgpXG5cdFx0fHwgdGhpcy52YWxpZGF0ZURlZmluZWRLZXl3b3JkcyhkYXRhLCBzY2hlbWEsIGRhdGFQb2ludGVyUGF0aClcblx0XHR8fCBudWxsO1xuXG5cdGlmICh0b3BMZXZlbCkge1xuXHRcdHdoaWxlICh0aGlzLnNjYW5uZWQubGVuZ3RoKSB7XG5cdFx0XHR2YXIgaXRlbSA9IHRoaXMuc2Nhbm5lZC5wb3AoKTtcblx0XHRcdGRlbGV0ZSBpdGVtW3RoaXMudmFsaWRhdGVkU2NoZW1hc0tleV07XG5cdFx0fVxuXHRcdHRoaXMuc2Nhbm5lZEZyb3plbiA9IFtdO1xuXHRcdHRoaXMuc2Nhbm5lZEZyb3plblNjaGVtYXMgPSBbXTtcblx0fVxuXG5cdGlmIChlcnJvciB8fCBlcnJvckNvdW50ICE9PSB0aGlzLmVycm9ycy5sZW5ndGgpIHtcblx0XHR3aGlsZSAoKGRhdGFQYXRoUGFydHMgJiYgZGF0YVBhdGhQYXJ0cy5sZW5ndGgpIHx8IChzY2hlbWFQYXRoUGFydHMgJiYgc2NoZW1hUGF0aFBhcnRzLmxlbmd0aCkpIHtcblx0XHRcdHZhciBkYXRhUGFydCA9IChkYXRhUGF0aFBhcnRzICYmIGRhdGFQYXRoUGFydHMubGVuZ3RoKSA/IFwiXCIgKyBkYXRhUGF0aFBhcnRzLnBvcCgpIDogbnVsbDtcblx0XHRcdHZhciBzY2hlbWFQYXJ0ID0gKHNjaGVtYVBhdGhQYXJ0cyAmJiBzY2hlbWFQYXRoUGFydHMubGVuZ3RoKSA/IFwiXCIgKyBzY2hlbWFQYXRoUGFydHMucG9wKCkgOiBudWxsO1xuXHRcdFx0aWYgKGVycm9yKSB7XG5cdFx0XHRcdGVycm9yID0gZXJyb3IucHJlZml4V2l0aChkYXRhUGFydCwgc2NoZW1hUGFydCk7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLnByZWZpeEVycm9ycyhlcnJvckNvdW50LCBkYXRhUGFydCwgc2NoZW1hUGFydCk7XG5cdFx0fVxuXHR9XG5cblx0aWYgKHNjYW5uZWRGcm96ZW5TY2hlbWFJbmRleCAhPT0gbnVsbCkge1xuXHRcdHRoaXMuc2Nhbm5lZEZyb3plblZhbGlkYXRpb25FcnJvcnNbZnJvemVuSW5kZXhdW3NjYW5uZWRGcm96ZW5TY2hlbWFJbmRleF0gPSB0aGlzLmVycm9ycy5zbGljZShzdGFydEVycm9yQ291bnQpO1xuXHR9IGVsc2UgaWYgKHNjYW5uZWRTY2hlbWFzSW5kZXggIT09IG51bGwpIHtcblx0XHRkYXRhW3RoaXMudmFsaWRhdGlvbkVycm9yc0tleV1bc2Nhbm5lZFNjaGVtYXNJbmRleF0gPSB0aGlzLmVycm9ycy5zbGljZShzdGFydEVycm9yQ291bnQpO1xuXHR9XG5cblx0cmV0dXJuIHRoaXMuaGFuZGxlRXJyb3IoZXJyb3IpO1xufTtcblZhbGlkYXRvckNvbnRleHQucHJvdG90eXBlLnZhbGlkYXRlRm9ybWF0ID0gZnVuY3Rpb24gKGRhdGEsIHNjaGVtYSkge1xuXHRpZiAodHlwZW9mIHNjaGVtYS5mb3JtYXQgIT09ICdzdHJpbmcnIHx8ICF0aGlzLmZvcm1hdFZhbGlkYXRvcnNbc2NoZW1hLmZvcm1hdF0pIHtcblx0XHRyZXR1cm4gbnVsbDtcblx0fVxuXHR2YXIgZXJyb3JNZXNzYWdlID0gdGhpcy5mb3JtYXRWYWxpZGF0b3JzW3NjaGVtYS5mb3JtYXRdLmNhbGwobnVsbCwgZGF0YSwgc2NoZW1hKTtcblx0aWYgKHR5cGVvZiBlcnJvck1lc3NhZ2UgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiBlcnJvck1lc3NhZ2UgPT09ICdudW1iZXInKSB7XG5cdFx0cmV0dXJuIHRoaXMuY3JlYXRlRXJyb3IoRXJyb3JDb2Rlcy5GT1JNQVRfQ1VTVE9NLCB7bWVzc2FnZTogZXJyb3JNZXNzYWdlfSwgJycsICcvZm9ybWF0JywgbnVsbCwgZGF0YSwgc2NoZW1hKTtcblx0fSBlbHNlIGlmIChlcnJvck1lc3NhZ2UgJiYgdHlwZW9mIGVycm9yTWVzc2FnZSA9PT0gJ29iamVjdCcpIHtcblx0XHRyZXR1cm4gdGhpcy5jcmVhdGVFcnJvcihFcnJvckNvZGVzLkZPUk1BVF9DVVNUT00sIHttZXNzYWdlOiBlcnJvck1lc3NhZ2UubWVzc2FnZSB8fCBcIj9cIn0sIGVycm9yTWVzc2FnZS5kYXRhUGF0aCB8fCAnJywgZXJyb3JNZXNzYWdlLnNjaGVtYVBhdGggfHwgXCIvZm9ybWF0XCIsIG51bGwsIGRhdGEsIHNjaGVtYSk7XG5cdH1cblx0cmV0dXJuIG51bGw7XG59O1xuVmFsaWRhdG9yQ29udGV4dC5wcm90b3R5cGUudmFsaWRhdGVEZWZpbmVkS2V5d29yZHMgPSBmdW5jdGlvbiAoZGF0YSwgc2NoZW1hLCBkYXRhUG9pbnRlclBhdGgpIHtcblx0Zm9yICh2YXIga2V5IGluIHRoaXMuZGVmaW5lZEtleXdvcmRzKSB7XG5cdFx0aWYgKHR5cGVvZiBzY2hlbWFba2V5XSA9PT0gJ3VuZGVmaW5lZCcpIHtcblx0XHRcdGNvbnRpbnVlO1xuXHRcdH1cblx0XHR2YXIgdmFsaWRhdGlvbkZ1bmN0aW9ucyA9IHRoaXMuZGVmaW5lZEtleXdvcmRzW2tleV07XG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCB2YWxpZGF0aW9uRnVuY3Rpb25zLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR2YXIgZnVuYyA9IHZhbGlkYXRpb25GdW5jdGlvbnNbaV07XG5cdFx0XHR2YXIgcmVzdWx0ID0gZnVuYyhkYXRhLCBzY2hlbWFba2V5XSwgc2NoZW1hLCBkYXRhUG9pbnRlclBhdGgpO1xuXHRcdFx0aWYgKHR5cGVvZiByZXN1bHQgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiByZXN1bHQgPT09ICdudW1iZXInKSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLmNyZWF0ZUVycm9yKEVycm9yQ29kZXMuS0VZV09SRF9DVVNUT00sIHtrZXk6IGtleSwgbWVzc2FnZTogcmVzdWx0fSwgJycsICcnLCBudWxsLCBkYXRhLCBzY2hlbWEpLnByZWZpeFdpdGgobnVsbCwga2V5KTtcblx0XHRcdH0gZWxzZSBpZiAocmVzdWx0ICYmIHR5cGVvZiByZXN1bHQgPT09ICdvYmplY3QnKSB7XG5cdFx0XHRcdHZhciBjb2RlID0gcmVzdWx0LmNvZGU7XG5cdFx0XHRcdGlmICh0eXBlb2YgY29kZSA9PT0gJ3N0cmluZycpIHtcblx0XHRcdFx0XHRpZiAoIUVycm9yQ29kZXNbY29kZV0pIHtcblx0XHRcdFx0XHRcdHRocm93IG5ldyBFcnJvcignVW5kZWZpbmVkIGVycm9yIGNvZGUgKHVzZSBkZWZpbmVFcnJvcik6ICcgKyBjb2RlKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0Y29kZSA9IEVycm9yQ29kZXNbY29kZV07XG5cdFx0XHRcdH0gZWxzZSBpZiAodHlwZW9mIGNvZGUgIT09ICdudW1iZXInKSB7XG5cdFx0XHRcdFx0Y29kZSA9IEVycm9yQ29kZXMuS0VZV09SRF9DVVNUT007XG5cdFx0XHRcdH1cblx0XHRcdFx0dmFyIG1lc3NhZ2VQYXJhbXMgPSAodHlwZW9mIHJlc3VsdC5tZXNzYWdlID09PSAnb2JqZWN0JykgPyByZXN1bHQubWVzc2FnZSA6IHtrZXk6IGtleSwgbWVzc2FnZTogcmVzdWx0Lm1lc3NhZ2UgfHwgXCI/XCJ9O1xuXHRcdFx0XHR2YXIgc2NoZW1hUGF0aCA9IHJlc3VsdC5zY2hlbWFQYXRoIHx8IChcIi9cIiArIGtleS5yZXBsYWNlKC9+L2csICd+MCcpLnJlcGxhY2UoL1xcLy9nLCAnfjEnKSk7XG5cdFx0XHRcdHJldHVybiB0aGlzLmNyZWF0ZUVycm9yKGNvZGUsIG1lc3NhZ2VQYXJhbXMsIHJlc3VsdC5kYXRhUGF0aCB8fCBudWxsLCBzY2hlbWFQYXRoLCBudWxsLCBkYXRhLCBzY2hlbWEpO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXHRyZXR1cm4gbnVsbDtcbn07XG5cbmZ1bmN0aW9uIHJlY3Vyc2l2ZUNvbXBhcmUoQSwgQikge1xuXHRpZiAoQSA9PT0gQikge1xuXHRcdHJldHVybiB0cnVlO1xuXHR9XG5cdGlmIChBICYmIEIgJiYgdHlwZW9mIEEgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIEIgPT09IFwib2JqZWN0XCIpIHtcblx0XHRpZiAoQXJyYXkuaXNBcnJheShBKSAhPT0gQXJyYXkuaXNBcnJheShCKSkge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShBKSkge1xuXHRcdFx0aWYgKEEubGVuZ3RoICE9PSBCLmxlbmd0aCkge1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IEEubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0aWYgKCFyZWN1cnNpdmVDb21wYXJlKEFbaV0sIEJbaV0pKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdHZhciBrZXk7XG5cdFx0XHRmb3IgKGtleSBpbiBBKSB7XG5cdFx0XHRcdGlmIChCW2tleV0gPT09IHVuZGVmaW5lZCAmJiBBW2tleV0gIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0Zm9yIChrZXkgaW4gQikge1xuXHRcdFx0XHRpZiAoQVtrZXldID09PSB1bmRlZmluZWQgJiYgQltrZXldICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGZvciAoa2V5IGluIEEpIHtcblx0XHRcdFx0aWYgKCFyZWN1cnNpdmVDb21wYXJlKEFba2V5XSwgQltrZXldKSkge1xuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gdHJ1ZTtcblx0fVxuXHRyZXR1cm4gZmFsc2U7XG59XG5cblZhbGlkYXRvckNvbnRleHQucHJvdG90eXBlLnZhbGlkYXRlQmFzaWMgPSBmdW5jdGlvbiB2YWxpZGF0ZUJhc2ljKGRhdGEsIHNjaGVtYSwgZGF0YVBvaW50ZXJQYXRoKSB7XG5cdHZhciBlcnJvcjtcblx0aWYgKGVycm9yID0gdGhpcy52YWxpZGF0ZVR5cGUoZGF0YSwgc2NoZW1hLCBkYXRhUG9pbnRlclBhdGgpKSB7XG5cdFx0cmV0dXJuIGVycm9yLnByZWZpeFdpdGgobnVsbCwgXCJ0eXBlXCIpO1xuXHR9XG5cdGlmIChlcnJvciA9IHRoaXMudmFsaWRhdGVFbnVtKGRhdGEsIHNjaGVtYSwgZGF0YVBvaW50ZXJQYXRoKSkge1xuXHRcdHJldHVybiBlcnJvci5wcmVmaXhXaXRoKG51bGwsIFwidHlwZVwiKTtcblx0fVxuXHRyZXR1cm4gbnVsbDtcbn07XG5cblZhbGlkYXRvckNvbnRleHQucHJvdG90eXBlLnZhbGlkYXRlVHlwZSA9IGZ1bmN0aW9uIHZhbGlkYXRlVHlwZShkYXRhLCBzY2hlbWEpIHtcblx0aWYgKHNjaGVtYS50eXBlID09PSB1bmRlZmluZWQpIHtcblx0XHRyZXR1cm4gbnVsbDtcblx0fVxuXHR2YXIgZGF0YVR5cGUgPSB0eXBlb2YgZGF0YTtcblx0aWYgKGRhdGEgPT09IG51bGwpIHtcblx0XHRkYXRhVHlwZSA9IFwibnVsbFwiO1xuXHR9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoZGF0YSkpIHtcblx0XHRkYXRhVHlwZSA9IFwiYXJyYXlcIjtcblx0fVxuXHR2YXIgYWxsb3dlZFR5cGVzID0gc2NoZW1hLnR5cGU7XG5cdGlmICghQXJyYXkuaXNBcnJheShhbGxvd2VkVHlwZXMpKSB7XG5cdFx0YWxsb3dlZFR5cGVzID0gW2FsbG93ZWRUeXBlc107XG5cdH1cblxuXHRmb3IgKHZhciBpID0gMDsgaSA8IGFsbG93ZWRUeXBlcy5sZW5ndGg7IGkrKykge1xuXHRcdHZhciB0eXBlID0gYWxsb3dlZFR5cGVzW2ldO1xuXHRcdGlmICh0eXBlID09PSBkYXRhVHlwZSB8fCAodHlwZSA9PT0gXCJpbnRlZ2VyXCIgJiYgZGF0YVR5cGUgPT09IFwibnVtYmVyXCIgJiYgKGRhdGEgJSAxID09PSAwKSkpIHtcblx0XHRcdHJldHVybiBudWxsO1xuXHRcdH1cblx0fVxuXHRyZXR1cm4gdGhpcy5jcmVhdGVFcnJvcihFcnJvckNvZGVzLklOVkFMSURfVFlQRSwge3R5cGU6IGRhdGFUeXBlLCBleHBlY3RlZDogYWxsb3dlZFR5cGVzLmpvaW4oXCIvXCIpfSwgJycsICcnLCBudWxsLCBkYXRhLCBzY2hlbWEpO1xufTtcblxuVmFsaWRhdG9yQ29udGV4dC5wcm90b3R5cGUudmFsaWRhdGVFbnVtID0gZnVuY3Rpb24gdmFsaWRhdGVFbnVtKGRhdGEsIHNjaGVtYSkge1xuXHRpZiAoc2NoZW1hW1wiZW51bVwiXSA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0cmV0dXJuIG51bGw7XG5cdH1cblx0Zm9yICh2YXIgaSA9IDA7IGkgPCBzY2hlbWFbXCJlbnVtXCJdLmxlbmd0aDsgaSsrKSB7XG5cdFx0dmFyIGVudW1WYWwgPSBzY2hlbWFbXCJlbnVtXCJdW2ldO1xuXHRcdGlmIChyZWN1cnNpdmVDb21wYXJlKGRhdGEsIGVudW1WYWwpKSB7XG5cdFx0XHRyZXR1cm4gbnVsbDtcblx0XHR9XG5cdH1cblx0cmV0dXJuIHRoaXMuY3JlYXRlRXJyb3IoRXJyb3JDb2Rlcy5FTlVNX01JU01BVENILCB7dmFsdWU6ICh0eXBlb2YgSlNPTiAhPT0gJ3VuZGVmaW5lZCcpID8gSlNPTi5zdHJpbmdpZnkoZGF0YSkgOiBkYXRhfSwgJycsICcnLCBudWxsLCBkYXRhLCBzY2hlbWEpO1xufTtcblxuVmFsaWRhdG9yQ29udGV4dC5wcm90b3R5cGUudmFsaWRhdGVOdW1lcmljID0gZnVuY3Rpb24gdmFsaWRhdGVOdW1lcmljKGRhdGEsIHNjaGVtYSwgZGF0YVBvaW50ZXJQYXRoKSB7XG5cdHJldHVybiB0aGlzLnZhbGlkYXRlTXVsdGlwbGVPZihkYXRhLCBzY2hlbWEsIGRhdGFQb2ludGVyUGF0aClcblx0XHR8fCB0aGlzLnZhbGlkYXRlTWluTWF4KGRhdGEsIHNjaGVtYSwgZGF0YVBvaW50ZXJQYXRoKVxuXHRcdHx8IHRoaXMudmFsaWRhdGVOYU4oZGF0YSwgc2NoZW1hLCBkYXRhUG9pbnRlclBhdGgpXG5cdFx0fHwgbnVsbDtcbn07XG5cbnZhciBDTE9TRV9FTk9VR0hfTE9XID0gTWF0aC5wb3coMiwgLTUxKTtcbnZhciBDTE9TRV9FTk9VR0hfSElHSCA9IDEgLSBDTE9TRV9FTk9VR0hfTE9XO1xuVmFsaWRhdG9yQ29udGV4dC5wcm90b3R5cGUudmFsaWRhdGVNdWx0aXBsZU9mID0gZnVuY3Rpb24gdmFsaWRhdGVNdWx0aXBsZU9mKGRhdGEsIHNjaGVtYSkge1xuXHR2YXIgbXVsdGlwbGVPZiA9IHNjaGVtYS5tdWx0aXBsZU9mIHx8IHNjaGVtYS5kaXZpc2libGVCeTtcblx0aWYgKG11bHRpcGxlT2YgPT09IHVuZGVmaW5lZCkge1xuXHRcdHJldHVybiBudWxsO1xuXHR9XG5cdGlmICh0eXBlb2YgZGF0YSA9PT0gXCJudW1iZXJcIikge1xuXHRcdHZhciByZW1haW5kZXIgPSAoZGF0YS9tdWx0aXBsZU9mKSUxO1xuXHRcdGlmIChyZW1haW5kZXIgPj0gQ0xPU0VfRU5PVUdIX0xPVyAmJiByZW1haW5kZXIgPCBDTE9TRV9FTk9VR0hfSElHSCkge1xuXHRcdFx0cmV0dXJuIHRoaXMuY3JlYXRlRXJyb3IoRXJyb3JDb2Rlcy5OVU1CRVJfTVVMVElQTEVfT0YsIHt2YWx1ZTogZGF0YSwgbXVsdGlwbGVPZjogbXVsdGlwbGVPZn0sICcnLCAnJywgbnVsbCwgZGF0YSwgc2NoZW1hKTtcblx0XHR9XG5cdH1cblx0cmV0dXJuIG51bGw7XG59O1xuXG5WYWxpZGF0b3JDb250ZXh0LnByb3RvdHlwZS52YWxpZGF0ZU1pbk1heCA9IGZ1bmN0aW9uIHZhbGlkYXRlTWluTWF4KGRhdGEsIHNjaGVtYSkge1xuXHRpZiAodHlwZW9mIGRhdGEgIT09IFwibnVtYmVyXCIpIHtcblx0XHRyZXR1cm4gbnVsbDtcblx0fVxuXHRpZiAoc2NoZW1hLm1pbmltdW0gIT09IHVuZGVmaW5lZCkge1xuXHRcdGlmIChkYXRhIDwgc2NoZW1hLm1pbmltdW0pIHtcblx0XHRcdHJldHVybiB0aGlzLmNyZWF0ZUVycm9yKEVycm9yQ29kZXMuTlVNQkVSX01JTklNVU0sIHt2YWx1ZTogZGF0YSwgbWluaW11bTogc2NoZW1hLm1pbmltdW19LCAnJywgJy9taW5pbXVtJywgbnVsbCwgZGF0YSwgc2NoZW1hKTtcblx0XHR9XG5cdFx0aWYgKHNjaGVtYS5leGNsdXNpdmVNaW5pbXVtICYmIGRhdGEgPT09IHNjaGVtYS5taW5pbXVtKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5jcmVhdGVFcnJvcihFcnJvckNvZGVzLk5VTUJFUl9NSU5JTVVNX0VYQ0xVU0lWRSwge3ZhbHVlOiBkYXRhLCBtaW5pbXVtOiBzY2hlbWEubWluaW11bX0sICcnLCAnL2V4Y2x1c2l2ZU1pbmltdW0nLCBudWxsLCBkYXRhLCBzY2hlbWEpO1xuXHRcdH1cblx0fVxuXHRpZiAoc2NoZW1hLm1heGltdW0gIT09IHVuZGVmaW5lZCkge1xuXHRcdGlmIChkYXRhID4gc2NoZW1hLm1heGltdW0pIHtcblx0XHRcdHJldHVybiB0aGlzLmNyZWF0ZUVycm9yKEVycm9yQ29kZXMuTlVNQkVSX01BWElNVU0sIHt2YWx1ZTogZGF0YSwgbWF4aW11bTogc2NoZW1hLm1heGltdW19LCAnJywgJy9tYXhpbXVtJywgbnVsbCwgZGF0YSwgc2NoZW1hKTtcblx0XHR9XG5cdFx0aWYgKHNjaGVtYS5leGNsdXNpdmVNYXhpbXVtICYmIGRhdGEgPT09IHNjaGVtYS5tYXhpbXVtKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5jcmVhdGVFcnJvcihFcnJvckNvZGVzLk5VTUJFUl9NQVhJTVVNX0VYQ0xVU0lWRSwge3ZhbHVlOiBkYXRhLCBtYXhpbXVtOiBzY2hlbWEubWF4aW11bX0sICcnLCAnL2V4Y2x1c2l2ZU1heGltdW0nLCBudWxsLCBkYXRhLCBzY2hlbWEpO1xuXHRcdH1cblx0fVxuXHRyZXR1cm4gbnVsbDtcbn07XG5cblZhbGlkYXRvckNvbnRleHQucHJvdG90eXBlLnZhbGlkYXRlTmFOID0gZnVuY3Rpb24gdmFsaWRhdGVOYU4oZGF0YSwgc2NoZW1hKSB7XG5cdGlmICh0eXBlb2YgZGF0YSAhPT0gXCJudW1iZXJcIikge1xuXHRcdHJldHVybiBudWxsO1xuXHR9XG5cdGlmIChpc05hTihkYXRhKSA9PT0gdHJ1ZSB8fCBkYXRhID09PSBJbmZpbml0eSB8fCBkYXRhID09PSAtSW5maW5pdHkpIHtcblx0XHRyZXR1cm4gdGhpcy5jcmVhdGVFcnJvcihFcnJvckNvZGVzLk5VTUJFUl9OT1RfQV9OVU1CRVIsIHt2YWx1ZTogZGF0YX0sICcnLCAnL3R5cGUnLCBudWxsLCBkYXRhLCBzY2hlbWEpO1xuXHR9XG5cdHJldHVybiBudWxsO1xufTtcblxuVmFsaWRhdG9yQ29udGV4dC5wcm90b3R5cGUudmFsaWRhdGVTdHJpbmcgPSBmdW5jdGlvbiB2YWxpZGF0ZVN0cmluZyhkYXRhLCBzY2hlbWEsIGRhdGFQb2ludGVyUGF0aCkge1xuXHRyZXR1cm4gdGhpcy52YWxpZGF0ZVN0cmluZ0xlbmd0aChkYXRhLCBzY2hlbWEsIGRhdGFQb2ludGVyUGF0aClcblx0XHR8fCB0aGlzLnZhbGlkYXRlU3RyaW5nUGF0dGVybihkYXRhLCBzY2hlbWEsIGRhdGFQb2ludGVyUGF0aClcblx0XHR8fCBudWxsO1xufTtcblxuVmFsaWRhdG9yQ29udGV4dC5wcm90b3R5cGUudmFsaWRhdGVTdHJpbmdMZW5ndGggPSBmdW5jdGlvbiB2YWxpZGF0ZVN0cmluZ0xlbmd0aChkYXRhLCBzY2hlbWEpIHtcblx0aWYgKHR5cGVvZiBkYXRhICE9PSBcInN0cmluZ1wiKSB7XG5cdFx0cmV0dXJuIG51bGw7XG5cdH1cblx0aWYgKHNjaGVtYS5taW5MZW5ndGggIT09IHVuZGVmaW5lZCkge1xuXHRcdGlmIChkYXRhLmxlbmd0aCA8IHNjaGVtYS5taW5MZW5ndGgpIHtcblx0XHRcdHJldHVybiB0aGlzLmNyZWF0ZUVycm9yKEVycm9yQ29kZXMuU1RSSU5HX0xFTkdUSF9TSE9SVCwge2xlbmd0aDogZGF0YS5sZW5ndGgsIG1pbmltdW06IHNjaGVtYS5taW5MZW5ndGh9LCAnJywgJy9taW5MZW5ndGgnLCBudWxsLCBkYXRhLCBzY2hlbWEpO1xuXHRcdH1cblx0fVxuXHRpZiAoc2NoZW1hLm1heExlbmd0aCAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0aWYgKGRhdGEubGVuZ3RoID4gc2NoZW1hLm1heExlbmd0aCkge1xuXHRcdFx0cmV0dXJuIHRoaXMuY3JlYXRlRXJyb3IoRXJyb3JDb2Rlcy5TVFJJTkdfTEVOR1RIX0xPTkcsIHtsZW5ndGg6IGRhdGEubGVuZ3RoLCBtYXhpbXVtOiBzY2hlbWEubWF4TGVuZ3RofSwgJycsICcvbWF4TGVuZ3RoJywgbnVsbCwgZGF0YSwgc2NoZW1hKTtcblx0XHR9XG5cdH1cblx0cmV0dXJuIG51bGw7XG59O1xuXG5WYWxpZGF0b3JDb250ZXh0LnByb3RvdHlwZS52YWxpZGF0ZVN0cmluZ1BhdHRlcm4gPSBmdW5jdGlvbiB2YWxpZGF0ZVN0cmluZ1BhdHRlcm4oZGF0YSwgc2NoZW1hKSB7XG5cdGlmICh0eXBlb2YgZGF0YSAhPT0gXCJzdHJpbmdcIiB8fCAodHlwZW9mIHNjaGVtYS5wYXR0ZXJuICE9PSBcInN0cmluZ1wiICYmICEoc2NoZW1hLnBhdHRlcm4gaW5zdGFuY2VvZiBSZWdFeHApKSkge1xuXHRcdHJldHVybiBudWxsO1xuXHR9XG5cdHZhciByZWdleHA7XG5cdGlmIChzY2hlbWEucGF0dGVybiBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuXHQgIHJlZ2V4cCA9IHNjaGVtYS5wYXR0ZXJuO1xuXHR9XG5cdGVsc2Uge1xuXHQgIHZhciBib2R5LCBmbGFncyA9ICcnO1xuXHQgIC8vIENoZWNrIGZvciByZWd1bGFyIGV4cHJlc3Npb24gbGl0ZXJhbHNcblx0ICAvLyBAc2VlIGh0dHA6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi81LjEvI3NlYy03LjguNVxuXHQgIHZhciBsaXRlcmFsID0gc2NoZW1hLnBhdHRlcm4ubWF0Y2goL15cXC8oLispXFwvKFtpbWddKikkLyk7XG5cdCAgaWYgKGxpdGVyYWwpIHtcblx0ICAgIGJvZHkgPSBsaXRlcmFsWzFdO1xuXHQgICAgZmxhZ3MgPSBsaXRlcmFsWzJdO1xuXHQgIH1cblx0ICBlbHNlIHtcblx0ICAgIGJvZHkgPSBzY2hlbWEucGF0dGVybjtcblx0ICB9XG5cdCAgcmVnZXhwID0gbmV3IFJlZ0V4cChib2R5LCBmbGFncyk7XG5cdH1cblx0aWYgKCFyZWdleHAudGVzdChkYXRhKSkge1xuXHRcdHJldHVybiB0aGlzLmNyZWF0ZUVycm9yKEVycm9yQ29kZXMuU1RSSU5HX1BBVFRFUk4sIHtwYXR0ZXJuOiBzY2hlbWEucGF0dGVybn0sICcnLCAnL3BhdHRlcm4nLCBudWxsLCBkYXRhLCBzY2hlbWEpO1xuXHR9XG5cdHJldHVybiBudWxsO1xufTtcblxuVmFsaWRhdG9yQ29udGV4dC5wcm90b3R5cGUudmFsaWRhdGVBcnJheSA9IGZ1bmN0aW9uIHZhbGlkYXRlQXJyYXkoZGF0YSwgc2NoZW1hLCBkYXRhUG9pbnRlclBhdGgpIHtcblx0aWYgKCFBcnJheS5pc0FycmF5KGRhdGEpKSB7XG5cdFx0cmV0dXJuIG51bGw7XG5cdH1cblx0cmV0dXJuIHRoaXMudmFsaWRhdGVBcnJheUxlbmd0aChkYXRhLCBzY2hlbWEsIGRhdGFQb2ludGVyUGF0aClcblx0XHR8fCB0aGlzLnZhbGlkYXRlQXJyYXlVbmlxdWVJdGVtcyhkYXRhLCBzY2hlbWEsIGRhdGFQb2ludGVyUGF0aClcblx0XHR8fCB0aGlzLnZhbGlkYXRlQXJyYXlJdGVtcyhkYXRhLCBzY2hlbWEsIGRhdGFQb2ludGVyUGF0aClcblx0XHR8fCBudWxsO1xufTtcblxuVmFsaWRhdG9yQ29udGV4dC5wcm90b3R5cGUudmFsaWRhdGVBcnJheUxlbmd0aCA9IGZ1bmN0aW9uIHZhbGlkYXRlQXJyYXlMZW5ndGgoZGF0YSwgc2NoZW1hKSB7XG5cdHZhciBlcnJvcjtcblx0aWYgKHNjaGVtYS5taW5JdGVtcyAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0aWYgKGRhdGEubGVuZ3RoIDwgc2NoZW1hLm1pbkl0ZW1zKSB7XG5cdFx0XHRlcnJvciA9IHRoaXMuY3JlYXRlRXJyb3IoRXJyb3JDb2Rlcy5BUlJBWV9MRU5HVEhfU0hPUlQsIHtsZW5ndGg6IGRhdGEubGVuZ3RoLCBtaW5pbXVtOiBzY2hlbWEubWluSXRlbXN9LCAnJywgJy9taW5JdGVtcycsIG51bGwsIGRhdGEsIHNjaGVtYSk7XG5cdFx0XHRpZiAodGhpcy5oYW5kbGVFcnJvcihlcnJvcikpIHtcblx0XHRcdFx0cmV0dXJuIGVycm9yO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXHRpZiAoc2NoZW1hLm1heEl0ZW1zICE9PSB1bmRlZmluZWQpIHtcblx0XHRpZiAoZGF0YS5sZW5ndGggPiBzY2hlbWEubWF4SXRlbXMpIHtcblx0XHRcdGVycm9yID0gdGhpcy5jcmVhdGVFcnJvcihFcnJvckNvZGVzLkFSUkFZX0xFTkdUSF9MT05HLCB7bGVuZ3RoOiBkYXRhLmxlbmd0aCwgbWF4aW11bTogc2NoZW1hLm1heEl0ZW1zfSwgJycsICcvbWF4SXRlbXMnLCBudWxsLCBkYXRhLCBzY2hlbWEpO1xuXHRcdFx0aWYgKHRoaXMuaGFuZGxlRXJyb3IoZXJyb3IpKSB7XG5cdFx0XHRcdHJldHVybiBlcnJvcjtcblx0XHRcdH1cblx0XHR9XG5cdH1cblx0cmV0dXJuIG51bGw7XG59O1xuXG5WYWxpZGF0b3JDb250ZXh0LnByb3RvdHlwZS52YWxpZGF0ZUFycmF5VW5pcXVlSXRlbXMgPSBmdW5jdGlvbiB2YWxpZGF0ZUFycmF5VW5pcXVlSXRlbXMoZGF0YSwgc2NoZW1hKSB7XG5cdGlmIChzY2hlbWEudW5pcXVlSXRlbXMpIHtcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyBpKyspIHtcblx0XHRcdGZvciAodmFyIGogPSBpICsgMTsgaiA8IGRhdGEubGVuZ3RoOyBqKyspIHtcblx0XHRcdFx0aWYgKHJlY3Vyc2l2ZUNvbXBhcmUoZGF0YVtpXSwgZGF0YVtqXSkpIHtcblx0XHRcdFx0XHR2YXIgZXJyb3IgPSB0aGlzLmNyZWF0ZUVycm9yKEVycm9yQ29kZXMuQVJSQVlfVU5JUVVFLCB7bWF0Y2gxOiBpLCBtYXRjaDI6IGp9LCAnJywgJy91bmlxdWVJdGVtcycsIG51bGwsIGRhdGEsIHNjaGVtYSk7XG5cdFx0XHRcdFx0aWYgKHRoaXMuaGFuZGxlRXJyb3IoZXJyb3IpKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZXJyb3I7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cdHJldHVybiBudWxsO1xufTtcblxuVmFsaWRhdG9yQ29udGV4dC5wcm90b3R5cGUudmFsaWRhdGVBcnJheUl0ZW1zID0gZnVuY3Rpb24gdmFsaWRhdGVBcnJheUl0ZW1zKGRhdGEsIHNjaGVtYSwgZGF0YVBvaW50ZXJQYXRoKSB7XG5cdGlmIChzY2hlbWEuaXRlbXMgPT09IHVuZGVmaW5lZCkge1xuXHRcdHJldHVybiBudWxsO1xuXHR9XG5cdHZhciBlcnJvciwgaTtcblx0aWYgKEFycmF5LmlzQXJyYXkoc2NoZW1hLml0ZW1zKSkge1xuXHRcdGZvciAoaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRpZiAoaSA8IHNjaGVtYS5pdGVtcy5sZW5ndGgpIHtcblx0XHRcdFx0aWYgKGVycm9yID0gdGhpcy52YWxpZGF0ZUFsbChkYXRhW2ldLCBzY2hlbWEuaXRlbXNbaV0sIFtpXSwgW1wiaXRlbXNcIiwgaV0sIGRhdGFQb2ludGVyUGF0aCArIFwiL1wiICsgaSkpIHtcblx0XHRcdFx0XHRyZXR1cm4gZXJyb3I7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSBpZiAoc2NoZW1hLmFkZGl0aW9uYWxJdGVtcyAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdGlmICh0eXBlb2Ygc2NoZW1hLmFkZGl0aW9uYWxJdGVtcyA9PT0gXCJib29sZWFuXCIpIHtcblx0XHRcdFx0XHRpZiAoIXNjaGVtYS5hZGRpdGlvbmFsSXRlbXMpIHtcblx0XHRcdFx0XHRcdGVycm9yID0gKHRoaXMuY3JlYXRlRXJyb3IoRXJyb3JDb2Rlcy5BUlJBWV9BRERJVElPTkFMX0lURU1TLCB7fSwgJy8nICsgaSwgJy9hZGRpdGlvbmFsSXRlbXMnLCBudWxsLCBkYXRhLCBzY2hlbWEpKTtcblx0XHRcdFx0XHRcdGlmICh0aGlzLmhhbmRsZUVycm9yKGVycm9yKSkge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gZXJyb3I7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IGVsc2UgaWYgKGVycm9yID0gdGhpcy52YWxpZGF0ZUFsbChkYXRhW2ldLCBzY2hlbWEuYWRkaXRpb25hbEl0ZW1zLCBbaV0sIFtcImFkZGl0aW9uYWxJdGVtc1wiXSwgZGF0YVBvaW50ZXJQYXRoICsgXCIvXCIgKyBpKSkge1xuXHRcdFx0XHRcdHJldHVybiBlcnJvcjtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fSBlbHNlIHtcblx0XHRmb3IgKGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkrKykge1xuXHRcdFx0aWYgKGVycm9yID0gdGhpcy52YWxpZGF0ZUFsbChkYXRhW2ldLCBzY2hlbWEuaXRlbXMsIFtpXSwgW1wiaXRlbXNcIl0sIGRhdGFQb2ludGVyUGF0aCArIFwiL1wiICsgaSkpIHtcblx0XHRcdFx0cmV0dXJuIGVycm9yO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXHRyZXR1cm4gbnVsbDtcbn07XG5cblZhbGlkYXRvckNvbnRleHQucHJvdG90eXBlLnZhbGlkYXRlT2JqZWN0ID0gZnVuY3Rpb24gdmFsaWRhdGVPYmplY3QoZGF0YSwgc2NoZW1hLCBkYXRhUG9pbnRlclBhdGgpIHtcblx0aWYgKHR5cGVvZiBkYXRhICE9PSBcIm9iamVjdFwiIHx8IGRhdGEgPT09IG51bGwgfHwgQXJyYXkuaXNBcnJheShkYXRhKSkge1xuXHRcdHJldHVybiBudWxsO1xuXHR9XG5cdHJldHVybiB0aGlzLnZhbGlkYXRlT2JqZWN0TWluTWF4UHJvcGVydGllcyhkYXRhLCBzY2hlbWEsIGRhdGFQb2ludGVyUGF0aClcblx0XHR8fCB0aGlzLnZhbGlkYXRlT2JqZWN0UmVxdWlyZWRQcm9wZXJ0aWVzKGRhdGEsIHNjaGVtYSwgZGF0YVBvaW50ZXJQYXRoKVxuXHRcdHx8IHRoaXMudmFsaWRhdGVPYmplY3RQcm9wZXJ0aWVzKGRhdGEsIHNjaGVtYSwgZGF0YVBvaW50ZXJQYXRoKVxuXHRcdHx8IHRoaXMudmFsaWRhdGVPYmplY3REZXBlbmRlbmNpZXMoZGF0YSwgc2NoZW1hLCBkYXRhUG9pbnRlclBhdGgpXG5cdFx0fHwgbnVsbDtcbn07XG5cblZhbGlkYXRvckNvbnRleHQucHJvdG90eXBlLnZhbGlkYXRlT2JqZWN0TWluTWF4UHJvcGVydGllcyA9IGZ1bmN0aW9uIHZhbGlkYXRlT2JqZWN0TWluTWF4UHJvcGVydGllcyhkYXRhLCBzY2hlbWEpIHtcblx0dmFyIGtleXMgPSBPYmplY3Qua2V5cyhkYXRhKTtcblx0dmFyIGVycm9yO1xuXHRpZiAoc2NoZW1hLm1pblByb3BlcnRpZXMgIT09IHVuZGVmaW5lZCkge1xuXHRcdGlmIChrZXlzLmxlbmd0aCA8IHNjaGVtYS5taW5Qcm9wZXJ0aWVzKSB7XG5cdFx0XHRlcnJvciA9IHRoaXMuY3JlYXRlRXJyb3IoRXJyb3JDb2Rlcy5PQkpFQ1RfUFJPUEVSVElFU19NSU5JTVVNLCB7cHJvcGVydHlDb3VudDoga2V5cy5sZW5ndGgsIG1pbmltdW06IHNjaGVtYS5taW5Qcm9wZXJ0aWVzfSwgJycsICcvbWluUHJvcGVydGllcycsIG51bGwsIGRhdGEsIHNjaGVtYSk7XG5cdFx0XHRpZiAodGhpcy5oYW5kbGVFcnJvcihlcnJvcikpIHtcblx0XHRcdFx0cmV0dXJuIGVycm9yO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXHRpZiAoc2NoZW1hLm1heFByb3BlcnRpZXMgIT09IHVuZGVmaW5lZCkge1xuXHRcdGlmIChrZXlzLmxlbmd0aCA+IHNjaGVtYS5tYXhQcm9wZXJ0aWVzKSB7XG5cdFx0XHRlcnJvciA9IHRoaXMuY3JlYXRlRXJyb3IoRXJyb3JDb2Rlcy5PQkpFQ1RfUFJPUEVSVElFU19NQVhJTVVNLCB7cHJvcGVydHlDb3VudDoga2V5cy5sZW5ndGgsIG1heGltdW06IHNjaGVtYS5tYXhQcm9wZXJ0aWVzfSwgJycsICcvbWF4UHJvcGVydGllcycsIG51bGwsIGRhdGEsIHNjaGVtYSk7XG5cdFx0XHRpZiAodGhpcy5oYW5kbGVFcnJvcihlcnJvcikpIHtcblx0XHRcdFx0cmV0dXJuIGVycm9yO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXHRyZXR1cm4gbnVsbDtcbn07XG5cblZhbGlkYXRvckNvbnRleHQucHJvdG90eXBlLnZhbGlkYXRlT2JqZWN0UmVxdWlyZWRQcm9wZXJ0aWVzID0gZnVuY3Rpb24gdmFsaWRhdGVPYmplY3RSZXF1aXJlZFByb3BlcnRpZXMoZGF0YSwgc2NoZW1hKSB7XG5cdGlmIChzY2hlbWEucmVxdWlyZWQgIT09IHVuZGVmaW5lZCkge1xuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgc2NoZW1hLnJlcXVpcmVkLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR2YXIga2V5ID0gc2NoZW1hLnJlcXVpcmVkW2ldO1xuXHRcdFx0aWYgKGRhdGFba2V5XSA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdHZhciBlcnJvciA9IHRoaXMuY3JlYXRlRXJyb3IoRXJyb3JDb2Rlcy5PQkpFQ1RfUkVRVUlSRUQsIHtrZXk6IGtleX0sICcnLCAnL3JlcXVpcmVkLycgKyBpLCBudWxsLCBkYXRhLCBzY2hlbWEpO1xuXHRcdFx0XHRpZiAodGhpcy5oYW5kbGVFcnJvcihlcnJvcikpIHtcblx0XHRcdFx0XHRyZXR1cm4gZXJyb3I7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblx0cmV0dXJuIG51bGw7XG59O1xuXG5WYWxpZGF0b3JDb250ZXh0LnByb3RvdHlwZS52YWxpZGF0ZU9iamVjdFByb3BlcnRpZXMgPSBmdW5jdGlvbiB2YWxpZGF0ZU9iamVjdFByb3BlcnRpZXMoZGF0YSwgc2NoZW1hLCBkYXRhUG9pbnRlclBhdGgpIHtcblx0dmFyIGVycm9yO1xuXHRmb3IgKHZhciBrZXkgaW4gZGF0YSkge1xuXHRcdHZhciBrZXlQb2ludGVyUGF0aCA9IGRhdGFQb2ludGVyUGF0aCArIFwiL1wiICsga2V5LnJlcGxhY2UoL34vZywgJ34wJykucmVwbGFjZSgvXFwvL2csICd+MScpO1xuXHRcdHZhciBmb3VuZE1hdGNoID0gZmFsc2U7XG5cdFx0aWYgKHNjaGVtYS5wcm9wZXJ0aWVzICE9PSB1bmRlZmluZWQgJiYgc2NoZW1hLnByb3BlcnRpZXNba2V5XSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRmb3VuZE1hdGNoID0gdHJ1ZTtcblx0XHRcdGlmIChlcnJvciA9IHRoaXMudmFsaWRhdGVBbGwoZGF0YVtrZXldLCBzY2hlbWEucHJvcGVydGllc1trZXldLCBba2V5XSwgW1wicHJvcGVydGllc1wiLCBrZXldLCBrZXlQb2ludGVyUGF0aCkpIHtcblx0XHRcdFx0cmV0dXJuIGVycm9yO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRpZiAoc2NoZW1hLnBhdHRlcm5Qcm9wZXJ0aWVzICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdGZvciAodmFyIHBhdHRlcm5LZXkgaW4gc2NoZW1hLnBhdHRlcm5Qcm9wZXJ0aWVzKSB7XG5cdFx0XHRcdHZhciByZWdleHAgPSBuZXcgUmVnRXhwKHBhdHRlcm5LZXkpO1xuXHRcdFx0XHRpZiAocmVnZXhwLnRlc3Qoa2V5KSkge1xuXHRcdFx0XHRcdGZvdW5kTWF0Y2ggPSB0cnVlO1xuXHRcdFx0XHRcdGlmIChlcnJvciA9IHRoaXMudmFsaWRhdGVBbGwoZGF0YVtrZXldLCBzY2hlbWEucGF0dGVyblByb3BlcnRpZXNbcGF0dGVybktleV0sIFtrZXldLCBbXCJwYXR0ZXJuUHJvcGVydGllc1wiLCBwYXR0ZXJuS2V5XSwga2V5UG9pbnRlclBhdGgpKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZXJyb3I7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGlmICghZm91bmRNYXRjaCkge1xuXHRcdFx0aWYgKHNjaGVtYS5hZGRpdGlvbmFsUHJvcGVydGllcyAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdGlmICh0aGlzLnRyYWNrVW5rbm93blByb3BlcnRpZXMpIHtcblx0XHRcdFx0XHR0aGlzLmtub3duUHJvcGVydHlQYXRoc1trZXlQb2ludGVyUGF0aF0gPSB0cnVlO1xuXHRcdFx0XHRcdGRlbGV0ZSB0aGlzLnVua25vd25Qcm9wZXJ0eVBhdGhzW2tleVBvaW50ZXJQYXRoXTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAodHlwZW9mIHNjaGVtYS5hZGRpdGlvbmFsUHJvcGVydGllcyA9PT0gXCJib29sZWFuXCIpIHtcblx0XHRcdFx0XHRpZiAoIXNjaGVtYS5hZGRpdGlvbmFsUHJvcGVydGllcykge1xuXHRcdFx0XHRcdFx0ZXJyb3IgPSB0aGlzLmNyZWF0ZUVycm9yKEVycm9yQ29kZXMuT0JKRUNUX0FERElUSU9OQUxfUFJPUEVSVElFUywge2tleToga2V5fSwgJycsICcvYWRkaXRpb25hbFByb3BlcnRpZXMnLCBudWxsLCBkYXRhLCBzY2hlbWEpLnByZWZpeFdpdGgoa2V5LCBudWxsKTtcblx0XHRcdFx0XHRcdGlmICh0aGlzLmhhbmRsZUVycm9yKGVycm9yKSkge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gZXJyb3I7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGlmIChlcnJvciA9IHRoaXMudmFsaWRhdGVBbGwoZGF0YVtrZXldLCBzY2hlbWEuYWRkaXRpb25hbFByb3BlcnRpZXMsIFtrZXldLCBbXCJhZGRpdGlvbmFsUHJvcGVydGllc1wiXSwga2V5UG9pbnRlclBhdGgpKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZXJyb3I7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2UgaWYgKHRoaXMudHJhY2tVbmtub3duUHJvcGVydGllcyAmJiAhdGhpcy5rbm93blByb3BlcnR5UGF0aHNba2V5UG9pbnRlclBhdGhdKSB7XG5cdFx0XHRcdHRoaXMudW5rbm93blByb3BlcnR5UGF0aHNba2V5UG9pbnRlclBhdGhdID0gdHJ1ZTtcblx0XHRcdH1cblx0XHR9IGVsc2UgaWYgKHRoaXMudHJhY2tVbmtub3duUHJvcGVydGllcykge1xuXHRcdFx0dGhpcy5rbm93blByb3BlcnR5UGF0aHNba2V5UG9pbnRlclBhdGhdID0gdHJ1ZTtcblx0XHRcdGRlbGV0ZSB0aGlzLnVua25vd25Qcm9wZXJ0eVBhdGhzW2tleVBvaW50ZXJQYXRoXTtcblx0XHR9XG5cdH1cblx0cmV0dXJuIG51bGw7XG59O1xuXG5WYWxpZGF0b3JDb250ZXh0LnByb3RvdHlwZS52YWxpZGF0ZU9iamVjdERlcGVuZGVuY2llcyA9IGZ1bmN0aW9uIHZhbGlkYXRlT2JqZWN0RGVwZW5kZW5jaWVzKGRhdGEsIHNjaGVtYSwgZGF0YVBvaW50ZXJQYXRoKSB7XG5cdHZhciBlcnJvcjtcblx0aWYgKHNjaGVtYS5kZXBlbmRlbmNpZXMgIT09IHVuZGVmaW5lZCkge1xuXHRcdGZvciAodmFyIGRlcEtleSBpbiBzY2hlbWEuZGVwZW5kZW5jaWVzKSB7XG5cdFx0XHRpZiAoZGF0YVtkZXBLZXldICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0dmFyIGRlcCA9IHNjaGVtYS5kZXBlbmRlbmNpZXNbZGVwS2V5XTtcblx0XHRcdFx0aWYgKHR5cGVvZiBkZXAgPT09IFwic3RyaW5nXCIpIHtcblx0XHRcdFx0XHRpZiAoZGF0YVtkZXBdID09PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0XHRcdGVycm9yID0gdGhpcy5jcmVhdGVFcnJvcihFcnJvckNvZGVzLk9CSkVDVF9ERVBFTkRFTkNZX0tFWSwge2tleTogZGVwS2V5LCBtaXNzaW5nOiBkZXB9LCAnJywgJycsIG51bGwsIGRhdGEsIHNjaGVtYSkucHJlZml4V2l0aChudWxsLCBkZXBLZXkpLnByZWZpeFdpdGgobnVsbCwgXCJkZXBlbmRlbmNpZXNcIik7XG5cdFx0XHRcdFx0XHRpZiAodGhpcy5oYW5kbGVFcnJvcihlcnJvcikpIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIGVycm9yO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSBlbHNlIGlmIChBcnJheS5pc0FycmF5KGRlcCkpIHtcblx0XHRcdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGRlcC5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRcdFx0dmFyIHJlcXVpcmVkS2V5ID0gZGVwW2ldO1xuXHRcdFx0XHRcdFx0aWYgKGRhdGFbcmVxdWlyZWRLZXldID09PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0XHRcdFx0ZXJyb3IgPSB0aGlzLmNyZWF0ZUVycm9yKEVycm9yQ29kZXMuT0JKRUNUX0RFUEVOREVOQ1lfS0VZLCB7a2V5OiBkZXBLZXksIG1pc3Npbmc6IHJlcXVpcmVkS2V5fSwgJycsICcvJyArIGksIG51bGwsIGRhdGEsIHNjaGVtYSkucHJlZml4V2l0aChudWxsLCBkZXBLZXkpLnByZWZpeFdpdGgobnVsbCwgXCJkZXBlbmRlbmNpZXNcIik7XG5cdFx0XHRcdFx0XHRcdGlmICh0aGlzLmhhbmRsZUVycm9yKGVycm9yKSkge1xuXHRcdFx0XHRcdFx0XHRcdHJldHVybiBlcnJvcjtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRpZiAoZXJyb3IgPSB0aGlzLnZhbGlkYXRlQWxsKGRhdGEsIGRlcCwgW10sIFtcImRlcGVuZGVuY2llc1wiLCBkZXBLZXldLCBkYXRhUG9pbnRlclBhdGgpKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZXJyb3I7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cdHJldHVybiBudWxsO1xufTtcblxuVmFsaWRhdG9yQ29udGV4dC5wcm90b3R5cGUudmFsaWRhdGVDb21iaW5hdGlvbnMgPSBmdW5jdGlvbiB2YWxpZGF0ZUNvbWJpbmF0aW9ucyhkYXRhLCBzY2hlbWEsIGRhdGFQb2ludGVyUGF0aCkge1xuXHRyZXR1cm4gdGhpcy52YWxpZGF0ZUFsbE9mKGRhdGEsIHNjaGVtYSwgZGF0YVBvaW50ZXJQYXRoKVxuXHRcdHx8IHRoaXMudmFsaWRhdGVBbnlPZihkYXRhLCBzY2hlbWEsIGRhdGFQb2ludGVyUGF0aClcblx0XHR8fCB0aGlzLnZhbGlkYXRlT25lT2YoZGF0YSwgc2NoZW1hLCBkYXRhUG9pbnRlclBhdGgpXG5cdFx0fHwgdGhpcy52YWxpZGF0ZU5vdChkYXRhLCBzY2hlbWEsIGRhdGFQb2ludGVyUGF0aClcblx0XHR8fCBudWxsO1xufTtcblxuVmFsaWRhdG9yQ29udGV4dC5wcm90b3R5cGUudmFsaWRhdGVBbGxPZiA9IGZ1bmN0aW9uIHZhbGlkYXRlQWxsT2YoZGF0YSwgc2NoZW1hLCBkYXRhUG9pbnRlclBhdGgpIHtcblx0aWYgKHNjaGVtYS5hbGxPZiA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0cmV0dXJuIG51bGw7XG5cdH1cblx0dmFyIGVycm9yO1xuXHRmb3IgKHZhciBpID0gMDsgaSA8IHNjaGVtYS5hbGxPZi5sZW5ndGg7IGkrKykge1xuXHRcdHZhciBzdWJTY2hlbWEgPSBzY2hlbWEuYWxsT2ZbaV07XG5cdFx0aWYgKGVycm9yID0gdGhpcy52YWxpZGF0ZUFsbChkYXRhLCBzdWJTY2hlbWEsIFtdLCBbXCJhbGxPZlwiLCBpXSwgZGF0YVBvaW50ZXJQYXRoKSkge1xuXHRcdFx0cmV0dXJuIGVycm9yO1xuXHRcdH1cblx0fVxuXHRyZXR1cm4gbnVsbDtcbn07XG5cblZhbGlkYXRvckNvbnRleHQucHJvdG90eXBlLnZhbGlkYXRlQW55T2YgPSBmdW5jdGlvbiB2YWxpZGF0ZUFueU9mKGRhdGEsIHNjaGVtYSwgZGF0YVBvaW50ZXJQYXRoKSB7XG5cdGlmIChzY2hlbWEuYW55T2YgPT09IHVuZGVmaW5lZCkge1xuXHRcdHJldHVybiBudWxsO1xuXHR9XG5cdHZhciBlcnJvcnMgPSBbXTtcblx0dmFyIHN0YXJ0RXJyb3JDb3VudCA9IHRoaXMuZXJyb3JzLmxlbmd0aDtcblx0dmFyIG9sZFVua25vd25Qcm9wZXJ0eVBhdGhzLCBvbGRLbm93blByb3BlcnR5UGF0aHM7XG5cdGlmICh0aGlzLnRyYWNrVW5rbm93blByb3BlcnRpZXMpIHtcblx0XHRvbGRVbmtub3duUHJvcGVydHlQYXRocyA9IHRoaXMudW5rbm93blByb3BlcnR5UGF0aHM7XG5cdFx0b2xkS25vd25Qcm9wZXJ0eVBhdGhzID0gdGhpcy5rbm93blByb3BlcnR5UGF0aHM7XG5cdH1cblx0dmFyIGVycm9yQXRFbmQgPSB0cnVlO1xuXHRmb3IgKHZhciBpID0gMDsgaSA8IHNjaGVtYS5hbnlPZi5sZW5ndGg7IGkrKykge1xuXHRcdGlmICh0aGlzLnRyYWNrVW5rbm93blByb3BlcnRpZXMpIHtcblx0XHRcdHRoaXMudW5rbm93blByb3BlcnR5UGF0aHMgPSB7fTtcblx0XHRcdHRoaXMua25vd25Qcm9wZXJ0eVBhdGhzID0ge307XG5cdFx0fVxuXHRcdHZhciBzdWJTY2hlbWEgPSBzY2hlbWEuYW55T2ZbaV07XG5cblx0XHR2YXIgZXJyb3JDb3VudCA9IHRoaXMuZXJyb3JzLmxlbmd0aDtcblx0XHR2YXIgZXJyb3IgPSB0aGlzLnZhbGlkYXRlQWxsKGRhdGEsIHN1YlNjaGVtYSwgW10sIFtcImFueU9mXCIsIGldLCBkYXRhUG9pbnRlclBhdGgpO1xuXG5cdFx0aWYgKGVycm9yID09PSBudWxsICYmIGVycm9yQ291bnQgPT09IHRoaXMuZXJyb3JzLmxlbmd0aCkge1xuXHRcdFx0dGhpcy5lcnJvcnMgPSB0aGlzLmVycm9ycy5zbGljZSgwLCBzdGFydEVycm9yQ291bnQpO1xuXG5cdFx0XHRpZiAodGhpcy50cmFja1Vua25vd25Qcm9wZXJ0aWVzKSB7XG5cdFx0XHRcdGZvciAodmFyIGtub3duS2V5IGluIHRoaXMua25vd25Qcm9wZXJ0eVBhdGhzKSB7XG5cdFx0XHRcdFx0b2xkS25vd25Qcm9wZXJ0eVBhdGhzW2tub3duS2V5XSA9IHRydWU7XG5cdFx0XHRcdFx0ZGVsZXRlIG9sZFVua25vd25Qcm9wZXJ0eVBhdGhzW2tub3duS2V5XTtcblx0XHRcdFx0fVxuXHRcdFx0XHRmb3IgKHZhciB1bmtub3duS2V5IGluIHRoaXMudW5rbm93blByb3BlcnR5UGF0aHMpIHtcblx0XHRcdFx0XHRpZiAoIW9sZEtub3duUHJvcGVydHlQYXRoc1t1bmtub3duS2V5XSkge1xuXHRcdFx0XHRcdFx0b2xkVW5rbm93blByb3BlcnR5UGF0aHNbdW5rbm93bktleV0gPSB0cnVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHQvLyBXZSBuZWVkIHRvIGNvbnRpbnVlIGxvb3Bpbmcgc28gd2UgY2F0Y2ggYWxsIHRoZSBwcm9wZXJ0eSBkZWZpbml0aW9ucywgYnV0IHdlIGRvbid0IHdhbnQgdG8gcmV0dXJuIGFuIGVycm9yXG5cdFx0XHRcdGVycm9yQXRFbmQgPSBmYWxzZTtcblx0XHRcdFx0Y29udGludWU7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBudWxsO1xuXHRcdH1cblx0XHRpZiAoZXJyb3IpIHtcblx0XHRcdGVycm9ycy5wdXNoKGVycm9yLnByZWZpeFdpdGgobnVsbCwgXCJcIiArIGkpLnByZWZpeFdpdGgobnVsbCwgXCJhbnlPZlwiKSk7XG5cdFx0fVxuXHR9XG5cdGlmICh0aGlzLnRyYWNrVW5rbm93blByb3BlcnRpZXMpIHtcblx0XHR0aGlzLnVua25vd25Qcm9wZXJ0eVBhdGhzID0gb2xkVW5rbm93blByb3BlcnR5UGF0aHM7XG5cdFx0dGhpcy5rbm93blByb3BlcnR5UGF0aHMgPSBvbGRLbm93blByb3BlcnR5UGF0aHM7XG5cdH1cblx0aWYgKGVycm9yQXRFbmQpIHtcblx0XHRlcnJvcnMgPSBlcnJvcnMuY29uY2F0KHRoaXMuZXJyb3JzLnNsaWNlKHN0YXJ0RXJyb3JDb3VudCkpO1xuXHRcdHRoaXMuZXJyb3JzID0gdGhpcy5lcnJvcnMuc2xpY2UoMCwgc3RhcnRFcnJvckNvdW50KTtcblx0XHRyZXR1cm4gdGhpcy5jcmVhdGVFcnJvcihFcnJvckNvZGVzLkFOWV9PRl9NSVNTSU5HLCB7fSwgXCJcIiwgXCIvYW55T2ZcIiwgZXJyb3JzLCBkYXRhLCBzY2hlbWEpO1xuXHR9XG59O1xuXG5WYWxpZGF0b3JDb250ZXh0LnByb3RvdHlwZS52YWxpZGF0ZU9uZU9mID0gZnVuY3Rpb24gdmFsaWRhdGVPbmVPZihkYXRhLCBzY2hlbWEsIGRhdGFQb2ludGVyUGF0aCkge1xuXHRpZiAoc2NoZW1hLm9uZU9mID09PSB1bmRlZmluZWQpIHtcblx0XHRyZXR1cm4gbnVsbDtcblx0fVxuXHR2YXIgdmFsaWRJbmRleCA9IG51bGw7XG5cdHZhciBlcnJvcnMgPSBbXTtcblx0dmFyIHN0YXJ0RXJyb3JDb3VudCA9IHRoaXMuZXJyb3JzLmxlbmd0aDtcblx0dmFyIG9sZFVua25vd25Qcm9wZXJ0eVBhdGhzLCBvbGRLbm93blByb3BlcnR5UGF0aHM7XG5cdGlmICh0aGlzLnRyYWNrVW5rbm93blByb3BlcnRpZXMpIHtcblx0XHRvbGRVbmtub3duUHJvcGVydHlQYXRocyA9IHRoaXMudW5rbm93blByb3BlcnR5UGF0aHM7XG5cdFx0b2xkS25vd25Qcm9wZXJ0eVBhdGhzID0gdGhpcy5rbm93blByb3BlcnR5UGF0aHM7XG5cdH1cblx0Zm9yICh2YXIgaSA9IDA7IGkgPCBzY2hlbWEub25lT2YubGVuZ3RoOyBpKyspIHtcblx0XHRpZiAodGhpcy50cmFja1Vua25vd25Qcm9wZXJ0aWVzKSB7XG5cdFx0XHR0aGlzLnVua25vd25Qcm9wZXJ0eVBhdGhzID0ge307XG5cdFx0XHR0aGlzLmtub3duUHJvcGVydHlQYXRocyA9IHt9O1xuXHRcdH1cblx0XHR2YXIgc3ViU2NoZW1hID0gc2NoZW1hLm9uZU9mW2ldO1xuXG5cdFx0dmFyIGVycm9yQ291bnQgPSB0aGlzLmVycm9ycy5sZW5ndGg7XG5cdFx0dmFyIGVycm9yID0gdGhpcy52YWxpZGF0ZUFsbChkYXRhLCBzdWJTY2hlbWEsIFtdLCBbXCJvbmVPZlwiLCBpXSwgZGF0YVBvaW50ZXJQYXRoKTtcblxuXHRcdGlmIChlcnJvciA9PT0gbnVsbCAmJiBlcnJvckNvdW50ID09PSB0aGlzLmVycm9ycy5sZW5ndGgpIHtcblx0XHRcdGlmICh2YWxpZEluZGV4ID09PSBudWxsKSB7XG5cdFx0XHRcdHZhbGlkSW5kZXggPSBpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGhpcy5lcnJvcnMgPSB0aGlzLmVycm9ycy5zbGljZSgwLCBzdGFydEVycm9yQ291bnQpO1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5jcmVhdGVFcnJvcihFcnJvckNvZGVzLk9ORV9PRl9NVUxUSVBMRSwge2luZGV4MTogdmFsaWRJbmRleCwgaW5kZXgyOiBpfSwgXCJcIiwgXCIvb25lT2ZcIiwgbnVsbCwgZGF0YSwgc2NoZW1hKTtcblx0XHRcdH1cblx0XHRcdGlmICh0aGlzLnRyYWNrVW5rbm93blByb3BlcnRpZXMpIHtcblx0XHRcdFx0Zm9yICh2YXIga25vd25LZXkgaW4gdGhpcy5rbm93blByb3BlcnR5UGF0aHMpIHtcblx0XHRcdFx0XHRvbGRLbm93blByb3BlcnR5UGF0aHNba25vd25LZXldID0gdHJ1ZTtcblx0XHRcdFx0XHRkZWxldGUgb2xkVW5rbm93blByb3BlcnR5UGF0aHNba25vd25LZXldO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGZvciAodmFyIHVua25vd25LZXkgaW4gdGhpcy51bmtub3duUHJvcGVydHlQYXRocykge1xuXHRcdFx0XHRcdGlmICghb2xkS25vd25Qcm9wZXJ0eVBhdGhzW3Vua25vd25LZXldKSB7XG5cdFx0XHRcdFx0XHRvbGRVbmtub3duUHJvcGVydHlQYXRoc1t1bmtub3duS2V5XSA9IHRydWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSBlbHNlIGlmIChlcnJvcikge1xuXHRcdFx0ZXJyb3JzLnB1c2goZXJyb3IpO1xuXHRcdH1cblx0fVxuXHRpZiAodGhpcy50cmFja1Vua25vd25Qcm9wZXJ0aWVzKSB7XG5cdFx0dGhpcy51bmtub3duUHJvcGVydHlQYXRocyA9IG9sZFVua25vd25Qcm9wZXJ0eVBhdGhzO1xuXHRcdHRoaXMua25vd25Qcm9wZXJ0eVBhdGhzID0gb2xkS25vd25Qcm9wZXJ0eVBhdGhzO1xuXHR9XG5cdGlmICh2YWxpZEluZGV4ID09PSBudWxsKSB7XG5cdFx0ZXJyb3JzID0gZXJyb3JzLmNvbmNhdCh0aGlzLmVycm9ycy5zbGljZShzdGFydEVycm9yQ291bnQpKTtcblx0XHR0aGlzLmVycm9ycyA9IHRoaXMuZXJyb3JzLnNsaWNlKDAsIHN0YXJ0RXJyb3JDb3VudCk7XG5cdFx0cmV0dXJuIHRoaXMuY3JlYXRlRXJyb3IoRXJyb3JDb2Rlcy5PTkVfT0ZfTUlTU0lORywge30sIFwiXCIsIFwiL29uZU9mXCIsIGVycm9ycywgZGF0YSwgc2NoZW1hKTtcblx0fSBlbHNlIHtcblx0XHR0aGlzLmVycm9ycyA9IHRoaXMuZXJyb3JzLnNsaWNlKDAsIHN0YXJ0RXJyb3JDb3VudCk7XG5cdH1cblx0cmV0dXJuIG51bGw7XG59O1xuXG5WYWxpZGF0b3JDb250ZXh0LnByb3RvdHlwZS52YWxpZGF0ZU5vdCA9IGZ1bmN0aW9uIHZhbGlkYXRlTm90KGRhdGEsIHNjaGVtYSwgZGF0YVBvaW50ZXJQYXRoKSB7XG5cdGlmIChzY2hlbWEubm90ID09PSB1bmRlZmluZWQpIHtcblx0XHRyZXR1cm4gbnVsbDtcblx0fVxuXHR2YXIgb2xkRXJyb3JDb3VudCA9IHRoaXMuZXJyb3JzLmxlbmd0aDtcblx0dmFyIG9sZFVua25vd25Qcm9wZXJ0eVBhdGhzLCBvbGRLbm93blByb3BlcnR5UGF0aHM7XG5cdGlmICh0aGlzLnRyYWNrVW5rbm93blByb3BlcnRpZXMpIHtcblx0XHRvbGRVbmtub3duUHJvcGVydHlQYXRocyA9IHRoaXMudW5rbm93blByb3BlcnR5UGF0aHM7XG5cdFx0b2xkS25vd25Qcm9wZXJ0eVBhdGhzID0gdGhpcy5rbm93blByb3BlcnR5UGF0aHM7XG5cdFx0dGhpcy51bmtub3duUHJvcGVydHlQYXRocyA9IHt9O1xuXHRcdHRoaXMua25vd25Qcm9wZXJ0eVBhdGhzID0ge307XG5cdH1cblx0dmFyIGVycm9yID0gdGhpcy52YWxpZGF0ZUFsbChkYXRhLCBzY2hlbWEubm90LCBudWxsLCBudWxsLCBkYXRhUG9pbnRlclBhdGgpO1xuXHR2YXIgbm90RXJyb3JzID0gdGhpcy5lcnJvcnMuc2xpY2Uob2xkRXJyb3JDb3VudCk7XG5cdHRoaXMuZXJyb3JzID0gdGhpcy5lcnJvcnMuc2xpY2UoMCwgb2xkRXJyb3JDb3VudCk7XG5cdGlmICh0aGlzLnRyYWNrVW5rbm93blByb3BlcnRpZXMpIHtcblx0XHR0aGlzLnVua25vd25Qcm9wZXJ0eVBhdGhzID0gb2xkVW5rbm93blByb3BlcnR5UGF0aHM7XG5cdFx0dGhpcy5rbm93blByb3BlcnR5UGF0aHMgPSBvbGRLbm93blByb3BlcnR5UGF0aHM7XG5cdH1cblx0aWYgKGVycm9yID09PSBudWxsICYmIG5vdEVycm9ycy5sZW5ndGggPT09IDApIHtcblx0XHRyZXR1cm4gdGhpcy5jcmVhdGVFcnJvcihFcnJvckNvZGVzLk5PVF9QQVNTRUQsIHt9LCBcIlwiLCBcIi9ub3RcIiwgbnVsbCwgZGF0YSwgc2NoZW1hKTtcblx0fVxuXHRyZXR1cm4gbnVsbDtcbn07XG5cblZhbGlkYXRvckNvbnRleHQucHJvdG90eXBlLnZhbGlkYXRlSHlwZXJtZWRpYSA9IGZ1bmN0aW9uIHZhbGlkYXRlQ29tYmluYXRpb25zKGRhdGEsIHNjaGVtYSwgZGF0YVBvaW50ZXJQYXRoKSB7XG5cdGlmICghc2NoZW1hLmxpbmtzKSB7XG5cdFx0cmV0dXJuIG51bGw7XG5cdH1cblx0dmFyIGVycm9yO1xuXHRmb3IgKHZhciBpID0gMDsgaSA8IHNjaGVtYS5saW5rcy5sZW5ndGg7IGkrKykge1xuXHRcdHZhciBsZG8gPSBzY2hlbWEubGlua3NbaV07XG5cdFx0aWYgKGxkby5yZWwgPT09IFwiZGVzY3JpYmVkYnlcIikge1xuXHRcdFx0dmFyIHRlbXBsYXRlID0gbmV3IFVyaVRlbXBsYXRlKGxkby5ocmVmKTtcblx0XHRcdHZhciBhbGxQcmVzZW50ID0gdHJ1ZTtcblx0XHRcdGZvciAodmFyIGogPSAwOyBqIDwgdGVtcGxhdGUudmFyTmFtZXMubGVuZ3RoOyBqKyspIHtcblx0XHRcdFx0aWYgKCEodGVtcGxhdGUudmFyTmFtZXNbal0gaW4gZGF0YSkpIHtcblx0XHRcdFx0XHRhbGxQcmVzZW50ID0gZmFsc2U7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGlmIChhbGxQcmVzZW50KSB7XG5cdFx0XHRcdHZhciBzY2hlbWFVcmwgPSB0ZW1wbGF0ZS5maWxsRnJvbU9iamVjdChkYXRhKTtcblx0XHRcdFx0dmFyIHN1YlNjaGVtYSA9IHtcIiRyZWZcIjogc2NoZW1hVXJsfTtcblx0XHRcdFx0aWYgKGVycm9yID0gdGhpcy52YWxpZGF0ZUFsbChkYXRhLCBzdWJTY2hlbWEsIFtdLCBbXCJsaW5rc1wiLCBpXSwgZGF0YVBvaW50ZXJQYXRoKSkge1xuXHRcdFx0XHRcdHJldHVybiBlcnJvcjtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxufTtcblxuLy8gcGFyc2VVUkkoKSBhbmQgcmVzb2x2ZVVybCgpIGFyZSBmcm9tIGh0dHBzOi8vZ2lzdC5naXRodWIuY29tLzEwODg4NTBcbi8vICAgLSAgcmVsZWFzZWQgYXMgcHVibGljIGRvbWFpbiBieSBhdXRob3IgKFwiWWFmZmxlXCIpIC0gc2VlIGNvbW1lbnRzIG9uIGdpc3RcblxuZnVuY3Rpb24gcGFyc2VVUkkodXJsKSB7XG5cdHZhciBtID0gU3RyaW5nKHVybCkucmVwbGFjZSgvXlxccyt8XFxzKyQvZywgJycpLm1hdGNoKC9eKFteOlxcLz8jXSs6KT8oXFwvXFwvKD86W146QF0qKD86OlteOkBdKik/QCk/KChbXjpcXC8/I10qKSg/OjooXFxkKikpPykpPyhbXj8jXSopKFxcP1teI10qKT8oI1tcXHNcXFNdKik/Lyk7XG5cdC8vIGF1dGhvcml0eSA9ICcvLycgKyB1c2VyICsgJzonICsgcGFzcyAnQCcgKyBob3N0bmFtZSArICc6JyBwb3J0XG5cdHJldHVybiAobSA/IHtcblx0XHRocmVmICAgICA6IG1bMF0gfHwgJycsXG5cdFx0cHJvdG9jb2wgOiBtWzFdIHx8ICcnLFxuXHRcdGF1dGhvcml0eTogbVsyXSB8fCAnJyxcblx0XHRob3N0ICAgICA6IG1bM10gfHwgJycsXG5cdFx0aG9zdG5hbWUgOiBtWzRdIHx8ICcnLFxuXHRcdHBvcnQgICAgIDogbVs1XSB8fCAnJyxcblx0XHRwYXRobmFtZSA6IG1bNl0gfHwgJycsXG5cdFx0c2VhcmNoICAgOiBtWzddIHx8ICcnLFxuXHRcdGhhc2ggICAgIDogbVs4XSB8fCAnJ1xuXHR9IDogbnVsbCk7XG59XG5cbmZ1bmN0aW9uIHJlc29sdmVVcmwoYmFzZSwgaHJlZikgey8vIFJGQyAzOTg2XG5cblx0ZnVuY3Rpb24gcmVtb3ZlRG90U2VnbWVudHMoaW5wdXQpIHtcblx0XHR2YXIgb3V0cHV0ID0gW107XG5cdFx0aW5wdXQucmVwbGFjZSgvXihcXC5cXC4/KFxcL3wkKSkrLywgJycpXG5cdFx0XHQucmVwbGFjZSgvXFwvKFxcLihcXC98JCkpKy9nLCAnLycpXG5cdFx0XHQucmVwbGFjZSgvXFwvXFwuXFwuJC8sICcvLi4vJylcblx0XHRcdC5yZXBsYWNlKC9cXC8/W15cXC9dKi9nLCBmdW5jdGlvbiAocCkge1xuXHRcdFx0XHRpZiAocCA9PT0gJy8uLicpIHtcblx0XHRcdFx0XHRvdXRwdXQucG9wKCk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0b3V0cHV0LnB1c2gocCk7XG5cdFx0XHRcdH1cblx0XHR9KTtcblx0XHRyZXR1cm4gb3V0cHV0LmpvaW4oJycpLnJlcGxhY2UoL15cXC8vLCBpbnB1dC5jaGFyQXQoMCkgPT09ICcvJyA/ICcvJyA6ICcnKTtcblx0fVxuXG5cdGhyZWYgPSBwYXJzZVVSSShocmVmIHx8ICcnKTtcblx0YmFzZSA9IHBhcnNlVVJJKGJhc2UgfHwgJycpO1xuXG5cdHJldHVybiAhaHJlZiB8fCAhYmFzZSA/IG51bGwgOiAoaHJlZi5wcm90b2NvbCB8fCBiYXNlLnByb3RvY29sKSArXG5cdFx0KGhyZWYucHJvdG9jb2wgfHwgaHJlZi5hdXRob3JpdHkgPyBocmVmLmF1dGhvcml0eSA6IGJhc2UuYXV0aG9yaXR5KSArXG5cdFx0cmVtb3ZlRG90U2VnbWVudHMoaHJlZi5wcm90b2NvbCB8fCBocmVmLmF1dGhvcml0eSB8fCBocmVmLnBhdGhuYW1lLmNoYXJBdCgwKSA9PT0gJy8nID8gaHJlZi5wYXRobmFtZSA6IChocmVmLnBhdGhuYW1lID8gKChiYXNlLmF1dGhvcml0eSAmJiAhYmFzZS5wYXRobmFtZSA/ICcvJyA6ICcnKSArIGJhc2UucGF0aG5hbWUuc2xpY2UoMCwgYmFzZS5wYXRobmFtZS5sYXN0SW5kZXhPZignLycpICsgMSkgKyBocmVmLnBhdGhuYW1lKSA6IGJhc2UucGF0aG5hbWUpKSArXG5cdFx0KGhyZWYucHJvdG9jb2wgfHwgaHJlZi5hdXRob3JpdHkgfHwgaHJlZi5wYXRobmFtZSA/IGhyZWYuc2VhcmNoIDogKGhyZWYuc2VhcmNoIHx8IGJhc2Uuc2VhcmNoKSkgK1xuXHRcdGhyZWYuaGFzaDtcbn1cblxuZnVuY3Rpb24gZ2V0RG9jdW1lbnRVcmkodXJpKSB7XG5cdHJldHVybiB1cmkuc3BsaXQoJyMnKVswXTtcbn1cbmZ1bmN0aW9uIG5vcm1TY2hlbWEoc2NoZW1hLCBiYXNlVXJpKSB7XG5cdGlmIChzY2hlbWEgJiYgdHlwZW9mIHNjaGVtYSA9PT0gXCJvYmplY3RcIikge1xuXHRcdGlmIChiYXNlVXJpID09PSB1bmRlZmluZWQpIHtcblx0XHRcdGJhc2VVcmkgPSBzY2hlbWEuaWQ7XG5cdFx0fSBlbHNlIGlmICh0eXBlb2Ygc2NoZW1hLmlkID09PSBcInN0cmluZ1wiKSB7XG5cdFx0XHRiYXNlVXJpID0gcmVzb2x2ZVVybChiYXNlVXJpLCBzY2hlbWEuaWQpO1xuXHRcdFx0c2NoZW1hLmlkID0gYmFzZVVyaTtcblx0XHR9XG5cdFx0aWYgKEFycmF5LmlzQXJyYXkoc2NoZW1hKSkge1xuXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBzY2hlbWEubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0bm9ybVNjaGVtYShzY2hlbWFbaV0sIGJhc2VVcmkpO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRpZiAodHlwZW9mIHNjaGVtYVsnJHJlZiddID09PSBcInN0cmluZ1wiKSB7XG5cdFx0XHRcdHNjaGVtYVsnJHJlZiddID0gcmVzb2x2ZVVybChiYXNlVXJpLCBzY2hlbWFbJyRyZWYnXSk7XG5cdFx0XHR9XG5cdFx0XHRmb3IgKHZhciBrZXkgaW4gc2NoZW1hKSB7XG5cdFx0XHRcdGlmIChrZXkgIT09IFwiZW51bVwiKSB7XG5cdFx0XHRcdFx0bm9ybVNjaGVtYShzY2hlbWFba2V5XSwgYmFzZVVyaSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cbn1cblxuZnVuY3Rpb24gZGVmYXVsdEVycm9yUmVwb3J0ZXIobGFuZ3VhZ2UpIHtcblx0bGFuZ3VhZ2UgPSBsYW5ndWFnZSB8fCAnZW4nO1xuXG5cdHZhciBlcnJvck1lc3NhZ2VzID0gbGFuZ3VhZ2VzW2xhbmd1YWdlXTtcblxuXHRyZXR1cm4gZnVuY3Rpb24gKGVycm9yKSB7XG5cdFx0dmFyIG1lc3NhZ2VUZW1wbGF0ZSA9IGVycm9yTWVzc2FnZXNbZXJyb3IuY29kZV0gfHwgRXJyb3JNZXNzYWdlc0RlZmF1bHRbZXJyb3IuY29kZV07XG5cdFx0aWYgKHR5cGVvZiBtZXNzYWdlVGVtcGxhdGUgIT09ICdzdHJpbmcnKSB7XG5cdFx0XHRyZXR1cm4gXCJVbmtub3duIGVycm9yIGNvZGUgXCIgKyBlcnJvci5jb2RlICsgXCI6IFwiICsgSlNPTi5zdHJpbmdpZnkoZXJyb3IubWVzc2FnZVBhcmFtcyk7XG5cdFx0fVxuXHRcdHZhciBtZXNzYWdlUGFyYW1zID0gZXJyb3IucGFyYW1zO1xuXHRcdC8vIEFkYXB0ZWQgZnJvbSBDcm9ja2ZvcmQncyBzdXBwbGFudCgpXG5cdFx0cmV0dXJuIG1lc3NhZ2VUZW1wbGF0ZS5yZXBsYWNlKC9cXHsoW157fV0qKVxcfS9nLCBmdW5jdGlvbiAod2hvbGUsIHZhck5hbWUpIHtcblx0XHRcdHZhciBzdWJWYWx1ZSA9IG1lc3NhZ2VQYXJhbXNbdmFyTmFtZV07XG5cdFx0XHRyZXR1cm4gdHlwZW9mIHN1YlZhbHVlID09PSAnc3RyaW5nJyB8fCB0eXBlb2Ygc3ViVmFsdWUgPT09ICdudW1iZXInID8gc3ViVmFsdWUgOiB3aG9sZTtcblx0XHR9KTtcblx0fTtcbn1cblxudmFyIEVycm9yQ29kZXMgPSB7XG5cdElOVkFMSURfVFlQRTogMCxcblx0RU5VTV9NSVNNQVRDSDogMSxcblx0QU5ZX09GX01JU1NJTkc6IDEwLFxuXHRPTkVfT0ZfTUlTU0lORzogMTEsXG5cdE9ORV9PRl9NVUxUSVBMRTogMTIsXG5cdE5PVF9QQVNTRUQ6IDEzLFxuXHQvLyBOdW1lcmljIGVycm9yc1xuXHROVU1CRVJfTVVMVElQTEVfT0Y6IDEwMCxcblx0TlVNQkVSX01JTklNVU06IDEwMSxcblx0TlVNQkVSX01JTklNVU1fRVhDTFVTSVZFOiAxMDIsXG5cdE5VTUJFUl9NQVhJTVVNOiAxMDMsXG5cdE5VTUJFUl9NQVhJTVVNX0VYQ0xVU0lWRTogMTA0LFxuXHROVU1CRVJfTk9UX0FfTlVNQkVSOiAxMDUsXG5cdC8vIFN0cmluZyBlcnJvcnNcblx0U1RSSU5HX0xFTkdUSF9TSE9SVDogMjAwLFxuXHRTVFJJTkdfTEVOR1RIX0xPTkc6IDIwMSxcblx0U1RSSU5HX1BBVFRFUk46IDIwMixcblx0Ly8gT2JqZWN0IGVycm9yc1xuXHRPQkpFQ1RfUFJPUEVSVElFU19NSU5JTVVNOiAzMDAsXG5cdE9CSkVDVF9QUk9QRVJUSUVTX01BWElNVU06IDMwMSxcblx0T0JKRUNUX1JFUVVJUkVEOiAzMDIsXG5cdE9CSkVDVF9BRERJVElPTkFMX1BST1BFUlRJRVM6IDMwMyxcblx0T0JKRUNUX0RFUEVOREVOQ1lfS0VZOiAzMDQsXG5cdC8vIEFycmF5IGVycm9yc1xuXHRBUlJBWV9MRU5HVEhfU0hPUlQ6IDQwMCxcblx0QVJSQVlfTEVOR1RIX0xPTkc6IDQwMSxcblx0QVJSQVlfVU5JUVVFOiA0MDIsXG5cdEFSUkFZX0FERElUSU9OQUxfSVRFTVM6IDQwMyxcblx0Ly8gQ3VzdG9tL3VzZXItZGVmaW5lZCBlcnJvcnNcblx0Rk9STUFUX0NVU1RPTTogNTAwLFxuXHRLRVlXT1JEX0NVU1RPTTogNTAxLFxuXHQvLyBTY2hlbWEgc3RydWN0dXJlXG5cdENJUkNVTEFSX1JFRkVSRU5DRTogNjAwLFxuXHQvLyBOb24tc3RhbmRhcmQgdmFsaWRhdGlvbiBvcHRpb25zXG5cdFVOS05PV05fUFJPUEVSVFk6IDEwMDBcbn07XG52YXIgRXJyb3JDb2RlTG9va3VwID0ge307XG5mb3IgKHZhciBrZXkgaW4gRXJyb3JDb2Rlcykge1xuXHRFcnJvckNvZGVMb29rdXBbRXJyb3JDb2Rlc1trZXldXSA9IGtleTtcbn1cbnZhciBFcnJvck1lc3NhZ2VzRGVmYXVsdCA9IHtcblx0SU5WQUxJRF9UWVBFOiBcIkludmFsaWQgdHlwZToge3R5cGV9IChleHBlY3RlZCB7ZXhwZWN0ZWR9KVwiLFxuXHRFTlVNX01JU01BVENIOiBcIk5vIGVudW0gbWF0Y2ggZm9yOiB7dmFsdWV9XCIsXG5cdEFOWV9PRl9NSVNTSU5HOiBcIkRhdGEgZG9lcyBub3QgbWF0Y2ggYW55IHNjaGVtYXMgZnJvbSBcXFwiYW55T2ZcXFwiXCIsXG5cdE9ORV9PRl9NSVNTSU5HOiBcIkRhdGEgZG9lcyBub3QgbWF0Y2ggYW55IHNjaGVtYXMgZnJvbSBcXFwib25lT2ZcXFwiXCIsXG5cdE9ORV9PRl9NVUxUSVBMRTogXCJEYXRhIGlzIHZhbGlkIGFnYWluc3QgbW9yZSB0aGFuIG9uZSBzY2hlbWEgZnJvbSBcXFwib25lT2ZcXFwiOiBpbmRpY2VzIHtpbmRleDF9IGFuZCB7aW5kZXgyfVwiLFxuXHROT1RfUEFTU0VEOiBcIkRhdGEgbWF0Y2hlcyBzY2hlbWEgZnJvbSBcXFwibm90XFxcIlwiLFxuXHQvLyBOdW1lcmljIGVycm9yc1xuXHROVU1CRVJfTVVMVElQTEVfT0Y6IFwiVmFsdWUge3ZhbHVlfSBpcyBub3QgYSBtdWx0aXBsZSBvZiB7bXVsdGlwbGVPZn1cIixcblx0TlVNQkVSX01JTklNVU06IFwiVmFsdWUge3ZhbHVlfSBpcyBsZXNzIHRoYW4gbWluaW11bSB7bWluaW11bX1cIixcblx0TlVNQkVSX01JTklNVU1fRVhDTFVTSVZFOiBcIlZhbHVlIHt2YWx1ZX0gaXMgZXF1YWwgdG8gZXhjbHVzaXZlIG1pbmltdW0ge21pbmltdW19XCIsXG5cdE5VTUJFUl9NQVhJTVVNOiBcIlZhbHVlIHt2YWx1ZX0gaXMgZ3JlYXRlciB0aGFuIG1heGltdW0ge21heGltdW19XCIsXG5cdE5VTUJFUl9NQVhJTVVNX0VYQ0xVU0lWRTogXCJWYWx1ZSB7dmFsdWV9IGlzIGVxdWFsIHRvIGV4Y2x1c2l2ZSBtYXhpbXVtIHttYXhpbXVtfVwiLFxuXHROVU1CRVJfTk9UX0FfTlVNQkVSOiBcIlZhbHVlIHt2YWx1ZX0gaXMgbm90IGEgdmFsaWQgbnVtYmVyXCIsXG5cdC8vIFN0cmluZyBlcnJvcnNcblx0U1RSSU5HX0xFTkdUSF9TSE9SVDogXCJTdHJpbmcgaXMgdG9vIHNob3J0ICh7bGVuZ3RofSBjaGFycyksIG1pbmltdW0ge21pbmltdW19XCIsXG5cdFNUUklOR19MRU5HVEhfTE9ORzogXCJTdHJpbmcgaXMgdG9vIGxvbmcgKHtsZW5ndGh9IGNoYXJzKSwgbWF4aW11bSB7bWF4aW11bX1cIixcblx0U1RSSU5HX1BBVFRFUk46IFwiU3RyaW5nIGRvZXMgbm90IG1hdGNoIHBhdHRlcm46IHtwYXR0ZXJufVwiLFxuXHQvLyBPYmplY3QgZXJyb3JzXG5cdE9CSkVDVF9QUk9QRVJUSUVTX01JTklNVU06IFwiVG9vIGZldyBwcm9wZXJ0aWVzIGRlZmluZWQgKHtwcm9wZXJ0eUNvdW50fSksIG1pbmltdW0ge21pbmltdW19XCIsXG5cdE9CSkVDVF9QUk9QRVJUSUVTX01BWElNVU06IFwiVG9vIG1hbnkgcHJvcGVydGllcyBkZWZpbmVkICh7cHJvcGVydHlDb3VudH0pLCBtYXhpbXVtIHttYXhpbXVtfVwiLFxuXHRPQkpFQ1RfUkVRVUlSRUQ6IFwiTWlzc2luZyByZXF1aXJlZCBwcm9wZXJ0eToge2tleX1cIixcblx0T0JKRUNUX0FERElUSU9OQUxfUFJPUEVSVElFUzogXCJBZGRpdGlvbmFsIHByb3BlcnRpZXMgbm90IGFsbG93ZWRcIixcblx0T0JKRUNUX0RFUEVOREVOQ1lfS0VZOiBcIkRlcGVuZGVuY3kgZmFpbGVkIC0ga2V5IG11c3QgZXhpc3Q6IHttaXNzaW5nfSAoZHVlIHRvIGtleToge2tleX0pXCIsXG5cdC8vIEFycmF5IGVycm9yc1xuXHRBUlJBWV9MRU5HVEhfU0hPUlQ6IFwiQXJyYXkgaXMgdG9vIHNob3J0ICh7bGVuZ3RofSksIG1pbmltdW0ge21pbmltdW19XCIsXG5cdEFSUkFZX0xFTkdUSF9MT05HOiBcIkFycmF5IGlzIHRvbyBsb25nICh7bGVuZ3RofSksIG1heGltdW0ge21heGltdW19XCIsXG5cdEFSUkFZX1VOSVFVRTogXCJBcnJheSBpdGVtcyBhcmUgbm90IHVuaXF1ZSAoaW5kaWNlcyB7bWF0Y2gxfSBhbmQge21hdGNoMn0pXCIsXG5cdEFSUkFZX0FERElUSU9OQUxfSVRFTVM6IFwiQWRkaXRpb25hbCBpdGVtcyBub3QgYWxsb3dlZFwiLFxuXHQvLyBGb3JtYXQgZXJyb3JzXG5cdEZPUk1BVF9DVVNUT006IFwiRm9ybWF0IHZhbGlkYXRpb24gZmFpbGVkICh7bWVzc2FnZX0pXCIsXG5cdEtFWVdPUkRfQ1VTVE9NOiBcIktleXdvcmQgZmFpbGVkOiB7a2V5fSAoe21lc3NhZ2V9KVwiLFxuXHQvLyBTY2hlbWEgc3RydWN0dXJlXG5cdENJUkNVTEFSX1JFRkVSRU5DRTogXCJDaXJjdWxhciAkcmVmczoge3VybHN9XCIsXG5cdC8vIE5vbi1zdGFuZGFyZCB2YWxpZGF0aW9uIG9wdGlvbnNcblx0VU5LTk9XTl9QUk9QRVJUWTogXCJVbmtub3duIHByb3BlcnR5IChub3QgaW4gc2NoZW1hKVwiXG59O1xuXG5mdW5jdGlvbiBWYWxpZGF0aW9uRXJyb3IoY29kZSwgcGFyYW1zLCBkYXRhUGF0aCwgc2NoZW1hUGF0aCwgc3ViRXJyb3JzKSB7XG5cdEVycm9yLmNhbGwodGhpcyk7XG5cdGlmIChjb2RlID09PSB1bmRlZmluZWQpIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IgKFwiTm8gZXJyb3IgY29kZSBzdXBwbGllZDogXCIgKyBzY2hlbWFQYXRoKTtcblx0fVxuXHR0aGlzLm1lc3NhZ2UgPSAnJztcblx0dGhpcy5wYXJhbXMgPSBwYXJhbXM7XG5cdHRoaXMuY29kZSA9IGNvZGU7XG5cdHRoaXMuZGF0YVBhdGggPSBkYXRhUGF0aCB8fCBcIlwiO1xuXHR0aGlzLnNjaGVtYVBhdGggPSBzY2hlbWFQYXRoIHx8IFwiXCI7XG5cdHRoaXMuc3ViRXJyb3JzID0gc3ViRXJyb3JzIHx8IG51bGw7XG5cblx0dmFyIGVyciA9IG5ldyBFcnJvcih0aGlzLm1lc3NhZ2UpO1xuXHR0aGlzLnN0YWNrID0gZXJyLnN0YWNrIHx8IGVyci5zdGFja3RyYWNlO1xuXHRpZiAoIXRoaXMuc3RhY2spIHtcblx0XHR0cnkge1xuXHRcdFx0dGhyb3cgZXJyO1xuXHRcdH1cblx0XHRjYXRjaChlcnIpIHtcblx0XHRcdHRoaXMuc3RhY2sgPSBlcnIuc3RhY2sgfHwgZXJyLnN0YWNrdHJhY2U7XG5cdFx0fVxuXHR9XG59XG5WYWxpZGF0aW9uRXJyb3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShFcnJvci5wcm90b3R5cGUpO1xuVmFsaWRhdGlvbkVycm9yLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFZhbGlkYXRpb25FcnJvcjtcblZhbGlkYXRpb25FcnJvci5wcm90b3R5cGUubmFtZSA9ICdWYWxpZGF0aW9uRXJyb3InO1xuXG5WYWxpZGF0aW9uRXJyb3IucHJvdG90eXBlLnByZWZpeFdpdGggPSBmdW5jdGlvbiAoZGF0YVByZWZpeCwgc2NoZW1hUHJlZml4KSB7XG5cdGlmIChkYXRhUHJlZml4ICE9PSBudWxsKSB7XG5cdFx0ZGF0YVByZWZpeCA9IGRhdGFQcmVmaXgucmVwbGFjZSgvfi9nLCBcIn4wXCIpLnJlcGxhY2UoL1xcLy9nLCBcIn4xXCIpO1xuXHRcdHRoaXMuZGF0YVBhdGggPSBcIi9cIiArIGRhdGFQcmVmaXggKyB0aGlzLmRhdGFQYXRoO1xuXHR9XG5cdGlmIChzY2hlbWFQcmVmaXggIT09IG51bGwpIHtcblx0XHRzY2hlbWFQcmVmaXggPSBzY2hlbWFQcmVmaXgucmVwbGFjZSgvfi9nLCBcIn4wXCIpLnJlcGxhY2UoL1xcLy9nLCBcIn4xXCIpO1xuXHRcdHRoaXMuc2NoZW1hUGF0aCA9IFwiL1wiICsgc2NoZW1hUHJlZml4ICsgdGhpcy5zY2hlbWFQYXRoO1xuXHR9XG5cdGlmICh0aGlzLnN1YkVycm9ycyAhPT0gbnVsbCkge1xuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5zdWJFcnJvcnMubGVuZ3RoOyBpKyspIHtcblx0XHRcdHRoaXMuc3ViRXJyb3JzW2ldLnByZWZpeFdpdGgoZGF0YVByZWZpeCwgc2NoZW1hUHJlZml4KTtcblx0XHR9XG5cdH1cblx0cmV0dXJuIHRoaXM7XG59O1xuXG5mdW5jdGlvbiBpc1RydXN0ZWRVcmwoYmFzZVVybCwgdGVzdFVybCkge1xuXHRpZih0ZXN0VXJsLnN1YnN0cmluZygwLCBiYXNlVXJsLmxlbmd0aCkgPT09IGJhc2VVcmwpe1xuXHRcdHZhciByZW1haW5kZXIgPSB0ZXN0VXJsLnN1YnN0cmluZyhiYXNlVXJsLmxlbmd0aCk7XG5cdFx0aWYgKCh0ZXN0VXJsLmxlbmd0aCA+IDAgJiYgdGVzdFVybC5jaGFyQXQoYmFzZVVybC5sZW5ndGggLSAxKSA9PT0gXCIvXCIpXG5cdFx0XHR8fCByZW1haW5kZXIuY2hhckF0KDApID09PSBcIiNcIlxuXHRcdFx0fHwgcmVtYWluZGVyLmNoYXJBdCgwKSA9PT0gXCI/XCIpIHtcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblx0fVxuXHRyZXR1cm4gZmFsc2U7XG59XG5cbnZhciBsYW5ndWFnZXMgPSB7fTtcbmZ1bmN0aW9uIGNyZWF0ZUFwaShsYW5ndWFnZSkge1xuXHR2YXIgZ2xvYmFsQ29udGV4dCA9IG5ldyBWYWxpZGF0b3JDb250ZXh0KCk7XG5cdHZhciBjdXJyZW50TGFuZ3VhZ2U7XG5cdHZhciBjdXN0b21FcnJvclJlcG9ydGVyO1xuXHR2YXIgYXBpID0ge1xuXHRcdHNldEVycm9yUmVwb3J0ZXI6IGZ1bmN0aW9uIChyZXBvcnRlcikge1xuXHRcdFx0aWYgKHR5cGVvZiByZXBvcnRlciA9PT0gJ3N0cmluZycpIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMubGFuZ3VhZ2UocmVwb3J0ZXIpO1xuXHRcdFx0fVxuXHRcdFx0Y3VzdG9tRXJyb3JSZXBvcnRlciA9IHJlcG9ydGVyO1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fSxcblx0XHRhZGRGb3JtYXQ6IGZ1bmN0aW9uICgpIHtcblx0XHRcdGdsb2JhbENvbnRleHQuYWRkRm9ybWF0LmFwcGx5KGdsb2JhbENvbnRleHQsIGFyZ3VtZW50cyk7XG5cdFx0fSxcblx0XHRsYW5ndWFnZTogZnVuY3Rpb24gKGNvZGUpIHtcblx0XHRcdGlmICghY29kZSkge1xuXHRcdFx0XHRyZXR1cm4gY3VycmVudExhbmd1YWdlO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCFsYW5ndWFnZXNbY29kZV0pIHtcblx0XHRcdFx0Y29kZSA9IGNvZGUuc3BsaXQoJy0nKVswXTsgLy8gZmFsbCBiYWNrIHRvIGJhc2UgbGFuZ3VhZ2Vcblx0XHRcdH1cblx0XHRcdGlmIChsYW5ndWFnZXNbY29kZV0pIHtcblx0XHRcdFx0Y3VycmVudExhbmd1YWdlID0gY29kZTtcblx0XHRcdFx0cmV0dXJuIGNvZGU7IC8vIHNvIHlvdSBjYW4gdGVsbCBpZiBmYWxsLWJhY2sgaGFzIGhhcHBlbmVkXG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fSxcblx0XHRhZGRMYW5ndWFnZTogZnVuY3Rpb24gKGNvZGUsIG1lc3NhZ2VNYXApIHtcblx0XHRcdHZhciBrZXk7XG5cdFx0XHRmb3IgKGtleSBpbiBFcnJvckNvZGVzKSB7XG5cdFx0XHRcdGlmIChtZXNzYWdlTWFwW2tleV0gJiYgIW1lc3NhZ2VNYXBbRXJyb3JDb2Rlc1trZXldXSkge1xuXHRcdFx0XHRcdG1lc3NhZ2VNYXBbRXJyb3JDb2Rlc1trZXldXSA9IG1lc3NhZ2VNYXBba2V5XTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0dmFyIHJvb3RDb2RlID0gY29kZS5zcGxpdCgnLScpWzBdO1xuXHRcdFx0aWYgKCFsYW5ndWFnZXNbcm9vdENvZGVdKSB7IC8vIHVzZSBmb3IgYmFzZSBsYW5ndWFnZSBpZiBub3QgeWV0IGRlZmluZWRcblx0XHRcdFx0bGFuZ3VhZ2VzW2NvZGVdID0gbWVzc2FnZU1hcDtcblx0XHRcdFx0bGFuZ3VhZ2VzW3Jvb3RDb2RlXSA9IG1lc3NhZ2VNYXA7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRsYW5ndWFnZXNbY29kZV0gPSBPYmplY3QuY3JlYXRlKGxhbmd1YWdlc1tyb290Q29kZV0pO1xuXHRcdFx0XHRmb3IgKGtleSBpbiBtZXNzYWdlTWFwKSB7XG5cdFx0XHRcdFx0aWYgKHR5cGVvZiBsYW5ndWFnZXNbcm9vdENvZGVdW2tleV0gPT09ICd1bmRlZmluZWQnKSB7XG5cdFx0XHRcdFx0XHRsYW5ndWFnZXNbcm9vdENvZGVdW2tleV0gPSBtZXNzYWdlTWFwW2tleV07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGxhbmd1YWdlc1tjb2RlXVtrZXldID0gbWVzc2FnZU1hcFtrZXldO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9LFxuXHRcdGZyZXNoQXBpOiBmdW5jdGlvbiAobGFuZ3VhZ2UpIHtcblx0XHRcdHZhciByZXN1bHQgPSBjcmVhdGVBcGkoKTtcblx0XHRcdGlmIChsYW5ndWFnZSkge1xuXHRcdFx0XHRyZXN1bHQubGFuZ3VhZ2UobGFuZ3VhZ2UpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHJlc3VsdDtcblx0XHR9LFxuXHRcdHZhbGlkYXRlOiBmdW5jdGlvbiAoZGF0YSwgc2NoZW1hLCBjaGVja1JlY3Vyc2l2ZSwgYmFuVW5rbm93blByb3BlcnRpZXMpIHtcblx0XHRcdHZhciBkZWYgPSBkZWZhdWx0RXJyb3JSZXBvcnRlcihjdXJyZW50TGFuZ3VhZ2UpO1xuXHRcdFx0dmFyIGVycm9yUmVwb3J0ZXIgPSBjdXN0b21FcnJvclJlcG9ydGVyID8gZnVuY3Rpb24gKGVycm9yLCBkYXRhLCBzY2hlbWEpIHtcblx0XHRcdFx0cmV0dXJuIGN1c3RvbUVycm9yUmVwb3J0ZXIoZXJyb3IsIGRhdGEsIHNjaGVtYSkgfHwgZGVmKGVycm9yLCBkYXRhLCBzY2hlbWEpO1xuXHRcdFx0fSA6IGRlZjtcblx0XHRcdHZhciBjb250ZXh0ID0gbmV3IFZhbGlkYXRvckNvbnRleHQoZ2xvYmFsQ29udGV4dCwgZmFsc2UsIGVycm9yUmVwb3J0ZXIsIGNoZWNrUmVjdXJzaXZlLCBiYW5Vbmtub3duUHJvcGVydGllcyk7XG5cdFx0XHRpZiAodHlwZW9mIHNjaGVtYSA9PT0gXCJzdHJpbmdcIikge1xuXHRcdFx0XHRzY2hlbWEgPSB7XCIkcmVmXCI6IHNjaGVtYX07XG5cdFx0XHR9XG5cdFx0XHRjb250ZXh0LmFkZFNjaGVtYShcIlwiLCBzY2hlbWEpO1xuXHRcdFx0dmFyIGVycm9yID0gY29udGV4dC52YWxpZGF0ZUFsbChkYXRhLCBzY2hlbWEsIG51bGwsIG51bGwsIFwiXCIpO1xuXHRcdFx0aWYgKCFlcnJvciAmJiBiYW5Vbmtub3duUHJvcGVydGllcykge1xuXHRcdFx0XHRlcnJvciA9IGNvbnRleHQuYmFuVW5rbm93blByb3BlcnRpZXMoZGF0YSwgc2NoZW1hKTtcblx0XHRcdH1cblx0XHRcdHRoaXMuZXJyb3IgPSBlcnJvcjtcblx0XHRcdHRoaXMubWlzc2luZyA9IGNvbnRleHQubWlzc2luZztcblx0XHRcdHRoaXMudmFsaWQgPSAoZXJyb3IgPT09IG51bGwpO1xuXHRcdFx0cmV0dXJuIHRoaXMudmFsaWQ7XG5cdFx0fSxcblx0XHR2YWxpZGF0ZVJlc3VsdDogZnVuY3Rpb24gKCkge1xuXHRcdFx0dmFyIHJlc3VsdCA9IHt9O1xuXHRcdFx0dGhpcy52YWxpZGF0ZS5hcHBseShyZXN1bHQsIGFyZ3VtZW50cyk7XG5cdFx0XHRyZXR1cm4gcmVzdWx0O1xuXHRcdH0sXG5cdFx0dmFsaWRhdGVNdWx0aXBsZTogZnVuY3Rpb24gKGRhdGEsIHNjaGVtYSwgY2hlY2tSZWN1cnNpdmUsIGJhblVua25vd25Qcm9wZXJ0aWVzKSB7XG5cdFx0XHR2YXIgZGVmID0gZGVmYXVsdEVycm9yUmVwb3J0ZXIoY3VycmVudExhbmd1YWdlKTtcblx0XHRcdHZhciBlcnJvclJlcG9ydGVyID0gY3VzdG9tRXJyb3JSZXBvcnRlciA/IGZ1bmN0aW9uIChlcnJvciwgZGF0YSwgc2NoZW1hKSB7XG5cdFx0XHRcdHJldHVybiBjdXN0b21FcnJvclJlcG9ydGVyKGVycm9yLCBkYXRhLCBzY2hlbWEpIHx8IGRlZihlcnJvciwgZGF0YSwgc2NoZW1hKTtcblx0XHRcdH0gOiBkZWY7XG5cdFx0XHR2YXIgY29udGV4dCA9IG5ldyBWYWxpZGF0b3JDb250ZXh0KGdsb2JhbENvbnRleHQsIHRydWUsIGVycm9yUmVwb3J0ZXIsIGNoZWNrUmVjdXJzaXZlLCBiYW5Vbmtub3duUHJvcGVydGllcyk7XG5cdFx0XHRpZiAodHlwZW9mIHNjaGVtYSA9PT0gXCJzdHJpbmdcIikge1xuXHRcdFx0XHRzY2hlbWEgPSB7XCIkcmVmXCI6IHNjaGVtYX07XG5cdFx0XHR9XG5cdFx0XHRjb250ZXh0LmFkZFNjaGVtYShcIlwiLCBzY2hlbWEpO1xuXHRcdFx0Y29udGV4dC52YWxpZGF0ZUFsbChkYXRhLCBzY2hlbWEsIG51bGwsIG51bGwsIFwiXCIpO1xuXHRcdFx0aWYgKGJhblVua25vd25Qcm9wZXJ0aWVzKSB7XG5cdFx0XHRcdGNvbnRleHQuYmFuVW5rbm93blByb3BlcnRpZXMoZGF0YSwgc2NoZW1hKTtcblx0XHRcdH1cblx0XHRcdHZhciByZXN1bHQgPSB7fTtcblx0XHRcdHJlc3VsdC5lcnJvcnMgPSBjb250ZXh0LmVycm9ycztcblx0XHRcdHJlc3VsdC5taXNzaW5nID0gY29udGV4dC5taXNzaW5nO1xuXHRcdFx0cmVzdWx0LnZhbGlkID0gKHJlc3VsdC5lcnJvcnMubGVuZ3RoID09PSAwKTtcblx0XHRcdHJldHVybiByZXN1bHQ7XG5cdFx0fSxcblx0XHRhZGRTY2hlbWE6IGZ1bmN0aW9uICgpIHtcblx0XHRcdHJldHVybiBnbG9iYWxDb250ZXh0LmFkZFNjaGVtYS5hcHBseShnbG9iYWxDb250ZXh0LCBhcmd1bWVudHMpO1xuXHRcdH0sXG5cdFx0Z2V0U2NoZW1hOiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRyZXR1cm4gZ2xvYmFsQ29udGV4dC5nZXRTY2hlbWEuYXBwbHkoZ2xvYmFsQ29udGV4dCwgYXJndW1lbnRzKTtcblx0XHR9LFxuXHRcdGdldFNjaGVtYU1hcDogZnVuY3Rpb24gKCkge1xuXHRcdFx0cmV0dXJuIGdsb2JhbENvbnRleHQuZ2V0U2NoZW1hTWFwLmFwcGx5KGdsb2JhbENvbnRleHQsIGFyZ3VtZW50cyk7XG5cdFx0fSxcblx0XHRnZXRTY2hlbWFVcmlzOiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRyZXR1cm4gZ2xvYmFsQ29udGV4dC5nZXRTY2hlbWFVcmlzLmFwcGx5KGdsb2JhbENvbnRleHQsIGFyZ3VtZW50cyk7XG5cdFx0fSxcblx0XHRnZXRNaXNzaW5nVXJpczogZnVuY3Rpb24gKCkge1xuXHRcdFx0cmV0dXJuIGdsb2JhbENvbnRleHQuZ2V0TWlzc2luZ1VyaXMuYXBwbHkoZ2xvYmFsQ29udGV4dCwgYXJndW1lbnRzKTtcblx0XHR9LFxuXHRcdGRyb3BTY2hlbWFzOiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRnbG9iYWxDb250ZXh0LmRyb3BTY2hlbWFzLmFwcGx5KGdsb2JhbENvbnRleHQsIGFyZ3VtZW50cyk7XG5cdFx0fSxcblx0XHRkZWZpbmVLZXl3b3JkOiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRnbG9iYWxDb250ZXh0LmRlZmluZUtleXdvcmQuYXBwbHkoZ2xvYmFsQ29udGV4dCwgYXJndW1lbnRzKTtcblx0XHR9LFxuXHRcdGRlZmluZUVycm9yOiBmdW5jdGlvbiAoY29kZU5hbWUsIGNvZGVOdW1iZXIsIGRlZmF1bHRNZXNzYWdlKSB7XG5cdFx0XHRpZiAodHlwZW9mIGNvZGVOYW1lICE9PSAnc3RyaW5nJyB8fCAhL15bQS1aXSsoX1tBLVpdKykqJC8udGVzdChjb2RlTmFtZSkpIHtcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCdDb2RlIG5hbWUgbXVzdCBiZSBhIHN0cmluZyBpbiBVUFBFUl9DQVNFX1dJVEhfVU5ERVJTQ09SRVMnKTtcblx0XHRcdH1cblx0XHRcdGlmICh0eXBlb2YgY29kZU51bWJlciAhPT0gJ251bWJlcicgfHwgY29kZU51bWJlciUxICE9PSAwIHx8IGNvZGVOdW1iZXIgPCAxMDAwMCkge1xuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ0NvZGUgbnVtYmVyIG11c3QgYmUgYW4gaW50ZWdlciA+IDEwMDAwJyk7XG5cdFx0XHR9XG5cdFx0XHRpZiAodHlwZW9mIEVycm9yQ29kZXNbY29kZU5hbWVdICE9PSAndW5kZWZpbmVkJykge1xuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ0Vycm9yIGFscmVhZHkgZGVmaW5lZDogJyArIGNvZGVOYW1lICsgJyBhcyAnICsgRXJyb3JDb2Rlc1tjb2RlTmFtZV0pO1xuXHRcdFx0fVxuXHRcdFx0aWYgKHR5cGVvZiBFcnJvckNvZGVMb29rdXBbY29kZU51bWJlcl0gIT09ICd1bmRlZmluZWQnKSB7XG5cdFx0XHRcdHRocm93IG5ldyBFcnJvcignRXJyb3IgY29kZSBhbHJlYWR5IHVzZWQ6ICcgKyBFcnJvckNvZGVMb29rdXBbY29kZU51bWJlcl0gKyAnIGFzICcgKyBjb2RlTnVtYmVyKTtcblx0XHRcdH1cblx0XHRcdEVycm9yQ29kZXNbY29kZU5hbWVdID0gY29kZU51bWJlcjtcblx0XHRcdEVycm9yQ29kZUxvb2t1cFtjb2RlTnVtYmVyXSA9IGNvZGVOYW1lO1xuXHRcdFx0RXJyb3JNZXNzYWdlc0RlZmF1bHRbY29kZU5hbWVdID0gRXJyb3JNZXNzYWdlc0RlZmF1bHRbY29kZU51bWJlcl0gPSBkZWZhdWx0TWVzc2FnZTtcblx0XHRcdGZvciAodmFyIGxhbmdDb2RlIGluIGxhbmd1YWdlcykge1xuXHRcdFx0XHR2YXIgbGFuZ3VhZ2UgPSBsYW5ndWFnZXNbbGFuZ0NvZGVdO1xuXHRcdFx0XHRpZiAobGFuZ3VhZ2VbY29kZU5hbWVdKSB7XG5cdFx0XHRcdFx0bGFuZ3VhZ2VbY29kZU51bWJlcl0gPSBsYW5ndWFnZVtjb2RlTnVtYmVyXSB8fCBsYW5ndWFnZVtjb2RlTmFtZV07XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9LFxuXHRcdHJlc2V0OiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRnbG9iYWxDb250ZXh0LnJlc2V0KCk7XG5cdFx0XHR0aGlzLmVycm9yID0gbnVsbDtcblx0XHRcdHRoaXMubWlzc2luZyA9IFtdO1xuXHRcdFx0dGhpcy52YWxpZCA9IHRydWU7XG5cdFx0fSxcblx0XHRtaXNzaW5nOiBbXSxcblx0XHRlcnJvcjogbnVsbCxcblx0XHR2YWxpZDogdHJ1ZSxcblx0XHRub3JtU2NoZW1hOiBub3JtU2NoZW1hLFxuXHRcdHJlc29sdmVVcmw6IHJlc29sdmVVcmwsXG5cdFx0Z2V0RG9jdW1lbnRVcmk6IGdldERvY3VtZW50VXJpLFxuXHRcdGVycm9yQ29kZXM6IEVycm9yQ29kZXNcblx0fTtcblx0YXBpLmxhbmd1YWdlKGxhbmd1YWdlIHx8ICdlbicpO1xuXHRyZXR1cm4gYXBpO1xufVxuXG52YXIgdHY0ID0gY3JlYXRlQXBpKCk7XG50djQuYWRkTGFuZ3VhZ2UoJ2VuLWdiJywgRXJyb3JNZXNzYWdlc0RlZmF1bHQpO1xuXG4vL2xlZ2FjeSBwcm9wZXJ0eVxudHY0LnR2NCA9IHR2NDtcblxucmV0dXJuIHR2NDsgLy8gdXNlZCBieSBfaGVhZGVyLmpzIHRvIGdsb2JhbGlzZS5cblxufSkpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi90djQvdHY0LmpzXG4vLyBtb2R1bGUgaWQgPSAxMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9");

/***/ },
/* 12 */
/***/ function(module, exports, __webpack_require__) {

	eval("/* WEBPACK VAR INJECTION */(function(global, Buffer) {'use strict';\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\n// var RemoteStorage = require('./remotestorage');\nvar log = __webpack_require__(4);\nvar util = __webpack_require__(2);\nvar eventHandling = __webpack_require__(3);\nvar Authorize = __webpack_require__(7);\n\n/**\n * Class: RemoteStorage.WireClient\n *\n * WireClient Interface\n * --------------------\n *\n * This file exposes a get/put/delete interface on top of XMLHttpRequest.\n * It requires to be configured with parameters about the remotestorage server to\n * connect to.\n * Each instance of WireClient is always associated with a single remotestorage\n * server and access token.\n *\n * Usually the WireClient instance can be accessed via `remoteStorage.remote`.\n *\n * This is the get/put/delete interface:\n *\n *   - #get() takes a path and optionally a ifNoneMatch option carrying a version\n *     string to check. It returns a promise that will be fulfilled with the HTTP\n *     response status, the response body, the MIME type as returned in the\n *     'Content-Type' header and the current revision, as returned in the 'ETag'\n *     header.\n *   - #put() takes a path, the request body and a content type string. It also\n *     accepts the ifMatch and ifNoneMatch options, that map to the If-Match and\n *     If-None-Match headers respectively. See the remotestorage-01 specification\n *     for details on handling these headers. It returns a promise, fulfilled with\n *     the same values as the one for #get().\n *   - #delete() takes a path and the ifMatch option as well. It returns a promise\n *     fulfilled with the same values as the one for #get().\n *\n * In addition to this, the WireClient has some compatibility features to work with\n * remotestorage 2012.04 compatible storages. For example it will cache revisions\n * from folder listings in-memory and return them accordingly as the \"revision\"\n * parameter in response to #get() requests. Similarly it will return 404 when it\n * receives an empty folder listing, to mimic remotestorage-01 behavior. Note\n * that it is not always possible to know the revision beforehand, hence it may\n * be undefined at times (especially for caching-roots).\n */\n\nvar hasLocalStorage;\nvar SETTINGS_KEY = 'remotestorage:wireclient';\n\nvar API_2012 = 1,\n    API_00 = 2,\n    API_01 = 3,\n    API_02 = 4,\n    API_HEAD = 5;\n\nvar STORAGE_APIS = {\n  'draft-dejong-remotestorage-00': API_00,\n  'draft-dejong-remotestorage-01': API_01,\n  'draft-dejong-remotestorage-02': API_02,\n  'https://www.w3.org/community/rww/wiki/read-write-web-00#simple': API_2012\n};\n\nvar isArrayBufferView;\n\nif (typeof ArrayBufferView === 'function') {\n  isArrayBufferView = function isArrayBufferView(object) {\n    return object && object instanceof ArrayBufferView;\n  };\n} else {\n  var arrayBufferViews = [Int8Array, Uint8Array, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array];\n  isArrayBufferView = function isArrayBufferView(object) {\n    for (var i = 0; i < 8; i++) {\n      if (object instanceof arrayBufferViews[i]) {\n        return true;\n      }\n    }\n    return false;\n  };\n}\n\nvar isFolder = util.isFolder;\nvar cleanPath = util.cleanPath;\n\nfunction addQuotes(str) {\n  if (typeof str !== 'string') {\n    return str;\n  }\n  if (str === '*') {\n    return '*';\n  }\n\n  return '\"' + str + '\"';\n}\n\nfunction stripQuotes(str) {\n  if (typeof str !== 'string') {\n    return str;\n  }\n\n  return str.replace(/^[\"']|[\"']$/g, '');\n}\n\nfunction readBinaryData(content, mimeType, callback) {\n  var blob;\n  util.globalContext.BlobBuilder = util.globalContext.BlobBuilder || util.globalContext.WebKitBlobBuilder;\n  if (typeof util.globalContext.BlobBuilder !== 'undefined') {\n    var bb = new global.BlobBuilder();\n    bb.append(content);\n    blob = bb.getBlob(mimeType);\n  } else {\n    blob = new Blob([content], { type: mimeType });\n  }\n\n  var reader = new FileReader();\n  if (typeof reader.addEventListener === 'function') {\n    reader.addEventListener('loadend', function () {\n      callback(reader.result); // reader.result contains the contents of blob as a typed array\n    });\n  } else {\n    reader.onloadend = function () {\n      callback(reader.result); // reader.result contains the contents of blob as a typed array\n    };\n  }\n  reader.readAsArrayBuffer(blob);\n}\n\nfunction getTextFromArrayBuffer(arrayBuffer, encoding) {\n  var pending = Promise.defer();\n  if (typeof Blob === 'undefined') {\n    var buffer = new Buffer(new Uint8Array(arrayBuffer));\n    pending.resolve(buffer.toString(encoding));\n  } else {\n    var blob;\n    util.globalContext.BlobBuilder = util.globalContext.BlobBuilder || util.globalContext.WebKitBlobBuilder;\n    if (typeof util.globalContext.BlobBuilder !== 'undefined') {\n      var bb = new global.BlobBuilder();\n      bb.append(arrayBuffer);\n      blob = bb.getBlob();\n    } else {\n      blob = new Blob([arrayBuffer]);\n    }\n\n    var fileReader = new FileReader();\n    if (typeof fileReader.addEventListener === 'function') {\n      fileReader.addEventListener('loadend', function (evt) {\n        pending.resolve(evt.target.result);\n      });\n    } else {\n      fileReader.onloadend = function (evt) {\n        pending.resolve(evt.target.result);\n      };\n    }\n    fileReader.readAsText(blob, encoding);\n  }\n  return pending.promise;\n}\n\nfunction determineCharset(mimeType) {\n  var charset = 'UTF-8';\n  var charsetMatch;\n\n  if (mimeType) {\n    charsetMatch = mimeType.match(/charset=(.+)$/);\n    if (charsetMatch) {\n      charset = charsetMatch[1];\n    }\n  }\n  return charset;\n}\n\nfunction isFolderDescription(body) {\n  return body['@context'] === 'http://remotestorage.io/spec/folder-description' && _typeof(body['items']) === 'object';\n}\n\nfunction isSuccessStatus(status) {\n  return [201, 204, 304].indexOf(status) >= 0;\n}\n\nfunction isErrorStatus(status) {\n  return [401, 403, 404, 412].indexOf(status) >= 0;\n}\n\nvar onErrorCb;\n\n/**\n * Class : RemoteStorage.WireClient\n **/\nvar WireClient = function WireClient(rs) {\n  this.rs = rs;\n  this.connected = false;\n\n  /**\n   * Event: change\n   *   Never fired for some reason\n   *   # TODO create issue and fix or remove\n   *\n   * Event: connected\n   *   Fired when the wireclient connect method realizes that it is in\n   *   possession of a token and href\n   **/\n  eventHandling(this, 'change', 'connected', 'not-connected', 'wire-busy', 'wire-done');\n\n  onErrorCb = function (error) {\n    if (error instanceof Authorize.Unauthorized) {\n      this.configure({ token: null });\n    }\n  }.bind(this);\n  rs.on('error', onErrorCb);\n  if (hasLocalStorage) {\n    var settings;\n    try {\n      settings = JSON.parse(localStorage[SETTINGS_KEY]);\n    } catch (e) {}\n    if (settings) {\n      setTimeout(function () {\n        this.configure(settings);\n      }.bind(this), 0);\n    }\n  }\n\n  this._revisionCache = {};\n\n  if (this.connected) {\n    setTimeout(this._emit.bind(this), 0, 'connected');\n  }\n};\n\nWireClient.REQUEST_TIMEOUT = 30000;\n\nWireClient.prototype = {\n  /**\n   * Property: token\n   *\n   * Holds the bearer token of this WireClient, as obtained in the OAuth dance\n   *\n   * Example:\n   *   (start code)\n   *\n   *   remoteStorage.remote.token\n   *   // -> 'DEADBEEF01=='\n   */\n\n  /**\n   * Property: href\n   *\n   * Holds the server's base URL, as obtained in the Webfinger discovery\n   *\n   * Example:\n   *   (start code)\n   *\n   *   remoteStorage.remote.href\n   *   // -> 'https://storage.example.com/users/jblogg/'\n   */\n\n  /**\n   * Property: storageApi\n   *\n   * Holds the spec version the server claims to be compatible with\n   *\n   * Example:\n   *   (start code)\n   *\n   *   remoteStorage.remote.storageApi\n   *   // -> 'draft-dejong-remotestorage-01'\n   */\n\n  _request: function _request(method, uri, token, headers, body, getEtag, fakeRevision) {\n    if ((method === 'PUT' || method === 'DELETE') && uri[uri.length - 1] === '/') {\n      return Promise.reject('Don\\'t ' + method + ' on directories!');\n    }\n\n    var revision;\n    var self = this;\n\n    if (token !== Authorize.IMPLIED_FAKE_TOKEN) {\n      headers['Authorization'] = 'Bearer ' + token;\n    }\n\n    this._emit('wire-busy', {\n      method: method,\n      isFolder: isFolder(uri)\n    });\n\n    return WireClient.request(method, uri, {\n      body: body,\n      headers: headers,\n      responseType: 'arraybuffer'\n    }).then(function (response) {\n      if (!self.online) {\n        self.online = true;\n        self.rs._emit('network-online');\n      }\n      self._emit('wire-done', {\n        method: method,\n        isFolder: isFolder(uri),\n        success: true\n      });\n\n      if (isErrorStatus(response.status)) {\n        log('[WireClient] Error response status', response.status);\n        if (getEtag) {\n          revision = stripQuotes(response.getResponseHeader('ETag'));\n        } else {\n          revision = undefined;\n        }\n        return Promise.resolve({ statusCode: response.status, revision: revision });\n      } else if (isSuccessStatus(response.status) || response.status === 200 && method !== 'GET') {\n        revision = stripQuotes(response.getResponseHeader('ETag'));\n        log('[WireClient] Successful request', revision);\n        return Promise.resolve({ statusCode: response.status, revision: revision });\n      } else {\n        var mimeType = response.getResponseHeader('Content-Type');\n        if (getEtag) {\n          revision = stripQuotes(response.getResponseHeader('ETag'));\n        } else {\n          revision = response.status === 200 ? fakeRevision : undefined;\n        }\n\n        var charset = determineCharset(mimeType);\n\n        if (!mimeType || charset === 'binary') {\n          log('[WireClient] Successful request with unknown or binary mime-type', revision);\n          return Promise.resolve({ statusCode: response.status, body: response.response, contentType: mimeType, revision: revision });\n        } else {\n          return getTextFromArrayBuffer(response.response, charset).then(function (body) {\n            log('[WireClient] Successful request', revision);\n            return Promise.resolve({ statusCode: response.status, body: body, contentType: mimeType, revision: revision });\n          });\n        }\n      }\n    }, function (error) {\n      if (self.online) {\n        self.online = false;\n        self.rs._emit('network-offline');\n      }\n      self._emit('wire-done', {\n        method: method,\n        isFolder: isFolder(uri),\n        success: false\n      });\n\n      return Promise.reject(error);\n    });\n  },\n\n  /**\n   *\n   * Method: configure\n   *\n   * Sets the userAddress, href, storageApi, token, and properties of a\n   * remote store. Also sets connected and online to true and emits the\n   * 'connected' event, if both token and href are present.\n   *\n   * Parameters:\n   *   settings - An object that may contain userAddress (string or null),\n   *              href (string or null), storageApi (string or null), token (string\n   *              or null), and/or properties (the JSON-parsed properties object\n   *              from the user's WebFinger record, see section 10 of\n   *              http://tools.ietf.org/html/draft-dejong-remotestorage-03\n   *              or null).\n   *              Fields that are not included (i.e. `undefined`), stay at\n   *              their current value. To set a field, include that field\n   *              with a `string` value. To reset a field, for instance when\n   *              the user disconnected their storage, or you found that the\n   *              token you have has expired, simply set that field to `null`.\n   */\n  configure: function configure(settings) {\n    if ((typeof settings === 'undefined' ? 'undefined' : _typeof(settings)) !== 'object') {\n      throw new Error('WireClient configure settings parameter should be an object');\n    }\n    if (typeof settings.userAddress !== 'undefined') {\n      this.userAddress = settings.userAddress;\n    }\n    if (typeof settings.href !== 'undefined') {\n      this.href = settings.href;\n    }\n    if (typeof settings.storageApi !== 'undefined') {\n      this.storageApi = settings.storageApi;\n    }\n    if (typeof settings.token !== 'undefined') {\n      this.token = settings.token;\n    }\n    if (typeof settings.properties !== 'undefined') {\n      this.properties = settings.properties;\n    }\n\n    if (typeof this.storageApi !== 'undefined') {\n      this._storageApi = STORAGE_APIS[this.storageApi] || API_HEAD;\n      this.supportsRevs = this._storageApi >= API_00;\n    }\n    if (this.href && this.token) {\n      this.connected = true;\n      this.online = true;\n      this._emit('connected');\n    } else {\n      this.connected = false;\n    }\n    if (hasLocalStorage) {\n      localStorage[SETTINGS_KEY] = JSON.stringify({\n        userAddress: this.userAddress,\n        href: this.href,\n        storageApi: this.storageApi,\n        token: this.token,\n        properties: this.properties\n      });\n    }\n  },\n\n  stopWaitingForToken: function stopWaitingForToken() {\n    if (!this.connected) {\n      this._emit('not-connected');\n    }\n  },\n\n  get: function get(path, options) {\n    var self = this;\n    if (!this.connected) {\n      return Promise.reject('not connected (path: ' + path + ')');\n    }\n    if (!options) {\n      options = {};\n    }\n    var headers = {};\n    if (this.supportsRevs) {\n      if (options.ifNoneMatch) {\n        headers['If-None-Match'] = addQuotes(options.ifNoneMatch);\n      }\n    } else if (options.ifNoneMatch) {\n      var oldRev = this._revisionCache[path];\n    }\n\n    return this._request('GET', this.href + cleanPath(path), this.token, headers, undefined, this.supportsRevs, this._revisionCache[path]).then(function (r) {\n      if (!isFolder(path)) {\n        return Promise.resolve(r);\n      }\n      var itemsMap = {};\n      if (typeof r.body !== 'undefined') {\n        try {\n          r.body = JSON.parse(r.body);\n        } catch (e) {\n          return Promise.reject('Folder description at ' + self.href + cleanPath(path) + ' is not JSON');\n        }\n      }\n\n      if (r.statusCode === 200 && _typeof(r.body) === 'object') {\n        // New folder listing received\n        if (Object.keys(r.body).length === 0) {\n          // Empty folder listing of any spec\n          r.statusCode = 404;\n        } else if (isFolderDescription(r.body)) {\n          // >= 02 spec\n          for (var item in r.body.items) {\n            self._revisionCache[path + item] = r.body.items[item].ETag;\n          }\n          itemsMap = r.body.items;\n        } else {\n          // < 02 spec\n          Object.keys(r.body).forEach(function (key) {\n            self._revisionCache[path + key] = r.body[key];\n            itemsMap[key] = { 'ETag': r.body[key] };\n          });\n        }\n        r.body = itemsMap;\n        return Promise.resolve(r);\n      } else {\n        return Promise.resolve(r);\n      }\n    });\n  },\n\n  put: function put(path, body, contentType, options) {\n    if (!this.connected) {\n      return Promise.reject('not connected (path: ' + path + ')');\n    }\n    if (!options) {\n      options = {};\n    }\n    if (!contentType.match(/charset=/) && (body instanceof ArrayBuffer || isArrayBufferView(body))) {\n      contentType += '; charset=binary';\n    }\n    var headers = { 'Content-Type': contentType };\n    if (this.supportsRevs) {\n      if (options.ifMatch) {\n        headers['If-Match'] = addQuotes(options.ifMatch);\n      }\n      if (options.ifNoneMatch) {\n        headers['If-None-Match'] = addQuotes(options.ifNoneMatch);\n      }\n    }\n    return this._request('PUT', this.href + cleanPath(path), this.token, headers, body, this.supportsRevs);\n  },\n\n  'delete': function _delete(path, options) {\n    if (!this.connected) {\n      throw new Error('not connected (path: ' + path + ')');\n    }\n    if (!options) {\n      options = {};\n    }\n    var headers = {};\n    if (this.supportsRevs) {\n      if (options.ifMatch) {\n        headers['If-Match'] = addQuotes(options.ifMatch);\n      }\n    }\n    return this._request('DELETE', this.href + cleanPath(path), this.token, headers, undefined, this.supportsRevs);\n  }\n};\n\n// Shared cleanPath used by Dropbox\nWireClient.cleanPath = cleanPath;\n\n// Shared isArrayBufferView used by WireClient and Dropbox\nWireClient.isArrayBufferView = isArrayBufferView;\n\nWireClient.readBinaryData = readBinaryData;\n\n// Shared request function used by WireClient, GoogleDrive and Dropbox.\nWireClient.request = function (method, url, options) {\n  var pending = Promise.defer();\n  log('[WireClient]', method, url);\n\n  var timedOut = false;\n\n  var timer = setTimeout(function () {\n    timedOut = true;\n    pending.reject('timeout');\n  }, WireClient.REQUEST_TIMEOUT);\n\n  var xhr = new XMLHttpRequest();\n  xhr.open(method, url, true);\n\n  if (options.responseType) {\n    xhr.responseType = options.responseType;\n  }\n\n  if (options.headers) {\n    for (var key in options.headers) {\n      xhr.setRequestHeader(key, options.headers[key]);\n    }\n  }\n\n  xhr.onload = function () {\n    if (timedOut) {\n      return;\n    }\n    clearTimeout(timer);\n    pending.resolve(xhr);\n  };\n\n  xhr.onerror = function (error) {\n    if (timedOut) {\n      return;\n    }\n    clearTimeout(timer);\n    pending.reject(error);\n  };\n\n  var body = options.body;\n\n  if ((typeof body === 'undefined' ? 'undefined' : _typeof(body)) === 'object' && !isArrayBufferView(body) && body instanceof ArrayBuffer) {\n    body = new Uint8Array(body);\n  }\n  xhr.send(body);\n  return pending.promise;\n};\n\nObject.defineProperty(WireClient.prototype, 'storageType', {\n  get: function get() {\n    if (this.storageApi) {\n      var spec = this.storageApi.match(/draft-dejong-(remotestorage-\\d\\d)/);\n      return spec ? spec[1] : '2012.04';\n    }\n  }\n});\n\nWireClient._rs_init = function (remoteStorage) {\n  hasLocalStorage = util.localStorageAvailable();\n  remoteStorage.remote = new WireClient(remoteStorage);\n  this.online = true;\n};\n\nWireClient._rs_supported = function () {\n  return !!XMLHttpRequest;\n};\n\nWireClient._rs_cleanup = function (remoteStorage) {\n  if (hasLocalStorage) {\n    delete localStorage[SETTINGS_KEY];\n  }\n  remoteStorage.removeEventListener('error', onErrorCb);\n};\n\nmodule.exports = WireClient;\n/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }()), __webpack_require__(13).Buffer))\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvd2lyZWNsaWVudC5qcz83NTRlIl0sIm5hbWVzIjpbImxvZyIsInJlcXVpcmUiLCJ1dGlsIiwiZXZlbnRIYW5kbGluZyIsIkF1dGhvcml6ZSIsImhhc0xvY2FsU3RvcmFnZSIsIlNFVFRJTkdTX0tFWSIsIkFQSV8yMDEyIiwiQVBJXzAwIiwiQVBJXzAxIiwiQVBJXzAyIiwiQVBJX0hFQUQiLCJTVE9SQUdFX0FQSVMiLCJpc0FycmF5QnVmZmVyVmlldyIsIkFycmF5QnVmZmVyVmlldyIsIm9iamVjdCIsImFycmF5QnVmZmVyVmlld3MiLCJJbnQ4QXJyYXkiLCJVaW50OEFycmF5IiwiSW50MTZBcnJheSIsIlVpbnQxNkFycmF5IiwiSW50MzJBcnJheSIsIlVpbnQzMkFycmF5IiwiRmxvYXQzMkFycmF5IiwiRmxvYXQ2NEFycmF5IiwiaSIsImlzRm9sZGVyIiwiY2xlYW5QYXRoIiwiYWRkUXVvdGVzIiwic3RyIiwic3RyaXBRdW90ZXMiLCJyZXBsYWNlIiwicmVhZEJpbmFyeURhdGEiLCJjb250ZW50IiwibWltZVR5cGUiLCJjYWxsYmFjayIsImJsb2IiLCJnbG9iYWxDb250ZXh0IiwiQmxvYkJ1aWxkZXIiLCJXZWJLaXRCbG9iQnVpbGRlciIsImJiIiwiZ2xvYmFsIiwiYXBwZW5kIiwiZ2V0QmxvYiIsIkJsb2IiLCJ0eXBlIiwicmVhZGVyIiwiRmlsZVJlYWRlciIsImFkZEV2ZW50TGlzdGVuZXIiLCJyZXN1bHQiLCJvbmxvYWRlbmQiLCJyZWFkQXNBcnJheUJ1ZmZlciIsImdldFRleHRGcm9tQXJyYXlCdWZmZXIiLCJhcnJheUJ1ZmZlciIsImVuY29kaW5nIiwicGVuZGluZyIsIlByb21pc2UiLCJkZWZlciIsImJ1ZmZlciIsIkJ1ZmZlciIsInJlc29sdmUiLCJ0b1N0cmluZyIsImZpbGVSZWFkZXIiLCJldnQiLCJ0YXJnZXQiLCJyZWFkQXNUZXh0IiwicHJvbWlzZSIsImRldGVybWluZUNoYXJzZXQiLCJjaGFyc2V0IiwiY2hhcnNldE1hdGNoIiwibWF0Y2giLCJpc0ZvbGRlckRlc2NyaXB0aW9uIiwiYm9keSIsImlzU3VjY2Vzc1N0YXR1cyIsInN0YXR1cyIsImluZGV4T2YiLCJpc0Vycm9yU3RhdHVzIiwib25FcnJvckNiIiwiV2lyZUNsaWVudCIsInJzIiwiY29ubmVjdGVkIiwiZXJyb3IiLCJVbmF1dGhvcml6ZWQiLCJjb25maWd1cmUiLCJ0b2tlbiIsImJpbmQiLCJvbiIsInNldHRpbmdzIiwiSlNPTiIsInBhcnNlIiwibG9jYWxTdG9yYWdlIiwiZSIsInNldFRpbWVvdXQiLCJfcmV2aXNpb25DYWNoZSIsIl9lbWl0IiwiUkVRVUVTVF9USU1FT1VUIiwicHJvdG90eXBlIiwiX3JlcXVlc3QiLCJtZXRob2QiLCJ1cmkiLCJoZWFkZXJzIiwiZ2V0RXRhZyIsImZha2VSZXZpc2lvbiIsImxlbmd0aCIsInJlamVjdCIsInJldmlzaW9uIiwic2VsZiIsIklNUExJRURfRkFLRV9UT0tFTiIsInJlcXVlc3QiLCJyZXNwb25zZVR5cGUiLCJ0aGVuIiwicmVzcG9uc2UiLCJvbmxpbmUiLCJzdWNjZXNzIiwiZ2V0UmVzcG9uc2VIZWFkZXIiLCJ1bmRlZmluZWQiLCJzdGF0dXNDb2RlIiwiY29udGVudFR5cGUiLCJFcnJvciIsInVzZXJBZGRyZXNzIiwiaHJlZiIsInN0b3JhZ2VBcGkiLCJwcm9wZXJ0aWVzIiwiX3N0b3JhZ2VBcGkiLCJzdXBwb3J0c1JldnMiLCJzdHJpbmdpZnkiLCJzdG9wV2FpdGluZ0ZvclRva2VuIiwiZ2V0IiwicGF0aCIsIm9wdGlvbnMiLCJpZk5vbmVNYXRjaCIsIm9sZFJldiIsInIiLCJpdGVtc01hcCIsIk9iamVjdCIsImtleXMiLCJpdGVtIiwiaXRlbXMiLCJFVGFnIiwiZm9yRWFjaCIsImtleSIsInB1dCIsIkFycmF5QnVmZmVyIiwiaWZNYXRjaCIsInVybCIsInRpbWVkT3V0IiwidGltZXIiLCJ4aHIiLCJYTUxIdHRwUmVxdWVzdCIsIm9wZW4iLCJzZXRSZXF1ZXN0SGVhZGVyIiwib25sb2FkIiwiY2xlYXJUaW1lb3V0Iiwib25lcnJvciIsInNlbmQiLCJkZWZpbmVQcm9wZXJ0eSIsInNwZWMiLCJfcnNfaW5pdCIsInJlbW90ZVN0b3JhZ2UiLCJsb2NhbFN0b3JhZ2VBdmFpbGFibGUiLCJyZW1vdGUiLCJfcnNfc3VwcG9ydGVkIiwiX3JzX2NsZWFudXAiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJtYXBwaW5ncyI6Ijs7OztBQUFFO0FBQ0EsSUFBSUEsTUFBTSxtQkFBQUMsQ0FBUSxDQUFSLENBQVY7QUFDQSxJQUFJQyxPQUFPLG1CQUFBRCxDQUFRLENBQVIsQ0FBWDtBQUNBLElBQUlFLGdCQUFnQixtQkFBQUYsQ0FBUSxDQUFSLENBQXBCO0FBQ0EsSUFBSUcsWUFBWSxtQkFBQUgsQ0FBUSxDQUFSLENBQWhCOztBQUVBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQXNDQSxJQUFJSSxlQUFKO0FBQ0EsSUFBSUMsZUFBZSwwQkFBbkI7O0FBRUEsSUFBSUMsV0FBVyxDQUFmO0FBQUEsSUFBa0JDLFNBQVMsQ0FBM0I7QUFBQSxJQUE4QkMsU0FBUyxDQUF2QztBQUFBLElBQTBDQyxTQUFTLENBQW5EO0FBQUEsSUFBc0RDLFdBQVcsQ0FBakU7O0FBRUEsSUFBSUMsZUFBZTtBQUNqQixtQ0FBaUNKLE1BRGhCO0FBRWpCLG1DQUFpQ0MsTUFGaEI7QUFHakIsbUNBQWlDQyxNQUhoQjtBQUlqQixvRUFBa0VIO0FBSmpELENBQW5COztBQU9BLElBQUlNLGlCQUFKOztBQUVBLElBQUksT0FBT0MsZUFBUCxLQUE0QixVQUFoQyxFQUE0QztBQUMxQ0Qsc0JBQW9CLDJCQUFVRSxNQUFWLEVBQWtCO0FBQUUsV0FBT0EsVUFBV0Esa0JBQWtCRCxlQUFwQztBQUF1RCxHQUEvRjtBQUNELENBRkQsTUFFTztBQUNMLE1BQUlFLG1CQUFtQixDQUNyQkMsU0FEcUIsRUFDVkMsVUFEVSxFQUNFQyxVQURGLEVBQ2NDLFdBRGQsRUFFckJDLFVBRnFCLEVBRVRDLFdBRlMsRUFF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O0FBQ0QsQ0FMRDs7QUFRQXVGLE9BQU9DLE9BQVAsR0FBaUJ2RixVQUFqQixDIiwiZmlsZSI6IjEyLmpzIiwic291cmNlc0NvbnRlbnQiOlsiICAvLyB2YXIgUmVtb3RlU3RvcmFnZSA9IHJlcXVpcmUoJy4vcmVtb3Rlc3RvcmFnZScpO1xuICB2YXIgbG9nID0gcmVxdWlyZSgnLi9sb2cnKTtcbiAgdmFyIHV0aWwgPSByZXF1aXJlKCcuL3V0aWwnKTtcbiAgdmFyIGV2ZW50SGFuZGxpbmcgPSByZXF1aXJlKCcuL2V2ZW50aGFuZGxpbmcnKTtcbiAgdmFyIEF1dGhvcml6ZSA9IHJlcXVpcmUoJy4vYXV0aG9yaXplJyk7XG5cbiAgLyoqXG4gICAqIENsYXNzOiBSZW1vdGVTdG9yYWdlLldpcmVDbGllbnRcbiAgICpcbiAgICogV2lyZUNsaWVudCBJbnRlcmZhY2VcbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICpcbiAgICogVGhpcyBmaWxlIGV4cG9zZXMgYSBnZXQvcHV0L2RlbGV0ZSBpbnRlcmZhY2Ugb24gdG9wIG9mIFhNTEh0dHBSZXF1ZXN0LlxuICAgKiBJdCByZXF1aXJlcyB0byBiZSBjb25maWd1cmVkIHdpdGggcGFyYW1ldGVycyBhYm91dCB0aGUgcmVtb3Rlc3RvcmFnZSBzZXJ2ZXIgdG9cbiAgICogY29ubmVjdCB0by5cbiAgICogRWFjaCBpbnN0YW5jZSBvZiBXaXJlQ2xpZW50IGlzIGFsd2F5cyBhc3NvY2lhdGVkIHdpdGggYSBzaW5nbGUgcmVtb3Rlc3RvcmFnZVxuICAgKiBzZXJ2ZXIgYW5kIGFjY2VzcyB0b2tlbi5cbiAgICpcbiAgICogVXN1YWxseSB0aGUgV2lyZUNsaWVudCBpbnN0YW5jZSBjYW4gYmUgYWNjZXNzZWQgdmlhIGByZW1vdGVTdG9yYWdlLnJlbW90ZWAuXG4gICAqXG4gICAqIFRoaXMgaXMgdGhlIGdldC9wdXQvZGVsZXRlIGludGVyZmFjZTpcbiAgICpcbiAgICogICAtICNnZXQoKSB0YWtlcyBhIHBhdGggYW5kIG9wdGlvbmFsbHkgYSBpZk5vbmVNYXRjaCBvcHRpb24gY2FycnlpbmcgYSB2ZXJzaW9uXG4gICAqICAgICBzdHJpbmcgdG8gY2hlY2suIEl0IHJldHVybnMgYSBwcm9taXNlIHRoYXQgd2lsbCBiZSBmdWxmaWxsZWQgd2l0aCB0aGUgSFRUUFxuICAgKiAgICAgcmVzcG9uc2Ugc3RhdHVzLCB0aGUgcmVzcG9uc2UgYm9keSwgdGhlIE1JTUUgdHlwZSBhcyByZXR1cm5lZCBpbiB0aGVcbiAgICogICAgICdDb250ZW50LVR5cGUnIGhlYWRlciBhbmQgdGhlIGN1cnJlbnQgcmV2aXNpb24sIGFzIHJldHVybmVkIGluIHRoZSAnRVRhZydcbiAgICogICAgIGhlYWRlci5cbiAgICogICAtICNwdXQoKSB0YWtlcyBhIHBhdGgsIHRoZSByZXF1ZXN0IGJvZHkgYW5kIGEgY29udGVudCB0eXBlIHN0cmluZy4gSXQgYWxzb1xuICAgKiAgICAgYWNjZXB0cyB0aGUgaWZNYXRjaCBhbmQgaWZOb25lTWF0Y2ggb3B0aW9ucywgdGhhdCBtYXAgdG8gdGhlIElmLU1hdGNoIGFuZFxuICAgKiAgICAgSWYtTm9uZS1NYXRjaCBoZWFkZXJzIHJlc3BlY3RpdmVseS4gU2VlIHRoZSByZW1vdGVzdG9yYWdlLTAxIHNwZWNpZmljYXRpb25cbiAgICogICAgIGZvciBkZXRhaWxzIG9uIGhhbmRsaW5nIHRoZXNlIGhlYWRlcnMuIEl0IHJldHVybnMgYSBwcm9taXNlLCBmdWxmaWxsZWQgd2l0aFxuICAgKiAgICAgdGhlIHNhbWUgdmFsdWVzIGFzIHRoZSBvbmUgZm9yICNnZXQoKS5cbiAgICogICAtICNkZWxldGUoKSB0YWtlcyBhIHBhdGggYW5kIHRoZSBpZk1hdGNoIG9wdGlvbiBhcyB3ZWxsLiBJdCByZXR1cm5zIGEgcHJvbWlzZVxuICAgKiAgICAgZnVsZmlsbGVkIHdpdGggdGhlIHNhbWUgdmFsdWVzIGFzIHRoZSBvbmUgZm9yICNnZXQoKS5cbiAgICpcbiAgICogSW4gYWRkaXRpb24gdG8gdGhpcywgdGhlIFdpcmVDbGllbnQgaGFzIHNvbWUgY29tcGF0aWJpbGl0eSBmZWF0dXJlcyB0byB3b3JrIHdpdGhcbiAgICogcmVtb3Rlc3RvcmFnZSAyMDEyLjA0IGNvbXBhdGlibGUgc3RvcmFnZXMuIEZvciBleGFtcGxlIGl0IHdpbGwgY2FjaGUgcmV2aXNpb25zXG4gICAqIGZyb20gZm9sZGVyIGxpc3RpbmdzIGluLW1lbW9yeSBhbmQgcmV0dXJuIHRoZW0gYWNjb3JkaW5nbHkgYXMgdGhlIFwicmV2aXNpb25cIlxuICAgKiBwYXJhbWV0ZXIgaW4gcmVzcG9uc2UgdG8gI2dldCgpIHJlcXVlc3RzLiBTaW1pbGFybHkgaXQgd2lsbCByZXR1cm4gNDA0IHdoZW4gaXRcbiAgICogcmVjZWl2ZXMgYW4gZW1wdHkgZm9sZGVyIGxpc3RpbmcsIHRvIG1pbWljIHJlbW90ZXN0b3JhZ2UtMDEgYmVoYXZpb3IuIE5vdGVcbiAgICogdGhhdCBpdCBpcyBub3QgYWx3YXlzIHBvc3NpYmxlIHRvIGtub3cgdGhlIHJldmlzaW9uIGJlZm9yZWhhbmQsIGhlbmNlIGl0IG1heVxuICAgKiBiZSB1bmRlZmluZWQgYXQgdGltZXMgKGVzcGVjaWFsbHkgZm9yIGNhY2hpbmctcm9vdHMpLlxuICAgKi9cblxuICB2YXIgaGFzTG9jYWxTdG9yYWdlO1xuICB2YXIgU0VUVElOR1NfS0VZID0gJ3JlbW90ZXN0b3JhZ2U6d2lyZWNsaWVudCc7XG5cbiAgdmFyIEFQSV8yMDEyID0gMSwgQVBJXzAwID0gMiwgQVBJXzAxID0gMywgQVBJXzAyID0gNCwgQVBJX0hFQUQgPSA1O1xuXG4gIHZhciBTVE9SQUdFX0FQSVMgPSB7XG4gICAgJ2RyYWZ0LWRlam9uZy1yZW1vdGVzdG9yYWdlLTAwJzogQVBJXzAwLFxuICAgICdkcmFmdC1kZWpvbmctcmVtb3Rlc3RvcmFnZS0wMSc6IEFQSV8wMSxcbiAgICAnZHJhZnQtZGVqb25nLXJlbW90ZXN0b3JhZ2UtMDInOiBBUElfMDIsXG4gICAgJ2h0dHBzOi8vd3d3LnczLm9yZy9jb21tdW5pdHkvcnd3L3dpa2kvcmVhZC13cml0ZS13ZWItMDAjc2ltcGxlJzogQVBJXzIwMTJcbiAgfTtcblxuICB2YXIgaXNBcnJheUJ1ZmZlclZpZXc7XG5cbiAgaWYgKHR5cGVvZihBcnJheUJ1ZmZlclZpZXcpID09PSAnZnVuY3Rpb24nKSB7XG4gICAgaXNBcnJheUJ1ZmZlclZpZXcgPSBmdW5jdGlvbiAob2JqZWN0KSB7IHJldHVybiBvYmplY3QgJiYgKG9iamVjdCBpbnN0YW5jZW9mIEFycmF5QnVmZmVyVmlldyk7IH07XG4gIH0gZWxzZSB7XG4gICAgdmFyIGFycmF5QnVmZmVyVmlld3MgPSBbXG4gICAgICBJbnQ4QXJyYXksIFVpbnQ4QXJyYXksIEludDE2QXJyYXksIFVpbnQxNkFycmF5LFxuICAgICAgSW50MzJBcnJheSwgVWludDMyQXJyYXksIEZsb2F0MzJBcnJheSwgRmxvYXQ2NEFycmF5XG4gICAgXTtcbiAgICBpc0FycmF5QnVmZmVyVmlldyA9IGZ1bmN0aW9uIChvYmplY3QpIHtcbiAgICAgIGZvciAodmFyIGk9MDtpPDg7aSsrKSB7XG4gICAgICAgIGlmIChvYmplY3QgaW5zdGFuY2VvZiBhcnJheUJ1ZmZlclZpZXdzW2ldKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuICB9XG5cbiAgdmFyIGlzRm9sZGVyID0gdXRpbC5pc0ZvbGRlcjtcbiAgdmFyIGNsZWFuUGF0aCA9IHV0aWwuY2xlYW5QYXRoO1xuXG4gIGZ1bmN0aW9uIGFkZFF1b3RlcyhzdHIpIHtcbiAgICBpZiAodHlwZW9mKHN0cikgIT09ICdzdHJpbmcnKSB7XG4gICAgICByZXR1cm4gc3RyO1xuICAgIH1cbiAgICBpZiAoc3RyID09PSAnKicpIHtcbiAgICAgIHJldHVybiAnKic7XG4gICAgfVxuXG4gICAgcmV0dXJuICdcIicgKyBzdHIgKyAnXCInO1xuICB9XG5cbiAgZnVuY3Rpb24gc3RyaXBRdW90ZXMoc3RyKSB7XG4gICAgaWYgKHR5cGVvZihzdHIpICE9PSAnc3RyaW5nJykge1xuICAgICAgcmV0dXJuIHN0cjtcbiAgICB9XG5cbiAgICByZXR1cm4gc3RyLnJlcGxhY2UoL15bXCInXXxbXCInXSQvZywgJycpO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVhZEJpbmFyeURhdGEoY29udGVudCwgbWltZVR5cGUsIGNhbGxiYWNrKSB7XG4gICAgdmFyIGJsb2I7XG4gICAgdXRpbC5nbG9iYWxDb250ZXh0LkJsb2JCdWlsZGVyID0gdXRpbC5nbG9iYWxDb250ZXh0LkJsb2JCdWlsZGVyIHx8IHV0aWwuZ2xvYmFsQ29udGV4dC5XZWJLaXRCbG9iQnVpbGRlcjtcbiAgICBpZiAodHlwZW9mIHV0aWwuZ2xvYmFsQ29udGV4dC5CbG9iQnVpbGRlciAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHZhciBiYiA9IG5ldyBnbG9iYWwuQmxvYkJ1aWxkZXIoKTtcbiAgICAgIGJiLmFwcGVuZChjb250ZW50KTtcbiAgICAgIGJsb2IgPSBiYi5nZXRCbG9iKG1pbWVUeXBlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYmxvYiA9IG5ldyBCbG9iKFtjb250ZW50XSwgeyB0eXBlOiBtaW1lVHlwZSB9KTtcbiAgICB9XG5cbiAgICB2YXIgcmVhZGVyID0gbmV3IEZpbGVSZWFkZXIoKTtcbiAgICBpZiAodHlwZW9mIHJlYWRlci5hZGRFdmVudExpc3RlbmVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZWFkZXIuYWRkRXZlbnRMaXN0ZW5lcignbG9hZGVuZCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY2FsbGJhY2socmVhZGVyLnJlc3VsdCk7IC8vIHJlYWRlci5yZXN1bHQgY29udGFpbnMgdGhlIGNvbnRlbnRzIG9mIGJsb2IgYXMgYSB0eXBlZCBhcnJheVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlYWRlci5vbmxvYWRlbmQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgY2FsbGJhY2socmVhZGVyLnJlc3VsdCk7IC8vIHJlYWRlci5yZXN1bHQgY29udGFpbnMgdGhlIGNvbnRlbnRzIG9mIGJsb2IgYXMgYSB0eXBlZCBhcnJheVxuICAgICAgfTtcbiAgICB9XG4gICAgcmVhZGVyLnJlYWRBc0FycmF5QnVmZmVyKGJsb2IpO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0VGV4dEZyb21BcnJheUJ1ZmZlcihhcnJheUJ1ZmZlciwgZW5jb2RpbmcpIHtcbiAgICB2YXIgcGVuZGluZyA9IFByb21pc2UuZGVmZXIoKTtcbiAgICBpZiAodHlwZW9mIEJsb2IgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICB2YXIgYnVmZmVyID0gbmV3IEJ1ZmZlcihuZXcgVWludDhBcnJheShhcnJheUJ1ZmZlcikpO1xuICAgICAgcGVuZGluZy5yZXNvbHZlKGJ1ZmZlci50b1N0cmluZyhlbmNvZGluZykpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgYmxvYjtcbiAgICAgIHV0aWwuZ2xvYmFsQ29udGV4dC5CbG9iQnVpbGRlciA9IHV0aWwuZ2xvYmFsQ29udGV4dC5CbG9iQnVpbGRlciB8fCB1dGlsLmdsb2JhbENvbnRleHQuV2ViS2l0QmxvYkJ1aWxkZXI7XG4gICAgICBpZiAodHlwZW9mIHV0aWwuZ2xvYmFsQ29udGV4dC5CbG9iQnVpbGRlciAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgdmFyIGJiID0gbmV3IGdsb2JhbC5CbG9iQnVpbGRlcigpO1xuICAgICAgICBiYi5hcHBlbmQoYXJyYXlCdWZmZXIpO1xuICAgICAgICBibG9iID0gYmIuZ2V0QmxvYigpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYmxvYiA9IG5ldyBCbG9iKFthcnJheUJ1ZmZlcl0pO1xuICAgICAgfVxuXG4gICAgICB2YXIgZmlsZVJlYWRlciA9IG5ldyBGaWxlUmVhZGVyKCk7XG4gICAgICBpZiAodHlwZW9mIGZpbGVSZWFkZXIuYWRkRXZlbnRMaXN0ZW5lciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBmaWxlUmVhZGVyLmFkZEV2ZW50TGlzdGVuZXIoJ2xvYWRlbmQnLCBmdW5jdGlvbiAoZXZ0KSB7XG4gICAgICAgICAgcGVuZGluZy5yZXNvbHZlKGV2dC50YXJnZXQucmVzdWx0KTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmaWxlUmVhZGVyLm9ubG9hZGVuZCA9IGZ1bmN0aW9uKGV2dCkge1xuICAgICAgICAgIHBlbmRpbmcucmVzb2x2ZShldnQudGFyZ2V0LnJlc3VsdCk7XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBmaWxlUmVhZGVyLnJlYWRBc1RleHQoYmxvYiwgZW5jb2RpbmcpO1xuICAgIH1cbiAgICByZXR1cm4gcGVuZGluZy5wcm9taXNlO1xuICB9XG5cbiAgZnVuY3Rpb24gZGV0ZXJtaW5lQ2hhcnNldChtaW1lVHlwZSkge1xuICAgIHZhciBjaGFyc2V0ID0gJ1VURi04JztcbiAgICB2YXIgY2hhcnNldE1hdGNoO1xuXG4gICAgaWYgKG1pbWVUeXBlKSB7XG4gICAgICBjaGFyc2V0TWF0Y2ggPSBtaW1lVHlwZS5tYXRjaCgvY2hhcnNldD0oLispJC8pO1xuICAgICAgaWYgKGNoYXJzZXRNYXRjaCkge1xuICAgICAgICBjaGFyc2V0ID0gY2hhcnNldE1hdGNoWzFdO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY2hhcnNldDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzRm9sZGVyRGVzY3JpcHRpb24oYm9keSkge1xuICAgIHJldHVybiAoKGJvZHlbJ0Bjb250ZXh0J10gPT09ICdodHRwOi8vcmVtb3Rlc3RvcmFnZS5pby9zcGVjL2ZvbGRlci1kZXNjcmlwdGlvbicpXG4gICAgICAgICAgICAgJiYgKHR5cGVvZihib2R5WydpdGVtcyddKSA9PT0gJ29iamVjdCcpKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzU3VjY2Vzc1N0YXR1cyhzdGF0dXMpIHtcbiAgICByZXR1cm4gWzIwMSwgMjA0LCAzMDRdLmluZGV4T2Yoc3RhdHVzKSA+PSAwO1xuICB9XG5cbiAgZnVuY3Rpb24gaXNFcnJvclN0YXR1cyhzdGF0dXMpIHtcbiAgICByZXR1cm4gWzQwMSwgNDAzLCA0MDQsIDQxMl0uaW5kZXhPZihzdGF0dXMpID49IDA7XG4gIH1cblxuICB2YXIgb25FcnJvckNiO1xuXG4gIC8qKlxuICAgKiBDbGFzcyA6IFJlbW90ZVN0b3JhZ2UuV2lyZUNsaWVudFxuICAgKiovXG4gIHZhciBXaXJlQ2xpZW50ID0gZnVuY3Rpb24gKHJzKSB7XG4gICAgdGhpcy5ycyA9IHJzO1xuICAgIHRoaXMuY29ubmVjdGVkID0gZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiBFdmVudDogY2hhbmdlXG4gICAgICogICBOZXZlciBmaXJlZCBmb3Igc29tZSByZWFzb25cbiAgICAgKiAgICMgVE9ETyBjcmVhdGUgaXNzdWUgYW5kIGZpeCBvciByZW1vdmVcbiAgICAgKlxuICAgICAqIEV2ZW50OiBjb25uZWN0ZWRcbiAgICAgKiAgIEZpcmVkIHdoZW4gdGhlIHdpcmVjbGllbnQgY29ubmVjdCBtZXRob2QgcmVhbGl6ZXMgdGhhdCBpdCBpcyBpblxuICAgICAqICAgcG9zc2Vzc2lvbiBvZiBhIHRva2VuIGFuZCBocmVmXG4gICAgICoqL1xuICAgIGV2ZW50SGFuZGxpbmcodGhpcywgJ2NoYW5nZScsICdjb25uZWN0ZWQnLCAnbm90LWNvbm5lY3RlZCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAnd2lyZS1idXN5JywgJ3dpcmUtZG9uZScpO1xuXG4gICAgb25FcnJvckNiID0gZnVuY3Rpb24gKGVycm9yKXtcbiAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEF1dGhvcml6ZS5VbmF1dGhvcml6ZWQpIHtcbiAgICAgICAgdGhpcy5jb25maWd1cmUoe3Rva2VuOiBudWxsfSk7XG4gICAgICB9XG4gICAgfS5iaW5kKHRoaXMpO1xuICAgIHJzLm9uKCdlcnJvcicsIG9uRXJyb3JDYik7XG4gICAgaWYgKGhhc0xvY2FsU3RvcmFnZSkge1xuICAgICAgdmFyIHNldHRpbmdzO1xuICAgICAgdHJ5IHsgc2V0dGluZ3MgPSBKU09OLnBhcnNlKGxvY2FsU3RvcmFnZVtTRVRUSU5HU19LRVldKTsgfSBjYXRjaChlKSB7fVxuICAgICAgaWYgKHNldHRpbmdzKSB7XG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHRoaXMuY29uZmlndXJlKHNldHRpbmdzKTtcbiAgICAgICAgfS5iaW5kKHRoaXMpLCAwKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLl9yZXZpc2lvbkNhY2hlID0ge307XG5cbiAgICBpZiAodGhpcy5jb25uZWN0ZWQpIHtcbiAgICAgIHNldFRpbWVvdXQodGhpcy5fZW1pdC5iaW5kKHRoaXMpLCAwLCAnY29ubmVjdGVkJyk7XG4gICAgfVxuICB9O1xuXG4gIFdpcmVDbGllbnQuUkVRVUVTVF9USU1FT1VUID0gMzAwMDA7XG5cbiAgV2lyZUNsaWVudC5wcm90b3R5cGUgPSB7XG4gICAgLyoqXG4gICAgICogUHJvcGVydHk6IHRva2VuXG4gICAgICpcbiAgICAgKiBIb2xkcyB0aGUgYmVhcmVyIHRva2VuIG9mIHRoaXMgV2lyZUNsaWVudCwgYXMgb2J0YWluZWQgaW4gdGhlIE9BdXRoIGRhbmNlXG4gICAgICpcbiAgICAgKiBFeGFtcGxlOlxuICAgICAqICAgKHN0YXJ0IGNvZGUpXG4gICAgICpcbiAgICAgKiAgIHJlbW90ZVN0b3JhZ2UucmVtb3RlLnRva2VuXG4gICAgICogICAvLyAtPiAnREVBREJFRUYwMT09J1xuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogUHJvcGVydHk6IGhyZWZcbiAgICAgKlxuICAgICAqIEhvbGRzIHRoZSBzZXJ2ZXIncyBiYXNlIFVSTCwgYXMgb2J0YWluZWQgaW4gdGhlIFdlYmZpbmdlciBkaXNjb3ZlcnlcbiAgICAgKlxuICAgICAqIEV4YW1wbGU6XG4gICAgICogICAoc3RhcnQgY29kZSlcbiAgICAgKlxuICAgICAqICAgcmVtb3RlU3RvcmFnZS5yZW1vdGUuaHJlZlxuICAgICAqICAgLy8gLT4gJ2h0dHBzOi8vc3RvcmFnZS5leGFtcGxlLmNvbS91c2Vycy9qYmxvZ2cvJ1xuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogUHJvcGVydHk6IHN0b3JhZ2VBcGlcbiAgICAgKlxuICAgICAqIEhvbGRzIHRoZSBzcGVjIHZlcnNpb24gdGhlIHNlcnZlciBjbGFpbXMgdG8gYmUgY29tcGF0aWJsZSB3aXRoXG4gICAgICpcbiAgICAgKiBFeGFtcGxlOlxuICAgICAqICAgKHN0YXJ0IGNvZGUpXG4gICAgICpcbiAgICAgKiAgIHJlbW90ZVN0b3JhZ2UucmVtb3RlLnN0b3JhZ2VBcGlcbiAgICAgKiAgIC8vIC0+ICdkcmFmdC1kZWpvbmctcmVtb3Rlc3RvcmFnZS0wMSdcbiAgICAgKi9cblxuICAgIF9yZXF1ZXN0OiBmdW5jdGlvbiAobWV0aG9kLCB1cmksIHRva2VuLCBoZWFkZXJzLCBib2R5LCBnZXRFdGFnLCBmYWtlUmV2aXNpb24pIHtcbiAgICAgIGlmICgobWV0aG9kID09PSAnUFVUJyB8fCBtZXRob2QgPT09ICdERUxFVEUnKSAmJiB1cmlbdXJpLmxlbmd0aCAtIDFdID09PSAnLycpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KCdEb25cXCd0ICcgKyBtZXRob2QgKyAnIG9uIGRpcmVjdG9yaWVzIScpO1xuICAgICAgfVxuXG4gICAgICB2YXIgcmV2aXNpb247XG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAgIGlmICh0b2tlbiAhPT0gQXV0aG9yaXplLklNUExJRURfRkFLRV9UT0tFTikge1xuICAgICAgICBoZWFkZXJzWydBdXRob3JpemF0aW9uJ10gPSAnQmVhcmVyICcgKyB0b2tlbjtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fZW1pdCgnd2lyZS1idXN5Jywge1xuICAgICAgICBtZXRob2Q6IG1ldGhvZCxcbiAgICAgICAgaXNGb2xkZXI6IGlzRm9sZGVyKHVyaSlcbiAgICAgIH0pO1xuXG4gICAgICByZXR1cm4gV2lyZUNsaWVudC5yZXF1ZXN0KG1ldGhvZCwgdXJpLCB7XG4gICAgICAgIGJvZHk6IGJvZHksXG4gICAgICAgIGhlYWRlcnM6IGhlYWRlcnMsXG4gICAgICAgIHJlc3BvbnNlVHlwZTogJ2FycmF5YnVmZmVyJ1xuICAgICAgfSkudGhlbihmdW5jdGlvbihyZXNwb25zZSkge1xuICAgICAgICBpZiAoIXNlbGYub25saW5lKSB7XG4gICAgICAgICAgc2VsZi5vbmxpbmUgPSB0cnVlO1xuICAgICAgICAgIHNlbGYucnMuX2VtaXQoJ25ldHdvcmstb25saW5lJyk7XG4gICAgICAgIH1cbiAgICAgICAgc2VsZi5fZW1pdCgnd2lyZS1kb25lJywge1xuICAgICAgICAgIG1ldGhvZDogbWV0aG9kLFxuICAgICAgICAgIGlzRm9sZGVyOiBpc0ZvbGRlcih1cmkpLFxuICAgICAgICAgIHN1Y2Nlc3M6IHRydWVcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKGlzRXJyb3JTdGF0dXMocmVzcG9uc2Uuc3RhdHVzKSkge1xuICAgICAgICAgIGxvZygnW1dpcmVDbGllbnRdIEVycm9yIHJlc3BvbnNlIHN0YXR1cycsIHJlc3BvbnNlLnN0YXR1cyk7XG4gICAgICAgICAgaWYgKGdldEV0YWcpIHtcbiAgICAgICAgICAgIHJldmlzaW9uID0gc3RyaXBRdW90ZXMocmVzcG9uc2UuZ2V0UmVzcG9uc2VIZWFkZXIoJ0VUYWcnKSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldmlzaW9uID0gdW5kZWZpbmVkO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHtzdGF0dXNDb2RlOiByZXNwb25zZS5zdGF0dXMsIHJldmlzaW9uOiByZXZpc2lvbn0pO1xuICAgICAgICB9IGVsc2UgaWYgKGlzU3VjY2Vzc1N0YXR1cyhyZXNwb25zZS5zdGF0dXMpIHx8XG4gICAgICAgICAgICAgICAgICAgKHJlc3BvbnNlLnN0YXR1cyA9PT0gMjAwICYmIG1ldGhvZCAhPT0gJ0dFVCcpKSB7XG4gICAgICAgICAgcmV2aXNpb24gPSBzdHJpcFF1b3RlcyhyZXNwb25zZS5nZXRSZXNwb25zZUhlYWRlcignRVRhZycpKTtcbiAgICAgICAgICBsb2coJ1tXaXJlQ2xpZW50XSBTdWNjZXNzZnVsIHJlcXVlc3QnLCByZXZpc2lvbik7XG4gICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh7c3RhdHVzQ29kZTogcmVzcG9uc2Uuc3RhdHVzLCByZXZpc2lvbjogcmV2aXNpb259KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgbWltZVR5cGUgPSByZXNwb25zZS5nZXRSZXNwb25zZUhlYWRlcignQ29udGVudC1UeXBlJyk7XG4gICAgICAgICAgaWYgKGdldEV0YWcpIHtcbiAgICAgICAgICAgIHJldmlzaW9uID0gc3RyaXBRdW90ZXMocmVzcG9uc2UuZ2V0UmVzcG9uc2VIZWFkZXIoJ0VUYWcnKSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldmlzaW9uID0gcmVzcG9uc2Uuc3RhdHVzID09PSAyMDAgPyBmYWtlUmV2aXNpb24gOiB1bmRlZmluZWQ7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIGNoYXJzZXQgPSBkZXRlcm1pbmVDaGFyc2V0KG1pbWVUeXBlKTtcblxuICAgICAgICAgIGlmICgoIW1pbWVUeXBlKSB8fCBjaGFyc2V0ID09PSAnYmluYXJ5Jykge1xuICAgICAgICAgICAgbG9nKCdbV2lyZUNsaWVudF0gU3VjY2Vzc2Z1bCByZXF1ZXN0IHdpdGggdW5rbm93biBvciBiaW5hcnkgbWltZS10eXBlJywgcmV2aXNpb24pO1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh7c3RhdHVzQ29kZTogcmVzcG9uc2Uuc3RhdHVzLCBib2R5OiByZXNwb25zZS5yZXNwb25zZSwgY29udGVudFR5cGU6IG1pbWVUeXBlLCByZXZpc2lvbjogcmV2aXNpb259KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGdldFRleHRGcm9tQXJyYXlCdWZmZXIocmVzcG9uc2UucmVzcG9uc2UsIGNoYXJzZXQpLnRoZW4oZnVuY3Rpb24gKGJvZHkpIHtcbiAgICAgICAgICAgICAgbG9nKCdbV2lyZUNsaWVudF0gU3VjY2Vzc2Z1bCByZXF1ZXN0JywgcmV2aXNpb24pO1xuICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHtzdGF0dXNDb2RlOiByZXNwb25zZS5zdGF0dXMsIGJvZHk6IGJvZHksIGNvbnRlbnRUeXBlOiBtaW1lVHlwZSwgcmV2aXNpb246IHJldmlzaW9ufSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sIGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICBpZiAoc2VsZi5vbmxpbmUpIHtcbiAgICAgICAgICBzZWxmLm9ubGluZSA9IGZhbHNlO1xuICAgICAgICAgIHNlbGYucnMuX2VtaXQoJ25ldHdvcmstb2ZmbGluZScpO1xuICAgICAgICB9XG4gICAgICAgIHNlbGYuX2VtaXQoJ3dpcmUtZG9uZScsIHtcbiAgICAgICAgICBtZXRob2Q6IG1ldGhvZCxcbiAgICAgICAgICBpc0ZvbGRlcjogaXNGb2xkZXIodXJpKSxcbiAgICAgICAgICBzdWNjZXNzOiBmYWxzZVxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZXJyb3IpO1xuICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqXG4gICAgICogTWV0aG9kOiBjb25maWd1cmVcbiAgICAgKlxuICAgICAqIFNldHMgdGhlIHVzZXJBZGRyZXNzLCBocmVmLCBzdG9yYWdlQXBpLCB0b2tlbiwgYW5kIHByb3BlcnRpZXMgb2YgYVxuICAgICAqIHJlbW90ZSBzdG9yZS4gQWxzbyBzZXRzIGNvbm5lY3RlZCBhbmQgb25saW5lIHRvIHRydWUgYW5kIGVtaXRzIHRoZVxuICAgICAqICdjb25uZWN0ZWQnIGV2ZW50LCBpZiBib3RoIHRva2VuIGFuZCBocmVmIGFyZSBwcmVzZW50LlxuICAgICAqXG4gICAgICogUGFyYW1ldGVyczpcbiAgICAgKiAgIHNldHRpbmdzIC0gQW4gb2JqZWN0IHRoYXQgbWF5IGNvbnRhaW4gdXNlckFkZHJlc3MgKHN0cmluZyBvciBudWxsKSxcbiAgICAgKiAgICAgICAgICAgICAgaHJlZiAoc3RyaW5nIG9yIG51bGwpLCBzdG9yYWdlQXBpIChzdHJpbmcgb3IgbnVsbCksIHRva2VuIChzdHJpbmdcbiAgICAgKiAgICAgICAgICAgICAgb3IgbnVsbCksIGFuZC9vciBwcm9wZXJ0aWVzICh0aGUgSlNPTi1wYXJzZWQgcHJvcGVydGllcyBvYmplY3RcbiAgICAgKiAgICAgICAgICAgICAgZnJvbSB0aGUgdXNlcidzIFdlYkZpbmdlciByZWNvcmQsIHNlZSBzZWN0aW9uIDEwIG9mXG4gICAgICogICAgICAgICAgICAgIGh0dHA6Ly90b29scy5pZXRmLm9yZy9odG1sL2RyYWZ0LWRlam9uZy1yZW1vdGVzdG9yYWdlLTAzXG4gICAgICogICAgICAgICAgICAgIG9yIG51bGwpLlxuICAgICAqICAgICAgICAgICAgICBGaWVsZHMgdGhhdCBhcmUgbm90IGluY2x1ZGVkIChpLmUuIGB1bmRlZmluZWRgKSwgc3RheSBhdFxuICAgICAqICAgICAgICAgICAgICB0aGVpciBjdXJyZW50IHZhbHVlLiBUbyBzZXQgYSBmaWVsZCwgaW5jbHVkZSB0aGF0IGZpZWxkXG4gICAgICogICAgICAgICAgICAgIHdpdGggYSBgc3RyaW5nYCB2YWx1ZS4gVG8gcmVzZXQgYSBmaWVsZCwgZm9yIGluc3RhbmNlIHdoZW5cbiAgICAgKiAgICAgICAgICAgICAgdGhlIHVzZXIgZGlzY29ubmVjdGVkIHRoZWlyIHN0b3JhZ2UsIG9yIHlvdSBmb3VuZCB0aGF0IHRoZVxuICAgICAqICAgICAgICAgICAgICB0b2tlbiB5b3UgaGF2ZSBoYXMgZXhwaXJlZCwgc2ltcGx5IHNldCB0aGF0IGZpZWxkIHRvIGBudWxsYC5cbiAgICAgKi9cbiAgICBjb25maWd1cmU6IGZ1bmN0aW9uIChzZXR0aW5ncykge1xuICAgICAgaWYgKHR5cGVvZiBzZXR0aW5ncyAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdXaXJlQ2xpZW50IGNvbmZpZ3VyZSBzZXR0aW5ncyBwYXJhbWV0ZXIgc2hvdWxkIGJlIGFuIG9iamVjdCcpO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBzZXR0aW5ncy51c2VyQWRkcmVzcyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgdGhpcy51c2VyQWRkcmVzcyA9IHNldHRpbmdzLnVzZXJBZGRyZXNzO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBzZXR0aW5ncy5ocmVmICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICB0aGlzLmhyZWYgPSBzZXR0aW5ncy5ocmVmO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBzZXR0aW5ncy5zdG9yYWdlQXBpICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICB0aGlzLnN0b3JhZ2VBcGkgPSBzZXR0aW5ncy5zdG9yYWdlQXBpO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBzZXR0aW5ncy50b2tlbiAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgdGhpcy50b2tlbiA9IHNldHRpbmdzLnRva2VuO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBzZXR0aW5ncy5wcm9wZXJ0aWVzICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICB0aGlzLnByb3BlcnRpZXMgPSBzZXR0aW5ncy5wcm9wZXJ0aWVzO1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIHRoaXMuc3RvcmFnZUFwaSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgdGhpcy5fc3RvcmFnZUFwaSA9IFNUT1JBR0VfQVBJU1t0aGlzLnN0b3JhZ2VBcGldIHx8IEFQSV9IRUFEO1xuICAgICAgICB0aGlzLnN1cHBvcnRzUmV2cyA9IHRoaXMuX3N0b3JhZ2VBcGkgPj0gQVBJXzAwO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuaHJlZiAmJiB0aGlzLnRva2VuKSB7XG4gICAgICAgIHRoaXMuY29ubmVjdGVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5vbmxpbmUgPSB0cnVlO1xuICAgICAgICB0aGlzLl9lbWl0KCdjb25uZWN0ZWQnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuY29ubmVjdGVkID0gZmFsc2U7XG4gICAgICB9XG4gICAgICBpZiAoaGFzTG9jYWxTdG9yYWdlKSB7XG4gICAgICAgIGxvY2FsU3RvcmFnZVtTRVRUSU5HU19LRVldID0gSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgIHVzZXJBZGRyZXNzOiB0aGlzLnVzZXJBZGRyZXNzLFxuICAgICAgICAgIGhyZWY6IHRoaXMuaHJlZixcbiAgICAgICAgICBzdG9yYWdlQXBpOiB0aGlzLnN0b3JhZ2VBcGksXG4gICAgICAgICAgdG9rZW46IHRoaXMudG9rZW4sXG4gICAgICAgICAgcHJvcGVydGllczogdGhpcy5wcm9wZXJ0aWVzXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBzdG9wV2FpdGluZ0ZvclRva2VuOiBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoIXRoaXMuY29ubmVjdGVkKSB7XG4gICAgICAgIHRoaXMuX2VtaXQoJ25vdC1jb25uZWN0ZWQnKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgZ2V0OiBmdW5jdGlvbiAocGF0aCwgb3B0aW9ucykge1xuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgaWYgKCF0aGlzLmNvbm5lY3RlZCkge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoJ25vdCBjb25uZWN0ZWQgKHBhdGg6ICcgKyBwYXRoICsgJyknKTtcbiAgICAgIH1cbiAgICAgIGlmICghb3B0aW9ucykgeyBvcHRpb25zID0ge307IH1cbiAgICAgIHZhciBoZWFkZXJzID0ge307XG4gICAgICBpZiAodGhpcy5zdXBwb3J0c1JldnMpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMuaWZOb25lTWF0Y2gpIHtcbiAgICAgICAgICBoZWFkZXJzWydJZi1Ob25lLU1hdGNoJ10gPSBhZGRRdW90ZXMob3B0aW9ucy5pZk5vbmVNYXRjaCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAob3B0aW9ucy5pZk5vbmVNYXRjaCkge1xuICAgICAgICB2YXIgb2xkUmV2ID0gdGhpcy5fcmV2aXNpb25DYWNoZVtwYXRoXTtcbiAgICAgIH1cblxuXG4gICAgICByZXR1cm4gdGhpcy5fcmVxdWVzdCgnR0VUJywgdGhpcy5ocmVmICsgY2xlYW5QYXRoKHBhdGgpLCB0aGlzLnRva2VuLCBoZWFkZXJzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVuZGVmaW5lZCwgdGhpcy5zdXBwb3J0c1JldnMsIHRoaXMuX3JldmlzaW9uQ2FjaGVbcGF0aF0pXG4gICAgICAudGhlbihmdW5jdGlvbiAocikge1xuICAgICAgICBpZiAoIWlzRm9sZGVyKHBhdGgpKSB7XG4gICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShyKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgaXRlbXNNYXAgPSB7fTtcbiAgICAgICAgaWYgKHR5cGVvZihyLmJvZHkpICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICByLmJvZHkgPSBKU09OLnBhcnNlKHIuYm9keSk7XG4gICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KCdGb2xkZXIgZGVzY3JpcHRpb24gYXQgJyArIHNlbGYuaHJlZiArIGNsZWFuUGF0aChwYXRoKSArICcgaXMgbm90IEpTT04nKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoci5zdGF0dXNDb2RlID09PSAyMDAgJiYgdHlwZW9mKHIuYm9keSkgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIC8vIE5ldyBmb2xkZXIgbGlzdGluZyByZWNlaXZlZFxuICAgICAgICAgIGlmIChPYmplY3Qua2V5cyhyLmJvZHkpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIC8vIEVtcHR5IGZvbGRlciBsaXN0aW5nIG9mIGFueSBzcGVjXG4gICAgICAgICAgICByLnN0YXR1c0NvZGUgPSA0MDQ7XG4gICAgICAgICAgfSBlbHNlIGlmIChpc0ZvbGRlckRlc2NyaXB0aW9uKHIuYm9keSkpIHtcbiAgICAgICAgICAvLyA+PSAwMiBzcGVjXG4gICAgICAgICAgICBmb3IgKHZhciBpdGVtIGluIHIuYm9keS5pdGVtcykge1xuICAgICAgICAgICAgICBzZWxmLl9yZXZpc2lvbkNhY2hlW3BhdGggKyBpdGVtXSA9IHIuYm9keS5pdGVtc1tpdGVtXS5FVGFnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaXRlbXNNYXAgPSByLmJvZHkuaXRlbXM7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyA8IDAyIHNwZWNcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKHIuYm9keSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KXtcbiAgICAgICAgICAgICAgc2VsZi5fcmV2aXNpb25DYWNoZVtwYXRoICsga2V5XSA9IHIuYm9keVtrZXldO1xuICAgICAgICAgICAgICBpdGVtc01hcFtrZXldID0geydFVGFnJzogci5ib2R5W2tleV19O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHIuYm9keSA9IGl0ZW1zTWFwO1xuICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUocik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShyKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSxcblxuICAgIHB1dDogZnVuY3Rpb24gKHBhdGgsIGJvZHksIGNvbnRlbnRUeXBlLCBvcHRpb25zKSB7XG4gICAgICBpZiAoIXRoaXMuY29ubmVjdGVkKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdCgnbm90IGNvbm5lY3RlZCAocGF0aDogJyArIHBhdGggKyAnKScpO1xuICAgICAgfVxuICAgICAgaWYgKCFvcHRpb25zKSB7IG9wdGlvbnMgPSB7fTsgfVxuICAgICAgaWYgKCghY29udGVudFR5cGUubWF0Y2goL2NoYXJzZXQ9LykpICYmIChib2R5IGluc3RhbmNlb2YgQXJyYXlCdWZmZXIgfHwgaXNBcnJheUJ1ZmZlclZpZXcoYm9keSkpKSB7XG4gICAgICAgIGNvbnRlbnRUeXBlICs9ICAnOyBjaGFyc2V0PWJpbmFyeSc7XG4gICAgICB9XG4gICAgICB2YXIgaGVhZGVycyA9IHsgJ0NvbnRlbnQtVHlwZSc6IGNvbnRlbnRUeXBlIH07XG4gICAgICBpZiAodGhpcy5zdXBwb3J0c1JldnMpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMuaWZNYXRjaCkge1xuICAgICAgICAgIGhlYWRlcnNbJ0lmLU1hdGNoJ10gPSBhZGRRdW90ZXMob3B0aW9ucy5pZk1hdGNoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucy5pZk5vbmVNYXRjaCkge1xuICAgICAgICAgIGhlYWRlcnNbJ0lmLU5vbmUtTWF0Y2gnXSA9IGFkZFF1b3RlcyhvcHRpb25zLmlmTm9uZU1hdGNoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuX3JlcXVlc3QoJ1BVVCcsIHRoaXMuaHJlZiArIGNsZWFuUGF0aChwYXRoKSwgdGhpcy50b2tlbixcbiAgICAgICAgICAgICAgICAgICAgIGhlYWRlcnMsIGJvZHksIHRoaXMuc3VwcG9ydHNSZXZzKTtcbiAgICB9LFxuXG4gICAgJ2RlbGV0ZSc6IGZ1bmN0aW9uIChwYXRoLCBvcHRpb25zKSB7XG4gICAgICBpZiAoIXRoaXMuY29ubmVjdGVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignbm90IGNvbm5lY3RlZCAocGF0aDogJyArIHBhdGggKyAnKScpO1xuICAgICAgfVxuICAgICAgaWYgKCFvcHRpb25zKSB7IG9wdGlvbnMgPSB7fTsgfVxuICAgICAgdmFyIGhlYWRlcnMgPSB7fTtcbiAgICAgIGlmICh0aGlzLnN1cHBvcnRzUmV2cykge1xuICAgICAgICBpZiAob3B0aW9ucy5pZk1hdGNoKSB7XG4gICAgICAgICAgaGVhZGVyc1snSWYtTWF0Y2gnXSA9IGFkZFF1b3RlcyhvcHRpb25zLmlmTWF0Y2gpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5fcmVxdWVzdCgnREVMRVRFJywgdGhpcy5ocmVmICsgY2xlYW5QYXRoKHBhdGgpLCB0aGlzLnRva2VuLFxuICAgICAgICAgICAgICAgICAgICAgaGVhZGVycyxcbiAgICAgICAgICAgICAgICAgICAgIHVuZGVmaW5lZCwgdGhpcy5zdXBwb3J0c1JldnMpO1xuICAgIH1cbiAgfTtcblxuICAvLyBTaGFyZWQgY2xlYW5QYXRoIHVzZWQgYnkgRHJvcGJveFxuICBXaXJlQ2xpZW50LmNsZWFuUGF0aCA9IGNsZWFuUGF0aDtcblxuICAvLyBTaGFyZWQgaXNBcnJheUJ1ZmZlclZpZXcgdXNlZCBieSBXaXJlQ2xpZW50IGFuZCBEcm9wYm94XG4gIFdpcmVDbGllbnQuaXNBcnJheUJ1ZmZlclZpZXcgPSBpc0FycmF5QnVmZmVyVmlldztcblxuICBXaXJlQ2xpZW50LnJlYWRCaW5hcnlEYXRhID0gcmVhZEJpbmFyeURhdGE7XG5cbiAgLy8gU2hhcmVkIHJlcXVlc3QgZnVuY3Rpb24gdXNlZCBieSBXaXJlQ2xpZW50LCBHb29nbGVEcml2ZSBhbmQgRHJvcGJveC5cbiAgV2lyZUNsaWVudC5yZXF1ZXN0ID0gZnVuY3Rpb24gKG1ldGhvZCwgdXJsLCBvcHRpb25zKSB7XG4gICAgdmFyIHBlbmRpbmcgPSBQcm9taXNlLmRlZmVyKCk7XG4gICAgbG9nKCdbV2lyZUNsaWVudF0nLCBtZXRob2QsIHVybCk7XG5cbiAgICB2YXIgdGltZWRPdXQgPSBmYWxzZTtcblxuICAgIHZhciB0aW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgdGltZWRPdXQgPSB0cnVlO1xuICAgICAgcGVuZGluZy5yZWplY3QoJ3RpbWVvdXQnKTtcbiAgICB9LCBXaXJlQ2xpZW50LlJFUVVFU1RfVElNRU9VVCk7XG5cbiAgICB2YXIgeGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG4gICAgeGhyLm9wZW4obWV0aG9kLCB1cmwsIHRydWUpO1xuXG4gICAgaWYgKG9wdGlvbnMucmVzcG9uc2VUeXBlKSB7XG4gICAgICB4aHIucmVzcG9uc2VUeXBlID0gb3B0aW9ucy5yZXNwb25zZVR5cGU7XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMuaGVhZGVycykge1xuICAgICAgZm9yICh2YXIga2V5IGluIG9wdGlvbnMuaGVhZGVycykge1xuICAgICAgICB4aHIuc2V0UmVxdWVzdEhlYWRlcihrZXksIG9wdGlvbnMuaGVhZGVyc1trZXldKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB4aHIub25sb2FkID0gZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKHRpbWVkT3V0KSB7IHJldHVybjsgfVxuICAgICAgY2xlYXJUaW1lb3V0KHRpbWVyKTtcbiAgICAgIHBlbmRpbmcucmVzb2x2ZSh4aHIpO1xuICAgIH07XG5cbiAgICB4aHIub25lcnJvciA9IGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgaWYgKHRpbWVkT3V0KSB7IHJldHVybjsgfVxuICAgICAgY2xlYXJUaW1lb3V0KHRpbWVyKTtcbiAgICAgIHBlbmRpbmcucmVqZWN0KGVycm9yKTtcbiAgICB9O1xuXG4gICAgdmFyIGJvZHkgPSBvcHRpb25zLmJvZHk7XG5cbiAgICBpZiAodHlwZW9mKGJvZHkpID09PSAnb2JqZWN0JyAmJiAhaXNBcnJheUJ1ZmZlclZpZXcoYm9keSkgJiYgYm9keSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG4gICAgICBib2R5ID0gbmV3IFVpbnQ4QXJyYXkoYm9keSk7XG4gICAgfVxuICAgIHhoci5zZW5kKGJvZHkpO1xuICAgIHJldHVybiBwZW5kaW5nLnByb21pc2U7XG4gIH07XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFdpcmVDbGllbnQucHJvdG90eXBlLCAnc3RvcmFnZVR5cGUnLCB7XG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAodGhpcy5zdG9yYWdlQXBpKSB7XG4gICAgICAgIHZhciBzcGVjID0gdGhpcy5zdG9yYWdlQXBpLm1hdGNoKC9kcmFmdC1kZWpvbmctKHJlbW90ZXN0b3JhZ2UtXFxkXFxkKS8pO1xuICAgICAgICByZXR1cm4gc3BlYyA/IHNwZWNbMV0gOiAnMjAxMi4wNCc7XG4gICAgICB9XG4gICAgfVxuICB9KTtcblxuXG4gIFdpcmVDbGllbnQuX3JzX2luaXQgPSBmdW5jdGlvbiAocmVtb3RlU3RvcmFnZSkge1xuICAgIGhhc0xvY2FsU3RvcmFnZSA9IHV0aWwubG9jYWxTdG9yYWdlQXZhaWxhYmxlKCk7XG4gICAgcmVtb3RlU3RvcmFnZS5yZW1vdGUgPSBuZXcgV2lyZUNsaWVudChyZW1vdGVTdG9yYWdlKTtcbiAgICB0aGlzLm9ubGluZSA9IHRydWU7XG4gIH07XG5cbiAgV2lyZUNsaWVudC5fcnNfc3VwcG9ydGVkID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiAhISBYTUxIdHRwUmVxdWVzdDtcbiAgfTtcblxuICBXaXJlQ2xpZW50Ll9yc19jbGVhbnVwID0gZnVuY3Rpb24gKHJlbW90ZVN0b3JhZ2Upe1xuICAgIGlmIChoYXNMb2NhbFN0b3JhZ2Upe1xuICAgICAgZGVsZXRlIGxvY2FsU3RvcmFnZVtTRVRUSU5HU19LRVldO1xuICAgIH1cbiAgICByZW1vdGVTdG9yYWdlLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2Vycm9yJywgb25FcnJvckNiKTtcbiAgfTtcblxuXG4gIG1vZHVsZS5leHBvcnRzID0gV2lyZUNsaWVudDtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy93aXJlY2xpZW50LmpzIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ },
/* 13 */
/***/ function(module, exports, __webpack_require__) {

	eval("/* WEBPACK VAR INJECTION */(function(Buffer, global) {/*!\n * The buffer module from node.js, for the browser.\n *\n * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>\n * @license  MIT\n */\n/* eslint-disable no-proto */\n\n'use strict'\n\nvar base64 = __webpack_require__(14)\nvar ieee754 = __webpack_require__(15)\nvar isArray = __webpack_require__(16)\n\nexports.Buffer = Buffer\nexports.SlowBuffer = SlowBuffer\nexports.INSPECT_MAX_BYTES = 50\n\n/**\n * If `Buffer.TYPED_ARRAY_SUPPORT`:\n *   === true    Use Uint8Array implementation (fastest)\n *   === false   Use Object implementation (most compatible, even IE6)\n *\n * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,\n * Opera 11.6+, iOS 4.2+.\n *\n * Due to various browser bugs, sometimes the Object implementation will be used even\n * when the browser supports typed arrays.\n *\n * Note:\n *\n *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,\n *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.\n *\n *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.\n *\n *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of\n *     incorrect length in some situations.\n\n * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they\n * get the Object implementation, which is slower but behaves correctly.\n */\nBuffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined\n  ? global.TYPED_ARRAY_SUPPORT\n  : typedArraySupport()\n\n/*\n * Export kMaxLength after typed array support is determined.\n */\nexports.kMaxLength = kMaxLength()\n\nfunction typedArraySupport () {\n  try {\n    var arr = new Uint8Array(1)\n    arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}\n    return arr.foo() === 42 && // typed array instances can be augmented\n        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`\n        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`\n  } catch (e) {\n    return false\n  }\n}\n\nfunction kMaxLength () {\n  return Buffer.TYPED_ARRAY_SUPPORT\n    ? 0x7fffffff\n    : 0x3fffffff\n}\n\nfunction createBuffer (that, length) {\n  if (kMaxLength() < length) {\n    throw new RangeError('Invalid typed array length')\n  }\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    // Return an augmented `Uint8Array` instance, for best performance\n    that = new Uint8Array(length)\n    that.__proto__ = Buffer.prototype\n  } else {\n    // Fallback: Return an object instance of the Buffer class\n    if (that === null) {\n      that = new Buffer(length)\n    }\n    that.length = length\n  }\n\n  return that\n}\n\n/**\n * The Buffer constructor returns instances of `Uint8Array` that have their\n * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of\n * `Uint8Array`, so the returned instances will have all the node `Buffer` methods\n * and the `Uint8Array` methods. Square bracket notation works as expected -- it\n * returns a single octet.\n *\n * The `Uint8Array` prototype remains unmodified.\n */\n\nfunction Buffer (arg, encodingOrOffset, length) {\n  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {\n    return new Buffer(arg, encodingOrOffset, length)\n  }\n\n  // Common case.\n  if (typeof arg === 'number') {\n    if (typeof encodingOrOffset === 'string') {\n      throw new Error(\n        'If encoding is specified then the first argument must be a string'\n      )\n    }\n    return allocUnsafe(this, arg)\n  }\n  return from(this, arg, encodingOrOffset, length)\n}\n\nBuffer.poolSize = 8192 // not used by this implementation\n\n// TODO: Legacy, not needed anymore. Remove in next major version.\nBuffer._augment = function (arr) {\n  arr.__proto__ = Buffer.prototype\n  return arr\n}\n\nfunction from (that, value, encodingOrOffset, length) {\n  if (typeof value === 'number') {\n    throw new TypeError('\"value\" argument must not be a number')\n  }\n\n  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {\n    return fromArrayBuffer(that, value, encodingOrOffset, length)\n  }\n\n  if (typeof value === 'string') {\n    return fromString(that, value, encodingOrOffset)\n  }\n\n  return fromObject(that, value)\n}\n\n/**\n * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError\n * if value is a number.\n * Buffer.from(str[, encoding])\n * Buffer.from(array)\n * Buffer.from(buffer)\n * Buffer.from(arrayBuffer[, byteOffset[, length]])\n **/\nBuffer.from = function (value, encodingOrOffset, length) {\n  return from(null, value, encodingOrOffset, length)\n}\n\nif (Buffer.TYPED_ARRAY_SUPPORT) {\n  Buffer.prototype.__proto__ = Uint8Array.prototype\n  Buffer.__proto__ = Uint8Array\n  if (typeof Symbol !== 'undefined' && Symbol.species &&\n      Buffer[Symbol.species] === Buffer) {\n    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97\n    Object.defineProperty(Buffer, Symbol.species, {\n      value: null,\n      configurable: true\n    })\n  }\n}\n\nfunction assertSize (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('\"size\" argument must be a number')\n  } else if (size < 0) {\n    throw new RangeError('\"size\" argument must not be negative')\n  }\n}\n\nfunction alloc (that, size, fill, encoding) {\n  assertSize(size)\n  if (size <= 0) {\n    return createBuffer(that, size)\n  }\n  if (fill !== undefined) {\n    // Only pay attention to encoding if it's a string. This\n    // prevents accidentally sending in a number that would\n    // be interpretted as a start offset.\n    return typeof encoding === 'string'\n      ? createBuffer(that, size).fill(fill, encoding)\n      : createBuffer(that, size).fill(fill)\n  }\n  return createBuffer(that, size)\n}\n\n/**\n * Creates a new filled Buffer instance.\n * alloc(size[, fill[, encoding]])\n **/\nBuffer.alloc = function (size, fill, encoding) {\n  return alloc(null, size, fill, encoding)\n}\n\nfunction allocUnsafe (that, size) {\n  assertSize(size)\n  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) {\n    for (var i = 0; i < size; ++i) {\n      that[i] = 0\n    }\n  }\n  return that\n}\n\n/**\n * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.\n * */\nBuffer.allocUnsafe = function (size) {\n  return allocUnsafe(null, size)\n}\n/**\n * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.\n */\nBuffer.allocUnsafeSlow = function (size) {\n  return allocUnsafe(null, size)\n}\n\nfunction fromString (that, string, encoding) {\n  if (typeof encoding !== 'string' || encoding === '') {\n    encoding = 'utf8'\n  }\n\n  if (!Buffer.isEncoding(encoding)) {\n    throw new TypeError('\"encoding\" must be a valid string encoding')\n  }\n\n  var length = byteLength(string, encoding) | 0\n  that = createBuffer(that, length)\n\n  var actual = that.write(string, encoding)\n\n  if (actual !== length) {\n    // Writing a hex string, for example, that contains invalid characters will\n    // cause everything after the first invalid character to be ignored. (e.g.\n    // 'abxxcd' will be treated as 'ab')\n    that = that.slice(0, actual)\n  }\n\n  return that\n}\n\nfunction fromArrayLike (that, array) {\n  var length = array.length < 0 ? 0 : checked(array.length) | 0\n  that = createBuffer(that, length)\n  for (var i = 0; i < length; i += 1) {\n    that[i] = array[i] & 255\n  }\n  return that\n}\n\nfunction fromArrayBuffer (that, array, byteOffset, length) {\n  array.byteLength // this throws if `array` is not a valid ArrayBuffer\n\n  if (byteOffset < 0 || array.byteLength < byteOffset) {\n    throw new RangeError('\\'offset\\' is out of bounds')\n  }\n\n  if (array.byteLength < byteOffset + (length || 0)) {\n    throw new RangeError('\\'length\\' is out of bounds')\n  }\n\n  if (byteOffset === undefined && length === undefined) {\n    array = new Uint8Array(array)\n  } else if (length === undefined) {\n    array = new Uint8Array(array, byteOffset)\n  } else {\n    array = new Uint8Array(array, byteOffset, length)\n  }\n\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    // Return an augmented `Uint8Array` instance, for best performance\n    that = array\n    that.__proto__ = Buffer.prototype\n  } else {\n    // Fallback: Return an object instance of the Buffer class\n    that = fromArrayLike(that, array)\n  }\n  return that\n}\n\nfunction fromObject (that, obj) {\n  if (Buffer.isBuffer(obj)) {\n    var len = checked(obj.length) | 0\n    that = createBuffer(that, len)\n\n    if (that.length === 0) {\n      return that\n    }\n\n    obj.copy(that, 0, 0, len)\n    return that\n  }\n\n  if (obj) {\n    if ((typeof ArrayBuffer !== 'undefined' &&\n        obj.buffer instanceof ArrayBuffer) || 'length' in obj) {\n      if (typeof obj.length !== 'number' || isnan(obj.length)) {\n        return createBuffer(that, 0)\n      }\n      return fromArrayLike(that, obj)\n    }\n\n    if (obj.type === 'Buffer' && isArray(obj.data)) {\n      return fromArrayLike(that, obj.data)\n    }\n  }\n\n  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')\n}\n\nfunction checked (length) {\n  // Note: cannot use `length < kMaxLength()` here because that fails when\n  // length is NaN (which is otherwise coerced to zero.)\n  if (length >= kMaxLength()) {\n    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +\n                         'size: 0x' + kMaxLength().toString(16) + ' bytes')\n  }\n  return length | 0\n}\n\nfunction SlowBuffer (length) {\n  if (+length != length) { // eslint-disable-line eqeqeq\n    length = 0\n  }\n  return Buffer.alloc(+length)\n}\n\nBuffer.isBuffer = function isBuffer (b) {\n  return !!(b != null && b._isBuffer)\n}\n\nBuffer.compare = function compare (a, b) {\n  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {\n    throw new TypeError('Arguments must be Buffers')\n  }\n\n  if (a === b) return 0\n\n  var x = a.length\n  var y = b.length\n\n  for (var i = 0, len = Math.min(x, y); i < len; ++i) {\n    if (a[i] !== b[i]) {\n      x = a[i]\n      y = b[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\nBuffer.isEncoding = function isEncoding (encoding) {\n  switch (String(encoding).toLowerCase()) {\n    case 'hex':\n    case 'utf8':\n    case 'utf-8':\n    case 'ascii':\n    case 'latin1':\n    case 'binary':\n    case 'base64':\n    case 'ucs2':\n    case 'ucs-2':\n    case 'utf16le':\n    case 'utf-16le':\n      return true\n    default:\n      return false\n  }\n}\n\nBuffer.concat = function concat (list, length) {\n  if (!isArray(list)) {\n    throw new TypeError('\"list\" argument must be an Array of Buffers')\n  }\n\n  if (list.length === 0) {\n    return Buffer.alloc(0)\n  }\n\n  var i\n  if (length === undefined) {\n    length = 0\n    for (i = 0; i < list.length; ++i) {\n      length += list[i].length\n    }\n  }\n\n  var buffer = Buffer.allocUnsafe(length)\n  var pos = 0\n  for (i = 0; i < list.length; ++i) {\n    var buf = list[i]\n    if (!Buffer.isBuffer(buf)) {\n      throw new TypeError('\"list\" argument must be an Array of Buffers')\n    }\n    buf.copy(buffer, pos)\n    pos += buf.length\n  }\n  return buffer\n}\n\nfunction byteLength (string, encoding) {\n  if (Buffer.isBuffer(string)) {\n    return string.length\n  }\n  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&\n      (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {\n    return string.byteLength\n  }\n  if (typeof string !== 'string') {\n    string = '' + string\n  }\n\n  var len = string.length\n  if (len === 0) return 0\n\n  // Use a for loop to avoid recursion\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'ascii':\n      case 'latin1':\n      case 'binary':\n        return len\n      case 'utf8':\n      case 'utf-8':\n      case undefined:\n        return utf8ToBytes(string).length\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return len * 2\n      case 'hex':\n        return len >>> 1\n      case 'base64':\n        return base64ToBytes(string).length\n      default:\n        if (loweredCase) return utf8ToBytes(string).length // assume utf8\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\nBuffer.byteLength = byteLength\n\nfunction slowToString (encoding, start, end) {\n  var loweredCase = false\n\n  // No need to verify that \"this.length <= MAX_UINT32\" since it's a read-only\n  // property of a typed array.\n\n  // This behaves neither like String nor Uint8Array in that we set start/end\n  // to their upper/lower bounds if the value passed is out of range.\n  // undefined is handled specially as per ECMA-262 6th Edition,\n  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.\n  if (start === undefined || start < 0) {\n    start = 0\n  }\n  // Return early if start > this.length. Done here to prevent potential uint32\n  // coercion fail below.\n  if (start > this.length) {\n    return ''\n  }\n\n  if (end === undefined || end > this.length) {\n    end = this.length\n  }\n\n  if (end <= 0) {\n    return ''\n  }\n\n  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.\n  end >>>= 0\n  start >>>= 0\n\n  if (end <= start) {\n    return ''\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  while (true) {\n    switch (encoding) {\n      case 'hex':\n        return hexSlice(this, start, end)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Slice(this, start, end)\n\n      case 'ascii':\n        return asciiSlice(this, start, end)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Slice(this, start, end)\n\n      case 'base64':\n        return base64Slice(this, start, end)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return utf16leSlice(this, start, end)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = (encoding + '').toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\n// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect\n// Buffer instances.\nBuffer.prototype._isBuffer = true\n\nfunction swap (b, n, m) {\n  var i = b[n]\n  b[n] = b[m]\n  b[m] = i\n}\n\nBuffer.prototype.swap16 = function swap16 () {\n  var len = this.length\n  if (len % 2 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 16-bits')\n  }\n  for (var i = 0; i < len; i += 2) {\n    swap(this, i, i + 1)\n  }\n  return this\n}\n\nBuffer.prototype.swap32 = function swap32 () {\n  var len = this.length\n  if (len % 4 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 32-bits')\n  }\n  for (var i = 0; i < len; i += 4) {\n    swap(this, i, i + 3)\n    swap(this, i + 1, i + 2)\n  }\n  return this\n}\n\nBuffer.prototype.swap64 = function swap64 () {\n  var len = this.length\n  if (len % 8 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 64-bits')\n  }\n  for (var i = 0; i < len; i += 8) {\n    swap(this, i, i + 7)\n    swap(this, i + 1, i + 6)\n    swap(this, i + 2, i + 5)\n    swap(this, i + 3, i + 4)\n  }\n  return this\n}\n\nBuffer.prototype.toString = function toString () {\n  var length = this.length | 0\n  if (length === 0) return ''\n  if (arguments.length === 0) return utf8Slice(this, 0, length)\n  return slowToString.apply(this, arguments)\n}\n\nBuffer.prototype.equals = function equals (b) {\n  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')\n  if (this === b) return true\n  return Buffer.compare(this, b) === 0\n}\n\nBuffer.prototype.inspect = function inspect () {\n  var str = ''\n  var max = exports.INSPECT_MAX_BYTES\n  if (this.length > 0) {\n    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')\n    if (this.length > max) str += ' ... '\n  }\n  return '<Buffer ' + str + '>'\n}\n\nBuffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {\n  if (!Buffer.isBuffer(target)) {\n    throw new TypeError('Argument must be a Buffer')\n  }\n\n  if (start === undefined) {\n    start = 0\n  }\n  if (end === undefined) {\n    end = target ? target.length : 0\n  }\n  if (thisStart === undefined) {\n    thisStart = 0\n  }\n  if (thisEnd === undefined) {\n    thisEnd = this.length\n  }\n\n  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {\n    throw new RangeError('out of range index')\n  }\n\n  if (thisStart >= thisEnd && start >= end) {\n    return 0\n  }\n  if (thisStart >= thisEnd) {\n    return -1\n  }\n  if (start >= end) {\n    return 1\n  }\n\n  start >>>= 0\n  end >>>= 0\n  thisStart >>>= 0\n  thisEnd >>>= 0\n\n  if (this === target) return 0\n\n  var x = thisEnd - thisStart\n  var y = end - start\n  var len = Math.min(x, y)\n\n  var thisCopy = this.slice(thisStart, thisEnd)\n  var targetCopy = target.slice(start, end)\n\n  for (var i = 0; i < len; ++i) {\n    if (thisCopy[i] !== targetCopy[i]) {\n      x = thisCopy[i]\n      y = targetCopy[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\n// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,\n// OR the last index of `val` in `buffer` at offset <= `byteOffset`.\n//\n// Arguments:\n// - buffer - a Buffer to search\n// - val - a string, Buffer, or number\n// - byteOffset - an index into `buffer`; will be clamped to an int32\n// - encoding - an optional encoding, relevant is val is a string\n// - dir - true for indexOf, false for lastIndexOf\nfunction bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {\n  // Empty buffer means no match\n  if (buffer.length === 0) return -1\n\n  // Normalize byteOffset\n  if (typeof byteOffset === 'string') {\n    encoding = byteOffset\n    byteOffset = 0\n  } else if (byteOffset > 0x7fffffff) {\n    byteOffset = 0x7fffffff\n  } else if (byteOffset < -0x80000000) {\n    byteOffset = -0x80000000\n  }\n  byteOffset = +byteOffset  // Coerce to Number.\n  if (isNaN(byteOffset)) {\n    // byteOffset: it it's undefined, null, NaN, \"foo\", etc, search whole buffer\n    byteOffset = dir ? 0 : (buffer.length - 1)\n  }\n\n  // Normalize byteOffset: negative offsets start from the end of the buffer\n  if (byteOffset < 0) byteOffset = buffer.length + byteOffset\n  if (byteOffset >= buffer.length) {\n    if (dir) return -1\n    else byteOffset = buffer.length - 1\n  } else if (byteOffset < 0) {\n    if (dir) byteOffset = 0\n    else return -1\n  }\n\n  // Normalize val\n  if (typeof val === 'string') {\n    val = Buffer.from(val, encoding)\n  }\n\n  // Finally, search either indexOf (if dir is true) or lastIndexOf\n  if (Buffer.isBuffer(val)) {\n    // Special case: looking for empty string/buffer always fails\n    if (val.length === 0) {\n      return -1\n    }\n    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)\n  } else if (typeof val === 'number') {\n    val = val & 0xFF // Search for a byte value [0-255]\n    if (Buffer.TYPED_ARRAY_SUPPORT &&\n        typeof Uint8Array.prototype.indexOf === 'function') {\n      if (dir) {\n        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)\n      } else {\n        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)\n      }\n    }\n    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)\n  }\n\n  throw new TypeError('val must be string, number or Buffer')\n}\n\nfunction arrayIndexOf (arr, val, byteOffset, encoding, dir) {\n  var indexSize = 1\n  var arrLength = arr.length\n  var valLength = val.length\n\n  if (encoding !== undefined) {\n    encoding = String(encoding).toLowerCase()\n    if (encoding === 'ucs2' || encoding === 'ucs-2' ||\n        encoding === 'utf16le' || encoding === 'utf-16le') {\n      if (arr.length < 2 || val.length < 2) {\n        return -1\n      }\n      indexSize = 2\n      arrLength /= 2\n      valLength /= 2\n      byteOffset /= 2\n    }\n  }\n\n  function read (buf, i) {\n    if (indexSize === 1) {\n      return buf[i]\n    } else {\n      return buf.readUInt16BE(i * indexSize)\n    }\n  }\n\n  var i\n  if (dir) {\n    var foundIndex = -1\n    for (i = byteOffset; i < arrLength; i++) {\n      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {\n        if (foundIndex === -1) foundIndex = i\n        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize\n      } else {\n        if (foundIndex !== -1) i -= i - foundIndex\n        foundIndex = -1\n      }\n    }\n  } else {\n    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength\n    for (i = byteOffset; i >= 0; i--) {\n      var found = true\n      for (var j = 0; j < valLength; j++) {\n        if (read(arr, i + j) !== read(val, j)) {\n          found = false\n          break\n        }\n      }\n      if (found) return i\n    }\n  }\n\n  return -1\n}\n\nBuffer.prototype.includes = function includes (val, byteOffset, encoding) {\n  return this.indexOf(val, byteOffset, encoding) !== -1\n}\n\nBuffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)\n}\n\nBuffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)\n}\n\nfunction hexWrite (buf, string, offset, length) {\n  offset = Number(offset) || 0\n  var remaining = buf.length - offset\n  if (!length) {\n    length = remaining\n  } else {\n    length = Number(length)\n    if (length > remaining) {\n      length = remaining\n    }\n  }\n\n  // must be an even number of digits\n  var strLen = string.length\n  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')\n\n  if (length > strLen / 2) {\n    length = strLen / 2\n  }\n  for (var i = 0; i < length; ++i) {\n    var parsed = parseInt(string.substr(i * 2, 2), 16)\n    if (isNaN(parsed)) return i\n    buf[offset + i] = parsed\n  }\n  return i\n}\n\nfunction utf8Write (buf, string, offset, length) {\n  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nfunction asciiWrite (buf, string, offset, length) {\n  return blitBuffer(asciiToBytes(string), buf, offset, length)\n}\n\nfunction latin1Write (buf, string, offset, length) {\n  return asciiWrite(buf, string, offset, length)\n}\n\nfunction base64Write (buf, string, offset, length) {\n  return blitBuffer(base64ToBytes(string), buf, offset, length)\n}\n\nfunction ucs2Write (buf, string, offset, length) {\n  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nBuffer.prototype.write = function write (string, offset, length, encoding) {\n  // Buffer#write(string)\n  if (offset === undefined) {\n    encoding = 'utf8'\n    length = this.length\n    offset = 0\n  // Buffer#write(string, encoding)\n  } else if (length === undefined && typeof offset === 'string') {\n    encoding = offset\n    length = this.length\n    offset = 0\n  // Buffer#write(string, offset[, length][, encoding])\n  } else if (isFinite(offset)) {\n    offset = offset | 0\n    if (isFinite(length)) {\n      length = length | 0\n      if (encoding === undefined) encoding = 'utf8'\n    } else {\n      encoding = length\n      length = undefined\n    }\n  // legacy write(string, encoding, offset, length) - remove in v0.13\n  } else {\n    throw new Error(\n      'Buffer.write(string, encoding, offset[, length]) is no longer supported'\n    )\n  }\n\n  var remaining = this.length - offset\n  if (length === undefined || length > remaining) length = remaining\n\n  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {\n    throw new RangeError('Attempt to write outside buffer bounds')\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'hex':\n        return hexWrite(this, string, offset, length)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Write(this, string, offset, length)\n\n      case 'ascii':\n        return asciiWrite(this, string, offset, length)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Write(this, string, offset, length)\n\n      case 'base64':\n        // Warning: maxLength not taken into account in base64Write\n        return base64Write(this, string, offset, length)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return ucs2Write(this, string, offset, length)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\nBuffer.prototype.toJSON = function toJSON () {\n  return {\n    type: 'Buffer',\n    data: Array.prototype.slice.call(this._arr || this, 0)\n  }\n}\n\nfunction base64Slice (buf, start, end) {\n  if (start === 0 && end === buf.length) {\n    return base64.fromByteArray(buf)\n  } else {\n    return base64.fromByteArray(buf.slice(start, end))\n  }\n}\n\nfunction utf8Slice (buf, start, end) {\n  end = Math.min(buf.length, end)\n  var res = []\n\n  var i = start\n  while (i < end) {\n    var firstByte = buf[i]\n    var codePoint = null\n    var bytesPerSequence = (firstByte > 0xEF) ? 4\n      : (firstByte > 0xDF) ? 3\n      : (firstByte > 0xBF) ? 2\n      : 1\n\n    if (i + bytesPerSequence <= end) {\n      var secondByte, thirdByte, fourthByte, tempCodePoint\n\n      switch (bytesPerSequence) {\n        case 1:\n          if (firstByte < 0x80) {\n            codePoint = firstByte\n          }\n          break\n        case 2:\n          secondByte = buf[i + 1]\n          if ((secondByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)\n            if (tempCodePoint > 0x7F) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 3:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)\n            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 4:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          fourthByte = buf[i + 3]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)\n            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {\n              codePoint = tempCodePoint\n            }\n          }\n      }\n    }\n\n    if (codePoint === null) {\n      // we did not generate a valid codePoint so insert a\n      // replacement char (U+FFFD) and advance only 1 byte\n      codePoint = 0xFFFD\n      bytesPerSequence = 1\n    } else if (codePoint > 0xFFFF) {\n      // encode to utf16 (surrogate pair dance)\n      codePoint -= 0x10000\n      res.push(codePoint >>> 10 & 0x3FF | 0xD800)\n      codePoint = 0xDC00 | codePoint & 0x3FF\n    }\n\n    res.push(codePoint)\n    i += bytesPerSequence\n  }\n\n  return decodeCodePointsArray(res)\n}\n\n// Based on http://stackoverflow.com/a/22747272/680742, the browser with\n// the lowest limit is Chrome, with 0x10000 args.\n// We go 1 magnitude less, for safety\nvar MAX_ARGUMENTS_LENGTH = 0x1000\n\nfunction decodeCodePointsArray (codePoints) {\n  var len = codePoints.length\n  if (len <= MAX_ARGUMENTS_LENGTH) {\n    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()\n  }\n\n  // Decode in chunks to avoid \"call stack size exceeded\".\n  var res = ''\n  var i = 0\n  while (i < len) {\n    res += String.fromCharCode.apply(\n      String,\n      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)\n    )\n  }\n  return res\n}\n\nfunction asciiSlice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i] & 0x7F)\n  }\n  return ret\n}\n\nfunction latin1Slice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i])\n  }\n  return ret\n}\n\nfunction hexSlice (buf, start, end) {\n  var len = buf.length\n\n  if (!start || start < 0) start = 0\n  if (!end || end < 0 || end > len) end = len\n\n  var out = ''\n  for (var i = start; i < end; ++i) {\n    out += toHex(buf[i])\n  }\n  return out\n}\n\nfunction utf16leSlice (buf, start, end) {\n  var bytes = buf.slice(start, end)\n  var res = ''\n  for (var i = 0; i < bytes.length; i += 2) {\n    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)\n  }\n  return res\n}\n\nBuffer.prototype.slice = function slice (start, end) {\n  var len = this.length\n  start = ~~start\n  end = end === undefined ? len : ~~end\n\n  if (start < 0) {\n    start += len\n    if (start < 0) start = 0\n  } else if (start > len) {\n    start = len\n  }\n\n  if (end < 0) {\n    end += len\n    if (end < 0) end = 0\n  } else if (end > len) {\n    end = len\n  }\n\n  if (end < start) end = start\n\n  var newBuf\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    newBuf = this.subarray(start, end)\n    newBuf.__proto__ = Buffer.prototype\n  } else {\n    var sliceLen = end - start\n    newBuf = new Buffer(sliceLen, undefined)\n    for (var i = 0; i < sliceLen; ++i) {\n      newBuf[i] = this[i + start]\n    }\n  }\n\n  return newBuf\n}\n\n/*\n * Need to make sure that buffer isn't trying to write out of bounds.\n */\nfunction checkOffset (offset, ext, length) {\n  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')\n  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')\n}\n\nBuffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    checkOffset(offset, byteLength, this.length)\n  }\n\n  var val = this[offset + --byteLength]\n  var mul = 1\n  while (byteLength > 0 && (mul *= 0x100)) {\n    val += this[offset + --byteLength] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  return this[offset]\n}\n\nBuffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return this[offset] | (this[offset + 1] << 8)\n}\n\nBuffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return (this[offset] << 8) | this[offset + 1]\n}\n\nBuffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return ((this[offset]) |\n      (this[offset + 1] << 8) |\n      (this[offset + 2] << 16)) +\n      (this[offset + 3] * 0x1000000)\n}\n\nBuffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] * 0x1000000) +\n    ((this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    this[offset + 3])\n}\n\nBuffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var i = byteLength\n  var mul = 1\n  var val = this[offset + --i]\n  while (i > 0 && (mul *= 0x100)) {\n    val += this[offset + --i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readInt8 = function readInt8 (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  if (!(this[offset] & 0x80)) return (this[offset])\n  return ((0xff - this[offset] + 1) * -1)\n}\n\nBuffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset] | (this[offset + 1] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset + 1] | (this[offset] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset]) |\n    (this[offset + 1] << 8) |\n    (this[offset + 2] << 16) |\n    (this[offset + 3] << 24)\n}\n\nBuffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] << 24) |\n    (this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    (this[offset + 3])\n}\n\nBuffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, true, 23, 4)\n}\n\nBuffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, false, 23, 4)\n}\n\nBuffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, true, 52, 8)\n}\n\nBuffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, false, 52, 8)\n}\n\nfunction checkInt (buf, value, offset, ext, max, min) {\n  if (!Buffer.isBuffer(buf)) throw new TypeError('\"buffer\" argument must be a Buffer instance')\n  if (value > max || value < min) throw new RangeError('\"value\" argument is out of bounds')\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n}\n\nBuffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  var mul = 1\n  var i = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  var i = byteLength - 1\n  var mul = 1\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nfunction objectWriteUInt16 (buf, value, offset, littleEndian) {\n  if (value < 0) value = 0xffff + value + 1\n  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {\n    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>\n      (littleEndian ? i : 1 - i) * 8\n  }\n}\n\nBuffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n  } else {\n    objectWriteUInt16(this, value, offset, true)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 8)\n    this[offset + 1] = (value & 0xff)\n  } else {\n    objectWriteUInt16(this, value, offset, false)\n  }\n  return offset + 2\n}\n\nfunction objectWriteUInt32 (buf, value, offset, littleEndian) {\n  if (value < 0) value = 0xffffffff + value + 1\n  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {\n    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff\n  }\n}\n\nBuffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset + 3] = (value >>> 24)\n    this[offset + 2] = (value >>> 16)\n    this[offset + 1] = (value >>> 8)\n    this[offset] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, true)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 24)\n    this[offset + 1] = (value >>> 16)\n    this[offset + 2] = (value >>> 8)\n    this[offset + 3] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, false)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) {\n    var limit = Math.pow(2, 8 * byteLength - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = 0\n  var mul = 1\n  var sub = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) {\n    var limit = Math.pow(2, 8 * byteLength - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = byteLength - 1\n  var mul = 1\n  var sub = 0\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)\n  if (value < 0) value = 0xff + value + 1\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nBuffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n  } else {\n    objectWriteUInt16(this, value, offset, true)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 8)\n    this[offset + 1] = (value & 0xff)\n  } else {\n    objectWriteUInt16(this, value, offset, false)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n    this[offset + 2] = (value >>> 16)\n    this[offset + 3] = (value >>> 24)\n  } else {\n    objectWriteUInt32(this, value, offset, true)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (value < 0) value = 0xffffffff + value + 1\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 24)\n    this[offset + 1] = (value >>> 16)\n    this[offset + 2] = (value >>> 8)\n    this[offset + 3] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, false)\n  }\n  return offset + 4\n}\n\nfunction checkIEEE754 (buf, value, offset, ext, max, min) {\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n  if (offset < 0) throw new RangeError('Index out of range')\n}\n\nfunction writeFloat (buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 23, 4)\n  return offset + 4\n}\n\nBuffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, false, noAssert)\n}\n\nfunction writeDouble (buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 52, 8)\n  return offset + 8\n}\n\nBuffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, false, noAssert)\n}\n\n// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\nBuffer.prototype.copy = function copy (target, targetStart, start, end) {\n  if (!start) start = 0\n  if (!end && end !== 0) end = this.length\n  if (targetStart >= target.length) targetStart = target.length\n  if (!targetStart) targetStart = 0\n  if (end > 0 && end < start) end = start\n\n  // Copy 0 bytes; we're done\n  if (end === start) return 0\n  if (target.length === 0 || this.length === 0) return 0\n\n  // Fatal error conditions\n  if (targetStart < 0) {\n    throw new RangeError('targetStart out of bounds')\n  }\n  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')\n  if (end < 0) throw new RangeError('sourceEnd out of bounds')\n\n  // Are we oob?\n  if (end > this.length) end = this.length\n  if (target.length - targetStart < end - start) {\n    end = target.length - targetStart + start\n  }\n\n  var len = end - start\n  var i\n\n  if (this === target && start < targetStart && targetStart < end) {\n    // descending copy from end\n    for (i = len - 1; i >= 0; --i) {\n      target[i + targetStart] = this[i + start]\n    }\n  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {\n    // ascending copy from start\n    for (i = 0; i < len; ++i) {\n      target[i + targetStart] = this[i + start]\n    }\n  } else {\n    Uint8Array.prototype.set.call(\n      target,\n      this.subarray(start, start + len),\n      targetStart\n    )\n  }\n\n  return len\n}\n\n// Usage:\n//    buffer.fill(number[, offset[, end]])\n//    buffer.fill(buffer[, offset[, end]])\n//    buffer.fill(string[, offset[, end]][, encoding])\nBuffer.prototype.fill = function fill (val, start, end, encoding) {\n  // Handle string cases:\n  if (typeof val === 'string') {\n    if (typeof start === 'string') {\n      encoding = start\n      start = 0\n      end = this.length\n    } else if (typeof end === 'string') {\n      encoding = end\n      end = this.length\n    }\n    if (val.length === 1) {\n      var code = val.charCodeAt(0)\n      if (code < 256) {\n        val = code\n      }\n    }\n    if (encoding !== undefined && typeof encoding !== 'string') {\n      throw new TypeError('encoding must be a string')\n    }\n    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {\n      throw new TypeError('Unknown encoding: ' + encoding)\n    }\n  } else if (typeof val === 'number') {\n    val = val & 255\n  }\n\n  // Invalid ranges are not set to a default, so can range check early.\n  if (start < 0 || this.length < start || this.length < end) {\n    throw new RangeError('Out of range index')\n  }\n\n  if (end <= start) {\n    return this\n  }\n\n  start = start >>> 0\n  end = end === undefined ? this.length : end >>> 0\n\n  if (!val) val = 0\n\n  var i\n  if (typeof val === 'number') {\n    for (i = start; i < end; ++i) {\n      this[i] = val\n    }\n  } else {\n    var bytes = Buffer.isBuffer(val)\n      ? val\n      : utf8ToBytes(new Buffer(val, encoding).toString())\n    var len = bytes.length\n    for (i = 0; i < end - start; ++i) {\n      this[i + start] = bytes[i % len]\n    }\n  }\n\n  return this\n}\n\n// HELPER FUNCTIONS\n// ================\n\nvar INVALID_BASE64_RE = /[^+\\/0-9A-Za-z-_]/g\n\nfunction base64clean (str) {\n  // Node strips out invalid characters like \\n and \\t from the string, base64-js does not\n  str = stringtrim(str).replace(INVALID_BASE64_RE, '')\n  // Node converts strings with length < 2 to ''\n  if (str.length < 2) return ''\n  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not\n  while (str.length % 4 !== 0) {\n    str = str + '='\n  }\n  return str\n}\n\nfunction stringtrim (str) {\n  if (str.trim) return str.trim()\n  return str.replace(/^\\s+|\\s+$/g, '')\n}\n\nfunction toHex (n) {\n  if (n < 16) return '0' + n.toString(16)\n  return n.toString(16)\n}\n\nfunction utf8ToBytes (string, units) {\n  units = units || Infinity\n  var codePoint\n  var length = string.length\n  var leadSurrogate = null\n  var bytes = []\n\n  for (var i = 0; i < length; ++i) {\n    codePoint = string.charCodeAt(i)\n\n    // is surrogate component\n    if (codePoint > 0xD7FF && codePoint < 0xE000) {\n      // last char was a lead\n      if (!leadSurrogate) {\n        // no lead yet\n        if (codePoint > 0xDBFF) {\n          // unexpected trail\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        } else if (i + 1 === length) {\n          // unpaired lead\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        }\n\n        // valid lead\n        leadSurrogate = codePoint\n\n        continue\n      }\n\n      // 2 leads in a row\n      if (codePoint < 0xDC00) {\n        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n        leadSurrogate = codePoint\n        continue\n      }\n\n      // valid surrogate pair\n      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000\n    } else if (leadSurrogate) {\n      // valid bmp char, but last char was a lead\n      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n    }\n\n    leadSurrogate = null\n\n    // encode utf8\n    if (codePoint < 0x80) {\n      if ((units -= 1) < 0) break\n      bytes.push(codePoint)\n    } else if (codePoint < 0x800) {\n      if ((units -= 2) < 0) break\n      bytes.push(\n        codePoint >> 0x6 | 0xC0,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x10000) {\n      if ((units -= 3) < 0) break\n      bytes.push(\n        codePoint >> 0xC | 0xE0,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x110000) {\n      if ((units -= 4) < 0) break\n      bytes.push(\n        codePoint >> 0x12 | 0xF0,\n        codePoint >> 0xC & 0x3F | 0x80,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else {\n      throw new Error('Invalid code point')\n    }\n  }\n\n  return bytes\n}\n\nfunction asciiToBytes (str) {\n  var byteArray = []\n  for (var i = 0; i < str.length; ++i) {\n    // Node's code seems to be doing this and not & 0x7F..\n    byteArray.push(str.charCodeAt(i) & 0xFF)\n  }\n  return byteArray\n}\n\nfunction utf16leToBytes (str, units) {\n  var c, hi, lo\n  var byteArray = []\n  for (var i = 0; i < str.length; ++i) {\n    if ((units -= 2) < 0) break\n\n    c = str.charCodeAt(i)\n    hi = c >> 8\n    lo = c % 256\n    byteArray.push(lo)\n    byteArray.push(hi)\n  }\n\n  return byteArray\n}\n\nfunction base64ToBytes (str) {\n  return base64.toByteArray(base64clean(str))\n}\n\nfunction blitBuffer (src, dst, offset, length) {\n  for (var i = 0; i < length; ++i) {\n    if ((i + offset >= dst.length) || (i >= src.length)) break\n    dst[i + offset] = src[i]\n  }\n  return i\n}\n\nfunction isnan (val) {\n  return val !== val // eslint-disable-line no-self-compare\n}\n\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(13).Buffer, (function() { return this; }())))\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vKHdlYnBhY2spL34vbm9kZS1saWJzLWJyb3dzZXIvfi9idWZmZXIvaW5kZXguanM/NzBlMSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixtREFBbUQ7QUFDeEU7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixVQUFVO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixZQUFZO0FBQzdCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsdUNBQXVDLFNBQVM7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxpQkFBaUI7QUFDaEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhLGlCQUFpQjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsU0FBUztBQUMxQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFNBQVM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFNBQVM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsRUFBRTtBQUNsRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxpQkFBaUIsU0FBUztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsZUFBZTtBQUN2QztBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSx3QkFBd0IsUUFBUTtBQUNoQztBQUNBLHFCQUFxQixlQUFlO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixZQUFZO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxxQkFBcUIsU0FBUztBQUM5QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEscUJBQXFCLFNBQVM7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EscUJBQXFCLFNBQVM7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLGtCQUFrQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsbUJBQW1CLGNBQWM7QUFDakM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHVEQUF1RCxPQUFPO0FBQzlEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx1REFBdUQsT0FBTztBQUM5RDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0I7QUFDbEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxxQkFBcUIsUUFBUTtBQUM3QjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsbUJBQW1CLFNBQVM7QUFDNUI7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsaUJBQWlCO0FBQ2hDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUJBQWlCLFlBQVk7QUFDN0I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlCQUFpQixnQkFBZ0I7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsZ0JBQWdCO0FBQ2pDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQixZQUFZO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBIiwiZmlsZSI6IjEzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiBUaGUgYnVmZmVyIG1vZHVsZSBmcm9tIG5vZGUuanMsIGZvciB0aGUgYnJvd3Nlci5cbiAqXG4gKiBAYXV0aG9yICAgRmVyb3NzIEFib3VraGFkaWplaCA8ZmVyb3NzQGZlcm9zcy5vcmc+IDxodHRwOi8vZmVyb3NzLm9yZz5cbiAqIEBsaWNlbnNlICBNSVRcbiAqL1xuLyogZXNsaW50LWRpc2FibGUgbm8tcHJvdG8gKi9cblxuJ3VzZSBzdHJpY3QnXG5cbnZhciBiYXNlNjQgPSByZXF1aXJlKCdiYXNlNjQtanMnKVxudmFyIGllZWU3NTQgPSByZXF1aXJlKCdpZWVlNzU0JylcbnZhciBpc0FycmF5ID0gcmVxdWlyZSgnaXNhcnJheScpXG5cbmV4cG9ydHMuQnVmZmVyID0gQnVmZmVyXG5leHBvcnRzLlNsb3dCdWZmZXIgPSBTbG93QnVmZmVyXG5leHBvcnRzLklOU1BFQ1RfTUFYX0JZVEVTID0gNTBcblxuLyoqXG4gKiBJZiBgQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlRgOlxuICogICA9PT0gdHJ1ZSAgICBVc2UgVWludDhBcnJheSBpbXBsZW1lbnRhdGlvbiAoZmFzdGVzdClcbiAqICAgPT09IGZhbHNlICAgVXNlIE9iamVjdCBpbXBsZW1lbnRhdGlvbiAobW9zdCBjb21wYXRpYmxlLCBldmVuIElFNilcbiAqXG4gKiBCcm93c2VycyB0aGF0IHN1cHBvcnQgdHlwZWQgYXJyYXlzIGFyZSBJRSAxMCssIEZpcmVmb3ggNCssIENocm9tZSA3KywgU2FmYXJpIDUuMSssXG4gKiBPcGVyYSAxMS42KywgaU9TIDQuMisuXG4gKlxuICogRHVlIHRvIHZhcmlvdXMgYnJvd3NlciBidWdzLCBzb21ldGltZXMgdGhlIE9iamVjdCBpbXBsZW1lbnRhdGlvbiB3aWxsIGJlIHVzZWQgZXZlblxuICogd2hlbiB0aGUgYnJvd3NlciBzdXBwb3J0cyB0eXBlZCBhcnJheXMuXG4gKlxuICogTm90ZTpcbiAqXG4gKiAgIC0gRmlyZWZveCA0LTI5IGxhY2tzIHN1cHBvcnQgZm9yIGFkZGluZyBuZXcgcHJvcGVydGllcyB0byBgVWludDhBcnJheWAgaW5zdGFuY2VzLFxuICogICAgIFNlZTogaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9Njk1NDM4LlxuICpcbiAqICAgLSBDaHJvbWUgOS0xMCBpcyBtaXNzaW5nIHRoZSBgVHlwZWRBcnJheS5wcm90b3R5cGUuc3ViYXJyYXlgIGZ1bmN0aW9uLlxuICpcbiAqICAgLSBJRTEwIGhhcyBhIGJyb2tlbiBgVHlwZWRBcnJheS5wcm90b3R5cGUuc3ViYXJyYXlgIGZ1bmN0aW9uIHdoaWNoIHJldHVybnMgYXJyYXlzIG9mXG4gKiAgICAgaW5jb3JyZWN0IGxlbmd0aCBpbiBzb21lIHNpdHVhdGlvbnMuXG5cbiAqIFdlIGRldGVjdCB0aGVzZSBidWdneSBicm93c2VycyBhbmQgc2V0IGBCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVGAgdG8gYGZhbHNlYCBzbyB0aGV5XG4gKiBnZXQgdGhlIE9iamVjdCBpbXBsZW1lbnRhdGlvbiwgd2hpY2ggaXMgc2xvd2VyIGJ1dCBiZWhhdmVzIGNvcnJlY3RseS5cbiAqL1xuQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQgPSBnbG9iYWwuVFlQRURfQVJSQVlfU1VQUE9SVCAhPT0gdW5kZWZpbmVkXG4gID8gZ2xvYmFsLlRZUEVEX0FSUkFZX1NVUFBPUlRcbiAgOiB0eXBlZEFycmF5U3VwcG9ydCgpXG5cbi8qXG4gKiBFeHBvcnQga01heExlbmd0aCBhZnRlciB0eXBlZCBhcnJheSBzdXBwb3J0IGlzIGRldGVybWluZWQuXG4gKi9cbmV4cG9ydHMua01heExlbmd0aCA9IGtNYXhMZW5ndGgoKVxuXG5mdW5jdGlvbiB0eXBlZEFycmF5U3VwcG9ydCAoKSB7XG4gIHRyeSB7XG4gICAgdmFyIGFyciA9IG5ldyBVaW50OEFycmF5KDEpXG4gICAgYXJyLl9fcHJvdG9fXyA9IHtfX3Byb3RvX186IFVpbnQ4QXJyYXkucHJvdG90eXBlLCBmb286IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDQyIH19XG4gICAgcmV0dXJuIGFyci5mb28oKSA9PT0gNDIgJiYgLy8gdHlwZWQgYXJyYXkgaW5zdGFuY2VzIGNhbiBiZSBhdWdtZW50ZWRcbiAgICAgICAgdHlwZW9mIGFyci5zdWJhcnJheSA9PT0gJ2Z1bmN0aW9uJyAmJiAvLyBjaHJvbWUgOS0xMCBsYWNrIGBzdWJhcnJheWBcbiAgICAgICAgYXJyLnN1YmFycmF5KDEsIDEpLmJ5dGVMZW5ndGggPT09IDAgLy8gaWUxMCBoYXMgYnJva2VuIGBzdWJhcnJheWBcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG59XG5cbmZ1bmN0aW9uIGtNYXhMZW5ndGggKCkge1xuICByZXR1cm4gQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlRcbiAgICA/IDB4N2ZmZmZmZmZcbiAgICA6IDB4M2ZmZmZmZmZcbn1cblxuZnVuY3Rpb24gY3JlYXRlQnVmZmVyICh0aGF0LCBsZW5ndGgpIHtcbiAgaWYgKGtNYXhMZW5ndGgoKSA8IGxlbmd0aCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbnZhbGlkIHR5cGVkIGFycmF5IGxlbmd0aCcpXG4gIH1cbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgLy8gUmV0dXJuIGFuIGF1Z21lbnRlZCBgVWludDhBcnJheWAgaW5zdGFuY2UsIGZvciBiZXN0IHBlcmZvcm1hbmNlXG4gICAgdGhhdCA9IG5ldyBVaW50OEFycmF5KGxlbmd0aClcbiAgICB0aGF0Ll9fcHJvdG9fXyA9IEJ1ZmZlci5wcm90b3R5cGVcbiAgfSBlbHNlIHtcbiAgICAvLyBGYWxsYmFjazogUmV0dXJuIGFuIG9iamVjdCBpbnN0YW5jZSBvZiB0aGUgQnVmZmVyIGNsYXNzXG4gICAgaWYgKHRoYXQgPT09IG51bGwpIHtcbiAgICAgIHRoYXQgPSBuZXcgQnVmZmVyKGxlbmd0aClcbiAgICB9XG4gICAgdGhhdC5sZW5ndGggPSBsZW5ndGhcbiAgfVxuXG4gIHJldHVybiB0aGF0XG59XG5cbi8qKlxuICogVGhlIEJ1ZmZlciBjb25zdHJ1Y3RvciByZXR1cm5zIGluc3RhbmNlcyBvZiBgVWludDhBcnJheWAgdGhhdCBoYXZlIHRoZWlyXG4gKiBwcm90b3R5cGUgY2hhbmdlZCB0byBgQnVmZmVyLnByb3RvdHlwZWAuIEZ1cnRoZXJtb3JlLCBgQnVmZmVyYCBpcyBhIHN1YmNsYXNzIG9mXG4gKiBgVWludDhBcnJheWAsIHNvIHRoZSByZXR1cm5lZCBpbnN0YW5jZXMgd2lsbCBoYXZlIGFsbCB0aGUgbm9kZSBgQnVmZmVyYCBtZXRob2RzXG4gKiBhbmQgdGhlIGBVaW50OEFycmF5YCBtZXRob2RzLiBTcXVhcmUgYnJhY2tldCBub3RhdGlvbiB3b3JrcyBhcyBleHBlY3RlZCAtLSBpdFxuICogcmV0dXJucyBhIHNpbmdsZSBvY3RldC5cbiAqXG4gKiBUaGUgYFVpbnQ4QXJyYXlgIHByb3RvdHlwZSByZW1haW5zIHVubW9kaWZpZWQuXG4gKi9cblxuZnVuY3Rpb24gQnVmZmVyIChhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICBpZiAoIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUICYmICEodGhpcyBpbnN0YW5jZW9mIEJ1ZmZlcikpIHtcbiAgICByZXR1cm4gbmV3IEJ1ZmZlcihhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbiAgfVxuXG4gIC8vIENvbW1vbiBjYXNlLlxuICBpZiAodHlwZW9mIGFyZyA9PT0gJ251bWJlcicpIHtcbiAgICBpZiAodHlwZW9mIGVuY29kaW5nT3JPZmZzZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdJZiBlbmNvZGluZyBpcyBzcGVjaWZpZWQgdGhlbiB0aGUgZmlyc3QgYXJndW1lbnQgbXVzdCBiZSBhIHN0cmluZydcbiAgICAgIClcbiAgICB9XG4gICAgcmV0dXJuIGFsbG9jVW5zYWZlKHRoaXMsIGFyZylcbiAgfVxuICByZXR1cm4gZnJvbSh0aGlzLCBhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbn1cblxuQnVmZmVyLnBvb2xTaXplID0gODE5MiAvLyBub3QgdXNlZCBieSB0aGlzIGltcGxlbWVudGF0aW9uXG5cbi8vIFRPRE86IExlZ2FjeSwgbm90IG5lZWRlZCBhbnltb3JlLiBSZW1vdmUgaW4gbmV4dCBtYWpvciB2ZXJzaW9uLlxuQnVmZmVyLl9hdWdtZW50ID0gZnVuY3Rpb24gKGFycikge1xuICBhcnIuX19wcm90b19fID0gQnVmZmVyLnByb3RvdHlwZVxuICByZXR1cm4gYXJyXG59XG5cbmZ1bmN0aW9uIGZyb20gKHRoYXQsIHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcInZhbHVlXCIgYXJndW1lbnQgbXVzdCBub3QgYmUgYSBudW1iZXInKVxuICB9XG5cbiAgaWYgKHR5cGVvZiBBcnJheUJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcgJiYgdmFsdWUgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgIHJldHVybiBmcm9tQXJyYXlCdWZmZXIodGhhdCwgdmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbiAgfVxuXG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGZyb21TdHJpbmcodGhhdCwgdmFsdWUsIGVuY29kaW5nT3JPZmZzZXQpXG4gIH1cblxuICByZXR1cm4gZnJvbU9iamVjdCh0aGF0LCB2YWx1ZSlcbn1cblxuLyoqXG4gKiBGdW5jdGlvbmFsbHkgZXF1aXZhbGVudCB0byBCdWZmZXIoYXJnLCBlbmNvZGluZykgYnV0IHRocm93cyBhIFR5cGVFcnJvclxuICogaWYgdmFsdWUgaXMgYSBudW1iZXIuXG4gKiBCdWZmZXIuZnJvbShzdHJbLCBlbmNvZGluZ10pXG4gKiBCdWZmZXIuZnJvbShhcnJheSlcbiAqIEJ1ZmZlci5mcm9tKGJ1ZmZlcilcbiAqIEJ1ZmZlci5mcm9tKGFycmF5QnVmZmVyWywgYnl0ZU9mZnNldFssIGxlbmd0aF1dKVxuICoqL1xuQnVmZmVyLmZyb20gPSBmdW5jdGlvbiAodmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gZnJvbShudWxsLCB2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxufVxuXG5pZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgQnVmZmVyLnByb3RvdHlwZS5fX3Byb3RvX18gPSBVaW50OEFycmF5LnByb3RvdHlwZVxuICBCdWZmZXIuX19wcm90b19fID0gVWludDhBcnJheVxuICBpZiAodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLnNwZWNpZXMgJiZcbiAgICAgIEJ1ZmZlcltTeW1ib2wuc3BlY2llc10gPT09IEJ1ZmZlcikge1xuICAgIC8vIEZpeCBzdWJhcnJheSgpIGluIEVTMjAxNi4gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlci9wdWxsLzk3XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEJ1ZmZlciwgU3ltYm9sLnNwZWNpZXMsIHtcbiAgICAgIHZhbHVlOiBudWxsLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSlcbiAgfVxufVxuXG5mdW5jdGlvbiBhc3NlcnRTaXplIChzaXplKSB7XG4gIGlmICh0eXBlb2Ygc2l6ZSAhPT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcInNpemVcIiBhcmd1bWVudCBtdXN0IGJlIGEgbnVtYmVyJylcbiAgfSBlbHNlIGlmIChzaXplIDwgMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdcInNpemVcIiBhcmd1bWVudCBtdXN0IG5vdCBiZSBuZWdhdGl2ZScpXG4gIH1cbn1cblxuZnVuY3Rpb24gYWxsb2MgKHRoYXQsIHNpemUsIGZpbGwsIGVuY29kaW5nKSB7XG4gIGFzc2VydFNpemUoc2l6ZSlcbiAgaWYgKHNpemUgPD0gMCkge1xuICAgIHJldHVybiBjcmVhdGVCdWZmZXIodGhhdCwgc2l6ZSlcbiAgfVxuICBpZiAoZmlsbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgLy8gT25seSBwYXkgYXR0ZW50aW9uIHRvIGVuY29kaW5nIGlmIGl0J3MgYSBzdHJpbmcuIFRoaXNcbiAgICAvLyBwcmV2ZW50cyBhY2NpZGVudGFsbHkgc2VuZGluZyBpbiBhIG51bWJlciB0aGF0IHdvdWxkXG4gICAgLy8gYmUgaW50ZXJwcmV0dGVkIGFzIGEgc3RhcnQgb2Zmc2V0LlxuICAgIHJldHVybiB0eXBlb2YgZW5jb2RpbmcgPT09ICdzdHJpbmcnXG4gICAgICA/IGNyZWF0ZUJ1ZmZlcih0aGF0LCBzaXplKS5maWxsKGZpbGwsIGVuY29kaW5nKVxuICAgICAgOiBjcmVhdGVCdWZmZXIodGhhdCwgc2l6ZSkuZmlsbChmaWxsKVxuICB9XG4gIHJldHVybiBjcmVhdGVCdWZmZXIodGhhdCwgc2l6ZSlcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IGZpbGxlZCBCdWZmZXIgaW5zdGFuY2UuXG4gKiBhbGxvYyhzaXplWywgZmlsbFssIGVuY29kaW5nXV0pXG4gKiovXG5CdWZmZXIuYWxsb2MgPSBmdW5jdGlvbiAoc2l6ZSwgZmlsbCwgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIGFsbG9jKG51bGwsIHNpemUsIGZpbGwsIGVuY29kaW5nKVxufVxuXG5mdW5jdGlvbiBhbGxvY1Vuc2FmZSAodGhhdCwgc2l6ZSkge1xuICBhc3NlcnRTaXplKHNpemUpXG4gIHRoYXQgPSBjcmVhdGVCdWZmZXIodGhhdCwgc2l6ZSA8IDAgPyAwIDogY2hlY2tlZChzaXplKSB8IDApXG4gIGlmICghQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNpemU7ICsraSkge1xuICAgICAgdGhhdFtpXSA9IDBcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRoYXRcbn1cblxuLyoqXG4gKiBFcXVpdmFsZW50IHRvIEJ1ZmZlcihudW0pLCBieSBkZWZhdWx0IGNyZWF0ZXMgYSBub24temVyby1maWxsZWQgQnVmZmVyIGluc3RhbmNlLlxuICogKi9cbkJ1ZmZlci5hbGxvY1Vuc2FmZSA9IGZ1bmN0aW9uIChzaXplKSB7XG4gIHJldHVybiBhbGxvY1Vuc2FmZShudWxsLCBzaXplKVxufVxuLyoqXG4gKiBFcXVpdmFsZW50IHRvIFNsb3dCdWZmZXIobnVtKSwgYnkgZGVmYXVsdCBjcmVhdGVzIGEgbm9uLXplcm8tZmlsbGVkIEJ1ZmZlciBpbnN0YW5jZS5cbiAqL1xuQnVmZmVyLmFsbG9jVW5zYWZlU2xvdyA9IGZ1bmN0aW9uIChzaXplKSB7XG4gIHJldHVybiBhbGxvY1Vuc2FmZShudWxsLCBzaXplKVxufVxuXG5mdW5jdGlvbiBmcm9tU3RyaW5nICh0aGF0LCBzdHJpbmcsIGVuY29kaW5nKSB7XG4gIGlmICh0eXBlb2YgZW5jb2RpbmcgIT09ICdzdHJpbmcnIHx8IGVuY29kaW5nID09PSAnJykge1xuICAgIGVuY29kaW5nID0gJ3V0ZjgnXG4gIH1cblxuICBpZiAoIUJ1ZmZlci5pc0VuY29kaW5nKGVuY29kaW5nKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wiZW5jb2RpbmdcIiBtdXN0IGJlIGEgdmFsaWQgc3RyaW5nIGVuY29kaW5nJylcbiAgfVxuXG4gIHZhciBsZW5ndGggPSBieXRlTGVuZ3RoKHN0cmluZywgZW5jb2RpbmcpIHwgMFxuICB0aGF0ID0gY3JlYXRlQnVmZmVyKHRoYXQsIGxlbmd0aClcblxuICB2YXIgYWN0dWFsID0gdGhhdC53cml0ZShzdHJpbmcsIGVuY29kaW5nKVxuXG4gIGlmIChhY3R1YWwgIT09IGxlbmd0aCkge1xuICAgIC8vIFdyaXRpbmcgYSBoZXggc3RyaW5nLCBmb3IgZXhhbXBsZSwgdGhhdCBjb250YWlucyBpbnZhbGlkIGNoYXJhY3RlcnMgd2lsbFxuICAgIC8vIGNhdXNlIGV2ZXJ5dGhpbmcgYWZ0ZXIgdGhlIGZpcnN0IGludmFsaWQgY2hhcmFjdGVyIHRvIGJlIGlnbm9yZWQuIChlLmcuXG4gICAgLy8gJ2FieHhjZCcgd2lsbCBiZSB0cmVhdGVkIGFzICdhYicpXG4gICAgdGhhdCA9IHRoYXQuc2xpY2UoMCwgYWN0dWFsKVxuICB9XG5cbiAgcmV0dXJuIHRoYXRcbn1cblxuZnVuY3Rpb24gZnJvbUFycmF5TGlrZSAodGhhdCwgYXJyYXkpIHtcbiAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aCA8IDAgPyAwIDogY2hlY2tlZChhcnJheS5sZW5ndGgpIHwgMFxuICB0aGF0ID0gY3JlYXRlQnVmZmVyKHRoYXQsIGxlbmd0aClcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkgKz0gMSkge1xuICAgIHRoYXRbaV0gPSBhcnJheVtpXSAmIDI1NVxuICB9XG4gIHJldHVybiB0aGF0XG59XG5cbmZ1bmN0aW9uIGZyb21BcnJheUJ1ZmZlciAodGhhdCwgYXJyYXksIGJ5dGVPZmZzZXQsIGxlbmd0aCkge1xuICBhcnJheS5ieXRlTGVuZ3RoIC8vIHRoaXMgdGhyb3dzIGlmIGBhcnJheWAgaXMgbm90IGEgdmFsaWQgQXJyYXlCdWZmZXJcblxuICBpZiAoYnl0ZU9mZnNldCA8IDAgfHwgYXJyYXkuYnl0ZUxlbmd0aCA8IGJ5dGVPZmZzZXQpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXFwnb2Zmc2V0XFwnIGlzIG91dCBvZiBib3VuZHMnKVxuICB9XG5cbiAgaWYgKGFycmF5LmJ5dGVMZW5ndGggPCBieXRlT2Zmc2V0ICsgKGxlbmd0aCB8fCAwKSkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdcXCdsZW5ndGhcXCcgaXMgb3V0IG9mIGJvdW5kcycpXG4gIH1cblxuICBpZiAoYnl0ZU9mZnNldCA9PT0gdW5kZWZpbmVkICYmIGxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgYXJyYXkgPSBuZXcgVWludDhBcnJheShhcnJheSlcbiAgfSBlbHNlIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgIGFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXksIGJ5dGVPZmZzZXQpXG4gIH0gZWxzZSB7XG4gICAgYXJyYXkgPSBuZXcgVWludDhBcnJheShhcnJheSwgYnl0ZU9mZnNldCwgbGVuZ3RoKVxuICB9XG5cbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgLy8gUmV0dXJuIGFuIGF1Z21lbnRlZCBgVWludDhBcnJheWAgaW5zdGFuY2UsIGZvciBiZXN0IHBlcmZvcm1hbmNlXG4gICAgdGhhdCA9IGFycmF5XG4gICAgdGhhdC5fX3Byb3RvX18gPSBCdWZmZXIucHJvdG90eXBlXG4gIH0gZWxzZSB7XG4gICAgLy8gRmFsbGJhY2s6IFJldHVybiBhbiBvYmplY3QgaW5zdGFuY2Ugb2YgdGhlIEJ1ZmZlciBjbGFzc1xuICAgIHRoYXQgPSBmcm9tQXJyYXlMaWtlKHRoYXQsIGFycmF5KVxuICB9XG4gIHJldHVybiB0aGF0XG59XG5cbmZ1bmN0aW9uIGZyb21PYmplY3QgKHRoYXQsIG9iaikge1xuICBpZiAoQnVmZmVyLmlzQnVmZmVyKG9iaikpIHtcbiAgICB2YXIgbGVuID0gY2hlY2tlZChvYmoubGVuZ3RoKSB8IDBcbiAgICB0aGF0ID0gY3JlYXRlQnVmZmVyKHRoYXQsIGxlbilcblxuICAgIGlmICh0aGF0Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIHRoYXRcbiAgICB9XG5cbiAgICBvYmouY29weSh0aGF0LCAwLCAwLCBsZW4pXG4gICAgcmV0dXJuIHRoYXRcbiAgfVxuXG4gIGlmIChvYmopIHtcbiAgICBpZiAoKHR5cGVvZiBBcnJheUJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgICAgb2JqLmJ1ZmZlciBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB8fCAnbGVuZ3RoJyBpbiBvYmopIHtcbiAgICAgIGlmICh0eXBlb2Ygb2JqLmxlbmd0aCAhPT0gJ251bWJlcicgfHwgaXNuYW4ob2JqLmxlbmd0aCkpIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUJ1ZmZlcih0aGF0LCAwKVxuICAgICAgfVxuICAgICAgcmV0dXJuIGZyb21BcnJheUxpa2UodGhhdCwgb2JqKVxuICAgIH1cblxuICAgIGlmIChvYmoudHlwZSA9PT0gJ0J1ZmZlcicgJiYgaXNBcnJheShvYmouZGF0YSkpIHtcbiAgICAgIHJldHVybiBmcm9tQXJyYXlMaWtlKHRoYXQsIG9iai5kYXRhKVxuICAgIH1cbiAgfVxuXG4gIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ZpcnN0IGFyZ3VtZW50IG11c3QgYmUgYSBzdHJpbmcsIEJ1ZmZlciwgQXJyYXlCdWZmZXIsIEFycmF5LCBvciBhcnJheS1saWtlIG9iamVjdC4nKVxufVxuXG5mdW5jdGlvbiBjaGVja2VkIChsZW5ndGgpIHtcbiAgLy8gTm90ZTogY2Fubm90IHVzZSBgbGVuZ3RoIDwga01heExlbmd0aCgpYCBoZXJlIGJlY2F1c2UgdGhhdCBmYWlscyB3aGVuXG4gIC8vIGxlbmd0aCBpcyBOYU4gKHdoaWNoIGlzIG90aGVyd2lzZSBjb2VyY2VkIHRvIHplcm8uKVxuICBpZiAobGVuZ3RoID49IGtNYXhMZW5ndGgoKSkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdBdHRlbXB0IHRvIGFsbG9jYXRlIEJ1ZmZlciBsYXJnZXIgdGhhbiBtYXhpbXVtICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICdzaXplOiAweCcgKyBrTWF4TGVuZ3RoKCkudG9TdHJpbmcoMTYpICsgJyBieXRlcycpXG4gIH1cbiAgcmV0dXJuIGxlbmd0aCB8IDBcbn1cblxuZnVuY3Rpb24gU2xvd0J1ZmZlciAobGVuZ3RoKSB7XG4gIGlmICgrbGVuZ3RoICE9IGxlbmd0aCkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGVxZXFlcVxuICAgIGxlbmd0aCA9IDBcbiAgfVxuICByZXR1cm4gQnVmZmVyLmFsbG9jKCtsZW5ndGgpXG59XG5cbkJ1ZmZlci5pc0J1ZmZlciA9IGZ1bmN0aW9uIGlzQnVmZmVyIChiKSB7XG4gIHJldHVybiAhIShiICE9IG51bGwgJiYgYi5faXNCdWZmZXIpXG59XG5cbkJ1ZmZlci5jb21wYXJlID0gZnVuY3Rpb24gY29tcGFyZSAoYSwgYikge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihhKSB8fCAhQnVmZmVyLmlzQnVmZmVyKGIpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnRzIG11c3QgYmUgQnVmZmVycycpXG4gIH1cblxuICBpZiAoYSA9PT0gYikgcmV0dXJuIDBcblxuICB2YXIgeCA9IGEubGVuZ3RoXG4gIHZhciB5ID0gYi5sZW5ndGhcblxuICBmb3IgKHZhciBpID0gMCwgbGVuID0gTWF0aC5taW4oeCwgeSk7IGkgPCBsZW47ICsraSkge1xuICAgIGlmIChhW2ldICE9PSBiW2ldKSB7XG4gICAgICB4ID0gYVtpXVxuICAgICAgeSA9IGJbaV1cbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG5cbiAgaWYgKHggPCB5KSByZXR1cm4gLTFcbiAgaWYgKHkgPCB4KSByZXR1cm4gMVxuICByZXR1cm4gMFxufVxuXG5CdWZmZXIuaXNFbmNvZGluZyA9IGZ1bmN0aW9uIGlzRW5jb2RpbmcgKGVuY29kaW5nKSB7XG4gIHN3aXRjaCAoU3RyaW5nKGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpKSB7XG4gICAgY2FzZSAnaGV4JzpcbiAgICBjYXNlICd1dGY4JzpcbiAgICBjYXNlICd1dGYtOCc6XG4gICAgY2FzZSAnYXNjaWknOlxuICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgY2FzZSAnYmluYXJ5JzpcbiAgICBjYXNlICdiYXNlNjQnOlxuICAgIGNhc2UgJ3VjczInOlxuICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICBjYXNlICd1dGYxNmxlJzpcbiAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZmFsc2VcbiAgfVxufVxuXG5CdWZmZXIuY29uY2F0ID0gZnVuY3Rpb24gY29uY2F0IChsaXN0LCBsZW5ndGgpIHtcbiAgaWYgKCFpc0FycmF5KGxpc3QpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJsaXN0XCIgYXJndW1lbnQgbXVzdCBiZSBhbiBBcnJheSBvZiBCdWZmZXJzJylcbiAgfVxuXG4gIGlmIChsaXN0Lmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBCdWZmZXIuYWxsb2MoMClcbiAgfVxuXG4gIHZhciBpXG4gIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgIGxlbmd0aCA9IDBcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7ICsraSkge1xuICAgICAgbGVuZ3RoICs9IGxpc3RbaV0ubGVuZ3RoXG4gICAgfVxuICB9XG5cbiAgdmFyIGJ1ZmZlciA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShsZW5ndGgpXG4gIHZhciBwb3MgPSAwXG4gIGZvciAoaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgKytpKSB7XG4gICAgdmFyIGJ1ZiA9IGxpc3RbaV1cbiAgICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihidWYpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImxpc3RcIiBhcmd1bWVudCBtdXN0IGJlIGFuIEFycmF5IG9mIEJ1ZmZlcnMnKVxuICAgIH1cbiAgICBidWYuY29weShidWZmZXIsIHBvcylcbiAgICBwb3MgKz0gYnVmLmxlbmd0aFxuICB9XG4gIHJldHVybiBidWZmZXJcbn1cblxuZnVuY3Rpb24gYnl0ZUxlbmd0aCAoc3RyaW5nLCBlbmNvZGluZykge1xuICBpZiAoQnVmZmVyLmlzQnVmZmVyKHN0cmluZykpIHtcbiAgICByZXR1cm4gc3RyaW5nLmxlbmd0aFxuICB9XG4gIGlmICh0eXBlb2YgQXJyYXlCdWZmZXIgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBBcnJheUJ1ZmZlci5pc1ZpZXcgPT09ICdmdW5jdGlvbicgJiZcbiAgICAgIChBcnJheUJ1ZmZlci5pc1ZpZXcoc3RyaW5nKSB8fCBzdHJpbmcgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikpIHtcbiAgICByZXR1cm4gc3RyaW5nLmJ5dGVMZW5ndGhcbiAgfVxuICBpZiAodHlwZW9mIHN0cmluZyAhPT0gJ3N0cmluZycpIHtcbiAgICBzdHJpbmcgPSAnJyArIHN0cmluZ1xuICB9XG5cbiAgdmFyIGxlbiA9IHN0cmluZy5sZW5ndGhcbiAgaWYgKGxlbiA9PT0gMCkgcmV0dXJuIDBcblxuICAvLyBVc2UgYSBmb3IgbG9vcCB0byBhdm9pZCByZWN1cnNpb25cbiAgdmFyIGxvd2VyZWRDYXNlID0gZmFsc2VcbiAgZm9yICg7Oykge1xuICAgIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgICBjYXNlICdiaW5hcnknOlxuICAgICAgICByZXR1cm4gbGVuXG4gICAgICBjYXNlICd1dGY4JzpcbiAgICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgIGNhc2UgdW5kZWZpbmVkOlxuICAgICAgICByZXR1cm4gdXRmOFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGhcbiAgICAgIGNhc2UgJ3VjczInOlxuICAgICAgY2FzZSAndWNzLTInOlxuICAgICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICAgIHJldHVybiBsZW4gKiAyXG4gICAgICBjYXNlICdoZXgnOlxuICAgICAgICByZXR1cm4gbGVuID4+PiAxXG4gICAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgICByZXR1cm4gYmFzZTY0VG9CeXRlcyhzdHJpbmcpLmxlbmd0aFxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKGxvd2VyZWRDYXNlKSByZXR1cm4gdXRmOFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGggLy8gYXNzdW1lIHV0ZjhcbiAgICAgICAgZW5jb2RpbmcgPSAoJycgKyBlbmNvZGluZykudG9Mb3dlckNhc2UoKVxuICAgICAgICBsb3dlcmVkQ2FzZSA9IHRydWVcbiAgICB9XG4gIH1cbn1cbkJ1ZmZlci5ieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aFxuXG5mdW5jdGlvbiBzbG93VG9TdHJpbmcgKGVuY29kaW5nLCBzdGFydCwgZW5kKSB7XG4gIHZhciBsb3dlcmVkQ2FzZSA9IGZhbHNlXG5cbiAgLy8gTm8gbmVlZCB0byB2ZXJpZnkgdGhhdCBcInRoaXMubGVuZ3RoIDw9IE1BWF9VSU5UMzJcIiBzaW5jZSBpdCdzIGEgcmVhZC1vbmx5XG4gIC8vIHByb3BlcnR5IG9mIGEgdHlwZWQgYXJyYXkuXG5cbiAgLy8gVGhpcyBiZWhhdmVzIG5laXRoZXIgbGlrZSBTdHJpbmcgbm9yIFVpbnQ4QXJyYXkgaW4gdGhhdCB3ZSBzZXQgc3RhcnQvZW5kXG4gIC8vIHRvIHRoZWlyIHVwcGVyL2xvd2VyIGJvdW5kcyBpZiB0aGUgdmFsdWUgcGFzc2VkIGlzIG91dCBvZiByYW5nZS5cbiAgLy8gdW5kZWZpbmVkIGlzIGhhbmRsZWQgc3BlY2lhbGx5IGFzIHBlciBFQ01BLTI2MiA2dGggRWRpdGlvbixcbiAgLy8gU2VjdGlvbiAxMy4zLjMuNyBSdW50aW1lIFNlbWFudGljczogS2V5ZWRCaW5kaW5nSW5pdGlhbGl6YXRpb24uXG4gIGlmIChzdGFydCA9PT0gdW5kZWZpbmVkIHx8IHN0YXJ0IDwgMCkge1xuICAgIHN0YXJ0ID0gMFxuICB9XG4gIC8vIFJldHVybiBlYXJseSBpZiBzdGFydCA+IHRoaXMubGVuZ3RoLiBEb25lIGhlcmUgdG8gcHJldmVudCBwb3RlbnRpYWwgdWludDMyXG4gIC8vIGNvZXJjaW9uIGZhaWwgYmVsb3cuXG4gIGlmIChzdGFydCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgcmV0dXJuICcnXG4gIH1cblxuICBpZiAoZW5kID09PSB1bmRlZmluZWQgfHwgZW5kID4gdGhpcy5sZW5ndGgpIHtcbiAgICBlbmQgPSB0aGlzLmxlbmd0aFxuICB9XG5cbiAgaWYgKGVuZCA8PSAwKSB7XG4gICAgcmV0dXJuICcnXG4gIH1cblxuICAvLyBGb3JjZSBjb2Vyc2lvbiB0byB1aW50MzIuIFRoaXMgd2lsbCBhbHNvIGNvZXJjZSBmYWxzZXkvTmFOIHZhbHVlcyB0byAwLlxuICBlbmQgPj4+PSAwXG4gIHN0YXJ0ID4+Pj0gMFxuXG4gIGlmIChlbmQgPD0gc3RhcnQpIHtcbiAgICByZXR1cm4gJydcbiAgfVxuXG4gIGlmICghZW5jb2RpbmcpIGVuY29kaW5nID0gJ3V0ZjgnXG5cbiAgd2hpbGUgKHRydWUpIHtcbiAgICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgICBjYXNlICdoZXgnOlxuICAgICAgICByZXR1cm4gaGV4U2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAndXRmOCc6XG4gICAgICBjYXNlICd1dGYtOCc6XG4gICAgICAgIHJldHVybiB1dGY4U2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAnYXNjaWknOlxuICAgICAgICByZXR1cm4gYXNjaWlTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICdsYXRpbjEnOlxuICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgICAgcmV0dXJuIGxhdGluMVNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICAgIHJldHVybiBiYXNlNjRTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICd1Y3MyJzpcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgICByZXR1cm4gdXRmMTZsZVNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChsb3dlcmVkQ2FzZSkgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKVxuICAgICAgICBlbmNvZGluZyA9IChlbmNvZGluZyArICcnKS50b0xvd2VyQ2FzZSgpXG4gICAgICAgIGxvd2VyZWRDYXNlID0gdHJ1ZVxuICAgIH1cbiAgfVxufVxuXG4vLyBUaGUgcHJvcGVydHkgaXMgdXNlZCBieSBgQnVmZmVyLmlzQnVmZmVyYCBhbmQgYGlzLWJ1ZmZlcmAgKGluIFNhZmFyaSA1LTcpIHRvIGRldGVjdFxuLy8gQnVmZmVyIGluc3RhbmNlcy5cbkJ1ZmZlci5wcm90b3R5cGUuX2lzQnVmZmVyID0gdHJ1ZVxuXG5mdW5jdGlvbiBzd2FwIChiLCBuLCBtKSB7XG4gIHZhciBpID0gYltuXVxuICBiW25dID0gYlttXVxuICBiW21dID0gaVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnN3YXAxNiA9IGZ1bmN0aW9uIHN3YXAxNiAoKSB7XG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aFxuICBpZiAobGVuICUgMiAhPT0gMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgMTYtYml0cycpXG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkgKz0gMikge1xuICAgIHN3YXAodGhpcywgaSwgaSArIDEpXG4gIH1cbiAgcmV0dXJuIHRoaXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zd2FwMzIgPSBmdW5jdGlvbiBzd2FwMzIgKCkge1xuICB2YXIgbGVuID0gdGhpcy5sZW5ndGhcbiAgaWYgKGxlbiAlIDQgIT09IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQnVmZmVyIHNpemUgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDMyLWJpdHMnKVxuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpICs9IDQpIHtcbiAgICBzd2FwKHRoaXMsIGksIGkgKyAzKVxuICAgIHN3YXAodGhpcywgaSArIDEsIGkgKyAyKVxuICB9XG4gIHJldHVybiB0aGlzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc3dhcDY0ID0gZnVuY3Rpb24gc3dhcDY0ICgpIHtcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoXG4gIGlmIChsZW4gJSA4ICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0J1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiA2NC1iaXRzJylcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSArPSA4KSB7XG4gICAgc3dhcCh0aGlzLCBpLCBpICsgNylcbiAgICBzd2FwKHRoaXMsIGkgKyAxLCBpICsgNilcbiAgICBzd2FwKHRoaXMsIGkgKyAyLCBpICsgNSlcbiAgICBzd2FwKHRoaXMsIGkgKyAzLCBpICsgNClcbiAgfVxuICByZXR1cm4gdGhpc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcgKCkge1xuICB2YXIgbGVuZ3RoID0gdGhpcy5sZW5ndGggfCAwXG4gIGlmIChsZW5ndGggPT09IDApIHJldHVybiAnJ1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIHV0ZjhTbGljZSh0aGlzLCAwLCBsZW5ndGgpXG4gIHJldHVybiBzbG93VG9TdHJpbmcuYXBwbHkodGhpcywgYXJndW1lbnRzKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLmVxdWFscyA9IGZ1bmN0aW9uIGVxdWFscyAoYikge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihiKSkgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBiZSBhIEJ1ZmZlcicpXG4gIGlmICh0aGlzID09PSBiKSByZXR1cm4gdHJ1ZVxuICByZXR1cm4gQnVmZmVyLmNvbXBhcmUodGhpcywgYikgPT09IDBcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5pbnNwZWN0ID0gZnVuY3Rpb24gaW5zcGVjdCAoKSB7XG4gIHZhciBzdHIgPSAnJ1xuICB2YXIgbWF4ID0gZXhwb3J0cy5JTlNQRUNUX01BWF9CWVRFU1xuICBpZiAodGhpcy5sZW5ndGggPiAwKSB7XG4gICAgc3RyID0gdGhpcy50b1N0cmluZygnaGV4JywgMCwgbWF4KS5tYXRjaCgvLnsyfS9nKS5qb2luKCcgJylcbiAgICBpZiAodGhpcy5sZW5ndGggPiBtYXgpIHN0ciArPSAnIC4uLiAnXG4gIH1cbiAgcmV0dXJuICc8QnVmZmVyICcgKyBzdHIgKyAnPidcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5jb21wYXJlID0gZnVuY3Rpb24gY29tcGFyZSAodGFyZ2V0LCBzdGFydCwgZW5kLCB0aGlzU3RhcnQsIHRoaXNFbmQpIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIodGFyZ2V0KSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXInKVxuICB9XG5cbiAgaWYgKHN0YXJ0ID09PSB1bmRlZmluZWQpIHtcbiAgICBzdGFydCA9IDBcbiAgfVxuICBpZiAoZW5kID09PSB1bmRlZmluZWQpIHtcbiAgICBlbmQgPSB0YXJnZXQgPyB0YXJnZXQubGVuZ3RoIDogMFxuICB9XG4gIGlmICh0aGlzU3RhcnQgPT09IHVuZGVmaW5lZCkge1xuICAgIHRoaXNTdGFydCA9IDBcbiAgfVxuICBpZiAodGhpc0VuZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdGhpc0VuZCA9IHRoaXMubGVuZ3RoXG4gIH1cblxuICBpZiAoc3RhcnQgPCAwIHx8IGVuZCA+IHRhcmdldC5sZW5ndGggfHwgdGhpc1N0YXJ0IDwgMCB8fCB0aGlzRW5kID4gdGhpcy5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignb3V0IG9mIHJhbmdlIGluZGV4JylcbiAgfVxuXG4gIGlmICh0aGlzU3RhcnQgPj0gdGhpc0VuZCAmJiBzdGFydCA+PSBlbmQpIHtcbiAgICByZXR1cm4gMFxuICB9XG4gIGlmICh0aGlzU3RhcnQgPj0gdGhpc0VuZCkge1xuICAgIHJldHVybiAtMVxuICB9XG4gIGlmIChzdGFydCA+PSBlbmQpIHtcbiAgICByZXR1cm4gMVxuICB9XG5cbiAgc3RhcnQgPj4+PSAwXG4gIGVuZCA+Pj49IDBcbiAgdGhpc1N0YXJ0ID4+Pj0gMFxuICB0aGlzRW5kID4+Pj0gMFxuXG4gIGlmICh0aGlzID09PSB0YXJnZXQpIHJldHVybiAwXG5cbiAgdmFyIHggPSB0aGlzRW5kIC0gdGhpc1N0YXJ0XG4gIHZhciB5ID0gZW5kIC0gc3RhcnRcbiAgdmFyIGxlbiA9IE1hdGgubWluKHgsIHkpXG5cbiAgdmFyIHRoaXNDb3B5ID0gdGhpcy5zbGljZSh0aGlzU3RhcnQsIHRoaXNFbmQpXG4gIHZhciB0YXJnZXRDb3B5ID0gdGFyZ2V0LnNsaWNlKHN0YXJ0LCBlbmQpXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47ICsraSkge1xuICAgIGlmICh0aGlzQ29weVtpXSAhPT0gdGFyZ2V0Q29weVtpXSkge1xuICAgICAgeCA9IHRoaXNDb3B5W2ldXG4gICAgICB5ID0gdGFyZ2V0Q29weVtpXVxuICAgICAgYnJlYWtcbiAgICB9XG4gIH1cblxuICBpZiAoeCA8IHkpIHJldHVybiAtMVxuICBpZiAoeSA8IHgpIHJldHVybiAxXG4gIHJldHVybiAwXG59XG5cbi8vIEZpbmRzIGVpdGhlciB0aGUgZmlyc3QgaW5kZXggb2YgYHZhbGAgaW4gYGJ1ZmZlcmAgYXQgb2Zmc2V0ID49IGBieXRlT2Zmc2V0YCxcbi8vIE9SIHRoZSBsYXN0IGluZGV4IG9mIGB2YWxgIGluIGBidWZmZXJgIGF0IG9mZnNldCA8PSBgYnl0ZU9mZnNldGAuXG4vL1xuLy8gQXJndW1lbnRzOlxuLy8gLSBidWZmZXIgLSBhIEJ1ZmZlciB0byBzZWFyY2hcbi8vIC0gdmFsIC0gYSBzdHJpbmcsIEJ1ZmZlciwgb3IgbnVtYmVyXG4vLyAtIGJ5dGVPZmZzZXQgLSBhbiBpbmRleCBpbnRvIGBidWZmZXJgOyB3aWxsIGJlIGNsYW1wZWQgdG8gYW4gaW50MzJcbi8vIC0gZW5jb2RpbmcgLSBhbiBvcHRpb25hbCBlbmNvZGluZywgcmVsZXZhbnQgaXMgdmFsIGlzIGEgc3RyaW5nXG4vLyAtIGRpciAtIHRydWUgZm9yIGluZGV4T2YsIGZhbHNlIGZvciBsYXN0SW5kZXhPZlxuZnVuY3Rpb24gYmlkaXJlY3Rpb25hbEluZGV4T2YgKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKSB7XG4gIC8vIEVtcHR5IGJ1ZmZlciBtZWFucyBubyBtYXRjaFxuICBpZiAoYnVmZmVyLmxlbmd0aCA9PT0gMCkgcmV0dXJuIC0xXG5cbiAgLy8gTm9ybWFsaXplIGJ5dGVPZmZzZXRcbiAgaWYgKHR5cGVvZiBieXRlT2Zmc2V0ID09PSAnc3RyaW5nJykge1xuICAgIGVuY29kaW5nID0gYnl0ZU9mZnNldFxuICAgIGJ5dGVPZmZzZXQgPSAwXG4gIH0gZWxzZSBpZiAoYnl0ZU9mZnNldCA+IDB4N2ZmZmZmZmYpIHtcbiAgICBieXRlT2Zmc2V0ID0gMHg3ZmZmZmZmZlxuICB9IGVsc2UgaWYgKGJ5dGVPZmZzZXQgPCAtMHg4MDAwMDAwMCkge1xuICAgIGJ5dGVPZmZzZXQgPSAtMHg4MDAwMDAwMFxuICB9XG4gIGJ5dGVPZmZzZXQgPSArYnl0ZU9mZnNldCAgLy8gQ29lcmNlIHRvIE51bWJlci5cbiAgaWYgKGlzTmFOKGJ5dGVPZmZzZXQpKSB7XG4gICAgLy8gYnl0ZU9mZnNldDogaXQgaXQncyB1bmRlZmluZWQsIG51bGwsIE5hTiwgXCJmb29cIiwgZXRjLCBzZWFyY2ggd2hvbGUgYnVmZmVyXG4gICAgYnl0ZU9mZnNldCA9IGRpciA/IDAgOiAoYnVmZmVyLmxlbmd0aCAtIDEpXG4gIH1cblxuICAvLyBOb3JtYWxpemUgYnl0ZU9mZnNldDogbmVnYXRpdmUgb2Zmc2V0cyBzdGFydCBmcm9tIHRoZSBlbmQgb2YgdGhlIGJ1ZmZlclxuICBpZiAoYnl0ZU9mZnNldCA8IDApIGJ5dGVPZmZzZXQgPSBidWZmZXIubGVuZ3RoICsgYnl0ZU9mZnNldFxuICBpZiAoYnl0ZU9mZnNldCA+PSBidWZmZXIubGVuZ3RoKSB7XG4gICAgaWYgKGRpcikgcmV0dXJuIC0xXG4gICAgZWxzZSBieXRlT2Zmc2V0ID0gYnVmZmVyLmxlbmd0aCAtIDFcbiAgfSBlbHNlIGlmIChieXRlT2Zmc2V0IDwgMCkge1xuICAgIGlmIChkaXIpIGJ5dGVPZmZzZXQgPSAwXG4gICAgZWxzZSByZXR1cm4gLTFcbiAgfVxuXG4gIC8vIE5vcm1hbGl6ZSB2YWxcbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKSB7XG4gICAgdmFsID0gQnVmZmVyLmZyb20odmFsLCBlbmNvZGluZylcbiAgfVxuXG4gIC8vIEZpbmFsbHksIHNlYXJjaCBlaXRoZXIgaW5kZXhPZiAoaWYgZGlyIGlzIHRydWUpIG9yIGxhc3RJbmRleE9mXG4gIGlmIChCdWZmZXIuaXNCdWZmZXIodmFsKSkge1xuICAgIC8vIFNwZWNpYWwgY2FzZTogbG9va2luZyBmb3IgZW1wdHkgc3RyaW5nL2J1ZmZlciBhbHdheXMgZmFpbHNcbiAgICBpZiAodmFsLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIC0xXG4gICAgfVxuICAgIHJldHVybiBhcnJheUluZGV4T2YoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpXG4gIH0gZWxzZSBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICB2YWwgPSB2YWwgJiAweEZGIC8vIFNlYXJjaCBmb3IgYSBieXRlIHZhbHVlIFswLTI1NV1cbiAgICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQgJiZcbiAgICAgICAgdHlwZW9mIFVpbnQ4QXJyYXkucHJvdG90eXBlLmluZGV4T2YgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGlmIChkaXIpIHtcbiAgICAgICAgcmV0dXJuIFVpbnQ4QXJyYXkucHJvdG90eXBlLmluZGV4T2YuY2FsbChidWZmZXIsIHZhbCwgYnl0ZU9mZnNldClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBVaW50OEFycmF5LnByb3RvdHlwZS5sYXN0SW5kZXhPZi5jYWxsKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0KVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYXJyYXlJbmRleE9mKGJ1ZmZlciwgWyB2YWwgXSwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcilcbiAgfVxuXG4gIHRocm93IG5ldyBUeXBlRXJyb3IoJ3ZhbCBtdXN0IGJlIHN0cmluZywgbnVtYmVyIG9yIEJ1ZmZlcicpXG59XG5cbmZ1bmN0aW9uIGFycmF5SW5kZXhPZiAoYXJyLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpIHtcbiAgdmFyIGluZGV4U2l6ZSA9IDFcbiAgdmFyIGFyckxlbmd0aCA9IGFyci5sZW5ndGhcbiAgdmFyIHZhbExlbmd0aCA9IHZhbC5sZW5ndGhcblxuICBpZiAoZW5jb2RpbmcgIT09IHVuZGVmaW5lZCkge1xuICAgIGVuY29kaW5nID0gU3RyaW5nKGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpXG4gICAgaWYgKGVuY29kaW5nID09PSAndWNzMicgfHwgZW5jb2RpbmcgPT09ICd1Y3MtMicgfHxcbiAgICAgICAgZW5jb2RpbmcgPT09ICd1dGYxNmxlJyB8fCBlbmNvZGluZyA9PT0gJ3V0Zi0xNmxlJykge1xuICAgICAgaWYgKGFyci5sZW5ndGggPCAyIHx8IHZhbC5sZW5ndGggPCAyKSB7XG4gICAgICAgIHJldHVybiAtMVxuICAgICAgfVxuICAgICAgaW5kZXhTaXplID0gMlxuICAgICAgYXJyTGVuZ3RoIC89IDJcbiAgICAgIHZhbExlbmd0aCAvPSAyXG4gICAgICBieXRlT2Zmc2V0IC89IDJcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZWFkIChidWYsIGkpIHtcbiAgICBpZiAoaW5kZXhTaXplID09PSAxKSB7XG4gICAgICByZXR1cm4gYnVmW2ldXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBidWYucmVhZFVJbnQxNkJFKGkgKiBpbmRleFNpemUpXG4gICAgfVxuICB9XG5cbiAgdmFyIGlcbiAgaWYgKGRpcikge1xuICAgIHZhciBmb3VuZEluZGV4ID0gLTFcbiAgICBmb3IgKGkgPSBieXRlT2Zmc2V0OyBpIDwgYXJyTGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChyZWFkKGFyciwgaSkgPT09IHJlYWQodmFsLCBmb3VuZEluZGV4ID09PSAtMSA/IDAgOiBpIC0gZm91bmRJbmRleCkpIHtcbiAgICAgICAgaWYgKGZvdW5kSW5kZXggPT09IC0xKSBmb3VuZEluZGV4ID0gaVxuICAgICAgICBpZiAoaSAtIGZvdW5kSW5kZXggKyAxID09PSB2YWxMZW5ndGgpIHJldHVybiBmb3VuZEluZGV4ICogaW5kZXhTaXplXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoZm91bmRJbmRleCAhPT0gLTEpIGkgLT0gaSAtIGZvdW5kSW5kZXhcbiAgICAgICAgZm91bmRJbmRleCA9IC0xXG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmIChieXRlT2Zmc2V0ICsgdmFsTGVuZ3RoID4gYXJyTGVuZ3RoKSBieXRlT2Zmc2V0ID0gYXJyTGVuZ3RoIC0gdmFsTGVuZ3RoXG4gICAgZm9yIChpID0gYnl0ZU9mZnNldDsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIHZhciBmb3VuZCA9IHRydWVcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgdmFsTGVuZ3RoOyBqKyspIHtcbiAgICAgICAgaWYgKHJlYWQoYXJyLCBpICsgaikgIT09IHJlYWQodmFsLCBqKSkge1xuICAgICAgICAgIGZvdW5kID0gZmFsc2VcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoZm91bmQpIHJldHVybiBpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIC0xXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuaW5jbHVkZXMgPSBmdW5jdGlvbiBpbmNsdWRlcyAodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykge1xuICByZXR1cm4gdGhpcy5pbmRleE9mKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpICE9PSAtMVxufVxuXG5CdWZmZXIucHJvdG90eXBlLmluZGV4T2YgPSBmdW5jdGlvbiBpbmRleE9mICh2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSB7XG4gIHJldHVybiBiaWRpcmVjdGlvbmFsSW5kZXhPZih0aGlzLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCB0cnVlKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLmxhc3RJbmRleE9mID0gZnVuY3Rpb24gbGFzdEluZGV4T2YgKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIGJpZGlyZWN0aW9uYWxJbmRleE9mKHRoaXMsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGZhbHNlKVxufVxuXG5mdW5jdGlvbiBoZXhXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIG9mZnNldCA9IE51bWJlcihvZmZzZXQpIHx8IDBcbiAgdmFyIHJlbWFpbmluZyA9IGJ1Zi5sZW5ndGggLSBvZmZzZXRcbiAgaWYgKCFsZW5ndGgpIHtcbiAgICBsZW5ndGggPSByZW1haW5pbmdcbiAgfSBlbHNlIHtcbiAgICBsZW5ndGggPSBOdW1iZXIobGVuZ3RoKVxuICAgIGlmIChsZW5ndGggPiByZW1haW5pbmcpIHtcbiAgICAgIGxlbmd0aCA9IHJlbWFpbmluZ1xuICAgIH1cbiAgfVxuXG4gIC8vIG11c3QgYmUgYW4gZXZlbiBudW1iZXIgb2YgZGlnaXRzXG4gIHZhciBzdHJMZW4gPSBzdHJpbmcubGVuZ3RoXG4gIGlmIChzdHJMZW4gJSAyICE9PSAwKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIGhleCBzdHJpbmcnKVxuXG4gIGlmIChsZW5ndGggPiBzdHJMZW4gLyAyKSB7XG4gICAgbGVuZ3RoID0gc3RyTGVuIC8gMlxuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICB2YXIgcGFyc2VkID0gcGFyc2VJbnQoc3RyaW5nLnN1YnN0cihpICogMiwgMiksIDE2KVxuICAgIGlmIChpc05hTihwYXJzZWQpKSByZXR1cm4gaVxuICAgIGJ1ZltvZmZzZXQgKyBpXSA9IHBhcnNlZFxuICB9XG4gIHJldHVybiBpXG59XG5cbmZ1bmN0aW9uIHV0ZjhXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKHV0ZjhUb0J5dGVzKHN0cmluZywgYnVmLmxlbmd0aCAtIG9mZnNldCksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIGFzY2lpV3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcihhc2NpaVRvQnl0ZXMoc3RyaW5nKSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gbGF0aW4xV3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYXNjaWlXcml0ZShidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIGJhc2U2NFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIoYmFzZTY0VG9CeXRlcyhzdHJpbmcpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiB1Y3MyV3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcih1dGYxNmxlVG9CeXRlcyhzdHJpbmcsIGJ1Zi5sZW5ndGggLSBvZmZzZXQpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gd3JpdGUgKHN0cmluZywgb2Zmc2V0LCBsZW5ndGgsIGVuY29kaW5nKSB7XG4gIC8vIEJ1ZmZlciN3cml0ZShzdHJpbmcpXG4gIGlmIChvZmZzZXQgPT09IHVuZGVmaW5lZCkge1xuICAgIGVuY29kaW5nID0gJ3V0ZjgnXG4gICAgbGVuZ3RoID0gdGhpcy5sZW5ndGhcbiAgICBvZmZzZXQgPSAwXG4gIC8vIEJ1ZmZlciN3cml0ZShzdHJpbmcsIGVuY29kaW5nKVxuICB9IGVsc2UgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkICYmIHR5cGVvZiBvZmZzZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgZW5jb2RpbmcgPSBvZmZzZXRcbiAgICBsZW5ndGggPSB0aGlzLmxlbmd0aFxuICAgIG9mZnNldCA9IDBcbiAgLy8gQnVmZmVyI3dyaXRlKHN0cmluZywgb2Zmc2V0WywgbGVuZ3RoXVssIGVuY29kaW5nXSlcbiAgfSBlbHNlIGlmIChpc0Zpbml0ZShvZmZzZXQpKSB7XG4gICAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICAgIGlmIChpc0Zpbml0ZShsZW5ndGgpKSB7XG4gICAgICBsZW5ndGggPSBsZW5ndGggfCAwXG4gICAgICBpZiAoZW5jb2RpbmcgPT09IHVuZGVmaW5lZCkgZW5jb2RpbmcgPSAndXRmOCdcbiAgICB9IGVsc2Uge1xuICAgICAgZW5jb2RpbmcgPSBsZW5ndGhcbiAgICAgIGxlbmd0aCA9IHVuZGVmaW5lZFxuICAgIH1cbiAgLy8gbGVnYWN5IHdyaXRlKHN0cmluZywgZW5jb2RpbmcsIG9mZnNldCwgbGVuZ3RoKSAtIHJlbW92ZSBpbiB2MC4xM1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICdCdWZmZXIud3JpdGUoc3RyaW5nLCBlbmNvZGluZywgb2Zmc2V0WywgbGVuZ3RoXSkgaXMgbm8gbG9uZ2VyIHN1cHBvcnRlZCdcbiAgICApXG4gIH1cblxuICB2YXIgcmVtYWluaW5nID0gdGhpcy5sZW5ndGggLSBvZmZzZXRcbiAgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkIHx8IGxlbmd0aCA+IHJlbWFpbmluZykgbGVuZ3RoID0gcmVtYWluaW5nXG5cbiAgaWYgKChzdHJpbmcubGVuZ3RoID4gMCAmJiAobGVuZ3RoIDwgMCB8fCBvZmZzZXQgPCAwKSkgfHwgb2Zmc2V0ID4gdGhpcy5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQXR0ZW1wdCB0byB3cml0ZSBvdXRzaWRlIGJ1ZmZlciBib3VuZHMnKVxuICB9XG5cbiAgaWYgKCFlbmNvZGluZykgZW5jb2RpbmcgPSAndXRmOCdcblxuICB2YXIgbG93ZXJlZENhc2UgPSBmYWxzZVxuICBmb3IgKDs7KSB7XG4gICAgc3dpdGNoIChlbmNvZGluZykge1xuICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgcmV0dXJuIGhleFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgY2FzZSAndXRmLTgnOlxuICAgICAgICByZXR1cm4gdXRmOFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgICAgcmV0dXJuIGFzY2lpV3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAnbGF0aW4xJzpcbiAgICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICAgIHJldHVybiBsYXRpbjFXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgICAvLyBXYXJuaW5nOiBtYXhMZW5ndGggbm90IHRha2VuIGludG8gYWNjb3VudCBpbiBiYXNlNjRXcml0ZVxuICAgICAgICByZXR1cm4gYmFzZTY0V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAndWNzMic6XG4gICAgICBjYXNlICd1Y3MtMic6XG4gICAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgICAgcmV0dXJuIHVjczJXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAobG93ZXJlZENhc2UpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZylcbiAgICAgICAgZW5jb2RpbmcgPSAoJycgKyBlbmNvZGluZykudG9Mb3dlckNhc2UoKVxuICAgICAgICBsb3dlcmVkQ2FzZSA9IHRydWVcbiAgICB9XG4gIH1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiB0b0pTT04gKCkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6ICdCdWZmZXInLFxuICAgIGRhdGE6IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKHRoaXMuX2FyciB8fCB0aGlzLCAwKVxuICB9XG59XG5cbmZ1bmN0aW9uIGJhc2U2NFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgaWYgKHN0YXJ0ID09PSAwICYmIGVuZCA9PT0gYnVmLmxlbmd0aCkge1xuICAgIHJldHVybiBiYXNlNjQuZnJvbUJ5dGVBcnJheShidWYpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGJhc2U2NC5mcm9tQnl0ZUFycmF5KGJ1Zi5zbGljZShzdGFydCwgZW5kKSlcbiAgfVxufVxuXG5mdW5jdGlvbiB1dGY4U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpXG4gIHZhciByZXMgPSBbXVxuXG4gIHZhciBpID0gc3RhcnRcbiAgd2hpbGUgKGkgPCBlbmQpIHtcbiAgICB2YXIgZmlyc3RCeXRlID0gYnVmW2ldXG4gICAgdmFyIGNvZGVQb2ludCA9IG51bGxcbiAgICB2YXIgYnl0ZXNQZXJTZXF1ZW5jZSA9IChmaXJzdEJ5dGUgPiAweEVGKSA/IDRcbiAgICAgIDogKGZpcnN0Qnl0ZSA+IDB4REYpID8gM1xuICAgICAgOiAoZmlyc3RCeXRlID4gMHhCRikgPyAyXG4gICAgICA6IDFcblxuICAgIGlmIChpICsgYnl0ZXNQZXJTZXF1ZW5jZSA8PSBlbmQpIHtcbiAgICAgIHZhciBzZWNvbmRCeXRlLCB0aGlyZEJ5dGUsIGZvdXJ0aEJ5dGUsIHRlbXBDb2RlUG9pbnRcblxuICAgICAgc3dpdGNoIChieXRlc1BlclNlcXVlbmNlKSB7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICBpZiAoZmlyc3RCeXRlIDwgMHg4MCkge1xuICAgICAgICAgICAgY29kZVBvaW50ID0gZmlyc3RCeXRlXG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICBzZWNvbmRCeXRlID0gYnVmW2kgKyAxXVxuICAgICAgICAgIGlmICgoc2Vjb25kQnl0ZSAmIDB4QzApID09PSAweDgwKSB7XG4gICAgICAgICAgICB0ZW1wQ29kZVBvaW50ID0gKGZpcnN0Qnl0ZSAmIDB4MUYpIDw8IDB4NiB8IChzZWNvbmRCeXRlICYgMHgzRilcbiAgICAgICAgICAgIGlmICh0ZW1wQ29kZVBvaW50ID4gMHg3Rikge1xuICAgICAgICAgICAgICBjb2RlUG9pbnQgPSB0ZW1wQ29kZVBvaW50XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICBzZWNvbmRCeXRlID0gYnVmW2kgKyAxXVxuICAgICAgICAgIHRoaXJkQnl0ZSA9IGJ1ZltpICsgMl1cbiAgICAgICAgICBpZiAoKHNlY29uZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCAmJiAodGhpcmRCeXRlICYgMHhDMCkgPT09IDB4ODApIHtcbiAgICAgICAgICAgIHRlbXBDb2RlUG9pbnQgPSAoZmlyc3RCeXRlICYgMHhGKSA8PCAweEMgfCAoc2Vjb25kQnl0ZSAmIDB4M0YpIDw8IDB4NiB8ICh0aGlyZEJ5dGUgJiAweDNGKVxuICAgICAgICAgICAgaWYgKHRlbXBDb2RlUG9pbnQgPiAweDdGRiAmJiAodGVtcENvZGVQb2ludCA8IDB4RDgwMCB8fCB0ZW1wQ29kZVBvaW50ID4gMHhERkZGKSkge1xuICAgICAgICAgICAgICBjb2RlUG9pbnQgPSB0ZW1wQ29kZVBvaW50XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgNDpcbiAgICAgICAgICBzZWNvbmRCeXRlID0gYnVmW2kgKyAxXVxuICAgICAgICAgIHRoaXJkQnl0ZSA9IGJ1ZltpICsgMl1cbiAgICAgICAgICBmb3VydGhCeXRlID0gYnVmW2kgKyAzXVxuICAgICAgICAgIGlmICgoc2Vjb25kQnl0ZSAmIDB4QzApID09PSAweDgwICYmICh0aGlyZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCAmJiAoZm91cnRoQnl0ZSAmIDB4QzApID09PSAweDgwKSB7XG4gICAgICAgICAgICB0ZW1wQ29kZVBvaW50ID0gKGZpcnN0Qnl0ZSAmIDB4RikgPDwgMHgxMiB8IChzZWNvbmRCeXRlICYgMHgzRikgPDwgMHhDIHwgKHRoaXJkQnl0ZSAmIDB4M0YpIDw8IDB4NiB8IChmb3VydGhCeXRlICYgMHgzRilcbiAgICAgICAgICAgIGlmICh0ZW1wQ29kZVBvaW50ID4gMHhGRkZGICYmIHRlbXBDb2RlUG9pbnQgPCAweDExMDAwMCkge1xuICAgICAgICAgICAgICBjb2RlUG9pbnQgPSB0ZW1wQ29kZVBvaW50XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChjb2RlUG9pbnQgPT09IG51bGwpIHtcbiAgICAgIC8vIHdlIGRpZCBub3QgZ2VuZXJhdGUgYSB2YWxpZCBjb2RlUG9pbnQgc28gaW5zZXJ0IGFcbiAgICAgIC8vIHJlcGxhY2VtZW50IGNoYXIgKFUrRkZGRCkgYW5kIGFkdmFuY2Ugb25seSAxIGJ5dGVcbiAgICAgIGNvZGVQb2ludCA9IDB4RkZGRFxuICAgICAgYnl0ZXNQZXJTZXF1ZW5jZSA9IDFcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA+IDB4RkZGRikge1xuICAgICAgLy8gZW5jb2RlIHRvIHV0ZjE2IChzdXJyb2dhdGUgcGFpciBkYW5jZSlcbiAgICAgIGNvZGVQb2ludCAtPSAweDEwMDAwXG4gICAgICByZXMucHVzaChjb2RlUG9pbnQgPj4+IDEwICYgMHgzRkYgfCAweEQ4MDApXG4gICAgICBjb2RlUG9pbnQgPSAweERDMDAgfCBjb2RlUG9pbnQgJiAweDNGRlxuICAgIH1cblxuICAgIHJlcy5wdXNoKGNvZGVQb2ludClcbiAgICBpICs9IGJ5dGVzUGVyU2VxdWVuY2VcbiAgfVxuXG4gIHJldHVybiBkZWNvZGVDb2RlUG9pbnRzQXJyYXkocmVzKVxufVxuXG4vLyBCYXNlZCBvbiBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8yMjc0NzI3Mi82ODA3NDIsIHRoZSBicm93c2VyIHdpdGhcbi8vIHRoZSBsb3dlc3QgbGltaXQgaXMgQ2hyb21lLCB3aXRoIDB4MTAwMDAgYXJncy5cbi8vIFdlIGdvIDEgbWFnbml0dWRlIGxlc3MsIGZvciBzYWZldHlcbnZhciBNQVhfQVJHVU1FTlRTX0xFTkdUSCA9IDB4MTAwMFxuXG5mdW5jdGlvbiBkZWNvZGVDb2RlUG9pbnRzQXJyYXkgKGNvZGVQb2ludHMpIHtcbiAgdmFyIGxlbiA9IGNvZGVQb2ludHMubGVuZ3RoXG4gIGlmIChsZW4gPD0gTUFYX0FSR1VNRU5UU19MRU5HVEgpIHtcbiAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShTdHJpbmcsIGNvZGVQb2ludHMpIC8vIGF2b2lkIGV4dHJhIHNsaWNlKClcbiAgfVxuXG4gIC8vIERlY29kZSBpbiBjaHVua3MgdG8gYXZvaWQgXCJjYWxsIHN0YWNrIHNpemUgZXhjZWVkZWRcIi5cbiAgdmFyIHJlcyA9ICcnXG4gIHZhciBpID0gMFxuICB3aGlsZSAoaSA8IGxlbikge1xuICAgIHJlcyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFxuICAgICAgU3RyaW5nLFxuICAgICAgY29kZVBvaW50cy5zbGljZShpLCBpICs9IE1BWF9BUkdVTUVOVFNfTEVOR1RIKVxuICAgIClcbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbmZ1bmN0aW9uIGFzY2lpU2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgcmV0ID0gJydcbiAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKVxuXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgcmV0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnVmW2ldICYgMHg3RilcbiAgfVxuICByZXR1cm4gcmV0XG59XG5cbmZ1bmN0aW9uIGxhdGluMVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIHJldCA9ICcnXG4gIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZClcblxuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgIHJldCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ1ZltpXSlcbiAgfVxuICByZXR1cm4gcmV0XG59XG5cbmZ1bmN0aW9uIGhleFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGxlbiA9IGJ1Zi5sZW5ndGhcblxuICBpZiAoIXN0YXJ0IHx8IHN0YXJ0IDwgMCkgc3RhcnQgPSAwXG4gIGlmICghZW5kIHx8IGVuZCA8IDAgfHwgZW5kID4gbGVuKSBlbmQgPSBsZW5cblxuICB2YXIgb3V0ID0gJydcbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICBvdXQgKz0gdG9IZXgoYnVmW2ldKVxuICB9XG4gIHJldHVybiBvdXRcbn1cblxuZnVuY3Rpb24gdXRmMTZsZVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGJ5dGVzID0gYnVmLnNsaWNlKHN0YXJ0LCBlbmQpXG4gIHZhciByZXMgPSAnJ1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGJ5dGVzLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgcmVzICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnl0ZXNbaV0gKyBieXRlc1tpICsgMV0gKiAyNTYpXG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnNsaWNlID0gZnVuY3Rpb24gc2xpY2UgKHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoXG4gIHN0YXJ0ID0gfn5zdGFydFxuICBlbmQgPSBlbmQgPT09IHVuZGVmaW5lZCA/IGxlbiA6IH5+ZW5kXG5cbiAgaWYgKHN0YXJ0IDwgMCkge1xuICAgIHN0YXJ0ICs9IGxlblxuICAgIGlmIChzdGFydCA8IDApIHN0YXJ0ID0gMFxuICB9IGVsc2UgaWYgKHN0YXJ0ID4gbGVuKSB7XG4gICAgc3RhcnQgPSBsZW5cbiAgfVxuXG4gIGlmIChlbmQgPCAwKSB7XG4gICAgZW5kICs9IGxlblxuICAgIGlmIChlbmQgPCAwKSBlbmQgPSAwXG4gIH0gZWxzZSBpZiAoZW5kID4gbGVuKSB7XG4gICAgZW5kID0gbGVuXG4gIH1cblxuICBpZiAoZW5kIDwgc3RhcnQpIGVuZCA9IHN0YXJ0XG5cbiAgdmFyIG5ld0J1ZlxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICBuZXdCdWYgPSB0aGlzLnN1YmFycmF5KHN0YXJ0LCBlbmQpXG4gICAgbmV3QnVmLl9fcHJvdG9fXyA9IEJ1ZmZlci5wcm90b3R5cGVcbiAgfSBlbHNlIHtcbiAgICB2YXIgc2xpY2VMZW4gPSBlbmQgLSBzdGFydFxuICAgIG5ld0J1ZiA9IG5ldyBCdWZmZXIoc2xpY2VMZW4sIHVuZGVmaW5lZClcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNsaWNlTGVuOyArK2kpIHtcbiAgICAgIG5ld0J1ZltpXSA9IHRoaXNbaSArIHN0YXJ0XVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBuZXdCdWZcbn1cblxuLypcbiAqIE5lZWQgdG8gbWFrZSBzdXJlIHRoYXQgYnVmZmVyIGlzbid0IHRyeWluZyB0byB3cml0ZSBvdXQgb2YgYm91bmRzLlxuICovXG5mdW5jdGlvbiBjaGVja09mZnNldCAob2Zmc2V0LCBleHQsIGxlbmd0aCkge1xuICBpZiAoKG9mZnNldCAlIDEpICE9PSAwIHx8IG9mZnNldCA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCdvZmZzZXQgaXMgbm90IHVpbnQnKVxuICBpZiAob2Zmc2V0ICsgZXh0ID4gbGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVHJ5aW5nIHRvIGFjY2VzcyBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnRMRSA9IGZ1bmN0aW9uIHJlYWRVSW50TEUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcblxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXRdXG4gIHZhciBtdWwgPSAxXG4gIHZhciBpID0gMFxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIGldICogbXVsXG4gIH1cblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnRCRSA9IGZ1bmN0aW9uIHJlYWRVSW50QkUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG4gIH1cblxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXQgKyAtLWJ5dGVMZW5ndGhdXG4gIHZhciBtdWwgPSAxXG4gIHdoaWxlIChieXRlTGVuZ3RoID4gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIC0tYnl0ZUxlbmd0aF0gKiBtdWxcbiAgfVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDggPSBmdW5jdGlvbiByZWFkVUludDggKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAxLCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIHRoaXNbb2Zmc2V0XVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MTZMRSA9IGZ1bmN0aW9uIHJlYWRVSW50MTZMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gdGhpc1tvZmZzZXRdIHwgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDE2QkUgPSBmdW5jdGlvbiByZWFkVUludDE2QkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuICh0aGlzW29mZnNldF0gPDwgOCkgfCB0aGlzW29mZnNldCArIDFdXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQzMkxFID0gZnVuY3Rpb24gcmVhZFVJbnQzMkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICgodGhpc1tvZmZzZXRdKSB8XG4gICAgICAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KSB8XG4gICAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCAxNikpICtcbiAgICAgICh0aGlzW29mZnNldCArIDNdICogMHgxMDAwMDAwKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MzJCRSA9IGZ1bmN0aW9uIHJlYWRVSW50MzJCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAodGhpc1tvZmZzZXRdICogMHgxMDAwMDAwKSArXG4gICAgKCh0aGlzW29mZnNldCArIDFdIDw8IDE2KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgOCkgfFxuICAgIHRoaXNbb2Zmc2V0ICsgM10pXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludExFID0gZnVuY3Rpb24gcmVhZEludExFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG5cbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0XVxuICB2YXIgbXVsID0gMVxuICB2YXIgaSA9IDBcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyBpXSAqIG11bFxuICB9XG4gIG11bCAqPSAweDgwXG5cbiAgaWYgKHZhbCA+PSBtdWwpIHZhbCAtPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aClcblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludEJFID0gZnVuY3Rpb24gcmVhZEludEJFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG5cbiAgdmFyIGkgPSBieXRlTGVuZ3RoXG4gIHZhciBtdWwgPSAxXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldCArIC0taV1cbiAgd2hpbGUgKGkgPiAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgLS1pXSAqIG11bFxuICB9XG4gIG11bCAqPSAweDgwXG5cbiAgaWYgKHZhbCA+PSBtdWwpIHZhbCAtPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aClcblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDggPSBmdW5jdGlvbiByZWFkSW50OCAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDEsIHRoaXMubGVuZ3RoKVxuICBpZiAoISh0aGlzW29mZnNldF0gJiAweDgwKSkgcmV0dXJuICh0aGlzW29mZnNldF0pXG4gIHJldHVybiAoKDB4ZmYgLSB0aGlzW29mZnNldF0gKyAxKSAqIC0xKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQxNkxFID0gZnVuY3Rpb24gcmVhZEludDE2TEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0XSB8ICh0aGlzW29mZnNldCArIDFdIDw8IDgpXG4gIHJldHVybiAodmFsICYgMHg4MDAwKSA/IHZhbCB8IDB4RkZGRjAwMDAgOiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MTZCRSA9IGZ1bmN0aW9uIHJlYWRJbnQxNkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldCArIDFdIHwgKHRoaXNbb2Zmc2V0XSA8PCA4KVxuICByZXR1cm4gKHZhbCAmIDB4ODAwMCkgPyB2YWwgfCAweEZGRkYwMDAwIDogdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDMyTEUgPSBmdW5jdGlvbiByZWFkSW50MzJMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAodGhpc1tvZmZzZXRdKSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOCkgfFxuICAgICh0aGlzW29mZnNldCArIDJdIDw8IDE2KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgM10gPDwgMjQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDMyQkUgPSBmdW5jdGlvbiByZWFkSW50MzJCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAodGhpc1tvZmZzZXRdIDw8IDI0KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgMTYpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCA4KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgM10pXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEZsb2F0TEUgPSBmdW5jdGlvbiByZWFkRmxvYXRMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgdHJ1ZSwgMjMsIDQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEZsb2F0QkUgPSBmdW5jdGlvbiByZWFkRmxvYXRCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgZmFsc2UsIDIzLCA0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWREb3VibGVMRSA9IGZ1bmN0aW9uIHJlYWREb3VibGVMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDgsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgdHJ1ZSwgNTIsIDgpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZERvdWJsZUJFID0gZnVuY3Rpb24gcmVhZERvdWJsZUJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgOCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCBmYWxzZSwgNTIsIDgpXG59XG5cbmZ1bmN0aW9uIGNoZWNrSW50IChidWYsIHZhbHVlLCBvZmZzZXQsIGV4dCwgbWF4LCBtaW4pIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYnVmKSkgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJidWZmZXJcIiBhcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyIGluc3RhbmNlJylcbiAgaWYgKHZhbHVlID4gbWF4IHx8IHZhbHVlIDwgbWluKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXCJ2YWx1ZVwiIGFyZ3VtZW50IGlzIG91dCBvZiBib3VuZHMnKVxuICBpZiAob2Zmc2V0ICsgZXh0ID4gYnVmLmxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZScpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50TEUgPSBmdW5jdGlvbiB3cml0ZVVJbnRMRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIHZhciBtYXhCeXRlcyA9IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKSAtIDFcbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBtYXhCeXRlcywgMClcbiAgfVxuXG4gIHZhciBtdWwgPSAxXG4gIHZhciBpID0gMFxuICB0aGlzW29mZnNldF0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB0aGlzW29mZnNldCArIGldID0gKHZhbHVlIC8gbXVsKSAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50QkUgPSBmdW5jdGlvbiB3cml0ZVVJbnRCRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIHZhciBtYXhCeXRlcyA9IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKSAtIDFcbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBtYXhCeXRlcywgMClcbiAgfVxuXG4gIHZhciBpID0gYnl0ZUxlbmd0aCAtIDFcbiAgdmFyIG11bCA9IDFcbiAgdGhpc1tvZmZzZXQgKyBpXSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoLS1pID49IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB0aGlzW29mZnNldCArIGldID0gKHZhbHVlIC8gbXVsKSAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50OCA9IGZ1bmN0aW9uIHdyaXRlVUludDggKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMSwgMHhmZiwgMClcbiAgaWYgKCFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkgdmFsdWUgPSBNYXRoLmZsb29yKHZhbHVlKVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgMVxufVxuXG5mdW5jdGlvbiBvYmplY3RXcml0ZVVJbnQxNiAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4pIHtcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmZmYgKyB2YWx1ZSArIDFcbiAgZm9yICh2YXIgaSA9IDAsIGogPSBNYXRoLm1pbihidWYubGVuZ3RoIC0gb2Zmc2V0LCAyKTsgaSA8IGo7ICsraSkge1xuICAgIGJ1ZltvZmZzZXQgKyBpXSA9ICh2YWx1ZSAmICgweGZmIDw8ICg4ICogKGxpdHRsZUVuZGlhbiA/IGkgOiAxIC0gaSkpKSkgPj4+XG4gICAgICAobGl0dGxlRW5kaWFuID8gaSA6IDEgLSBpKSAqIDhcbiAgfVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDE2TEUgPSBmdW5jdGlvbiB3cml0ZVVJbnQxNkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4ZmZmZiwgMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDE2KHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQxNkJFID0gZnVuY3Rpb24gd3JpdGVVSW50MTZCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweGZmZmYsIDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlICYgMHhmZilcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5mdW5jdGlvbiBvYmplY3RXcml0ZVVJbnQzMiAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4pIHtcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmZmZmZmZmICsgdmFsdWUgKyAxXG4gIGZvciAodmFyIGkgPSAwLCBqID0gTWF0aC5taW4oYnVmLmxlbmd0aCAtIG9mZnNldCwgNCk7IGkgPCBqOyArK2kpIHtcbiAgICBidWZbb2Zmc2V0ICsgaV0gPSAodmFsdWUgPj4+IChsaXR0bGVFbmRpYW4gPyBpIDogMyAtIGkpICogOCkgJiAweGZmXG4gIH1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQzMkxFID0gZnVuY3Rpb24gd3JpdGVVSW50MzJMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweGZmZmZmZmZmLCAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlID4+PiAyNClcbiAgICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiAxNilcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDMyQkUgPSBmdW5jdGlvbiB3cml0ZVVJbnQzMkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4ZmZmZmZmZmYsIDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gMjQpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gICAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlICYgMHhmZilcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50TEUgPSBmdW5jdGlvbiB3cml0ZUludExFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICB2YXIgbGltaXQgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCAtIDEpXG5cbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBsaW1pdCAtIDEsIC1saW1pdClcbiAgfVxuXG4gIHZhciBpID0gMFxuICB2YXIgbXVsID0gMVxuICB2YXIgc3ViID0gMFxuICB0aGlzW29mZnNldF0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICBpZiAodmFsdWUgPCAwICYmIHN1YiA9PT0gMCAmJiB0aGlzW29mZnNldCArIGkgLSAxXSAhPT0gMCkge1xuICAgICAgc3ViID0gMVxuICAgIH1cbiAgICB0aGlzW29mZnNldCArIGldID0gKCh2YWx1ZSAvIG11bCkgPj4gMCkgLSBzdWIgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50QkUgPSBmdW5jdGlvbiB3cml0ZUludEJFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICB2YXIgbGltaXQgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCAtIDEpXG5cbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBsaW1pdCAtIDEsIC1saW1pdClcbiAgfVxuXG4gIHZhciBpID0gYnl0ZUxlbmd0aCAtIDFcbiAgdmFyIG11bCA9IDFcbiAgdmFyIHN1YiA9IDBcbiAgdGhpc1tvZmZzZXQgKyBpXSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoLS1pID49IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICBpZiAodmFsdWUgPCAwICYmIHN1YiA9PT0gMCAmJiB0aGlzW29mZnNldCArIGkgKyAxXSAhPT0gMCkge1xuICAgICAgc3ViID0gMVxuICAgIH1cbiAgICB0aGlzW29mZnNldCArIGldID0gKCh2YWx1ZSAvIG11bCkgPj4gMCkgLSBzdWIgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50OCA9IGZ1bmN0aW9uIHdyaXRlSW50OCAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAxLCAweDdmLCAtMHg4MClcbiAgaWYgKCFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkgdmFsdWUgPSBNYXRoLmZsb29yKHZhbHVlKVxuICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmYgKyB2YWx1ZSArIDFcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDFcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDE2TEUgPSBmdW5jdGlvbiB3cml0ZUludDE2TEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHg3ZmZmLCAtMHg4MDAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MTZCRSA9IGZ1bmN0aW9uIHdyaXRlSW50MTZCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweDdmZmYsIC0weDgwMDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlICYgMHhmZilcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MzJMRSA9IGZ1bmN0aW9uIHdyaXRlSW50MzJMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweDdmZmZmZmZmLCAtMHg4MDAwMDAwMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDE2KVxuICAgIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgPj4+IDI0KVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDMyKHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDMyQkUgPSBmdW5jdGlvbiB3cml0ZUludDMyQkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHg3ZmZmZmZmZiwgLTB4ODAwMDAwMDApXG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZmZmZmZmZiArIHZhbHVlICsgMVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDI0KVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDE2KVxuICAgIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDgpXG4gICAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuZnVuY3Rpb24gY2hlY2tJRUVFNzU0IChidWYsIHZhbHVlLCBvZmZzZXQsIGV4dCwgbWF4LCBtaW4pIHtcbiAgaWYgKG9mZnNldCArIGV4dCA+IGJ1Zi5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UnKVxuICBpZiAob2Zmc2V0IDwgMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZScpXG59XG5cbmZ1bmN0aW9uIHdyaXRlRmxvYXQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY2hlY2tJRUVFNzU0KGJ1ZiwgdmFsdWUsIG9mZnNldCwgNCwgMy40MDI4MjM0NjYzODUyODg2ZSszOCwgLTMuNDAyODIzNDY2Mzg1Mjg4NmUrMzgpXG4gIH1cbiAgaWVlZTc1NC53cml0ZShidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgMjMsIDQpXG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVGbG9hdExFID0gZnVuY3Rpb24gd3JpdGVGbG9hdExFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVGbG9hdCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUZsb2F0QkUgPSBmdW5jdGlvbiB3cml0ZUZsb2F0QkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZUZsb2F0KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn1cblxuZnVuY3Rpb24gd3JpdGVEb3VibGUgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY2hlY2tJRUVFNzU0KGJ1ZiwgdmFsdWUsIG9mZnNldCwgOCwgMS43OTc2OTMxMzQ4NjIzMTU3RSszMDgsIC0xLjc5NzY5MzEzNDg2MjMxNTdFKzMwOClcbiAgfVxuICBpZWVlNzU0LndyaXRlKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCA1MiwgOClcbiAgcmV0dXJuIG9mZnNldCArIDhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZURvdWJsZUxFID0gZnVuY3Rpb24gd3JpdGVEb3VibGVMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRG91YmxlKHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRG91YmxlQkUgPSBmdW5jdGlvbiB3cml0ZURvdWJsZUJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVEb3VibGUodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG4vLyBjb3B5KHRhcmdldEJ1ZmZlciwgdGFyZ2V0U3RhcnQ9MCwgc291cmNlU3RhcnQ9MCwgc291cmNlRW5kPWJ1ZmZlci5sZW5ndGgpXG5CdWZmZXIucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiBjb3B5ICh0YXJnZXQsIHRhcmdldFN0YXJ0LCBzdGFydCwgZW5kKSB7XG4gIGlmICghc3RhcnQpIHN0YXJ0ID0gMFxuICBpZiAoIWVuZCAmJiBlbmQgIT09IDApIGVuZCA9IHRoaXMubGVuZ3RoXG4gIGlmICh0YXJnZXRTdGFydCA+PSB0YXJnZXQubGVuZ3RoKSB0YXJnZXRTdGFydCA9IHRhcmdldC5sZW5ndGhcbiAgaWYgKCF0YXJnZXRTdGFydCkgdGFyZ2V0U3RhcnQgPSAwXG4gIGlmIChlbmQgPiAwICYmIGVuZCA8IHN0YXJ0KSBlbmQgPSBzdGFydFxuXG4gIC8vIENvcHkgMCBieXRlczsgd2UncmUgZG9uZVxuICBpZiAoZW5kID09PSBzdGFydCkgcmV0dXJuIDBcbiAgaWYgKHRhcmdldC5sZW5ndGggPT09IDAgfHwgdGhpcy5sZW5ndGggPT09IDApIHJldHVybiAwXG5cbiAgLy8gRmF0YWwgZXJyb3IgY29uZGl0aW9uc1xuICBpZiAodGFyZ2V0U3RhcnQgPCAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3RhcmdldFN0YXJ0IG91dCBvZiBib3VuZHMnKVxuICB9XG4gIGlmIChzdGFydCA8IDAgfHwgc3RhcnQgPj0gdGhpcy5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdzb3VyY2VTdGFydCBvdXQgb2YgYm91bmRzJylcbiAgaWYgKGVuZCA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCdzb3VyY2VFbmQgb3V0IG9mIGJvdW5kcycpXG5cbiAgLy8gQXJlIHdlIG9vYj9cbiAgaWYgKGVuZCA+IHRoaXMubGVuZ3RoKSBlbmQgPSB0aGlzLmxlbmd0aFxuICBpZiAodGFyZ2V0Lmxlbmd0aCAtIHRhcmdldFN0YXJ0IDwgZW5kIC0gc3RhcnQpIHtcbiAgICBlbmQgPSB0YXJnZXQubGVuZ3RoIC0gdGFyZ2V0U3RhcnQgKyBzdGFydFxuICB9XG5cbiAgdmFyIGxlbiA9IGVuZCAtIHN0YXJ0XG4gIHZhciBpXG5cbiAgaWYgKHRoaXMgPT09IHRhcmdldCAmJiBzdGFydCA8IHRhcmdldFN0YXJ0ICYmIHRhcmdldFN0YXJ0IDwgZW5kKSB7XG4gICAgLy8gZGVzY2VuZGluZyBjb3B5IGZyb20gZW5kXG4gICAgZm9yIChpID0gbGVuIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgIHRhcmdldFtpICsgdGFyZ2V0U3RhcnRdID0gdGhpc1tpICsgc3RhcnRdXG4gICAgfVxuICB9IGVsc2UgaWYgKGxlbiA8IDEwMDAgfHwgIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgLy8gYXNjZW5kaW5nIGNvcHkgZnJvbSBzdGFydFxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47ICsraSkge1xuICAgICAgdGFyZ2V0W2kgKyB0YXJnZXRTdGFydF0gPSB0aGlzW2kgKyBzdGFydF1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgVWludDhBcnJheS5wcm90b3R5cGUuc2V0LmNhbGwoXG4gICAgICB0YXJnZXQsXG4gICAgICB0aGlzLnN1YmFycmF5KHN0YXJ0LCBzdGFydCArIGxlbiksXG4gICAgICB0YXJnZXRTdGFydFxuICAgIClcbiAgfVxuXG4gIHJldHVybiBsZW5cbn1cblxuLy8gVXNhZ2U6XG4vLyAgICBidWZmZXIuZmlsbChudW1iZXJbLCBvZmZzZXRbLCBlbmRdXSlcbi8vICAgIGJ1ZmZlci5maWxsKGJ1ZmZlclssIG9mZnNldFssIGVuZF1dKVxuLy8gICAgYnVmZmVyLmZpbGwoc3RyaW5nWywgb2Zmc2V0WywgZW5kXV1bLCBlbmNvZGluZ10pXG5CdWZmZXIucHJvdG90eXBlLmZpbGwgPSBmdW5jdGlvbiBmaWxsICh2YWwsIHN0YXJ0LCBlbmQsIGVuY29kaW5nKSB7XG4gIC8vIEhhbmRsZSBzdHJpbmcgY2FzZXM6XG4gIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJykge1xuICAgIGlmICh0eXBlb2Ygc3RhcnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICBlbmNvZGluZyA9IHN0YXJ0XG4gICAgICBzdGFydCA9IDBcbiAgICAgIGVuZCA9IHRoaXMubGVuZ3RoXG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZW5kID09PSAnc3RyaW5nJykge1xuICAgICAgZW5jb2RpbmcgPSBlbmRcbiAgICAgIGVuZCA9IHRoaXMubGVuZ3RoXG4gICAgfVxuICAgIGlmICh2YWwubGVuZ3RoID09PSAxKSB7XG4gICAgICB2YXIgY29kZSA9IHZhbC5jaGFyQ29kZUF0KDApXG4gICAgICBpZiAoY29kZSA8IDI1Nikge1xuICAgICAgICB2YWwgPSBjb2RlXG4gICAgICB9XG4gICAgfVxuICAgIGlmIChlbmNvZGluZyAhPT0gdW5kZWZpbmVkICYmIHR5cGVvZiBlbmNvZGluZyAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2VuY29kaW5nIG11c3QgYmUgYSBzdHJpbmcnKVxuICAgIH1cbiAgICBpZiAodHlwZW9mIGVuY29kaW5nID09PSAnc3RyaW5nJyAmJiAhQnVmZmVyLmlzRW5jb2RpbmcoZW5jb2RpbmcpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gICAgfVxuICB9IGVsc2UgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgdmFsID0gdmFsICYgMjU1XG4gIH1cblxuICAvLyBJbnZhbGlkIHJhbmdlcyBhcmUgbm90IHNldCB0byBhIGRlZmF1bHQsIHNvIGNhbiByYW5nZSBjaGVjayBlYXJseS5cbiAgaWYgKHN0YXJ0IDwgMCB8fCB0aGlzLmxlbmd0aCA8IHN0YXJ0IHx8IHRoaXMubGVuZ3RoIDwgZW5kKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ091dCBvZiByYW5nZSBpbmRleCcpXG4gIH1cblxuICBpZiAoZW5kIDw9IHN0YXJ0KSB7XG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIHN0YXJ0ID0gc3RhcnQgPj4+IDBcbiAgZW5kID0gZW5kID09PSB1bmRlZmluZWQgPyB0aGlzLmxlbmd0aCA6IGVuZCA+Pj4gMFxuXG4gIGlmICghdmFsKSB2YWwgPSAwXG5cbiAgdmFyIGlcbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgZm9yIChpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgICAgdGhpc1tpXSA9IHZhbFxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YXIgYnl0ZXMgPSBCdWZmZXIuaXNCdWZmZXIodmFsKVxuICAgICAgPyB2YWxcbiAgICAgIDogdXRmOFRvQnl0ZXMobmV3IEJ1ZmZlcih2YWwsIGVuY29kaW5nKS50b1N0cmluZygpKVxuICAgIHZhciBsZW4gPSBieXRlcy5sZW5ndGhcbiAgICBmb3IgKGkgPSAwOyBpIDwgZW5kIC0gc3RhcnQ7ICsraSkge1xuICAgICAgdGhpc1tpICsgc3RhcnRdID0gYnl0ZXNbaSAlIGxlbl1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGhpc1xufVxuXG4vLyBIRUxQRVIgRlVOQ1RJT05TXG4vLyA9PT09PT09PT09PT09PT09XG5cbnZhciBJTlZBTElEX0JBU0U2NF9SRSA9IC9bXitcXC8wLTlBLVphLXotX10vZ1xuXG5mdW5jdGlvbiBiYXNlNjRjbGVhbiAoc3RyKSB7XG4gIC8vIE5vZGUgc3RyaXBzIG91dCBpbnZhbGlkIGNoYXJhY3RlcnMgbGlrZSBcXG4gYW5kIFxcdCBmcm9tIHRoZSBzdHJpbmcsIGJhc2U2NC1qcyBkb2VzIG5vdFxuICBzdHIgPSBzdHJpbmd0cmltKHN0cikucmVwbGFjZShJTlZBTElEX0JBU0U2NF9SRSwgJycpXG4gIC8vIE5vZGUgY29udmVydHMgc3RyaW5ncyB3aXRoIGxlbmd0aCA8IDIgdG8gJydcbiAgaWYgKHN0ci5sZW5ndGggPCAyKSByZXR1cm4gJydcbiAgLy8gTm9kZSBhbGxvd3MgZm9yIG5vbi1wYWRkZWQgYmFzZTY0IHN0cmluZ3MgKG1pc3NpbmcgdHJhaWxpbmcgPT09KSwgYmFzZTY0LWpzIGRvZXMgbm90XG4gIHdoaWxlIChzdHIubGVuZ3RoICUgNCAhPT0gMCkge1xuICAgIHN0ciA9IHN0ciArICc9J1xuICB9XG4gIHJldHVybiBzdHJcbn1cblxuZnVuY3Rpb24gc3RyaW5ndHJpbSAoc3RyKSB7XG4gIGlmIChzdHIudHJpbSkgcmV0dXJuIHN0ci50cmltKClcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKC9eXFxzK3xcXHMrJC9nLCAnJylcbn1cblxuZnVuY3Rpb24gdG9IZXggKG4pIHtcbiAgaWYgKG4gPCAxNikgcmV0dXJuICcwJyArIG4udG9TdHJpbmcoMTYpXG4gIHJldHVybiBuLnRvU3RyaW5nKDE2KVxufVxuXG5mdW5jdGlvbiB1dGY4VG9CeXRlcyAoc3RyaW5nLCB1bml0cykge1xuICB1bml0cyA9IHVuaXRzIHx8IEluZmluaXR5XG4gIHZhciBjb2RlUG9pbnRcbiAgdmFyIGxlbmd0aCA9IHN0cmluZy5sZW5ndGhcbiAgdmFyIGxlYWRTdXJyb2dhdGUgPSBudWxsXG4gIHZhciBieXRlcyA9IFtdXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgIGNvZGVQb2ludCA9IHN0cmluZy5jaGFyQ29kZUF0KGkpXG5cbiAgICAvLyBpcyBzdXJyb2dhdGUgY29tcG9uZW50XG4gICAgaWYgKGNvZGVQb2ludCA+IDB4RDdGRiAmJiBjb2RlUG9pbnQgPCAweEUwMDApIHtcbiAgICAgIC8vIGxhc3QgY2hhciB3YXMgYSBsZWFkXG4gICAgICBpZiAoIWxlYWRTdXJyb2dhdGUpIHtcbiAgICAgICAgLy8gbm8gbGVhZCB5ZXRcbiAgICAgICAgaWYgKGNvZGVQb2ludCA+IDB4REJGRikge1xuICAgICAgICAgIC8vIHVuZXhwZWN0ZWQgdHJhaWxcbiAgICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9IGVsc2UgaWYgKGkgKyAxID09PSBsZW5ndGgpIHtcbiAgICAgICAgICAvLyB1bnBhaXJlZCBsZWFkXG4gICAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHZhbGlkIGxlYWRcbiAgICAgICAgbGVhZFN1cnJvZ2F0ZSA9IGNvZGVQb2ludFxuXG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG5cbiAgICAgIC8vIDIgbGVhZHMgaW4gYSByb3dcbiAgICAgIGlmIChjb2RlUG9pbnQgPCAweERDMDApIHtcbiAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgICAgIGxlYWRTdXJyb2dhdGUgPSBjb2RlUG9pbnRcbiAgICAgICAgY29udGludWVcbiAgICAgIH1cblxuICAgICAgLy8gdmFsaWQgc3Vycm9nYXRlIHBhaXJcbiAgICAgIGNvZGVQb2ludCA9IChsZWFkU3Vycm9nYXRlIC0gMHhEODAwIDw8IDEwIHwgY29kZVBvaW50IC0gMHhEQzAwKSArIDB4MTAwMDBcbiAgICB9IGVsc2UgaWYgKGxlYWRTdXJyb2dhdGUpIHtcbiAgICAgIC8vIHZhbGlkIGJtcCBjaGFyLCBidXQgbGFzdCBjaGFyIHdhcyBhIGxlYWRcbiAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgIH1cblxuICAgIGxlYWRTdXJyb2dhdGUgPSBudWxsXG5cbiAgICAvLyBlbmNvZGUgdXRmOFxuICAgIGlmIChjb2RlUG9pbnQgPCAweDgwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDEpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goY29kZVBvaW50KVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHg4MDApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gMikgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChcbiAgICAgICAgY29kZVBvaW50ID4+IDB4NiB8IDB4QzAsXG4gICAgICAgIGNvZGVQb2ludCAmIDB4M0YgfCAweDgwXG4gICAgICApXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCAweDEwMDAwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDMpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goXG4gICAgICAgIGNvZGVQb2ludCA+PiAweEMgfCAweEUwLFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHg2ICYgMHgzRiB8IDB4ODAsXG4gICAgICAgIGNvZGVQb2ludCAmIDB4M0YgfCAweDgwXG4gICAgICApXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCAweDExMDAwMCkge1xuICAgICAgaWYgKCh1bml0cyAtPSA0KSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHgxMiB8IDB4RjAsXG4gICAgICAgIGNvZGVQb2ludCA+PiAweEMgJiAweDNGIHwgMHg4MCxcbiAgICAgICAgY29kZVBvaW50ID4+IDB4NiAmIDB4M0YgfCAweDgwLFxuICAgICAgICBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MFxuICAgICAgKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgY29kZSBwb2ludCcpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGJ5dGVzXG59XG5cbmZ1bmN0aW9uIGFzY2lpVG9CeXRlcyAoc3RyKSB7XG4gIHZhciBieXRlQXJyYXkgPSBbXVxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7ICsraSkge1xuICAgIC8vIE5vZGUncyBjb2RlIHNlZW1zIHRvIGJlIGRvaW5nIHRoaXMgYW5kIG5vdCAmIDB4N0YuLlxuICAgIGJ5dGVBcnJheS5wdXNoKHN0ci5jaGFyQ29kZUF0KGkpICYgMHhGRilcbiAgfVxuICByZXR1cm4gYnl0ZUFycmF5XG59XG5cbmZ1bmN0aW9uIHV0ZjE2bGVUb0J5dGVzIChzdHIsIHVuaXRzKSB7XG4gIHZhciBjLCBoaSwgbG9cbiAgdmFyIGJ5dGVBcnJheSA9IFtdXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgKytpKSB7XG4gICAgaWYgKCh1bml0cyAtPSAyKSA8IDApIGJyZWFrXG5cbiAgICBjID0gc3RyLmNoYXJDb2RlQXQoaSlcbiAgICBoaSA9IGMgPj4gOFxuICAgIGxvID0gYyAlIDI1NlxuICAgIGJ5dGVBcnJheS5wdXNoKGxvKVxuICAgIGJ5dGVBcnJheS5wdXNoKGhpKVxuICB9XG5cbiAgcmV0dXJuIGJ5dGVBcnJheVxufVxuXG5mdW5jdGlvbiBiYXNlNjRUb0J5dGVzIChzdHIpIHtcbiAgcmV0dXJuIGJhc2U2NC50b0J5dGVBcnJheShiYXNlNjRjbGVhbihzdHIpKVxufVxuXG5mdW5jdGlvbiBibGl0QnVmZmVyIChzcmMsIGRzdCwgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgIGlmICgoaSArIG9mZnNldCA+PSBkc3QubGVuZ3RoKSB8fCAoaSA+PSBzcmMubGVuZ3RoKSkgYnJlYWtcbiAgICBkc3RbaSArIG9mZnNldF0gPSBzcmNbaV1cbiAgfVxuICByZXR1cm4gaVxufVxuXG5mdW5jdGlvbiBpc25hbiAodmFsKSB7XG4gIHJldHVybiB2YWwgIT09IHZhbCAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXNlbGYtY29tcGFyZVxufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gKHdlYnBhY2spL34vbm9kZS1saWJzLWJyb3dzZXIvfi9idWZmZXIvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDEzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ },
/* 14 */
/***/ function(module, exports) {

	eval("'use strict'\n\nexports.byteLength = byteLength\nexports.toByteArray = toByteArray\nexports.fromByteArray = fromByteArray\n\nvar lookup = []\nvar revLookup = []\nvar Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array\n\nvar code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\nfor (var i = 0, len = code.length; i < len; ++i) {\n  lookup[i] = code[i]\n  revLookup[code.charCodeAt(i)] = i\n}\n\nrevLookup['-'.charCodeAt(0)] = 62\nrevLookup['_'.charCodeAt(0)] = 63\n\nfunction placeHoldersCount (b64) {\n  var len = b64.length\n  if (len % 4 > 0) {\n    throw new Error('Invalid string. Length must be a multiple of 4')\n  }\n\n  // the number of equal signs (place holders)\n  // if there are two placeholders, than the two characters before it\n  // represent one byte\n  // if there is only one, then the three characters before it represent 2 bytes\n  // this is just a cheap hack to not do indexOf twice\n  return b64[len - 2] === '=' ? 2 : b64[len - 1] === '=' ? 1 : 0\n}\n\nfunction byteLength (b64) {\n  // base64 is 4/3 + up to two characters of the original data\n  return b64.length * 3 / 4 - placeHoldersCount(b64)\n}\n\nfunction toByteArray (b64) {\n  var i, j, l, tmp, placeHolders, arr\n  var len = b64.length\n  placeHolders = placeHoldersCount(b64)\n\n  arr = new Arr(len * 3 / 4 - placeHolders)\n\n  // if there are placeholders, only get up to the last complete 4 chars\n  l = placeHolders > 0 ? len - 4 : len\n\n  var L = 0\n\n  for (i = 0, j = 0; i < l; i += 4, j += 3) {\n    tmp = (revLookup[b64.charCodeAt(i)] << 18) | (revLookup[b64.charCodeAt(i + 1)] << 12) | (revLookup[b64.charCodeAt(i + 2)] << 6) | revLookup[b64.charCodeAt(i + 3)]\n    arr[L++] = (tmp >> 16) & 0xFF\n    arr[L++] = (tmp >> 8) & 0xFF\n    arr[L++] = tmp & 0xFF\n  }\n\n  if (placeHolders === 2) {\n    tmp = (revLookup[b64.charCodeAt(i)] << 2) | (revLookup[b64.charCodeAt(i + 1)] >> 4)\n    arr[L++] = tmp & 0xFF\n  } else if (placeHolders === 1) {\n    tmp = (revLookup[b64.charCodeAt(i)] << 10) | (revLookup[b64.charCodeAt(i + 1)] << 4) | (revLookup[b64.charCodeAt(i + 2)] >> 2)\n    arr[L++] = (tmp >> 8) & 0xFF\n    arr[L++] = tmp & 0xFF\n  }\n\n  return arr\n}\n\nfunction tripletToBase64 (num) {\n  return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F]\n}\n\nfunction encodeChunk (uint8, start, end) {\n  var tmp\n  var output = []\n  for (var i = start; i < end; i += 3) {\n    tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])\n    output.push(tripletToBase64(tmp))\n  }\n  return output.join('')\n}\n\nfunction fromByteArray (uint8) {\n  var tmp\n  var len = uint8.length\n  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes\n  var output = ''\n  var parts = []\n  var maxChunkLength = 16383 // must be multiple of 3\n\n  // go through the array every three bytes, we'll deal with trailing stuff later\n  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\n    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))\n  }\n\n  // pad the end with zeros, but make sure to not forget the extra bytes\n  if (extraBytes === 1) {\n    tmp = uint8[len - 1]\n    output += lookup[tmp >> 2]\n    output += lookup[(tmp << 4) & 0x3F]\n    output += '=='\n  } else if (extraBytes === 2) {\n    tmp = (uint8[len - 2] << 8) + (uint8[len - 1])\n    output += lookup[tmp >> 10]\n    output += lookup[(tmp >> 4) & 0x3F]\n    output += lookup[(tmp << 2) & 0x3F]\n    output += '='\n  }\n\n  parts.push(output)\n\n  return parts.join('')\n}\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2Jhc2U2NC1qcy9pbmRleC5qcz8yYWRkIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQ0FBa0MsU0FBUztBQUMzQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsb0JBQW9CLE9BQU87QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLFNBQVM7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDBDQUEwQyxVQUFVO0FBQ3BEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBIiwiZmlsZSI6IjE0LmpzIiwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbmV4cG9ydHMuYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGhcbmV4cG9ydHMudG9CeXRlQXJyYXkgPSB0b0J5dGVBcnJheVxuZXhwb3J0cy5mcm9tQnl0ZUFycmF5ID0gZnJvbUJ5dGVBcnJheVxuXG52YXIgbG9va3VwID0gW11cbnZhciByZXZMb29rdXAgPSBbXVxudmFyIEFyciA9IHR5cGVvZiBVaW50OEFycmF5ICE9PSAndW5kZWZpbmVkJyA/IFVpbnQ4QXJyYXkgOiBBcnJheVxuXG52YXIgY29kZSA9ICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvJ1xuZm9yICh2YXIgaSA9IDAsIGxlbiA9IGNvZGUubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgbG9va3VwW2ldID0gY29kZVtpXVxuICByZXZMb29rdXBbY29kZS5jaGFyQ29kZUF0KGkpXSA9IGlcbn1cblxucmV2TG9va3VwWyctJy5jaGFyQ29kZUF0KDApXSA9IDYyXG5yZXZMb29rdXBbJ18nLmNoYXJDb2RlQXQoMCldID0gNjNcblxuZnVuY3Rpb24gcGxhY2VIb2xkZXJzQ291bnQgKGI2NCkge1xuICB2YXIgbGVuID0gYjY0Lmxlbmd0aFxuICBpZiAobGVuICUgNCA+IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc3RyaW5nLiBMZW5ndGggbXVzdCBiZSBhIG11bHRpcGxlIG9mIDQnKVxuICB9XG5cbiAgLy8gdGhlIG51bWJlciBvZiBlcXVhbCBzaWducyAocGxhY2UgaG9sZGVycylcbiAgLy8gaWYgdGhlcmUgYXJlIHR3byBwbGFjZWhvbGRlcnMsIHRoYW4gdGhlIHR3byBjaGFyYWN0ZXJzIGJlZm9yZSBpdFxuICAvLyByZXByZXNlbnQgb25lIGJ5dGVcbiAgLy8gaWYgdGhlcmUgaXMgb25seSBvbmUsIHRoZW4gdGhlIHRocmVlIGNoYXJhY3RlcnMgYmVmb3JlIGl0IHJlcHJlc2VudCAyIGJ5dGVzXG4gIC8vIHRoaXMgaXMganVzdCBhIGNoZWFwIGhhY2sgdG8gbm90IGRvIGluZGV4T2YgdHdpY2VcbiAgcmV0dXJuIGI2NFtsZW4gLSAyXSA9PT0gJz0nID8gMiA6IGI2NFtsZW4gLSAxXSA9PT0gJz0nID8gMSA6IDBcbn1cblxuZnVuY3Rpb24gYnl0ZUxlbmd0aCAoYjY0KSB7XG4gIC8vIGJhc2U2NCBpcyA0LzMgKyB1cCB0byB0d28gY2hhcmFjdGVycyBvZiB0aGUgb3JpZ2luYWwgZGF0YVxuICByZXR1cm4gYjY0Lmxlbmd0aCAqIDMgLyA0IC0gcGxhY2VIb2xkZXJzQ291bnQoYjY0KVxufVxuXG5mdW5jdGlvbiB0b0J5dGVBcnJheSAoYjY0KSB7XG4gIHZhciBpLCBqLCBsLCB0bXAsIHBsYWNlSG9sZGVycywgYXJyXG4gIHZhciBsZW4gPSBiNjQubGVuZ3RoXG4gIHBsYWNlSG9sZGVycyA9IHBsYWNlSG9sZGVyc0NvdW50KGI2NClcblxuICBhcnIgPSBuZXcgQXJyKGxlbiAqIDMgLyA0IC0gcGxhY2VIb2xkZXJzKVxuXG4gIC8vIGlmIHRoZXJlIGFyZSBwbGFjZWhvbGRlcnMsIG9ubHkgZ2V0IHVwIHRvIHRoZSBsYXN0IGNvbXBsZXRlIDQgY2hhcnNcbiAgbCA9IHBsYWNlSG9sZGVycyA+IDAgPyBsZW4gLSA0IDogbGVuXG5cbiAgdmFyIEwgPSAwXG5cbiAgZm9yIChpID0gMCwgaiA9IDA7IGkgPCBsOyBpICs9IDQsIGogKz0gMykge1xuICAgIHRtcCA9IChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSldIDw8IDE4KSB8IChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDEpXSA8PCAxMikgfCAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAyKV0gPDwgNikgfCByZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDMpXVxuICAgIGFycltMKytdID0gKHRtcCA+PiAxNikgJiAweEZGXG4gICAgYXJyW0wrK10gPSAodG1wID4+IDgpICYgMHhGRlxuICAgIGFycltMKytdID0gdG1wICYgMHhGRlxuICB9XG5cbiAgaWYgKHBsYWNlSG9sZGVycyA9PT0gMikge1xuICAgIHRtcCA9IChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSldIDw8IDIpIHwgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMSldID4+IDQpXG4gICAgYXJyW0wrK10gPSB0bXAgJiAweEZGXG4gIH0gZWxzZSBpZiAocGxhY2VIb2xkZXJzID09PSAxKSB7XG4gICAgdG1wID0gKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpKV0gPDwgMTApIHwgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMSldIDw8IDQpIHwgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMildID4+IDIpXG4gICAgYXJyW0wrK10gPSAodG1wID4+IDgpICYgMHhGRlxuICAgIGFycltMKytdID0gdG1wICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIGFyclxufVxuXG5mdW5jdGlvbiB0cmlwbGV0VG9CYXNlNjQgKG51bSkge1xuICByZXR1cm4gbG9va3VwW251bSA+PiAxOCAmIDB4M0ZdICsgbG9va3VwW251bSA+PiAxMiAmIDB4M0ZdICsgbG9va3VwW251bSA+PiA2ICYgMHgzRl0gKyBsb29rdXBbbnVtICYgMHgzRl1cbn1cblxuZnVuY3Rpb24gZW5jb2RlQ2h1bmsgKHVpbnQ4LCBzdGFydCwgZW5kKSB7XG4gIHZhciB0bXBcbiAgdmFyIG91dHB1dCA9IFtdXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgaSArPSAzKSB7XG4gICAgdG1wID0gKHVpbnQ4W2ldIDw8IDE2KSArICh1aW50OFtpICsgMV0gPDwgOCkgKyAodWludDhbaSArIDJdKVxuICAgIG91dHB1dC5wdXNoKHRyaXBsZXRUb0Jhc2U2NCh0bXApKVxuICB9XG4gIHJldHVybiBvdXRwdXQuam9pbignJylcbn1cblxuZnVuY3Rpb24gZnJvbUJ5dGVBcnJheSAodWludDgpIHtcbiAgdmFyIHRtcFxuICB2YXIgbGVuID0gdWludDgubGVuZ3RoXG4gIHZhciBleHRyYUJ5dGVzID0gbGVuICUgMyAvLyBpZiB3ZSBoYXZlIDEgYnl0ZSBsZWZ0LCBwYWQgMiBieXRlc1xuICB2YXIgb3V0cHV0ID0gJydcbiAgdmFyIHBhcnRzID0gW11cbiAgdmFyIG1heENodW5rTGVuZ3RoID0gMTYzODMgLy8gbXVzdCBiZSBtdWx0aXBsZSBvZiAzXG5cbiAgLy8gZ28gdGhyb3VnaCB0aGUgYXJyYXkgZXZlcnkgdGhyZWUgYnl0ZXMsIHdlJ2xsIGRlYWwgd2l0aCB0cmFpbGluZyBzdHVmZiBsYXRlclxuICBmb3IgKHZhciBpID0gMCwgbGVuMiA9IGxlbiAtIGV4dHJhQnl0ZXM7IGkgPCBsZW4yOyBpICs9IG1heENodW5rTGVuZ3RoKSB7XG4gICAgcGFydHMucHVzaChlbmNvZGVDaHVuayh1aW50OCwgaSwgKGkgKyBtYXhDaHVua0xlbmd0aCkgPiBsZW4yID8gbGVuMiA6IChpICsgbWF4Q2h1bmtMZW5ndGgpKSlcbiAgfVxuXG4gIC8vIHBhZCB0aGUgZW5kIHdpdGggemVyb3MsIGJ1dCBtYWtlIHN1cmUgdG8gbm90IGZvcmdldCB0aGUgZXh0cmEgYnl0ZXNcbiAgaWYgKGV4dHJhQnl0ZXMgPT09IDEpIHtcbiAgICB0bXAgPSB1aW50OFtsZW4gLSAxXVxuICAgIG91dHB1dCArPSBsb29rdXBbdG1wID4+IDJdXG4gICAgb3V0cHV0ICs9IGxvb2t1cFsodG1wIDw8IDQpICYgMHgzRl1cbiAgICBvdXRwdXQgKz0gJz09J1xuICB9IGVsc2UgaWYgKGV4dHJhQnl0ZXMgPT09IDIpIHtcbiAgICB0bXAgPSAodWludDhbbGVuIC0gMl0gPDwgOCkgKyAodWludDhbbGVuIC0gMV0pXG4gICAgb3V0cHV0ICs9IGxvb2t1cFt0bXAgPj4gMTBdXG4gICAgb3V0cHV0ICs9IGxvb2t1cFsodG1wID4+IDQpICYgMHgzRl1cbiAgICBvdXRwdXQgKz0gbG9va3VwWyh0bXAgPDwgMikgJiAweDNGXVxuICAgIG91dHB1dCArPSAnPSdcbiAgfVxuXG4gIHBhcnRzLnB1c2gob3V0cHV0KVxuXG4gIHJldHVybiBwYXJ0cy5qb2luKCcnKVxufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2Jhc2U2NC1qcy9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gMTRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ },
/* 15 */
/***/ function(module, exports) {

	eval("exports.read = function (buffer, offset, isLE, mLen, nBytes) {\n  var e, m\n  var eLen = nBytes * 8 - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var nBits = -7\n  var i = isLE ? (nBytes - 1) : 0\n  var d = isLE ? -1 : 1\n  var s = buffer[offset + i]\n\n  i += d\n\n  e = s & ((1 << (-nBits)) - 1)\n  s >>= (-nBits)\n  nBits += eLen\n  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}\n\n  m = e & ((1 << (-nBits)) - 1)\n  e >>= (-nBits)\n  nBits += mLen\n  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}\n\n  if (e === 0) {\n    e = 1 - eBias\n  } else if (e === eMax) {\n    return m ? NaN : ((s ? -1 : 1) * Infinity)\n  } else {\n    m = m + Math.pow(2, mLen)\n    e = e - eBias\n  }\n  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)\n}\n\nexports.write = function (buffer, value, offset, isLE, mLen, nBytes) {\n  var e, m, c\n  var eLen = nBytes * 8 - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)\n  var i = isLE ? 0 : (nBytes - 1)\n  var d = isLE ? 1 : -1\n  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0\n\n  value = Math.abs(value)\n\n  if (isNaN(value) || value === Infinity) {\n    m = isNaN(value) ? 1 : 0\n    e = eMax\n  } else {\n    e = Math.floor(Math.log(value) / Math.LN2)\n    if (value * (c = Math.pow(2, -e)) < 1) {\n      e--\n      c *= 2\n    }\n    if (e + eBias >= 1) {\n      value += rt / c\n    } else {\n      value += rt * Math.pow(2, 1 - eBias)\n    }\n    if (value * c >= 2) {\n      e++\n      c /= 2\n    }\n\n    if (e + eBias >= eMax) {\n      m = 0\n      e = eMax\n    } else if (e + eBias >= 1) {\n      m = (value * c - 1) * Math.pow(2, mLen)\n      e = e + eBias\n    } else {\n      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)\n      e = 0\n    }\n  }\n\n  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}\n\n  e = (e << mLen) | m\n  eLen += mLen\n  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}\n\n  buffer[offset + i - d] |= s * 128\n}\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2llZWU3NTQvaW5kZXguanM/NzBmZSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUSxXQUFXOztBQUVuQjtBQUNBO0FBQ0E7QUFDQSxRQUFRLFdBQVc7O0FBRW5CO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxRQUFRLFdBQVc7O0FBRW5CO0FBQ0E7QUFDQSxRQUFRLFVBQVU7O0FBRWxCO0FBQ0EiLCJmaWxlIjoiMTUuanMiLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnRzLnJlYWQgPSBmdW5jdGlvbiAoYnVmZmVyLCBvZmZzZXQsIGlzTEUsIG1MZW4sIG5CeXRlcykge1xuICB2YXIgZSwgbVxuICB2YXIgZUxlbiA9IG5CeXRlcyAqIDggLSBtTGVuIC0gMVxuICB2YXIgZU1heCA9ICgxIDw8IGVMZW4pIC0gMVxuICB2YXIgZUJpYXMgPSBlTWF4ID4+IDFcbiAgdmFyIG5CaXRzID0gLTdcbiAgdmFyIGkgPSBpc0xFID8gKG5CeXRlcyAtIDEpIDogMFxuICB2YXIgZCA9IGlzTEUgPyAtMSA6IDFcbiAgdmFyIHMgPSBidWZmZXJbb2Zmc2V0ICsgaV1cblxuICBpICs9IGRcblxuICBlID0gcyAmICgoMSA8PCAoLW5CaXRzKSkgLSAxKVxuICBzID4+PSAoLW5CaXRzKVxuICBuQml0cyArPSBlTGVuXG4gIGZvciAoOyBuQml0cyA+IDA7IGUgPSBlICogMjU2ICsgYnVmZmVyW29mZnNldCArIGldLCBpICs9IGQsIG5CaXRzIC09IDgpIHt9XG5cbiAgbSA9IGUgJiAoKDEgPDwgKC1uQml0cykpIC0gMSlcbiAgZSA+Pj0gKC1uQml0cylcbiAgbkJpdHMgKz0gbUxlblxuICBmb3IgKDsgbkJpdHMgPiAwOyBtID0gbSAqIDI1NiArIGJ1ZmZlcltvZmZzZXQgKyBpXSwgaSArPSBkLCBuQml0cyAtPSA4KSB7fVxuXG4gIGlmIChlID09PSAwKSB7XG4gICAgZSA9IDEgLSBlQmlhc1xuICB9IGVsc2UgaWYgKGUgPT09IGVNYXgpIHtcbiAgICByZXR1cm4gbSA/IE5hTiA6ICgocyA/IC0xIDogMSkgKiBJbmZpbml0eSlcbiAgfSBlbHNlIHtcbiAgICBtID0gbSArIE1hdGgucG93KDIsIG1MZW4pXG4gICAgZSA9IGUgLSBlQmlhc1xuICB9XG4gIHJldHVybiAocyA/IC0xIDogMSkgKiBtICogTWF0aC5wb3coMiwgZSAtIG1MZW4pXG59XG5cbmV4cG9ydHMud3JpdGUgPSBmdW5jdGlvbiAoYnVmZmVyLCB2YWx1ZSwgb2Zmc2V0LCBpc0xFLCBtTGVuLCBuQnl0ZXMpIHtcbiAgdmFyIGUsIG0sIGNcbiAgdmFyIGVMZW4gPSBuQnl0ZXMgKiA4IC0gbUxlbiAtIDFcbiAgdmFyIGVNYXggPSAoMSA8PCBlTGVuKSAtIDFcbiAgdmFyIGVCaWFzID0gZU1heCA+PiAxXG4gIHZhciBydCA9IChtTGVuID09PSAyMyA/IE1hdGgucG93KDIsIC0yNCkgLSBNYXRoLnBvdygyLCAtNzcpIDogMClcbiAgdmFyIGkgPSBpc0xFID8gMCA6IChuQnl0ZXMgLSAxKVxuICB2YXIgZCA9IGlzTEUgPyAxIDogLTFcbiAgdmFyIHMgPSB2YWx1ZSA8IDAgfHwgKHZhbHVlID09PSAwICYmIDEgLyB2YWx1ZSA8IDApID8gMSA6IDBcblxuICB2YWx1ZSA9IE1hdGguYWJzKHZhbHVlKVxuXG4gIGlmIChpc05hTih2YWx1ZSkgfHwgdmFsdWUgPT09IEluZmluaXR5KSB7XG4gICAgbSA9IGlzTmFOKHZhbHVlKSA/IDEgOiAwXG4gICAgZSA9IGVNYXhcbiAgfSBlbHNlIHtcbiAgICBlID0gTWF0aC5mbG9vcihNYXRoLmxvZyh2YWx1ZSkgLyBNYXRoLkxOMilcbiAgICBpZiAodmFsdWUgKiAoYyA9IE1hdGgucG93KDIsIC1lKSkgPCAxKSB7XG4gICAgICBlLS1cbiAgICAgIGMgKj0gMlxuICAgIH1cbiAgICBpZiAoZSArIGVCaWFzID49IDEpIHtcbiAgICAgIHZhbHVlICs9IHJ0IC8gY1xuICAgIH0gZWxzZSB7XG4gICAgICB2YWx1ZSArPSBydCAqIE1hdGgucG93KDIsIDEgLSBlQmlhcylcbiAgICB9XG4gICAgaWYgKHZhbHVlICogYyA+PSAyKSB7XG4gICAgICBlKytcbiAgICAgIGMgLz0gMlxuICAgIH1cblxuICAgIGlmIChlICsgZUJpYXMgPj0gZU1heCkge1xuICAgICAgbSA9IDBcbiAgICAgIGUgPSBlTWF4XG4gICAgfSBlbHNlIGlmIChlICsgZUJpYXMgPj0gMSkge1xuICAgICAgbSA9ICh2YWx1ZSAqIGMgLSAxKSAqIE1hdGgucG93KDIsIG1MZW4pXG4gICAgICBlID0gZSArIGVCaWFzXG4gICAgfSBlbHNlIHtcbiAgICAgIG0gPSB2YWx1ZSAqIE1hdGgucG93KDIsIGVCaWFzIC0gMSkgKiBNYXRoLnBvdygyLCBtTGVuKVxuICAgICAgZSA9IDBcbiAgICB9XG4gIH1cblxuICBmb3IgKDsgbUxlbiA+PSA4OyBidWZmZXJbb2Zmc2V0ICsgaV0gPSBtICYgMHhmZiwgaSArPSBkLCBtIC89IDI1NiwgbUxlbiAtPSA4KSB7fVxuXG4gIGUgPSAoZSA8PCBtTGVuKSB8IG1cbiAgZUxlbiArPSBtTGVuXG4gIGZvciAoOyBlTGVuID4gMDsgYnVmZmVyW29mZnNldCArIGldID0gZSAmIDB4ZmYsIGkgKz0gZCwgZSAvPSAyNTYsIGVMZW4gLT0gOCkge31cblxuICBidWZmZXJbb2Zmc2V0ICsgaSAtIGRdIHw9IHMgKiAxMjhcbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9pZWVlNzU0L2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSAxNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9");

/***/ },
/* 16 */
/***/ function(module, exports) {

	eval("var toString = {}.toString;\n\nmodule.exports = Array.isArray || function (arr) {\n  return toString.call(arr) == '[object Array]';\n};\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2lzYXJyYXkvaW5kZXguanM/ZWFiYyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxpQkFBaUI7O0FBRWpCO0FBQ0E7QUFDQSIsImZpbGUiOiIxNi5qcyIsInNvdXJjZXNDb250ZW50IjpbInZhciB0b1N0cmluZyA9IHt9LnRvU3RyaW5nO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gKGFycikge1xuICByZXR1cm4gdG9TdHJpbmcuY2FsbChhcnIpID09ICdbb2JqZWN0IEFycmF5XSc7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2lzYXJyYXkvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDE2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ },
/* 17 */
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\n// var RemoteStorage = require('./remotestorage');\nvar util = __webpack_require__(2);\nvar Env = __webpack_require__(18);\nvar eventHandling = __webpack_require__(3);\nvar log = __webpack_require__(4);\nvar Authorize = __webpack_require__(7);\nvar config = __webpack_require__(5);\n\n/* TOFIX */\n// var syncInterval = 10000,\n//     backgroundSyncInterval = 60000,\n//     isBackground = false;\n\nvar isFolder = util.isFolder;\nvar isDocument = util.isDocument;\nvar equal = util.equal;\nvar deepClone = util.deepClone;\nvar pathsFromRoot = util.pathsFromRoot;\n\nfunction taskFor(action, path, promise) {\n  return {\n    action: action,\n    path: path,\n    promise: promise\n  };\n}\n\nfunction isStaleChild(node) {\n  return node.remote && node.remote.revision && !node.remote.itemsMap && !node.remote.body;\n}\n\nfunction hasCommonRevision(node) {\n  return node.common && node.common.revision;\n}\n\nfunction handleVisibility() {\n  var rs = this;\n\n  function handleVisibilityChange(fg) {\n    var oldValue, newValue;\n    oldValue = rs.getCurrentSyncInterval();\n    config.isBackground = !fg;\n    newValue = rs.getCurrentSyncInterval();\n    rs._emit('sync-interval-change', { oldValue: oldValue, newValue: newValue });\n  }\n\n  Env.on(\"background\", function () {\n    handleVisibilityChange(false);\n  });\n\n  Env.on(\"foreground\", function () {\n    handleVisibilityChange(true);\n  });\n}\n\n/**\n * Class: RemoteStorage.Sync\n *\n * What this class does is basically six things:\n * - retrieving the remote version of relevant documents and folders\n * - add all local and remote documents together into one tree\n * - push local documents out if they don't exist remotely\n * - push local changes out to remote documents (conditionally, to\n *      avoid race conditions where both have changed)\n * - adopt the local version of a document to its remote version if\n *      both exist and they differ\n * - delete the local version of a document if it was deleted remotely\n * - if any get requests were waiting for remote data, resolve them once\n *      this data comes in.\n *\n * It does this using requests to documents, and to folders. Whenever a\n * folder GET comes in, it gives information about all the documents it\n * contains (this is the `markChildren` function).\n **/\nvar Sync = function Sync(remoteStorage, setLocal, setRemote, setAccess, setCaching) {\n  this.remoteStorage = remoteStorage;\n  this.local = setLocal;\n  this.local.onDiff(function (path) {\n    this.addTask(path);\n    this.doTasks();\n  }.bind(this));\n  this.remote = setRemote;\n  this.access = setAccess;\n  this.caching = setCaching;\n  this._tasks = {};\n  this._running = {};\n  this._timeStarted = {};\n  eventHandling(this, 'done', 'req-done');\n  this.caching.onActivate(function (path) {\n    this.addTask(path);\n    this.doTasks();\n  }.bind(this));\n};\n\nSync.prototype = {\n\n  now: function now() {\n    return new Date().getTime();\n  },\n\n  queueGetRequest: function queueGetRequest(path) {\n    var pending = Promise.defer();\n\n    if (!this.remote.connected) {\n      pending.reject('cannot fulfill maxAge requirement - remote is not connected');\n    } else if (!this.remote.online) {\n      pending.reject('cannot fulfill maxAge requirement - remote is not online');\n    } else {\n      this.addTask(path, function () {\n        this.local.get(path).then(function (r) {\n          return pending.resolve(r);\n        });\n      }.bind(this));\n\n      this.doTasks();\n    }\n\n    return pending.promise;\n  },\n\n  corruptServerItemsMap: function corruptServerItemsMap(itemsMap, force02) {\n    if ((typeof itemsMap === 'undefined' ? 'undefined' : _typeof(itemsMap)) !== 'object' || Array.isArray(itemsMap)) {\n      return true;\n    }\n\n    for (var itemName in itemsMap) {\n      var item = itemsMap[itemName];\n\n      if ((typeof item === 'undefined' ? 'undefined' : _typeof(item)) !== 'object') {\n        return true;\n      }\n      if (typeof item.ETag !== 'string') {\n        return true;\n      }\n      if (isFolder(itemName)) {\n        if (itemName.substring(0, itemName.length - 1).indexOf('/') !== -1) {\n          return true;\n        }\n      } else {\n        if (itemName.indexOf('/') !== -1) {\n          return true;\n        }\n        if (force02) {\n          if (typeof item['Content-Type'] !== 'string') {\n            return true;\n          }\n          if (typeof item['Content-Length'] !== 'number') {\n            return true;\n          }\n        }\n      }\n    }\n\n    return false;\n  },\n\n  corruptItemsMap: function corruptItemsMap(itemsMap) {\n    if ((typeof itemsMap === 'undefined' ? 'undefined' : _typeof(itemsMap)) !== 'object' || Array.isArray(itemsMap)) {\n      return true;\n    }\n\n    for (var itemName in itemsMap) {\n      if (typeof itemsMap[itemName] !== 'boolean') {\n        return true;\n      }\n    }\n\n    return false;\n  },\n\n  corruptRevision: function corruptRevision(rev) {\n    return (typeof rev === 'undefined' ? 'undefined' : _typeof(rev)) !== 'object' || Array.isArray(rev) || rev.revision && typeof rev.revision !== 'string' || rev.body && typeof rev.body !== 'string' && _typeof(rev.body) !== 'object' || rev.contentType && typeof rev.contentType !== 'string' || rev.contentLength && typeof rev.contentLength !== 'number' || rev.timestamp && typeof rev.timestamp !== 'number' || rev.itemsMap && this.corruptItemsMap(rev.itemsMap);\n  },\n\n  isCorrupt: function isCorrupt(node) {\n    return (typeof node === 'undefined' ? 'undefined' : _typeof(node)) !== 'object' || Array.isArray(node) || typeof node.path !== 'string' || this.corruptRevision(node.common) || node.local && this.corruptRevision(node.local) || node.remote && this.corruptRevision(node.remote) || node.push && this.corruptRevision(node.push);\n  },\n\n  hasTasks: function hasTasks() {\n    return Object.getOwnPropertyNames(this._tasks).length > 0;\n  },\n\n  collectDiffTasks: function collectDiffTasks() {\n    var num = 0;\n\n    return this.local.forAllNodes(function (node) {\n\n      if (num > 100) {\n        return;\n      }\n\n      if (this.isCorrupt(node)) {\n        log('[Sync] WARNING: corrupt node in local cache', node);\n        if ((typeof node === 'undefined' ? 'undefined' : _typeof(node)) === 'object' && node.path) {\n          this.addTask(node.path);\n          num++;\n        }\n      } else if (this.needsFetch(node) && this.access.checkPathPermission(node.path, 'r')) {\n        this.addTask(node.path);\n        num++;\n      } else if (isDocument(node.path) && this.needsPush(node) && this.access.checkPathPermission(node.path, 'rw')) {\n        this.addTask(node.path);\n        num++;\n      }\n    }.bind(this)).then(function () {\n      return num;\n    }, function (err) {\n      throw err;\n    });\n  },\n\n  inConflict: function inConflict(node) {\n    return node.local && node.remote && (node.remote.body !== undefined || node.remote.itemsMap);\n  },\n\n  needsRefresh: function needsRefresh(node) {\n    if (node.common) {\n      if (!node.common.timestamp) {\n        return true;\n      }\n      return this.now() - node.common.timestamp > config.syncInterval;\n    }\n    return false;\n  },\n\n  needsFetch: function needsFetch(node) {\n    if (this.inConflict(node)) {\n      return true;\n    }\n    if (node.common && node.common.itemsMap === undefined && node.common.body === undefined) {\n      return true;\n    }\n    if (node.remote && node.remote.itemsMap === undefined && node.remote.body === undefined) {\n      return true;\n    }\n    return false;\n  },\n\n  needsPush: function needsPush(node) {\n    if (this.inConflict(node)) {\n      return false;\n    }\n    if (node.local && !node.push) {\n      return true;\n    }\n  },\n\n  needsRemotePut: function needsRemotePut(node) {\n    return node.local && node.local.body;\n  },\n\n  needsRemoteDelete: function needsRemoteDelete(node) {\n    return node.local && node.local.body === false;\n  },\n\n  getParentPath: function getParentPath(path) {\n    var parts = path.match(/^(.*\\/)([^\\/]+\\/?)$/);\n\n    if (parts) {\n      return parts[1];\n    } else {\n      throw new Error('Not a valid path: \"' + path + '\"');\n    }\n  },\n\n  deleteChildPathsFromTasks: function deleteChildPathsFromTasks() {\n    for (var path in this._tasks) {\n      var paths = pathsFromRoot(path);\n\n      for (var i = 1; i < paths.length; i++) {\n        if (this._tasks[paths[i]]) {\n          // move pending promises to parent task\n          if (Array.isArray(this._tasks[path]) && this._tasks[path].length) {\n            Array.prototype.push.apply(this._tasks[paths[i]], this._tasks[path]);\n          }\n          delete this._tasks[path];\n        }\n      }\n    }\n  },\n\n  collectRefreshTasks: function collectRefreshTasks() {\n    return this.local.forAllNodes(function (node) {\n      var parentPath;\n      if (this.needsRefresh(node)) {\n        try {\n          parentPath = this.getParentPath(node.path);\n        } catch (e) {\n          // node.path is already '/', can't take parentPath\n        }\n        if (parentPath && this.access.checkPathPermission(parentPath, 'r')) {\n          this.addTask(parentPath);\n        } else if (this.access.checkPathPermission(node.path, 'r')) {\n          this.addTask(node.path);\n        }\n      }\n    }.bind(this)).then(function () {\n      this.deleteChildPathsFromTasks();\n    }.bind(this), function (err) {\n      throw err;\n    });\n  },\n\n  flush: function flush(nodes) {\n    for (var path in nodes) {\n      // Strategy is 'FLUSH' and no local changes exist\n      if (this.caching.checkPath(path) === 'FLUSH' && nodes[path] && !nodes[path].local) {\n        log('[Sync] Flushing', path);\n        nodes[path] = undefined; // Cause node to be flushed from cache\n      }\n    }\n    return nodes;\n  },\n\n  doTask: function doTask(path) {\n    return this.local.getNodes([path]).then(function (nodes) {\n      var node = nodes[path];\n      // First fetch:\n      if (typeof node === 'undefined') {\n        return taskFor('get', path, this.remote.get(path));\n      }\n      // Fetch known-stale child:\n      else if (isStaleChild(node)) {\n          return taskFor('get', path, this.remote.get(path));\n        }\n        // Push PUT:\n        else if (this.needsRemotePut(node)) {\n            node.push = deepClone(node.local);\n            node.push.timestamp = this.now();\n\n            return this.local.setNodes(this.flush(nodes)).then(function () {\n              var options;\n              if (hasCommonRevision(node)) {\n                options = { ifMatch: node.common.revision };\n              } else {\n                // Initial PUT (fail if something is already there)\n                options = { ifNoneMatch: '*' };\n              }\n\n              return taskFor('put', path, this.remote.put(path, node.push.body, node.push.contentType, options));\n            }.bind(this));\n          }\n          // Push DELETE:\n          else if (this.needsRemoteDelete(node)) {\n              node.push = { body: false, timestamp: this.now() };\n\n              return this.local.setNodes(this.flush(nodes)).then(function () {\n                if (hasCommonRevision(node)) {\n                  return taskFor('delete', path, this.remote.delete(path, { ifMatch: node.common.revision }));\n                } else {\n                  // Ascertain current common or remote revision first\n                  return taskFor('get', path, this.remote.get(path));\n                }\n              }.bind(this));\n            }\n            // Conditional refresh:\n            else if (hasCommonRevision(node)) {\n                return taskFor('get', path, this.remote.get(path, { ifNoneMatch: node.common.revision }));\n              } else {\n                return taskFor('get', path, this.remote.get(path));\n              }\n    }.bind(this));\n  },\n\n  autoMergeFolder: function autoMergeFolder(node) {\n    if (node.remote.itemsMap) {\n      node.common = node.remote;\n      delete node.remote;\n\n      if (node.common.itemsMap) {\n        for (var itemName in node.common.itemsMap) {\n          if (!node.local.itemsMap[itemName]) {\n            // Indicates the node is either newly being fetched\n            // has been deleted locally (whether or not leading to conflict);\n            // before listing it in local listings, check if a local deletion\n            // exists.\n            node.local.itemsMap[itemName] = false;\n          }\n        }\n\n        if (equal(node.local.itemsMap, node.common.itemsMap)) {\n          delete node.local;\n        }\n      }\n    }\n    return node;\n  },\n\n  autoMergeDocument: function autoMergeDocument(node) {\n    hasNoRemoteChanges = function hasNoRemoteChanges(node) {\n      if (node.remote && node.remote.revision && node.remote.revision !== node.common.revision) {\n        return false;\n      }\n      return node.common.body === undefined && node.remote.body === false || node.remote.body === node.common.body && node.remote.contentType === node.common.contentType;\n    };\n    mergeMutualDeletion = function mergeMutualDeletion(node) {\n      if (node.remote && node.remote.body === false && node.local && node.local.body === false) {\n        delete node.local;\n      }\n      return node;\n    };\n\n    if (hasNoRemoteChanges(node)) {\n      node = mergeMutualDeletion(node);\n      delete node.remote;\n    } else if (node.remote.body !== undefined) {\n      // keep/revert:\n      log('[Sync] Emitting keep/revert');\n\n      this.local._emitChange({\n        origin: 'conflict',\n        path: node.path,\n        oldValue: node.local.body,\n        newValue: node.remote.body,\n        lastCommonValue: node.common.body,\n        oldContentType: node.local.contentType,\n        newContentType: node.remote.contentType,\n        lastCommonContentType: node.common.contentType\n      });\n\n      if (node.remote.body) {\n        node.common = node.remote;\n      } else {\n        node.common = {};\n      }\n      delete node.remote;\n      delete node.local;\n    }\n    return node;\n  },\n\n  autoMerge: function autoMerge(node) {\n    if (node.remote) {\n      if (node.local) {\n        if (isFolder(node.path)) {\n          return this.autoMergeFolder(node);\n        } else {\n          return this.autoMergeDocument(node);\n        }\n      } else {\n        // no local changes\n        if (isFolder(node.path)) {\n          if (node.remote.itemsMap !== undefined) {\n            node.common = node.remote;\n            delete node.remote;\n          }\n        } else {\n          if (node.remote.body !== undefined) {\n            var change = {\n              origin: 'remote',\n              path: node.path,\n              oldValue: node.common.body === false ? undefined : node.common.body,\n              newValue: node.remote.body === false ? undefined : node.remote.body,\n              oldContentType: node.common.contentType,\n              newContentType: node.remote.contentType\n            };\n            if (change.oldValue || change.newValue) {\n              this.local._emitChange(change);\n            }\n\n            if (!node.remote.body) {\n              // no remote, so delete/don't create\n              return;\n            }\n\n            node.common = node.remote;\n            delete node.remote;\n          }\n        }\n      }\n    } else {\n      if (node.common.body) {\n        this.local._emitChange({\n          origin: 'remote',\n          path: node.path,\n          oldValue: node.common.body,\n          newValue: undefined,\n          oldContentType: node.common.contentType,\n          newContentType: undefined\n        });\n      }\n\n      return undefined;\n    }\n    return node;\n  },\n\n  updateCommonTimestamp: function updateCommonTimestamp(path, revision) {\n    return this.local.getNodes([path]).then(function (nodes) {\n      if (nodes[path] && nodes[path].common && nodes[path].common.revision === revision) {\n        nodes[path].common.timestamp = this.now();\n      }\n      return this.local.setNodes(this.flush(nodes));\n    }.bind(this));\n  },\n\n  markChildren: function markChildren(path, itemsMap, changedNodes, missingChildren) {\n    var paths = [];\n    var meta = {};\n    var recurse = {};\n\n    for (var item in itemsMap) {\n      paths.push(path + item);\n      meta[path + item] = itemsMap[item];\n    }\n    for (var childName in missingChildren) {\n      paths.push(path + childName);\n    }\n\n    return this.local.getNodes(paths).then(function (nodes) {\n      var cachingStrategy;\n      var node;\n\n      var nodeChanged = function nodeChanged(node, etag) {\n        return node.common.revision !== etag && (!node.remote || node.remote.revision !== etag);\n      };\n\n      for (var nodePath in nodes) {\n        node = nodes[nodePath];\n\n        if (meta[nodePath]) {\n          if (node && node.common) {\n            if (nodeChanged(node, meta[nodePath].ETag)) {\n              changedNodes[nodePath] = deepClone(node);\n              changedNodes[nodePath].remote = {\n                revision: meta[nodePath].ETag,\n                timestamp: this.now()\n              };\n              changedNodes[nodePath] = this.autoMerge(changedNodes[nodePath]);\n            }\n          } else {\n            cachingStrategy = this.caching.checkPath(nodePath);\n            if (cachingStrategy === 'ALL') {\n              changedNodes[nodePath] = {\n                path: nodePath,\n                common: {\n                  timestamp: this.now()\n                },\n                remote: {\n                  revision: meta[nodePath].ETag,\n                  timestamp: this.now()\n                }\n              };\n            }\n          }\n\n          if (changedNodes[nodePath] && meta[nodePath]['Content-Type']) {\n            changedNodes[nodePath].remote.contentType = meta[nodePath]['Content-Type'];\n          }\n\n          if (changedNodes[nodePath] && meta[nodePath]['Content-Length']) {\n            changedNodes[nodePath].remote.contentLength = meta[nodePath]['Content-Length'];\n          }\n        } else if (missingChildren[nodePath.substring(path.length)] && node && node.common) {\n          if (node.common.itemsMap) {\n            for (var commonItem in node.common.itemsMap) {\n              recurse[nodePath + commonItem] = true;\n            }\n          }\n\n          if (node.local && node.local.itemsMap) {\n            for (var localItem in node.local.itemsMap) {\n              recurse[nodePath + localItem] = true;\n            }\n          }\n\n          if (node.remote || isFolder(nodePath)) {\n            changedNodes[nodePath] = undefined;\n          } else {\n            changedNodes[nodePath] = this.autoMerge(node);\n\n            if (typeof changedNodes[nodePath] === 'undefined') {\n              var parentPath = this.getParentPath(nodePath);\n              var parentNode = changedNodes[parentPath];\n              var itemName = nodePath.substring(path.length);\n              if (parentNode && parentNode.local) {\n                delete parentNode.local.itemsMap[itemName];\n\n                if (equal(parentNode.local.itemsMap, parentNode.common.itemsMap)) {\n                  delete parentNode.local;\n                }\n              }\n            }\n          }\n        }\n      }\n\n      return this.deleteRemoteTrees(Object.keys(recurse), changedNodes).then(function (changedObjs2) {\n        return this.local.setNodes(this.flush(changedObjs2));\n      }.bind(this));\n    }.bind(this));\n  },\n\n  deleteRemoteTrees: function deleteRemoteTrees(paths, changedNodes) {\n    if (paths.length === 0) {\n      return Promise.resolve(changedNodes);\n    }\n\n    return this.local.getNodes(paths).then(function (nodes) {\n      var subPaths = {};\n\n      collectSubPaths = function collectSubPaths(folder, path) {\n        if (folder && folder.itemsMap) {\n          for (var itemName in folder.itemsMap) {\n            subPaths[path + itemName] = true;\n          }\n        }\n      };\n\n      for (var path in nodes) {\n        var node = nodes[path];\n\n        // TODO Why check for the node here? I don't think this check ever applies\n        if (!node) {\n          continue;\n        }\n\n        if (isFolder(path)) {\n          collectSubPaths(node.common, path);\n          collectSubPaths(node.local, path);\n        } else {\n          if (node.common && _typeof(node.common.body) !== undefined) {\n            changedNodes[path] = deepClone(node);\n            changedNodes[path].remote = {\n              body: false,\n              timestamp: this.now()\n            };\n            changedNodes[path] = this.autoMerge(changedNodes[path]);\n          }\n        }\n      }\n\n      // Recurse whole tree depth levels at once:\n      return this.deleteRemoteTrees(Object.keys(subPaths), changedNodes).then(function (changedNodes2) {\n        return this.local.setNodes(this.flush(changedNodes2));\n      }.bind(this));\n    }.bind(this));\n  },\n\n  completeFetch: function completeFetch(path, bodyOrItemsMap, contentType, revision) {\n    var paths;\n    var parentPath;\n    var pathsFromRootArr = pathsFromRoot(path);\n\n    if (isFolder(path)) {\n      paths = [path];\n    } else {\n      parentPath = pathsFromRootArr[1];\n      paths = [path, parentPath];\n    }\n\n    return this.local.getNodes(paths).then(function (nodes) {\n      var itemName;\n      var missingChildren = {};\n      var node = nodes[path];\n      var parentNode;\n\n      var collectMissingChildren = function collectMissingChildren(folder) {\n        if (folder && folder.itemsMap) {\n          for (var itemName in folder.itemsMap) {\n            if (!bodyOrItemsMap[itemName]) {\n              missingChildren[itemName] = true;\n            }\n          }\n        }\n      };\n\n      if ((typeof node === 'undefined' ? 'undefined' : _typeof(node)) !== 'object' || node.path !== path || _typeof(node.common) !== 'object') {\n        node = {\n          path: path,\n          common: {}\n        };\n        nodes[path] = node;\n      }\n\n      node.remote = {\n        revision: revision,\n        timestamp: this.now()\n      };\n\n      if (isFolder(path)) {\n        collectMissingChildren(node.common);\n        collectMissingChildren(node.remote);\n\n        node.remote.itemsMap = {};\n        for (itemName in bodyOrItemsMap) {\n          node.remote.itemsMap[itemName] = true;\n        }\n      } else {\n        node.remote.body = bodyOrItemsMap;\n        node.remote.contentType = contentType;\n\n        parentNode = nodes[parentPath];\n        if (parentNode && parentNode.local && parentNode.local.itemsMap) {\n          itemName = path.substring(parentPath.length);\n          parentNode.local.itemsMap[itemName] = true;\n          if (equal(parentNode.local.itemsMap, parentNode.common.itemsMap)) {\n            delete parentNode.local;\n          }\n        }\n      }\n\n      nodes[path] = this.autoMerge(node);\n      return {\n        toBeSaved: nodes,\n        missingChildren: missingChildren\n      };\n    }.bind(this));\n  },\n\n  completePush: function completePush(path, action, conflict, revision) {\n    return this.local.getNodes([path]).then(function (nodes) {\n      var node = nodes[path];\n\n      if (!node.push) {\n        this.stopped = true;\n        throw new Error('completePush called but no push version!');\n      }\n\n      if (conflict) {\n        log('[Sync] We have a conflict');\n\n        if (!node.remote || node.remote.revision !== revision) {\n          node.remote = {\n            revision: revision || 'conflict',\n            timestamp: this.now()\n          };\n          delete node.push;\n        }\n\n        nodes[path] = this.autoMerge(node);\n      } else {\n        node.common = {\n          revision: revision,\n          timestamp: this.now()\n        };\n\n        if (action === 'put') {\n          node.common.body = node.push.body;\n          node.common.contentType = node.push.contentType;\n\n          if (equal(node.local.body, node.push.body) && node.local.contentType === node.push.contentType) {\n            delete node.local;\n          }\n\n          delete node.push;\n        } else if (action === 'delete') {\n          if (node.local.body === false) {\n            // No new local changes since push; flush it.\n            nodes[path] = undefined;\n          } else {\n            delete node.push;\n          }\n        }\n      }\n\n      return this.local.setNodes(this.flush(nodes));\n    }.bind(this));\n  },\n\n  dealWithFailure: function dealWithFailure(path, action, statusMeaning) {\n\n    return this.local.getNodes([path]).then(function (nodes) {\n      if (nodes[path]) {\n        delete nodes[path].push;\n        return this.local.setNodes(this.flush(nodes));\n      }\n    }.bind(this));\n  },\n\n  interpretStatus: function interpretStatus(statusCode) {\n    if (statusCode === 'offline' || statusCode === 'timeout') {\n      return {\n        successful: false,\n        networkProblems: true,\n        statusCode: statusCode\n      };\n    }\n\n    var series = Math.floor(statusCode / 100);\n\n    return {\n      successful: series === 2 || statusCode === 304 || statusCode === 412 || statusCode === 404,\n      conflict: statusCode === 412,\n      unAuth: statusCode === 401 && this.remote.token !== Authorize.IMPLIED_FAKE_TOKEN || statusCode === 402 || statusCode === 403,\n      notFound: statusCode === 404,\n      changed: statusCode !== 304,\n      statusCode: statusCode\n    };\n  },\n\n  handleGetResponse: function handleGetResponse(path, status, bodyOrItemsMap, contentType, revision) {\n    if (status.notFound) {\n      if (isFolder(path)) {\n        bodyOrItemsMap = {};\n      } else {\n        bodyOrItemsMap = false;\n      }\n    }\n\n    if (status.changed) {\n      return this.completeFetch(path, bodyOrItemsMap, contentType, revision).then(function (dataFromFetch) {\n        if (isFolder(path)) {\n          if (this.corruptServerItemsMap(bodyOrItemsMap)) {\n            log('[Sync] WARNING: Discarding corrupt folder description from server for ' + path);\n            return false;\n          } else {\n            return this.markChildren(path, bodyOrItemsMap, dataFromFetch.toBeSaved, dataFromFetch.missingChildren).then(function () {\n              return true;\n            });\n          }\n        } else {\n          return this.local.setNodes(this.flush(dataFromFetch.toBeSaved)).then(function () {\n            return true;\n          });\n        }\n      }.bind(this));\n    } else {\n      return this.updateCommonTimestamp(path, revision).then(function () {\n        return true;\n      });\n    }\n  },\n\n  handleResponse: function handleResponse(path, action, r) {\n    var status = this.interpretStatus(r.statusCode);\n    if (status.successful) {\n      if (action === 'get') {\n        return this.handleGetResponse(path, status, r.body, r.contentType, r.revision);\n      } else if (action === 'put' || action === 'delete') {\n        return this.completePush(path, action, status.conflict, r.revision).then(function () {\n          return true;\n        });\n      } else {\n        throw new Error('cannot handle response for unknown action', action);\n      }\n    } else {\n      // Unsuccessful\n      var error;\n      if (status.unAuth) {\n        error = new Authorize.Unauthorized();\n      } else if (status.networkProblems) {\n        error = new Sync.SyncError('Network request failed.');\n      } else {\n        error = new Error('HTTP response code ' + status.statusCode + ' received.');\n      }\n\n      return this.dealWithFailure(path, action, status).then(function () {\n        this.remoteStorage._emit('error', error);\n        throw error;\n      });\n    }\n  },\n\n  numThreads: 10,\n\n  finishTask: function finishTask(task) {\n    if (task.action === undefined) {\n      delete this._running[task.path];\n      return;\n    }\n    var self = this;\n\n    return task.promise.then(function (r) {\n      return self.handleResponse(task.path, task.action, r);\n    }, function (err) {\n      log('[Sync] wireclient rejects its promise!', task.path, task.action, err);\n      return self.handleResponse(task.path, task.action, { statusCode: 'offline' });\n    }).then(function (completed) {\n      delete self._timeStarted[task.path];\n      delete self._running[task.path];\n\n      if (completed) {\n        if (self._tasks[task.path]) {\n          for (var i = 0; i < self._tasks[task.path].length; i++) {\n            self._tasks[task.path][i]();\n          }\n          delete self._tasks[task.path];\n        }\n      }\n\n      self._emit('req-done');\n\n      self.collectTasks(false).then(function () {\n        // See if there are any more tasks that are not refresh tasks\n        if (!self.hasTasks() || self.stopped) {\n          log('[Sync] Sync is done! Reschedule?', Object.getOwnPropertyNames(self._tasks).length, self.stopped);\n          if (!self.done) {\n            self.done = true;\n            self._emit('done');\n          }\n        } else {\n          // Use a 10ms timeout to let the JavaScript runtime catch its breath\n          // (and hopefully force an IndexedDB auto-commit?), and also to cause\n          // the threads to get staggered and get a good spread over time:\n          setTimeout(function () {\n            self.doTasks();\n          }, 10);\n        }\n      });\n    }, function (err) {\n      log('[Sync] Error', err);\n      delete self._timeStarted[task.path];\n      delete self._running[task.path];\n      self._emit('req-done');\n      if (!self.done) {\n        self.done = true;\n        self._emit('done');\n      }\n    });\n  },\n\n  doTasks: function doTasks() {\n    var numToHave,\n        numAdded = 0,\n        numToAdd,\n        path;\n    if (this.remote.connected) {\n      if (this.remote.online) {\n        numToHave = this.numThreads;\n      } else {\n        numToHave = 1;\n      }\n    } else {\n      numToHave = 0;\n    }\n    numToAdd = numToHave - Object.getOwnPropertyNames(this._running).length;\n    if (numToAdd <= 0) {\n      return true;\n    }\n    for (path in this._tasks) {\n      if (!this._running[path]) {\n        this._timeStarted[path] = this.now();\n        this._running[path] = this.doTask(path);\n        this._running[path].then(this.finishTask.bind(this));\n        numAdded++;\n        if (numAdded >= numToAdd) {\n          return true;\n        }\n      }\n    }\n    return numAdded >= numToAdd;\n  },\n\n  collectTasks: function collectTasks(alsoCheckRefresh) {\n    if (this.hasTasks() || this.stopped) {\n      return Promise.resolve();\n    }\n\n    return this.collectDiffTasks().then(function (numDiffs) {\n      if (numDiffs || alsoCheckRefresh === false) {\n        return Promise.resolve();\n      } else {\n        return this.collectRefreshTasks();\n      }\n    }.bind(this), function (err) {\n      throw err;\n    });\n  },\n\n  addTask: function addTask(path, cb) {\n    if (!this._tasks[path]) {\n      this._tasks[path] = [];\n    }\n    if (typeof cb === 'function') {\n      this._tasks[path].push(cb);\n    }\n  },\n\n  /**\n   * Method: sync\n   **/\n  sync: function sync() {\n    this.done = false;\n\n    if (!this.doTasks()) {\n      return this.collectTasks().then(function () {\n        try {\n          this.doTasks();\n        } catch (e) {\n          log('[Sync] doTasks error', e);\n        }\n      }.bind(this), function (e) {\n        log('[Sync] Sync error', e);\n        throw new Error('Local cache unavailable');\n      });\n    } else {\n      return Promise.resolve();\n    }\n  }\n};\n\nvar syncCycleCb, _syncOnConnect;\nSync._rs_init = function (remoteStorage) {\n\n  syncCycleCb = function syncCycleCb() {\n    // if (!config.cache) return false\n    log('[Sync] syncCycleCb calling syncCycle');\n    if (Env.isBrowser()) {\n      handleVisibility.bind(remoteStorage)();\n    }\n\n    if (!remoteStorage.sync) {\n      // Call this now that all other modules are also ready:\n      remoteStorage.sync = new Sync(remoteStorage, remoteStorage.local, remoteStorage.remote, remoteStorage.access, remoteStorage.caching);\n\n      if (remoteStorage.syncStopped) {\n        log('[Sync] Instantiating sync stopped');\n        remoteStorage.sync.stopped = true;\n        delete remoteStorage.syncStopped;\n      }\n    }\n\n    log('[Sync] syncCycleCb calling syncCycle');\n    remoteStorage.syncCycle();\n  };\n\n  _syncOnConnect = function syncOnConnect() {\n    remoteStorage.removeEventListener('connected', _syncOnConnect);\n    remoteStorage.startSync();\n  };\n\n  remoteStorage.on('ready', syncCycleCb);\n  remoteStorage.on('connected', _syncOnConnect);\n};\n\nSync._rs_cleanup = function (remoteStorage) {\n  remoteStorage.stopSync();\n  remoteStorage.removeEventListener('ready', syncCycleCb);\n  remoteStorage.removeEventListener('connected', _syncOnConnect);\n\n  remoteStorage.sync = undefined;\n  delete remoteStorage.sync;\n};\n\nvar SyncError = function SyncError(originalError) {\n  var msg = 'Sync failed: ';\n  if ((typeof originalError === 'undefined' ? 'undefined' : _typeof(originalError)) === 'object' && 'message' in originalError) {\n    msg += originalError.message;\n  } else {\n    msg += originalError;\n  }\n  this.originalError = originalError;\n  this.message = msg;\n};\n\nSyncError.prototype = new Error();\nSyncError.prototype.constructor = SyncError;\n\nSync.SyncError = SyncError;\n\nmodule.exports = Sync;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvc3luYy5qcz81ODY0Il0sIm5hbWVzIjpbInV0aWwiLCJyZXF1aXJlIiwiRW52IiwiZXZlbnRIYW5kbGluZyIsImxvZyIsIkF1dGhvcml6ZSIsImNvbmZpZyIsImlzRm9sZGVyIiwiaXNEb2N1bWVudCIsImVxdWFsIiwiZGVlcENsb25lIiwicGF0aHNGcm9tUm9vdCIsInRhc2tGb3IiLCJhY3Rpb24iLCJwYXRoIiwicHJvbWlzZSIsImlzU3RhbGVDaGlsZCIsIm5vZGUiLCJyZW1vdGUiLCJyZXZpc2lvbiIsIml0ZW1zTWFwIiwiYm9keSIsImhhc0NvbW1vblJldmlzaW9uIiwiY29tbW9uIiwiaGFuZGxlVmlzaWJpbGl0eSIsInJzIiwiaGFuZGxlVmlzaWJpbGl0eUNoYW5nZSIsImZnIiwib2xkVmFsdWUiLCJuZXdWYWx1ZSIsImdldEN1cnJlbnRTeW5jSW50ZXJ2YWwiLCJpc0JhY2tncm91bmQiLCJfZW1pdCIsIm9uIiwiU3luYyIsInJlbW90ZVN0b3JhZ2UiLCJzZXRMb2NhbCIsInNldFJlbW90ZSIsInNldEFjY2VzcyIsInNldENhY2hpbmciLCJsb2NhbCIsIm9uRGlmZiIsImFkZFRhc2siLCJkb1Rhc2tzIiwiYmluZCIsImFjY2VzcyIsImNhY2hpbmciLCJfdGFza3MiLCJfcnVubmluZyIsIl90aW1lU3RhcnRlZCIsIm9uQWN0aXZhdGUiLCJwcm90b3R5cGUiLCJub3ciLCJEYXRlIiwiZ2V0VGltZSIsInF1ZXVlR2V0UmVxdWVzdCIsInBlbmRpbmciLCJQcm9taXNlIiwiZGVmZXIiLCJjb25uZWN0ZWQiLCJyZWplY3QiLCJvbmxpbmUiLCJnZXQiLCJ0aGVuIiwiciIsInJlc29sdmUiLCJjb3JydXB0U2VydmVySXRlbXNNYXAiLCJmb3JjZTAyIiwiQXJyYXkiLCJpc0FycmF5IiwiaXRlbU5hbWUiLCJpdGVtIiwiRVRhZyIsInN1YnN0cmluZyIsImxlbmd0aCIsImluZGV4T2YiLCJjb3JydXB0SXRlbXNNYXAiLCJjb3JydXB0UmV2aXNpb24iLCJyZXYiLCJjb250ZW50VHlwZSIsImNvbnRlbnRMZW5ndGgiLCJ0aW1lc3RhbXAiLCJpc0NvcnJ1cHQiLCJwdXNoIiwiaGFzVGFza3MiLCJPYmplY3QiLCJnZXRPd25Qcm9wZXJ0eU5hbWVzIiwiY29sbGVjdERpZmZUYXNrcyIsIm51bSIsImZvckFsbE5vZGVzIiwibmVlZHNGZXRjaCIsImNoZWNrUGF0aFBlcm1pc3Npb24iLCJuZWVkc1B1c2giLCJlcnIiLCJpbkNvbmZsaWN0IiwidW5kZWZpbmVkIiwibmVlZHNSZWZyZXNoIiwic3luY0ludGVydmFsIiwibmVlZHNSZW1vdGVQdXQiLCJuZWVkc1JlbW90ZURlbGV0ZSIsImdldFBhcmVudFBhdGgiLCJwYXJ0cyIsIm1hdGNoIiwiRXJyb3IiLCJkZWxldGVDaGlsZFBhdGhzRnJvbVRhc2tzIiwicGF0aHMiLCJpIiwiYXBwbHkiLCJjb2xsZWN0UmVmcmVzaFRhc2tzIiwicGFyZW50UGF0aCIsImUiLCJmbHVzaCIsIm5vZGVzIiwiY2hlY2tQYXRoIiwiZG9UYXNrIiwiZ2V0Tm9kZXMiLCJzZXROb2RlcyIsIm9wdGlvbnMiLCJpZk1hdGNoIiwiaWZOb25lTWF0Y2giLCJwdXQiLCJkZWxldGUiLCJhdXRvTWVyZ2VGb2xkZXIiLCJhdXRvTWVyZ2VEb2N1bWVudCIsImhhc05vUmVtb3RlQ2hhbmdlcyIsIm1lcmdlTXV0dWFsRGVsZXRpb24iLCJfZW1pdENoYW5nZSIsIm9yaWdpbiIsImxhc3RDb21tb25WYWx1ZSIsIm9sZENvbnRlbnRUeXBlIiwibmV3Q29udGVudFR5cGUiLCJsYXN0Q29tbW9uQ29udGVudFR5cGUiLCJhdXRvTWVyZ2UiLCJjaGFuZ2UiLCJ1cGRhdGVDb21tb25UaW1lc3RhbXAiLCJtYXJrQ2hpbGRyZW4iLCJjaGFuZ2VkTm9kZXMiLCJtaXNzaW5nQ2hpbGRyZW4iLCJtZXRhIiwicmVjdXJzZSIsImNoaWxkTmFtZSIsImNhY2hpbmdTdHJhdGVneSIsIm5vZGVDaGFuZ2VkIiwiZXRhZyIsIm5vZGVQYXRoIiwiY29tbW9uSXRlbSIsImxvY2FsSXRlbSIsInBhcmVudE5vZGUiLCJkZWxldGVSZW1vdGVUcmVlcyIsImtleXMiLCJjaGFuZ2VkT2JqczIiLCJzdWJQYXRocyIsImNvbGxlY3RTdWJQYXRocyIsImZvbGRlciIsImNoYW5nZWROb2RlczIiLCJjb21wbGV0ZUZldGNoIiwiYm9keU9ySXRlbXNNYXAiLCJwYXRoc0Zyb21Sb290QXJyIiwiY29sbGVjdE1pc3NpbmdDaGlsZHJlbiIsInRvQmVTYXZlZCIsImNvbXBsZXRlUHVzaCIsImNvbmZsaWN0Iiwic3RvcHBlZCIsImRlYWxXaXRoRmFpbHVyZSIsInN0YXR1c01lYW5pbmciLCJpbnRlcnByZXRTdGF0dXMiLCJzdGF0dXNDb2RlIiwic3VjY2Vzc2Z1bCIsIm5ldHdvcmtQcm9ibGVtcyIsInNlcmllcyIsIk1hdGgiLCJmbG9vciIsInVuQXV0aCIsInRva2VuIiwiSU1QTElFRF9GQUtFX1RPS0VOIiwibm90Rm91bmQiLCJjaGFuZ2VkIiwiaGFuZGxlR2V0UmVzcG9uc2UiLCJzdGF0dXMiLCJkYXRhRnJvbUZldGNoIiwiaGFuZGxlUmVzcG9uc2UiLCJlcnJvciIsIlVuYXV0aG9yaXplZCIsIlN5bmNFcnJvciIsIm51bVRocmVhZHMiLCJmaW5pc2hUYXNrIiwidGFzayIsInNlbGYiLCJjb21wbGV0ZWQiLCJjb2xsZWN0VGFza3MiLCJkb25lIiwic2V0VGltZW91dCIsIm51bVRvSGF2ZSIsIm51bUFkZGVkIiwibnVtVG9BZGQiLCJhbHNvQ2hlY2tSZWZyZXNoIiwibnVtRGlmZnMiLCJjYiIsInN5bmMiLCJzeW5jQ3ljbGVDYiIsInN5bmNPbkNvbm5lY3QiLCJfcnNfaW5pdCIsImlzQnJvd3NlciIsInN5bmNTdG9wcGVkIiwic3luY0N5Y2xlIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsInN0YXJ0U3luYyIsIl9yc19jbGVhbnVwIiwic3RvcFN5bmMiLCJvcmlnaW5hbEVycm9yIiwibXNnIiwibWVzc2FnZSIsImNvbnN0cnVjdG9yIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJtYXBwaW5n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a0M3QixTQUFsQzs7QUFFQXJKLEtBQUtxSixTQUFMLEdBQWlCQSxTQUFqQjs7QUFFQThCLE9BQU9DLE9BQVAsR0FBaUJwTCxJQUFqQiIsImZpbGUiOiIxNy5qcyIsInNvdXJjZXNDb250ZW50IjpbIiAgLy8gdmFyIFJlbW90ZVN0b3JhZ2UgPSByZXF1aXJlKCcuL3JlbW90ZXN0b3JhZ2UnKTtcbiAgdmFyIHV0aWwgPSByZXF1aXJlKCcuL3V0aWwnKTtcbiAgdmFyIEVudiA9IHJlcXVpcmUoJy4vZW52Jyk7XG4gIHZhciBldmVudEhhbmRsaW5nID0gcmVxdWlyZSgnLi9ldmVudGhhbmRsaW5nJyk7XG4gIHZhciBsb2cgPSByZXF1aXJlKCcuL2xvZycpO1xuICB2YXIgQXV0aG9yaXplID0gcmVxdWlyZSgnLi9hdXRob3JpemUnKTtcbiAgdmFyIGNvbmZpZyA9IHJlcXVpcmUoJy4vY29uZmlnJyk7XG4gIFxuICAvKiBUT0ZJWCAqL1xuICAvLyB2YXIgc3luY0ludGVydmFsID0gMTAwMDAsXG4gIC8vICAgICBiYWNrZ3JvdW5kU3luY0ludGVydmFsID0gNjAwMDAsXG4gIC8vICAgICBpc0JhY2tncm91bmQgPSBmYWxzZTtcblxuICB2YXIgaXNGb2xkZXIgPSB1dGlsLmlzRm9sZGVyO1xuICB2YXIgaXNEb2N1bWVudCA9IHV0aWwuaXNEb2N1bWVudDtcbiAgdmFyIGVxdWFsID0gdXRpbC5lcXVhbDtcbiAgdmFyIGRlZXBDbG9uZSA9IHV0aWwuZGVlcENsb25lO1xuICB2YXIgcGF0aHNGcm9tUm9vdCA9IHV0aWwucGF0aHNGcm9tUm9vdDtcblxuICBmdW5jdGlvbiB0YXNrRm9yKGFjdGlvbiwgcGF0aCwgcHJvbWlzZSkge1xuICAgIHJldHVybiB7XG4gICAgICBhY3Rpb246ICBhY3Rpb24sXG4gICAgICBwYXRoOiAgICBwYXRoLFxuICAgICAgcHJvbWlzZTogcHJvbWlzZVxuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBpc1N0YWxlQ2hpbGQobm9kZSkge1xuICAgIHJldHVybiBub2RlLnJlbW90ZSAmJiBub2RlLnJlbW90ZS5yZXZpc2lvbiAmJiAhbm9kZS5yZW1vdGUuaXRlbXNNYXAgJiYgIW5vZGUucmVtb3RlLmJvZHk7XG4gIH1cblxuICBmdW5jdGlvbiBoYXNDb21tb25SZXZpc2lvbihub2RlKSB7XG4gICAgcmV0dXJuIG5vZGUuY29tbW9uICYmIG5vZGUuY29tbW9uLnJldmlzaW9uO1xuICB9XG5cbiAgZnVuY3Rpb24gaGFuZGxlVmlzaWJpbGl0eSgpIHtcbiAgICB2YXIgcnMgPSB0aGlzO1xuXG4gICAgZnVuY3Rpb24gaGFuZGxlVmlzaWJpbGl0eUNoYW5nZShmZykge1xuICAgICAgdmFyIG9sZFZhbHVlLCBuZXdWYWx1ZTtcbiAgICAgIG9sZFZhbHVlID0gcnMuZ2V0Q3VycmVudFN5bmNJbnRlcnZhbCgpO1xuICAgICAgY29uZmlnLmlzQmFja2dyb3VuZCA9ICFmZztcbiAgICAgIG5ld1ZhbHVlID0gcnMuZ2V0Q3VycmVudFN5bmNJbnRlcnZhbCgpO1xuICAgICAgcnMuX2VtaXQoJ3N5bmMtaW50ZXJ2YWwtY2hhbmdlJywge29sZFZhbHVlOiBvbGRWYWx1ZSwgbmV3VmFsdWU6IG5ld1ZhbHVlfSk7XG4gICAgfVxuXG4gICAgRW52Lm9uKFwiYmFja2dyb3VuZFwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICBoYW5kbGVWaXNpYmlsaXR5Q2hhbmdlKGZhbHNlKTtcbiAgICB9KTtcblxuICAgIEVudi5vbihcImZvcmVncm91bmRcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgaGFuZGxlVmlzaWJpbGl0eUNoYW5nZSh0cnVlKTtcbiAgICB9KTtcbiAgfVxuXG5cbiAgLyoqXG4gICAqIENsYXNzOiBSZW1vdGVTdG9yYWdlLlN5bmNcbiAgICpcbiAgICogV2hhdCB0aGlzIGNsYXNzIGRvZXMgaXMgYmFzaWNhbGx5IHNpeCB0aGluZ3M6XG4gICAqIC0gcmV0cmlldmluZyB0aGUgcmVtb3RlIHZlcnNpb24gb2YgcmVsZXZhbnQgZG9jdW1lbnRzIGFuZCBmb2xkZXJzXG4gICAqIC0gYWRkIGFsbCBsb2NhbCBhbmQgcmVtb3RlIGRvY3VtZW50cyB0b2dldGhlciBpbnRvIG9uZSB0cmVlXG4gICAqIC0gcHVzaCBsb2NhbCBkb2N1bWVudHMgb3V0IGlmIHRoZXkgZG9uJ3QgZXhpc3QgcmVtb3RlbHlcbiAgICogLSBwdXNoIGxvY2FsIGNoYW5nZXMgb3V0IHRvIHJlbW90ZSBkb2N1bWVudHMgKGNvbmRpdGlvbmFsbHksIHRvXG4gICAqICAgICAgYXZvaWQgcmFjZSBjb25kaXRpb25zIHdoZXJlIGJvdGggaGF2ZSBjaGFuZ2VkKVxuICAgKiAtIGFkb3B0IHRoZSBsb2NhbCB2ZXJzaW9uIG9mIGEgZG9jdW1lbnQgdG8gaXRzIHJlbW90ZSB2ZXJzaW9uIGlmXG4gICAqICAgICAgYm90aCBleGlzdCBhbmQgdGhleSBkaWZmZXJcbiAgICogLSBkZWxldGUgdGhlIGxvY2FsIHZlcnNpb24gb2YgYSBkb2N1bWVudCBpZiBpdCB3YXMgZGVsZXRlZCByZW1vdGVseVxuICAgKiAtIGlmIGFueSBnZXQgcmVxdWVzdHMgd2VyZSB3YWl0aW5nIGZvciByZW1vdGUgZGF0YSwgcmVzb2x2ZSB0aGVtIG9uY2VcbiAgICogICAgICB0aGlzIGRhdGEgY29tZXMgaW4uXG4gICAqXG4gICAqIEl0IGRvZXMgdGhpcyB1c2luZyByZXF1ZXN0cyB0byBkb2N1bWVudHMsIGFuZCB0byBmb2xkZXJzLiBXaGVuZXZlciBhXG4gICAqIGZvbGRlciBHRVQgY29tZXMgaW4sIGl0IGdpdmVzIGluZm9ybWF0aW9uIGFib3V0IGFsbCB0aGUgZG9jdW1lbnRzIGl0XG4gICAqIGNvbnRhaW5zICh0aGlzIGlzIHRoZSBgbWFya0NoaWxkcmVuYCBmdW5jdGlvbikuXG4gICAqKi9cbiAgdmFyIFN5bmMgPSBmdW5jdGlvbiAocmVtb3RlU3RvcmFnZSwgc2V0TG9jYWwsIHNldFJlbW90ZSwgc2V0QWNjZXNzLCBzZXRDYWNoaW5nKSB7XG4gICAgdGhpcy5yZW1vdGVTdG9yYWdlID0gcmVtb3RlU3RvcmFnZTtcbiAgICB0aGlzLmxvY2FsID0gc2V0TG9jYWw7XG4gICAgdGhpcy5sb2NhbC5vbkRpZmYoZnVuY3Rpb24gKHBhdGgpIHtcbiAgICAgIHRoaXMuYWRkVGFzayhwYXRoKTtcbiAgICAgIHRoaXMuZG9UYXNrcygpO1xuICAgIH0uYmluZCh0aGlzKSk7XG4gICAgdGhpcy5yZW1vdGUgPSBzZXRSZW1vdGU7XG4gICAgdGhpcy5hY2Nlc3MgPSBzZXRBY2Nlc3M7XG4gICAgdGhpcy5jYWNoaW5nID0gc2V0Q2FjaGluZztcbiAgICB0aGlzLl90YXNrcyA9IHt9O1xuICAgIHRoaXMuX3J1bm5pbmcgPSB7fTtcbiAgICB0aGlzLl90aW1lU3RhcnRlZCA9IHt9O1xuICAgIGV2ZW50SGFuZGxpbmcodGhpcywgJ2RvbmUnLCAncmVxLWRvbmUnKTtcbiAgICB0aGlzLmNhY2hpbmcub25BY3RpdmF0ZShmdW5jdGlvbiAocGF0aCkge1xuICAgICAgdGhpcy5hZGRUYXNrKHBhdGgpO1xuICAgICAgdGhpcy5kb1Rhc2tzKCk7XG4gICAgfS5iaW5kKHRoaXMpKTtcbiAgfTtcblxuICBTeW5jLnByb3RvdHlwZSA9IHtcblxuICAgIG5vdzogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuICAgIH0sXG5cbiAgICBxdWV1ZUdldFJlcXVlc3Q6IGZ1bmN0aW9uIChwYXRoKSB7XG4gICAgICB2YXIgcGVuZGluZyA9IFByb21pc2UuZGVmZXIoKTtcblxuICAgICAgaWYgKCF0aGlzLnJlbW90ZS5jb25uZWN0ZWQpIHtcbiAgICAgICAgcGVuZGluZy5yZWplY3QoJ2Nhbm5vdCBmdWxmaWxsIG1heEFnZSByZXF1aXJlbWVudCAtIHJlbW90ZSBpcyBub3QgY29ubmVjdGVkJyk7XG4gICAgICB9IGVsc2UgaWYgKCF0aGlzLnJlbW90ZS5vbmxpbmUpIHtcbiAgICAgICAgcGVuZGluZy5yZWplY3QoJ2Nhbm5vdCBmdWxmaWxsIG1heEFnZSByZXF1aXJlbWVudCAtIHJlbW90ZSBpcyBub3Qgb25saW5lJyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmFkZFRhc2socGF0aCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHRoaXMubG9jYWwuZ2V0KHBhdGgpLnRoZW4oZnVuY3Rpb24gKHIpIHtcbiAgICAgICAgICAgIHJldHVybiBwZW5kaW5nLnJlc29sdmUocik7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0uYmluZCh0aGlzKSk7XG5cbiAgICAgICAgdGhpcy5kb1Rhc2tzKCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBwZW5kaW5nLnByb21pc2U7XG4gICAgfSxcblxuICAgIGNvcnJ1cHRTZXJ2ZXJJdGVtc01hcDogZnVuY3Rpb24gKGl0ZW1zTWFwLCBmb3JjZTAyKSB7XG4gICAgICBpZiAoKHR5cGVvZihpdGVtc01hcCkgIT09ICdvYmplY3QnKSB8fCAoQXJyYXkuaXNBcnJheShpdGVtc01hcCkpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBpdGVtTmFtZSBpbiBpdGVtc01hcCkge1xuICAgICAgICB2YXIgaXRlbSA9IGl0ZW1zTWFwW2l0ZW1OYW1lXTtcblxuICAgICAgICBpZiAodHlwZW9mKGl0ZW0pICE9PSAnb2JqZWN0Jykge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YoaXRlbS5FVGFnKSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNGb2xkZXIoaXRlbU5hbWUpKSB7XG4gICAgICAgICAgaWYgKGl0ZW1OYW1lLnN1YnN0cmluZygwLCBpdGVtTmFtZS5sZW5ndGgtMSkuaW5kZXhPZignLycpICE9PSAtMSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChpdGVtTmFtZS5pbmRleE9mKCcvJykgIT09IC0xKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGZvcmNlMDIpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YoaXRlbVsnQ29udGVudC1UeXBlJ10pICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2YoaXRlbVsnQ29udGVudC1MZW5ndGgnXSkgIT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSxcblxuICAgIGNvcnJ1cHRJdGVtc01hcDogZnVuY3Rpb24gKGl0ZW1zTWFwKSB7XG4gICAgICBpZiAoKHR5cGVvZihpdGVtc01hcCkgIT09ICdvYmplY3QnKSB8fCAoQXJyYXkuaXNBcnJheShpdGVtc01hcCkpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBpdGVtTmFtZSBpbiBpdGVtc01hcCkge1xuICAgICAgICBpZiAodHlwZW9mKGl0ZW1zTWFwW2l0ZW1OYW1lXSkgIT09ICdib29sZWFuJykge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9LFxuXG4gICAgY29ycnVwdFJldmlzaW9uOiBmdW5jdGlvbiAocmV2KSB7XG4gICAgICByZXR1cm4gKCh0eXBlb2YocmV2KSAhPT0gJ29iamVjdCcpIHx8XG4gICAgICAgICAgICAgIChBcnJheS5pc0FycmF5KHJldikpIHx8XG4gICAgICAgICAgICAgIChyZXYucmV2aXNpb24gJiYgdHlwZW9mKHJldi5yZXZpc2lvbikgIT09ICdzdHJpbmcnKSB8fFxuICAgICAgICAgICAgICAocmV2LmJvZHkgJiYgdHlwZW9mKHJldi5ib2R5KSAhPT0gJ3N0cmluZycgJiYgdHlwZW9mKHJldi5ib2R5KSAhPT0gJ29iamVjdCcpIHx8XG4gICAgICAgICAgICAgIChyZXYuY29udGVudFR5cGUgJiYgdHlwZW9mKHJldi5jb250ZW50VHlwZSkgIT09ICdzdHJpbmcnKSB8fFxuICAgICAgICAgICAgICAocmV2LmNvbnRlbnRMZW5ndGggJiYgdHlwZW9mKHJldi5jb250ZW50TGVuZ3RoKSAhPT0gJ251bWJlcicpIHx8XG4gICAgICAgICAgICAgIChyZXYudGltZXN0YW1wICYmIHR5cGVvZihyZXYudGltZXN0YW1wKSAhPT0gJ251bWJlcicpIHx8XG4gICAgICAgICAgICAgIChyZXYuaXRlbXNNYXAgJiYgdGhpcy5jb3JydXB0SXRlbXNNYXAocmV2Lml0ZW1zTWFwKSkpO1xuICAgIH0sXG5cbiAgICBpc0NvcnJ1cHQ6IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICByZXR1cm4gKCh0eXBlb2Yobm9kZSkgIT09ICdvYmplY3QnKSB8fFxuICAgICAgICAgICAgICAoQXJyYXkuaXNBcnJheShub2RlKSkgfHxcbiAgICAgICAgICAgICAgKHR5cGVvZihub2RlLnBhdGgpICE9PSAnc3RyaW5nJykgfHxcbiAgICAgICAgICAgICAgKHRoaXMuY29ycnVwdFJldmlzaW9uKG5vZGUuY29tbW9uKSkgfHxcbiAgICAgICAgICAgICAgKG5vZGUubG9jYWwgJiYgdGhpcy5jb3JydXB0UmV2aXNpb24obm9kZS5sb2NhbCkpIHx8XG4gICAgICAgICAgICAgIChub2RlLnJlbW90ZSAmJiB0aGlzLmNvcnJ1cHRSZXZpc2lvbihub2RlLnJlbW90ZSkpIHx8XG4gICAgICAgICAgICAgIChub2RlLnB1c2ggJiYgdGhpcy5jb3JydXB0UmV2aXNpb24obm9kZS5wdXNoKSkpO1xuICAgIH0sXG5cbiAgICBoYXNUYXNrczogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHRoaXMuX3Rhc2tzKS5sZW5ndGggPiAwO1xuICAgIH0sXG5cbiAgICBjb2xsZWN0RGlmZlRhc2tzOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgbnVtID0gMDtcblxuICAgICAgcmV0dXJuIHRoaXMubG9jYWwuZm9yQWxsTm9kZXMoZnVuY3Rpb24gKG5vZGUpIHtcblxuICAgICAgICBpZiAobnVtID4gMTAwKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuaXNDb3JydXB0KG5vZGUpKSB7XG4gICAgICAgICAgbG9nKCdbU3luY10gV0FSTklORzogY29ycnVwdCBub2RlIGluIGxvY2FsIGNhY2hlJywgbm9kZSk7XG4gICAgICAgICAgaWYgKHR5cGVvZihub2RlKSA9PT0gJ29iamVjdCcgJiYgbm9kZS5wYXRoKSB7XG4gICAgICAgICAgICB0aGlzLmFkZFRhc2sobm9kZS5wYXRoKTtcbiAgICAgICAgICAgIG51bSsrO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLm5lZWRzRmV0Y2gobm9kZSkgJiYgdGhpcy5hY2Nlc3MuY2hlY2tQYXRoUGVybWlzc2lvbihub2RlLnBhdGgsICdyJykpIHtcbiAgICAgICAgICB0aGlzLmFkZFRhc2sobm9kZS5wYXRoKTtcbiAgICAgICAgICBudW0rKztcbiAgICAgICAgfSBlbHNlIGlmIChpc0RvY3VtZW50KG5vZGUucGF0aCkgJiYgdGhpcy5uZWVkc1B1c2gobm9kZSkgJiZcbiAgICAgICAgICAgICAgICAgICB0aGlzLmFjY2Vzcy5jaGVja1BhdGhQZXJtaXNzaW9uKG5vZGUucGF0aCwgJ3J3JykpIHtcbiAgICAgICAgICB0aGlzLmFkZFRhc2sobm9kZS5wYXRoKTtcbiAgICAgICAgICBudW0rKztcbiAgICAgICAgfVxuICAgICAgfS5iaW5kKHRoaXMpKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIG51bTtcbiAgICAgIH0sIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgfSk7XG4gICAgfSxcblxuICAgIGluQ29uZmxpY3Q6IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICByZXR1cm4gKG5vZGUubG9jYWwgJiYgbm9kZS5yZW1vdGUgJiZcbiAgICAgICAgICAgICAgKG5vZGUucmVtb3RlLmJvZHkgIT09IHVuZGVmaW5lZCB8fCBub2RlLnJlbW90ZS5pdGVtc01hcCkpO1xuICAgIH0sXG5cbiAgICBuZWVkc1JlZnJlc2g6IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICBpZiAobm9kZS5jb21tb24pIHtcbiAgICAgICAgaWYgKCFub2RlLmNvbW1vbi50aW1lc3RhbXApIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKHRoaXMubm93KCkgLSBub2RlLmNvbW1vbi50aW1lc3RhbXAgPiBjb25maWcuc3luY0ludGVydmFsKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9LFxuXG4gICAgbmVlZHNGZXRjaDogZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgIGlmICh0aGlzLmluQ29uZmxpY3Qobm9kZSkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICBpZiAobm9kZS5jb21tb24gJiYgbm9kZS5jb21tb24uaXRlbXNNYXAgPT09IHVuZGVmaW5lZCAmJiBub2RlLmNvbW1vbi5ib2R5ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICBpZiAobm9kZS5yZW1vdGUgJiYgbm9kZS5yZW1vdGUuaXRlbXNNYXAgPT09IHVuZGVmaW5lZCAmJiBub2RlLnJlbW90ZS5ib2R5ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSxcblxuICAgIG5lZWRzUHVzaDogZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgIGlmICh0aGlzLmluQ29uZmxpY3Qobm9kZSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgaWYgKG5vZGUubG9jYWwgJiYgIW5vZGUucHVzaCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgbmVlZHNSZW1vdGVQdXQ6IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICByZXR1cm4gbm9kZS5sb2NhbCAmJiBub2RlLmxvY2FsLmJvZHk7XG4gICAgfSxcblxuICAgIG5lZWRzUmVtb3RlRGVsZXRlOiBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgcmV0dXJuIG5vZGUubG9jYWwgJiYgbm9kZS5sb2NhbC5ib2R5ID09PSBmYWxzZTtcbiAgICB9LFxuXG4gICAgZ2V0UGFyZW50UGF0aDogZnVuY3Rpb24gKHBhdGgpIHtcbiAgICAgIHZhciBwYXJ0cyA9IHBhdGgubWF0Y2goL14oLipcXC8pKFteXFwvXStcXC8/KSQvKTtcblxuICAgICAgaWYgKHBhcnRzKSB7XG4gICAgICAgIHJldHVybiBwYXJ0c1sxXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTm90IGEgdmFsaWQgcGF0aDogXCInK3BhdGgrJ1wiJyk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIGRlbGV0ZUNoaWxkUGF0aHNGcm9tVGFza3M6IGZ1bmN0aW9uICgpIHtcbiAgICAgIGZvciAodmFyIHBhdGggaW4gdGhpcy5fdGFza3MpIHtcbiAgICAgICAgdmFyIHBhdGhzID0gcGF0aHNGcm9tUm9vdChwYXRoKTtcblxuICAgICAgICBmb3IgKHZhciBpPTE7IGk8cGF0aHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBpZiAodGhpcy5fdGFza3NbcGF0aHNbaV1dKSB7XG4gICAgICAgICAgICAvLyBtb3ZlIHBlbmRpbmcgcHJvbWlzZXMgdG8gcGFyZW50IHRhc2tcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRoaXMuX3Rhc2tzW3BhdGhdKSAmJiB0aGlzLl90YXNrc1twYXRoXS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgQXJyYXkucHJvdG90eXBlLnB1c2guYXBwbHkoXG4gICAgICAgICAgICAgICAgdGhpcy5fdGFza3NbcGF0aHNbaV1dLFxuICAgICAgICAgICAgICAgIHRoaXMuX3Rhc2tzW3BhdGhdXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5fdGFza3NbcGF0aF07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIGNvbGxlY3RSZWZyZXNoVGFza3M6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLmxvY2FsLmZvckFsbE5vZGVzKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgIHZhciBwYXJlbnRQYXRoO1xuICAgICAgICBpZiAodGhpcy5uZWVkc1JlZnJlc2gobm9kZSkpIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgcGFyZW50UGF0aCA9IHRoaXMuZ2V0UGFyZW50UGF0aChub2RlLnBhdGgpO1xuICAgICAgICAgIH0gY2F0Y2goZSkge1xuICAgICAgICAgICAgLy8gbm9kZS5wYXRoIGlzIGFscmVhZHkgJy8nLCBjYW4ndCB0YWtlIHBhcmVudFBhdGhcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHBhcmVudFBhdGggJiYgdGhpcy5hY2Nlc3MuY2hlY2tQYXRoUGVybWlzc2lvbihwYXJlbnRQYXRoLCAncicpKSB7XG4gICAgICAgICAgICB0aGlzLmFkZFRhc2socGFyZW50UGF0aCk7XG4gICAgICAgICAgfSBlbHNlIGlmICh0aGlzLmFjY2Vzcy5jaGVja1BhdGhQZXJtaXNzaW9uKG5vZGUucGF0aCwgJ3InKSkge1xuICAgICAgICAgICAgdGhpcy5hZGRUYXNrKG5vZGUucGF0aCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LmJpbmQodGhpcykpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmRlbGV0ZUNoaWxkUGF0aHNGcm9tVGFza3MoKTtcbiAgICAgIH0uYmluZCh0aGlzKSwgZnVuY3Rpb24gKGVycikge1xuICAgICAgICB0aHJvdyBlcnI7XG4gICAgICB9KTtcbiAgICB9LFxuXG4gICAgZmx1c2g6IGZ1bmN0aW9uIChub2Rlcykge1xuICAgICAgZm9yICh2YXIgcGF0aCBpbiBub2Rlcykge1xuICAgICAgICAvLyBTdHJhdGVneSBpcyAnRkxVU0gnIGFuZCBubyBsb2NhbCBjaGFuZ2VzIGV4aXN0XG4gICAgICAgIGlmICh0aGlzLmNhY2hpbmcuY2hlY2tQYXRoKHBhdGgpID09PSAnRkxVU0gnICYmIG5vZGVzW3BhdGhdICYmICFub2Rlc1twYXRoXS5sb2NhbCkge1xuICAgICAgICAgIGxvZygnW1N5bmNdIEZsdXNoaW5nJywgcGF0aCk7XG4gICAgICAgICAgbm9kZXNbcGF0aF0gPSB1bmRlZmluZWQ7IC8vIENhdXNlIG5vZGUgdG8gYmUgZmx1c2hlZCBmcm9tIGNhY2hlXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBub2RlcztcbiAgICB9LFxuXG4gICAgZG9UYXNrOiBmdW5jdGlvbiAocGF0aCkge1xuICAgICAgcmV0dXJuIHRoaXMubG9jYWwuZ2V0Tm9kZXMoW3BhdGhdKS50aGVuKGZ1bmN0aW9uIChub2Rlcykge1xuICAgICAgICB2YXIgbm9kZSA9IG5vZGVzW3BhdGhdO1xuICAgICAgICAvLyBGaXJzdCBmZXRjaDpcbiAgICAgICAgaWYgKHR5cGVvZihub2RlKSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICByZXR1cm4gdGFza0ZvcignZ2V0JywgcGF0aCwgdGhpcy5yZW1vdGUuZ2V0KHBhdGgpKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBGZXRjaCBrbm93bi1zdGFsZSBjaGlsZDpcbiAgICAgICAgZWxzZSBpZiAoaXNTdGFsZUNoaWxkKG5vZGUpKSB7XG4gICAgICAgICAgcmV0dXJuIHRhc2tGb3IoJ2dldCcsIHBhdGgsIHRoaXMucmVtb3RlLmdldChwYXRoKSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUHVzaCBQVVQ6XG4gICAgICAgIGVsc2UgaWYgKHRoaXMubmVlZHNSZW1vdGVQdXQobm9kZSkpIHtcbiAgICAgICAgICBub2RlLnB1c2ggPSBkZWVwQ2xvbmUobm9kZS5sb2NhbCk7XG4gICAgICAgICAgbm9kZS5wdXNoLnRpbWVzdGFtcCA9IHRoaXMubm93KCk7XG5cbiAgICAgICAgICByZXR1cm4gdGhpcy5sb2NhbC5zZXROb2Rlcyh0aGlzLmZsdXNoKG5vZGVzKSkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgb3B0aW9ucztcbiAgICAgICAgICAgIGlmIChoYXNDb21tb25SZXZpc2lvbihub2RlKSkge1xuICAgICAgICAgICAgICBvcHRpb25zID0geyBpZk1hdGNoOiBub2RlLmNvbW1vbi5yZXZpc2lvbiB9O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgLy8gSW5pdGlhbCBQVVQgKGZhaWwgaWYgc29tZXRoaW5nIGlzIGFscmVhZHkgdGhlcmUpXG4gICAgICAgICAgICAgIG9wdGlvbnMgPSB7IGlmTm9uZU1hdGNoOiAnKicgfTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHRhc2tGb3IoJ3B1dCcsIHBhdGgsXG4gICAgICAgICAgICAgIHRoaXMucmVtb3RlLnB1dChwYXRoLCBub2RlLnB1c2guYm9keSwgbm9kZS5wdXNoLmNvbnRlbnRUeXBlLCBvcHRpb25zKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9LmJpbmQodGhpcykpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFB1c2ggREVMRVRFOlxuICAgICAgICBlbHNlIGlmICh0aGlzLm5lZWRzUmVtb3RlRGVsZXRlKG5vZGUpKSB7XG4gICAgICAgICAgbm9kZS5wdXNoID0geyBib2R5OiBmYWxzZSwgdGltZXN0YW1wOiB0aGlzLm5vdygpIH07XG5cbiAgICAgICAgICByZXR1cm4gdGhpcy5sb2NhbC5zZXROb2Rlcyh0aGlzLmZsdXNoKG5vZGVzKSkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoaGFzQ29tbW9uUmV2aXNpb24obm9kZSkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHRhc2tGb3IoJ2RlbGV0ZScsIHBhdGgsXG4gICAgICAgICAgICAgICAgdGhpcy5yZW1vdGUuZGVsZXRlKHBhdGgsIHsgaWZNYXRjaDogbm9kZS5jb21tb24ucmV2aXNpb24gfSlcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH0gZWxzZSB7IC8vIEFzY2VydGFpbiBjdXJyZW50IGNvbW1vbiBvciByZW1vdGUgcmV2aXNpb24gZmlyc3RcbiAgICAgICAgICAgICAgcmV0dXJuIHRhc2tGb3IoJ2dldCcsIHBhdGgsIHRoaXMucmVtb3RlLmdldChwYXRoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfS5iaW5kKHRoaXMpKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBDb25kaXRpb25hbCByZWZyZXNoOlxuICAgICAgICBlbHNlIGlmIChoYXNDb21tb25SZXZpc2lvbihub2RlKSkge1xuICAgICAgICAgIHJldHVybiB0YXNrRm9yKCdnZXQnLCBwYXRoLFxuICAgICAgICAgICAgdGhpcy5yZW1vdGUuZ2V0KHBhdGgsIHsgaWZOb25lTWF0Y2g6IG5vZGUuY29tbW9uLnJldmlzaW9uIH0pXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gdGFza0ZvcignZ2V0JywgcGF0aCwgdGhpcy5yZW1vdGUuZ2V0KHBhdGgpKTtcbiAgICAgICAgfVxuICAgICAgfS5iaW5kKHRoaXMpKTtcbiAgICB9LFxuXG4gICAgYXV0b01lcmdlRm9sZGVyOiBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgaWYgKG5vZGUucmVtb3RlLml0ZW1zTWFwKSB7XG4gICAgICAgIG5vZGUuY29tbW9uID0gbm9kZS5yZW1vdGU7XG4gICAgICAgIGRlbGV0ZSBub2RlLnJlbW90ZTtcblxuICAgICAgICBpZiAobm9kZS5jb21tb24uaXRlbXNNYXApIHtcbiAgICAgICAgICBmb3IgKHZhciBpdGVtTmFtZSBpbiBub2RlLmNvbW1vbi5pdGVtc01hcCkge1xuICAgICAgICAgICAgaWYgKCFub2RlLmxvY2FsLml0ZW1zTWFwW2l0ZW1OYW1lXSkge1xuICAgICAgICAgICAgICAvLyBJbmRpY2F0ZXMgdGhlIG5vZGUgaXMgZWl0aGVyIG5ld2x5IGJlaW5nIGZldGNoZWRcbiAgICAgICAgICAgICAgLy8gaGFzIGJlZW4gZGVsZXRlZCBsb2NhbGx5ICh3aGV0aGVyIG9yIG5vdCBsZWFkaW5nIHRvIGNvbmZsaWN0KTtcbiAgICAgICAgICAgICAgLy8gYmVmb3JlIGxpc3RpbmcgaXQgaW4gbG9jYWwgbGlzdGluZ3MsIGNoZWNrIGlmIGEgbG9jYWwgZGVsZXRpb25cbiAgICAgICAgICAgICAgLy8gZXhpc3RzLlxuICAgICAgICAgICAgICBub2RlLmxvY2FsLml0ZW1zTWFwW2l0ZW1OYW1lXSA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChlcXVhbChub2RlLmxvY2FsLml0ZW1zTWFwLCBub2RlLmNvbW1vbi5pdGVtc01hcCkpIHtcbiAgICAgICAgICAgIGRlbGV0ZSBub2RlLmxvY2FsO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfSxcblxuICAgIGF1dG9NZXJnZURvY3VtZW50OiBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgaGFzTm9SZW1vdGVDaGFuZ2VzID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgaWYgKG5vZGUucmVtb3RlICYmIG5vZGUucmVtb3RlLnJldmlzaW9uICYmIG5vZGUucmVtb3RlLnJldmlzaW9uICE9PSBub2RlLmNvbW1vbi5yZXZpc2lvbikge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKG5vZGUuY29tbW9uLmJvZHkgPT09IHVuZGVmaW5lZCAmJiBub2RlLnJlbW90ZS5ib2R5ID09PSBmYWxzZSkgfHxcbiAgICAgICAgICAgICAgIChub2RlLnJlbW90ZS5ib2R5ID09PSBub2RlLmNvbW1vbi5ib2R5ICYmXG4gICAgICAgICAgICAgICAgbm9kZS5yZW1vdGUuY29udGVudFR5cGUgPT09IG5vZGUuY29tbW9uLmNvbnRlbnRUeXBlKTtcbiAgICAgIH07XG4gICAgICBtZXJnZU11dHVhbERlbGV0aW9uID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgaWYgKG5vZGUucmVtb3RlICYmIG5vZGUucmVtb3RlLmJvZHkgPT09IGZhbHNlXG4gICAgICAgICAgICAmJiBub2RlLmxvY2FsICYmIG5vZGUubG9jYWwuYm9keSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgZGVsZXRlIG5vZGUubG9jYWw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICB9O1xuXG4gICAgICBpZiAoaGFzTm9SZW1vdGVDaGFuZ2VzKG5vZGUpKSB7XG4gICAgICAgIG5vZGUgPSBtZXJnZU11dHVhbERlbGV0aW9uKG5vZGUpO1xuICAgICAgICBkZWxldGUgbm9kZS5yZW1vdGU7XG4gICAgICB9IGVsc2UgaWYgKG5vZGUucmVtb3RlLmJvZHkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAvLyBrZWVwL3JldmVydDpcbiAgICAgICAgbG9nKCdbU3luY10gRW1pdHRpbmcga2VlcC9yZXZlcnQnKTtcblxuICAgICAgICB0aGlzLmxvY2FsLl9lbWl0Q2hhbmdlKHtcbiAgICAgICAgICBvcmlnaW46ICAgICAgICAgJ2NvbmZsaWN0JyxcbiAgICAgICAgICBwYXRoOiAgICAgICAgICAgbm9kZS5wYXRoLFxuICAgICAgICAgIG9sZFZhbHVlOiAgICAgICBub2RlLmxvY2FsLmJvZHksXG4gICAgICAgICAgbmV3VmFsdWU6ICAgICAgIG5vZGUucmVtb3RlLmJvZHksXG4gICAgICAgICAgbGFzdENvbW1vblZhbHVlOiBub2RlLmNvbW1vbi5ib2R5LFxuICAgICAgICAgIG9sZENvbnRlbnRUeXBlOiBub2RlLmxvY2FsLmNvbnRlbnRUeXBlLFxuICAgICAgICAgIG5ld0NvbnRlbnRUeXBlOiBub2RlLnJlbW90ZS5jb250ZW50VHlwZSxcbiAgICAgICAgICBsYXN0Q29tbW9uQ29udGVudFR5cGU6IG5vZGUuY29tbW9uLmNvbnRlbnRUeXBlXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmIChub2RlLnJlbW90ZS5ib2R5KSB7XG4gICAgICAgICAgbm9kZS5jb21tb24gPSBub2RlLnJlbW90ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBub2RlLmNvbW1vbiA9IHt9O1xuICAgICAgICB9XG4gICAgICAgIGRlbGV0ZSBub2RlLnJlbW90ZTtcbiAgICAgICAgZGVsZXRlIG5vZGUubG9jYWw7XG4gICAgICB9XG4gICAgICByZXR1cm4gbm9kZTtcbiAgICB9LFxuXG4gICAgYXV0b01lcmdlOiBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgaWYgKG5vZGUucmVtb3RlKSB7XG4gICAgICAgIGlmIChub2RlLmxvY2FsKSB7XG4gICAgICAgICAgaWYgKGlzRm9sZGVyKG5vZGUucGF0aCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmF1dG9NZXJnZUZvbGRlcihub2RlKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYXV0b01lcmdlRG9jdW1lbnQobm9kZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgeyAvLyBubyBsb2NhbCBjaGFuZ2VzXG4gICAgICAgICAgaWYgKGlzRm9sZGVyKG5vZGUucGF0aCkpIHtcbiAgICAgICAgICAgIGlmIChub2RlLnJlbW90ZS5pdGVtc01hcCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgIG5vZGUuY29tbW9uID0gbm9kZS5yZW1vdGU7XG4gICAgICAgICAgICAgIGRlbGV0ZSBub2RlLnJlbW90ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKG5vZGUucmVtb3RlLmJvZHkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICB2YXIgY2hhbmdlID0ge1xuICAgICAgICAgICAgICAgIG9yaWdpbjogICAncmVtb3RlJyxcbiAgICAgICAgICAgICAgICBwYXRoOiAgICAgbm9kZS5wYXRoLFxuICAgICAgICAgICAgICAgIG9sZFZhbHVlOiAobm9kZS5jb21tb24uYm9keSA9PT0gZmFsc2UgPyB1bmRlZmluZWQgOiBub2RlLmNvbW1vbi5ib2R5KSxcbiAgICAgICAgICAgICAgICBuZXdWYWx1ZTogKG5vZGUucmVtb3RlLmJvZHkgPT09IGZhbHNlID8gdW5kZWZpbmVkIDogbm9kZS5yZW1vdGUuYm9keSksXG4gICAgICAgICAgICAgICAgb2xkQ29udGVudFR5cGU6IG5vZGUuY29tbW9uLmNvbnRlbnRUeXBlLFxuICAgICAgICAgICAgICAgIG5ld0NvbnRlbnRUeXBlOiBub2RlLnJlbW90ZS5jb250ZW50VHlwZVxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICBpZiAoY2hhbmdlLm9sZFZhbHVlIHx8IGNoYW5nZS5uZXdWYWx1ZSkge1xuICAgICAgICAgICAgICAgIHRoaXMubG9jYWwuX2VtaXRDaGFuZ2UoY2hhbmdlKTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGlmICghbm9kZS5yZW1vdGUuYm9keSkgeyAvLyBubyByZW1vdGUsIHNvIGRlbGV0ZS9kb24ndCBjcmVhdGVcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBub2RlLmNvbW1vbiA9IG5vZGUucmVtb3RlO1xuICAgICAgICAgICAgICBkZWxldGUgbm9kZS5yZW1vdGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAobm9kZS5jb21tb24uYm9keSkge1xuICAgICAgICAgIHRoaXMubG9jYWwuX2VtaXRDaGFuZ2Uoe1xuICAgICAgICAgICAgb3JpZ2luOiAgICdyZW1vdGUnLFxuICAgICAgICAgICAgcGF0aDogICAgIG5vZGUucGF0aCxcbiAgICAgICAgICAgIG9sZFZhbHVlOiBub2RlLmNvbW1vbi5ib2R5LFxuICAgICAgICAgICAgbmV3VmFsdWU6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIG9sZENvbnRlbnRUeXBlOiBub2RlLmNvbW1vbi5jb250ZW50VHlwZSxcbiAgICAgICAgICAgIG5ld0NvbnRlbnRUeXBlOiB1bmRlZmluZWRcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gbm9kZTtcbiAgICB9LFxuXG4gICAgdXBkYXRlQ29tbW9uVGltZXN0YW1wOiBmdW5jdGlvbiAocGF0aCwgcmV2aXNpb24pIHtcbiAgICAgIHJldHVybiB0aGlzLmxvY2FsLmdldE5vZGVzKFtwYXRoXSkudGhlbihmdW5jdGlvbiAobm9kZXMpIHtcbiAgICAgICAgaWYgKG5vZGVzW3BhdGhdICYmIG5vZGVzW3BhdGhdLmNvbW1vbiAmJiBub2Rlc1twYXRoXS5jb21tb24ucmV2aXNpb24gPT09IHJldmlzaW9uKSB7XG4gICAgICAgICAgbm9kZXNbcGF0aF0uY29tbW9uLnRpbWVzdGFtcCA9IHRoaXMubm93KCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMubG9jYWwuc2V0Tm9kZXModGhpcy5mbHVzaChub2RlcykpO1xuICAgICAgfS5iaW5kKHRoaXMpKTtcbiAgICB9LFxuXG4gICAgbWFya0NoaWxkcmVuOiBmdW5jdGlvbiAocGF0aCwgaXRlbXNNYXAsIGNoYW5nZWROb2RlcywgbWlzc2luZ0NoaWxkcmVuKSB7XG4gICAgICB2YXIgcGF0aHMgPSBbXTtcbiAgICAgIHZhciBtZXRhID0ge307XG4gICAgICB2YXIgcmVjdXJzZSA9IHt9O1xuXG4gICAgICBmb3IgKHZhciBpdGVtIGluIGl0ZW1zTWFwKSB7XG4gICAgICAgIHBhdGhzLnB1c2gocGF0aCtpdGVtKTtcbiAgICAgICAgbWV0YVtwYXRoK2l0ZW1dID0gaXRlbXNNYXBbaXRlbV07XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBjaGlsZE5hbWUgaW4gbWlzc2luZ0NoaWxkcmVuKSB7XG4gICAgICAgIHBhdGhzLnB1c2gocGF0aCtjaGlsZE5hbWUpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5sb2NhbC5nZXROb2RlcyhwYXRocykudGhlbihmdW5jdGlvbiAobm9kZXMpIHtcbiAgICAgICAgdmFyIGNhY2hpbmdTdHJhdGVneTtcbiAgICAgICAgdmFyIG5vZGU7XG5cbiAgICAgICAgdmFyIG5vZGVDaGFuZ2VkID0gZnVuY3Rpb24gKG5vZGUsIGV0YWcpIHtcbiAgICAgICAgICByZXR1cm4gbm9kZS5jb21tb24ucmV2aXNpb24gIT09IGV0YWcgJiYgKCFub2RlLnJlbW90ZSB8fCBub2RlLnJlbW90ZS5yZXZpc2lvbiAhPT0gZXRhZyk7XG4gICAgICAgIH07XG5cbiAgICAgICAgZm9yICh2YXIgbm9kZVBhdGggaW4gbm9kZXMpIHtcbiAgICAgICAgICBub2RlID0gbm9kZXNbbm9kZVBhdGhdO1xuXG4gICAgICAgICAgaWYgKG1ldGFbbm9kZVBhdGhdKSB7XG4gICAgICAgICAgICBpZiAobm9kZSAmJiBub2RlLmNvbW1vbikge1xuICAgICAgICAgICAgICBpZiAobm9kZUNoYW5nZWQobm9kZSwgbWV0YVtub2RlUGF0aF0uRVRhZykpIHtcbiAgICAgICAgICAgICAgICBjaGFuZ2VkTm9kZXNbbm9kZVBhdGhdID0gZGVlcENsb25lKG5vZGUpO1xuICAgICAgICAgICAgICAgIGNoYW5nZWROb2Rlc1tub2RlUGF0aF0ucmVtb3RlID0ge1xuICAgICAgICAgICAgICAgICAgcmV2aXNpb246ICBtZXRhW25vZGVQYXRoXS5FVGFnLFxuICAgICAgICAgICAgICAgICAgdGltZXN0YW1wOiB0aGlzLm5vdygpXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBjaGFuZ2VkTm9kZXNbbm9kZVBhdGhdID0gdGhpcy5hdXRvTWVyZ2UoY2hhbmdlZE5vZGVzW25vZGVQYXRoXSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGNhY2hpbmdTdHJhdGVneSA9IHRoaXMuY2FjaGluZy5jaGVja1BhdGgobm9kZVBhdGgpO1xuICAgICAgICAgICAgICBpZiAoY2FjaGluZ1N0cmF0ZWd5ID09PSAnQUxMJykge1xuICAgICAgICAgICAgICAgIGNoYW5nZWROb2Rlc1tub2RlUGF0aF0gPSB7XG4gICAgICAgICAgICAgICAgICBwYXRoOiBub2RlUGF0aCxcbiAgICAgICAgICAgICAgICAgIGNvbW1vbjoge1xuICAgICAgICAgICAgICAgICAgICB0aW1lc3RhbXA6IHRoaXMubm93KClcbiAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICByZW1vdGU6IHtcbiAgICAgICAgICAgICAgICAgICAgcmV2aXNpb246IG1ldGFbbm9kZVBhdGhdLkVUYWcsXG4gICAgICAgICAgICAgICAgICAgIHRpbWVzdGFtcDogdGhpcy5ub3coKVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGNoYW5nZWROb2Rlc1tub2RlUGF0aF0gJiYgbWV0YVtub2RlUGF0aF1bJ0NvbnRlbnQtVHlwZSddKSB7XG4gICAgICAgICAgICAgIGNoYW5nZWROb2Rlc1tub2RlUGF0aF0ucmVtb3RlLmNvbnRlbnRUeXBlID0gbWV0YVtub2RlUGF0aF1bJ0NvbnRlbnQtVHlwZSddO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoY2hhbmdlZE5vZGVzW25vZGVQYXRoXSAmJiBtZXRhW25vZGVQYXRoXVsnQ29udGVudC1MZW5ndGgnXSkge1xuICAgICAgICAgICAgICBjaGFuZ2VkTm9kZXNbbm9kZVBhdGhdLnJlbW90ZS5jb250ZW50TGVuZ3RoID0gbWV0YVtub2RlUGF0aF1bJ0NvbnRlbnQtTGVuZ3RoJ107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIGlmIChtaXNzaW5nQ2hpbGRyZW5bbm9kZVBhdGguc3Vic3RyaW5nKHBhdGgubGVuZ3RoKV0gJiYgbm9kZSAmJiBub2RlLmNvbW1vbikge1xuICAgICAgICAgICAgaWYgKG5vZGUuY29tbW9uLml0ZW1zTWFwKSB7XG4gICAgICAgICAgICAgIGZvciAodmFyIGNvbW1vbkl0ZW0gaW4gbm9kZS5jb21tb24uaXRlbXNNYXApIHtcbiAgICAgICAgICAgICAgICByZWN1cnNlW25vZGVQYXRoK2NvbW1vbkl0ZW1dID0gdHJ1ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAobm9kZS5sb2NhbCAmJiBub2RlLmxvY2FsLml0ZW1zTWFwKSB7XG4gICAgICAgICAgICAgIGZvciAodmFyIGxvY2FsSXRlbSBpbiBub2RlLmxvY2FsLml0ZW1zTWFwKSB7XG4gICAgICAgICAgICAgICAgcmVjdXJzZVtub2RlUGF0aCtsb2NhbEl0ZW1dID0gdHJ1ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAobm9kZS5yZW1vdGUgfHwgaXNGb2xkZXIobm9kZVBhdGgpKSB7XG4gICAgICAgICAgICAgIGNoYW5nZWROb2Rlc1tub2RlUGF0aF0gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBjaGFuZ2VkTm9kZXNbbm9kZVBhdGhdID0gdGhpcy5hdXRvTWVyZ2Uobm9kZSk7XG5cbiAgICAgICAgICAgICAgaWYgKHR5cGVvZiBjaGFuZ2VkTm9kZXNbbm9kZVBhdGhdID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIHZhciBwYXJlbnRQYXRoID0gdGhpcy5nZXRQYXJlbnRQYXRoKG5vZGVQYXRoKTtcbiAgICAgICAgICAgICAgICB2YXIgcGFyZW50Tm9kZSA9IGNoYW5nZWROb2Rlc1twYXJlbnRQYXRoXTtcbiAgICAgICAgICAgICAgICB2YXIgaXRlbU5hbWUgPSBub2RlUGF0aC5zdWJzdHJpbmcocGF0aC5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIGlmIChwYXJlbnROb2RlICYmIHBhcmVudE5vZGUubG9jYWwpIHtcbiAgICAgICAgICAgICAgICAgIGRlbGV0ZSBwYXJlbnROb2RlLmxvY2FsLml0ZW1zTWFwW2l0ZW1OYW1lXTtcblxuICAgICAgICAgICAgICAgICAgaWYgKGVxdWFsKHBhcmVudE5vZGUubG9jYWwuaXRlbXNNYXAsIHBhcmVudE5vZGUuY29tbW9uLml0ZW1zTWFwKSkge1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgcGFyZW50Tm9kZS5sb2NhbDtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5kZWxldGVSZW1vdGVUcmVlcyhPYmplY3Qua2V5cyhyZWN1cnNlKSwgY2hhbmdlZE5vZGVzKS50aGVuKGZ1bmN0aW9uIChjaGFuZ2VkT2JqczIpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5sb2NhbC5zZXROb2Rlcyh0aGlzLmZsdXNoKGNoYW5nZWRPYmpzMikpO1xuICAgICAgICB9LmJpbmQodGhpcykpO1xuICAgICAgfS5iaW5kKHRoaXMpKTtcbiAgICB9LFxuXG4gICAgZGVsZXRlUmVtb3RlVHJlZXM6IGZ1bmN0aW9uIChwYXRocywgY2hhbmdlZE5vZGVzKSB7XG4gICAgICBpZiAocGF0aHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoY2hhbmdlZE5vZGVzKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMubG9jYWwuZ2V0Tm9kZXMocGF0aHMpLnRoZW4oZnVuY3Rpb24gKG5vZGVzKSB7XG4gICAgICAgIHZhciBzdWJQYXRocyA9IHt9O1xuXG4gICAgICAgIGNvbGxlY3RTdWJQYXRocyA9IGZ1bmN0aW9uIChmb2xkZXIsIHBhdGgpIHtcbiAgICAgICAgICBpZiAoZm9sZGVyICYmIGZvbGRlci5pdGVtc01hcCkge1xuICAgICAgICAgICAgZm9yICh2YXIgaXRlbU5hbWUgaW4gZm9sZGVyLml0ZW1zTWFwKSB7XG4gICAgICAgICAgICAgIHN1YlBhdGhzW3BhdGgraXRlbU5hbWVdID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgZm9yICh2YXIgcGF0aCBpbiBub2Rlcykge1xuICAgICAgICAgIHZhciBub2RlID0gbm9kZXNbcGF0aF07XG5cbiAgICAgICAgICAvLyBUT0RPIFdoeSBjaGVjayBmb3IgdGhlIG5vZGUgaGVyZT8gSSBkb24ndCB0aGluayB0aGlzIGNoZWNrIGV2ZXIgYXBwbGllc1xuICAgICAgICAgIGlmICghbm9kZSkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGlzRm9sZGVyKHBhdGgpKSB7XG4gICAgICAgICAgICBjb2xsZWN0U3ViUGF0aHMobm9kZS5jb21tb24sIHBhdGgpO1xuICAgICAgICAgICAgY29sbGVjdFN1YlBhdGhzKG5vZGUubG9jYWwsIHBhdGgpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAobm9kZS5jb21tb24gJiYgdHlwZW9mKG5vZGUuY29tbW9uLmJvZHkpICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgY2hhbmdlZE5vZGVzW3BhdGhdID0gZGVlcENsb25lKG5vZGUpO1xuICAgICAgICAgICAgICBjaGFuZ2VkTm9kZXNbcGF0aF0ucmVtb3RlID0ge1xuICAgICAgICAgICAgICAgIGJvZHk6ICAgICAgZmFsc2UsXG4gICAgICAgICAgICAgICAgdGltZXN0YW1wOiB0aGlzLm5vdygpXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIGNoYW5nZWROb2Rlc1twYXRoXSA9IHRoaXMuYXV0b01lcmdlKGNoYW5nZWROb2Rlc1twYXRoXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gUmVjdXJzZSB3aG9sZSB0cmVlIGRlcHRoIGxldmVscyBhdCBvbmNlOlxuICAgICAgICByZXR1cm4gdGhpcy5kZWxldGVSZW1vdGVUcmVlcyhPYmplY3Qua2V5cyhzdWJQYXRocyksIGNoYW5nZWROb2RlcykudGhlbihmdW5jdGlvbiAoY2hhbmdlZE5vZGVzMikge1xuICAgICAgICAgIHJldHVybiB0aGlzLmxvY2FsLnNldE5vZGVzKHRoaXMuZmx1c2goY2hhbmdlZE5vZGVzMikpO1xuICAgICAgICB9LmJpbmQodGhpcykpO1xuICAgICAgfS5iaW5kKHRoaXMpKTtcbiAgICB9LFxuXG4gICAgY29tcGxldGVGZXRjaDogZnVuY3Rpb24gKHBhdGgsIGJvZHlPckl0ZW1zTWFwLCBjb250ZW50VHlwZSwgcmV2aXNpb24pIHtcbiAgICAgIHZhciBwYXRocztcbiAgICAgIHZhciBwYXJlbnRQYXRoO1xuICAgICAgdmFyIHBhdGhzRnJvbVJvb3RBcnIgPSBwYXRoc0Zyb21Sb290KHBhdGgpO1xuXG4gICAgICBpZiAoaXNGb2xkZXIocGF0aCkpIHtcbiAgICAgICAgcGF0aHMgPSBbcGF0aF07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwYXJlbnRQYXRoID0gcGF0aHNGcm9tUm9vdEFyclsxXTtcbiAgICAgICAgcGF0aHMgPSBbcGF0aCwgcGFyZW50UGF0aF07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLmxvY2FsLmdldE5vZGVzKHBhdGhzKS50aGVuKGZ1bmN0aW9uIChub2Rlcykge1xuICAgICAgICB2YXIgaXRlbU5hbWU7XG4gICAgICAgIHZhciBtaXNzaW5nQ2hpbGRyZW4gPSB7fTtcbiAgICAgICAgdmFyIG5vZGUgPSBub2Rlc1twYXRoXTtcbiAgICAgICAgdmFyIHBhcmVudE5vZGU7XG5cbiAgICAgICAgdmFyIGNvbGxlY3RNaXNzaW5nQ2hpbGRyZW4gPSBmdW5jdGlvbiAoZm9sZGVyKSB7XG4gICAgICAgICAgaWYgKGZvbGRlciAmJiBmb2xkZXIuaXRlbXNNYXApIHtcbiAgICAgICAgICAgIGZvciAodmFyIGl0ZW1OYW1lIGluIGZvbGRlci5pdGVtc01hcCkge1xuICAgICAgICAgICAgICBpZiAoIWJvZHlPckl0ZW1zTWFwW2l0ZW1OYW1lXSkge1xuICAgICAgICAgICAgICAgIG1pc3NpbmdDaGlsZHJlbltpdGVtTmFtZV0gPSB0cnVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIGlmICh0eXBlb2Yobm9kZSkgIT09ICdvYmplY3QnICB8fCBub2RlLnBhdGggIT09IHBhdGggfHxcbiAgICAgICAgICAgIHR5cGVvZihub2RlLmNvbW1vbikgIT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgbm9kZSA9IHtcbiAgICAgICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgICAgICBjb21tb246IHt9XG4gICAgICAgICAgfTtcbiAgICAgICAgICBub2Rlc1twYXRoXSA9IG5vZGU7XG4gICAgICAgIH1cblxuICAgICAgICBub2RlLnJlbW90ZSA9IHtcbiAgICAgICAgICByZXZpc2lvbjogcmV2aXNpb24sXG4gICAgICAgICAgdGltZXN0YW1wOiB0aGlzLm5vdygpXG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKGlzRm9sZGVyKHBhdGgpKSB7XG4gICAgICAgICAgY29sbGVjdE1pc3NpbmdDaGlsZHJlbihub2RlLmNvbW1vbik7XG4gICAgICAgICAgY29sbGVjdE1pc3NpbmdDaGlsZHJlbihub2RlLnJlbW90ZSk7XG5cbiAgICAgICAgICBub2RlLnJlbW90ZS5pdGVtc01hcCA9IHt9O1xuICAgICAgICAgIGZvciAoaXRlbU5hbWUgaW4gYm9keU9ySXRlbXNNYXApIHtcbiAgICAgICAgICAgIG5vZGUucmVtb3RlLml0ZW1zTWFwW2l0ZW1OYW1lXSA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5vZGUucmVtb3RlLmJvZHkgPSBib2R5T3JJdGVtc01hcDtcbiAgICAgICAgICBub2RlLnJlbW90ZS5jb250ZW50VHlwZSA9IGNvbnRlbnRUeXBlO1xuXG4gICAgICAgICAgcGFyZW50Tm9kZSA9IG5vZGVzW3BhcmVudFBhdGhdO1xuICAgICAgICAgIGlmIChwYXJlbnROb2RlICYmIHBhcmVudE5vZGUubG9jYWwgJiYgcGFyZW50Tm9kZS5sb2NhbC5pdGVtc01hcCkge1xuICAgICAgICAgICAgaXRlbU5hbWUgPSBwYXRoLnN1YnN0cmluZyhwYXJlbnRQYXRoLmxlbmd0aCk7XG4gICAgICAgICAgICBwYXJlbnROb2RlLmxvY2FsLml0ZW1zTWFwW2l0ZW1OYW1lXSA9IHRydWU7XG4gICAgICAgICAgICBpZiAoZXF1YWwocGFyZW50Tm9kZS5sb2NhbC5pdGVtc01hcCwgcGFyZW50Tm9kZS5jb21tb24uaXRlbXNNYXApKSB7XG4gICAgICAgICAgICAgIGRlbGV0ZSBwYXJlbnROb2RlLmxvY2FsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIG5vZGVzW3BhdGhdID0gdGhpcy5hdXRvTWVyZ2Uobm9kZSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdG9CZVNhdmVkOiAgICAgICBub2RlcyxcbiAgICAgICAgICBtaXNzaW5nQ2hpbGRyZW46IG1pc3NpbmdDaGlsZHJlblxuICAgICAgICB9O1xuICAgICAgfS5iaW5kKHRoaXMpKTtcbiAgICB9LFxuXG4gICAgY29tcGxldGVQdXNoOiBmdW5jdGlvbiAocGF0aCwgYWN0aW9uLCBjb25mbGljdCwgcmV2aXNpb24pIHtcbiAgICAgIHJldHVybiB0aGlzLmxvY2FsLmdldE5vZGVzKFtwYXRoXSkudGhlbihmdW5jdGlvbiAobm9kZXMpIHtcbiAgICAgICAgdmFyIG5vZGUgPSBub2Rlc1twYXRoXTtcblxuICAgICAgICBpZiAoIW5vZGUucHVzaCkge1xuICAgICAgICAgIHRoaXMuc3RvcHBlZCA9IHRydWU7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdjb21wbGV0ZVB1c2ggY2FsbGVkIGJ1dCBubyBwdXNoIHZlcnNpb24hJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY29uZmxpY3QpIHtcbiAgICAgICAgICBsb2coJ1tTeW5jXSBXZSBoYXZlIGEgY29uZmxpY3QnKTtcblxuICAgICAgICAgIGlmICghbm9kZS5yZW1vdGUgfHwgbm9kZS5yZW1vdGUucmV2aXNpb24gIT09IHJldmlzaW9uKSB7XG4gICAgICAgICAgICBub2RlLnJlbW90ZSA9IHtcbiAgICAgICAgICAgICAgcmV2aXNpb246ICByZXZpc2lvbiB8fCAnY29uZmxpY3QnLFxuICAgICAgICAgICAgICB0aW1lc3RhbXA6IHRoaXMubm93KClcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBkZWxldGUgbm9kZS5wdXNoO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIG5vZGVzW3BhdGhdID0gdGhpcy5hdXRvTWVyZ2Uobm9kZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbm9kZS5jb21tb24gPSB7XG4gICAgICAgICAgICByZXZpc2lvbjogIHJldmlzaW9uLFxuICAgICAgICAgICAgdGltZXN0YW1wOiB0aGlzLm5vdygpXG4gICAgICAgICAgfTtcblxuICAgICAgICAgIGlmIChhY3Rpb24gPT09ICdwdXQnKSB7XG4gICAgICAgICAgICBub2RlLmNvbW1vbi5ib2R5ID0gbm9kZS5wdXNoLmJvZHk7XG4gICAgICAgICAgICBub2RlLmNvbW1vbi5jb250ZW50VHlwZSA9IG5vZGUucHVzaC5jb250ZW50VHlwZTtcblxuICAgICAgICAgICAgaWYgKGVxdWFsKG5vZGUubG9jYWwuYm9keSwgbm9kZS5wdXNoLmJvZHkpICYmXG4gICAgICAgICAgICAgICAgbm9kZS5sb2NhbC5jb250ZW50VHlwZSA9PT0gbm9kZS5wdXNoLmNvbnRlbnRUeXBlKSB7XG4gICAgICAgICAgICAgIGRlbGV0ZSBub2RlLmxvY2FsO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBkZWxldGUgbm9kZS5wdXNoO1xuICAgICAgICAgIH0gZWxzZSBpZiAoYWN0aW9uID09PSAnZGVsZXRlJykge1xuICAgICAgICAgICAgaWYgKG5vZGUubG9jYWwuYm9keSA9PT0gZmFsc2UpIHsgLy8gTm8gbmV3IGxvY2FsIGNoYW5nZXMgc2luY2UgcHVzaDsgZmx1c2ggaXQuXG4gICAgICAgICAgICAgIG5vZGVzW3BhdGhdID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgZGVsZXRlIG5vZGUucHVzaDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5sb2NhbC5zZXROb2Rlcyh0aGlzLmZsdXNoKG5vZGVzKSk7XG4gICAgICB9LmJpbmQodGhpcykpO1xuICAgIH0sXG5cbiAgICBkZWFsV2l0aEZhaWx1cmU6IGZ1bmN0aW9uIChwYXRoLCBhY3Rpb24sIHN0YXR1c01lYW5pbmcpIHtcblxuICAgICAgcmV0dXJuIHRoaXMubG9jYWwuZ2V0Tm9kZXMoW3BhdGhdKS50aGVuKGZ1bmN0aW9uIChub2Rlcykge1xuICAgICAgICBpZiAobm9kZXNbcGF0aF0pIHtcbiAgICAgICAgICBkZWxldGUgbm9kZXNbcGF0aF0ucHVzaDtcbiAgICAgICAgICByZXR1cm4gdGhpcy5sb2NhbC5zZXROb2Rlcyh0aGlzLmZsdXNoKG5vZGVzKSk7XG4gICAgICAgIH1cbiAgICAgIH0uYmluZCh0aGlzKSk7XG4gICAgfSxcblxuICAgIGludGVycHJldFN0YXR1czogZnVuY3Rpb24gKHN0YXR1c0NvZGUpIHtcbiAgICAgIGlmIChzdGF0dXNDb2RlID09PSAnb2ZmbGluZScgfHwgc3RhdHVzQ29kZSA9PT0gJ3RpbWVvdXQnKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgc3VjY2Vzc2Z1bDogICAgICBmYWxzZSxcbiAgICAgICAgICBuZXR3b3JrUHJvYmxlbXM6IHRydWUsXG4gICAgICAgICAgc3RhdHVzQ29kZTogc3RhdHVzQ29kZVxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICB2YXIgc2VyaWVzID0gTWF0aC5mbG9vcihzdGF0dXNDb2RlIC8gMTAwKTtcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc3VjY2Vzc2Z1bDogKHNlcmllcyA9PT0gMiB8fCBzdGF0dXNDb2RlID09PSAzMDQgfHwgc3RhdHVzQ29kZSA9PT0gNDEyIHx8IHN0YXR1c0NvZGUgPT09IDQwNCksXG4gICAgICAgIGNvbmZsaWN0OiAgIChzdGF0dXNDb2RlID09PSA0MTIpLFxuICAgICAgICB1bkF1dGg6ICAgICAoKHN0YXR1c0NvZGUgPT09IDQwMSAmJiB0aGlzLnJlbW90ZS50b2tlbiAhPT0gQXV0aG9yaXplLklNUExJRURfRkFLRV9UT0tFTikgfHxcbiAgICAgICAgICAgICAgICAgICAgIHN0YXR1c0NvZGUgPT09IDQwMiB8fCBzdGF0dXNDb2RlID09PSA0MDMpLFxuICAgICAgICBub3RGb3VuZDogICAoc3RhdHVzQ29kZSA9PT0gNDA0KSxcbiAgICAgICAgY2hhbmdlZDogICAgKHN0YXR1c0NvZGUgIT09IDMwNCksXG4gICAgICAgIHN0YXR1c0NvZGU6IHN0YXR1c0NvZGVcbiAgICAgIH07XG4gICAgfSxcblxuICAgIGhhbmRsZUdldFJlc3BvbnNlOiBmdW5jdGlvbiAocGF0aCwgc3RhdHVzLCBib2R5T3JJdGVtc01hcCwgY29udGVudFR5cGUsIHJldmlzaW9uKSB7XG4gICAgICBpZiAoc3RhdHVzLm5vdEZvdW5kKSB7XG4gICAgICAgIGlmIChpc0ZvbGRlcihwYXRoKSkge1xuICAgICAgICAgIGJvZHlPckl0ZW1zTWFwID0ge307XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYm9keU9ySXRlbXNNYXAgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoc3RhdHVzLmNoYW5nZWQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcGxldGVGZXRjaChwYXRoLCBib2R5T3JJdGVtc01hcCwgY29udGVudFR5cGUsIHJldmlzaW9uKS50aGVuKGZ1bmN0aW9uIChkYXRhRnJvbUZldGNoKSB7XG4gICAgICAgICAgaWYgKGlzRm9sZGVyKHBhdGgpKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5jb3JydXB0U2VydmVySXRlbXNNYXAoYm9keU9ySXRlbXNNYXApKSB7XG4gICAgICAgICAgICAgIGxvZygnW1N5bmNdIFdBUk5JTkc6IERpc2NhcmRpbmcgY29ycnVwdCBmb2xkZXIgZGVzY3JpcHRpb24gZnJvbSBzZXJ2ZXIgZm9yICcgKyBwYXRoKTtcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubWFya0NoaWxkcmVuKHBhdGgsIGJvZHlPckl0ZW1zTWFwLCBkYXRhRnJvbUZldGNoLnRvQmVTYXZlZCwgZGF0YUZyb21GZXRjaC5taXNzaW5nQ2hpbGRyZW4pLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubG9jYWwuc2V0Tm9kZXModGhpcy5mbHVzaChkYXRhRnJvbUZldGNoLnRvQmVTYXZlZCkpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfS5iaW5kKHRoaXMpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0aGlzLnVwZGF0ZUNvbW1vblRpbWVzdGFtcChwYXRoLCByZXZpc2lvbikudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBoYW5kbGVSZXNwb25zZTogZnVuY3Rpb24gKHBhdGgsIGFjdGlvbiwgcikge1xuICAgICAgdmFyIHN0YXR1cyA9IHRoaXMuaW50ZXJwcmV0U3RhdHVzKHIuc3RhdHVzQ29kZSk7XG4gICAgICBpZiAoc3RhdHVzLnN1Y2Nlc3NmdWwpIHtcbiAgICAgICAgaWYgKGFjdGlvbiA9PT0gJ2dldCcpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5oYW5kbGVHZXRSZXNwb25zZShwYXRoLCBzdGF0dXMsIHIuYm9keSwgci5jb250ZW50VHlwZSwgci5yZXZpc2lvbik7XG4gICAgICAgIH0gZWxzZSBpZiAoYWN0aW9uID09PSAncHV0JyB8fCBhY3Rpb24gPT09ICdkZWxldGUnKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuY29tcGxldGVQdXNoKHBhdGgsIGFjdGlvbiwgc3RhdHVzLmNvbmZsaWN0LCByLnJldmlzaW9uKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignY2Fubm90IGhhbmRsZSByZXNwb25zZSBmb3IgdW5rbm93biBhY3Rpb24nLCBhY3Rpb24pO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgLy8gVW5zdWNjZXNzZnVsXG4gICAgICAgIHZhciBlcnJvcjtcbiAgICAgICAgaWYgKHN0YXR1cy51bkF1dGgpIHtcbiAgICAgICAgICBlcnJvciA9IG5ldyBBdXRob3JpemUuVW5hdXRob3JpemVkKCk7XG4gICAgICAgIH0gZWxzZSBpZiAoc3RhdHVzLm5ldHdvcmtQcm9ibGVtcykge1xuICAgICAgICAgIGVycm9yID0gbmV3IFN5bmMuU3luY0Vycm9yKCdOZXR3b3JrIHJlcXVlc3QgZmFpbGVkLicpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGVycm9yID0gbmV3IEVycm9yKCdIVFRQIHJlc3BvbnNlIGNvZGUgJyArIHN0YXR1cy5zdGF0dXNDb2RlICsgJyByZWNlaXZlZC4nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLmRlYWxXaXRoRmFpbHVyZShwYXRoLCBhY3Rpb24sIHN0YXR1cykudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdGhpcy5yZW1vdGVTdG9yYWdlLl9lbWl0KCdlcnJvcicsIGVycm9yKTtcbiAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIG51bVRocmVhZHM6IDEwLFxuXG4gICAgZmluaXNoVGFzazogZnVuY3Rpb24gKHRhc2spIHtcbiAgICAgIGlmICh0YXNrLmFjdGlvbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGRlbGV0ZSB0aGlzLl9ydW5uaW5nW3Rhc2sucGF0aF07XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgICAgcmV0dXJuIHRhc2sucHJvbWlzZS50aGVuKGZ1bmN0aW9uIChyKSB7XG4gICAgICAgIHJldHVybiBzZWxmLmhhbmRsZVJlc3BvbnNlKHRhc2sucGF0aCwgdGFzay5hY3Rpb24sIHIpO1xuICAgICAgfSwgZnVuY3Rpb24gKGVycikge1xuICAgICAgICBsb2coJ1tTeW5jXSB3aXJlY2xpZW50IHJlamVjdHMgaXRzIHByb21pc2UhJywgdGFzay5wYXRoLCB0YXNrLmFjdGlvbiwgZXJyKTtcbiAgICAgICAgcmV0dXJuIHNlbGYuaGFuZGxlUmVzcG9uc2UodGFzay5wYXRoLCB0YXNrLmFjdGlvbiwge3N0YXR1c0NvZGU6ICdvZmZsaW5lJ30pO1xuICAgICAgfSlcblxuICAgICAgLnRoZW4oZnVuY3Rpb24gKGNvbXBsZXRlZCkge1xuICAgICAgICBkZWxldGUgc2VsZi5fdGltZVN0YXJ0ZWRbdGFzay5wYXRoXTtcbiAgICAgICAgZGVsZXRlIHNlbGYuX3J1bm5pbmdbdGFzay5wYXRoXTtcblxuICAgICAgICBpZiAoY29tcGxldGVkKSB7XG4gICAgICAgICAgaWYgKHNlbGYuX3Rhc2tzW3Rhc2sucGF0aF0pIHtcbiAgICAgICAgICAgIGZvciAodmFyIGk9MDsgaTxzZWxmLl90YXNrc1t0YXNrLnBhdGhdLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgIHNlbGYuX3Rhc2tzW3Rhc2sucGF0aF1baV0oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRlbGV0ZSBzZWxmLl90YXNrc1t0YXNrLnBhdGhdO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHNlbGYuX2VtaXQoJ3JlcS1kb25lJyk7XG5cbiAgICAgICAgc2VsZi5jb2xsZWN0VGFza3MoZmFsc2UpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgIC8vIFNlZSBpZiB0aGVyZSBhcmUgYW55IG1vcmUgdGFza3MgdGhhdCBhcmUgbm90IHJlZnJlc2ggdGFza3NcbiAgICAgICAgICBpZiAoIXNlbGYuaGFzVGFza3MoKSB8fCBzZWxmLnN0b3BwZWQpIHtcbiAgICAgICAgICAgIGxvZygnW1N5bmNdIFN5bmMgaXMgZG9uZSEgUmVzY2hlZHVsZT8nLCBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhzZWxmLl90YXNrcykubGVuZ3RoLCBzZWxmLnN0b3BwZWQpO1xuICAgICAgICAgICAgaWYgKCFzZWxmLmRvbmUpIHtcbiAgICAgICAgICAgICAgc2VsZi5kb25lID0gdHJ1ZTtcbiAgICAgICAgICAgICAgc2VsZi5fZW1pdCgnZG9uZScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBVc2UgYSAxMG1zIHRpbWVvdXQgdG8gbGV0IHRoZSBKYXZhU2NyaXB0IHJ1bnRpbWUgY2F0Y2ggaXRzIGJyZWF0aFxuICAgICAgICAgICAgLy8gKGFuZCBob3BlZnVsbHkgZm9yY2UgYW4gSW5kZXhlZERCIGF1dG8tY29tbWl0PyksIGFuZCBhbHNvIHRvIGNhdXNlXG4gICAgICAgICAgICAvLyB0aGUgdGhyZWFkcyB0byBnZXQgc3RhZ2dlcmVkIGFuZCBnZXQgYSBnb29kIHNwcmVhZCBvdmVyIHRpbWU6XG4gICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgc2VsZi5kb1Rhc2tzKCk7XG4gICAgICAgICAgICB9LCAxMCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0sIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgbG9nKCdbU3luY10gRXJyb3InLCBlcnIpO1xuICAgICAgICBkZWxldGUgc2VsZi5fdGltZVN0YXJ0ZWRbdGFzay5wYXRoXTtcbiAgICAgICAgZGVsZXRlIHNlbGYuX3J1bm5pbmdbdGFzay5wYXRoXTtcbiAgICAgICAgc2VsZi5fZW1pdCgncmVxLWRvbmUnKTtcbiAgICAgICAgaWYgKCFzZWxmLmRvbmUpIHtcbiAgICAgICAgICBzZWxmLmRvbmUgPSB0cnVlO1xuICAgICAgICAgIHNlbGYuX2VtaXQoJ2RvbmUnKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSxcblxuICAgIGRvVGFza3M6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBudW1Ub0hhdmUsIG51bUFkZGVkID0gMCwgbnVtVG9BZGQsIHBhdGg7XG4gICAgICBpZiAodGhpcy5yZW1vdGUuY29ubmVjdGVkKSB7XG4gICAgICAgIGlmICh0aGlzLnJlbW90ZS5vbmxpbmUpIHtcbiAgICAgICAgICBudW1Ub0hhdmUgPSB0aGlzLm51bVRocmVhZHM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbnVtVG9IYXZlID0gMTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbnVtVG9IYXZlID0gMDtcbiAgICAgIH1cbiAgICAgIG51bVRvQWRkID0gbnVtVG9IYXZlIC0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModGhpcy5fcnVubmluZykubGVuZ3RoO1xuICAgICAgaWYgKG51bVRvQWRkIDw9IDApIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICBmb3IgKHBhdGggaW4gdGhpcy5fdGFza3MpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9ydW5uaW5nW3BhdGhdKSB7XG4gICAgICAgICAgdGhpcy5fdGltZVN0YXJ0ZWRbcGF0aF0gPSB0aGlzLm5vdygpO1xuICAgICAgICAgIHRoaXMuX3J1bm5pbmdbcGF0aF0gPSB0aGlzLmRvVGFzayhwYXRoKTtcbiAgICAgICAgICB0aGlzLl9ydW5uaW5nW3BhdGhdLnRoZW4odGhpcy5maW5pc2hUYXNrLmJpbmQodGhpcykpO1xuICAgICAgICAgIG51bUFkZGVkKys7XG4gICAgICAgICAgaWYgKG51bUFkZGVkID49IG51bVRvQWRkKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiAobnVtQWRkZWQgPj0gbnVtVG9BZGQpO1xuICAgIH0sXG5cbiAgICBjb2xsZWN0VGFza3M6IGZ1bmN0aW9uIChhbHNvQ2hlY2tSZWZyZXNoKSB7XG4gICAgICBpZiAodGhpcy5oYXNUYXNrcygpIHx8IHRoaXMuc3RvcHBlZCkge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLmNvbGxlY3REaWZmVGFza3MoKS50aGVuKGZ1bmN0aW9uIChudW1EaWZmcykge1xuICAgICAgICBpZiAobnVtRGlmZnMgfHwgYWxzb0NoZWNrUmVmcmVzaCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuY29sbGVjdFJlZnJlc2hUYXNrcygpO1xuICAgICAgICB9XG4gICAgICB9LmJpbmQodGhpcyksIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgfSk7XG4gICAgfSxcblxuICAgIGFkZFRhc2s6IGZ1bmN0aW9uIChwYXRoLCBjYikge1xuICAgICAgaWYgKCF0aGlzLl90YXNrc1twYXRoXSkge1xuICAgICAgICB0aGlzLl90YXNrc1twYXRoXSA9IFtdO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZihjYikgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhpcy5fdGFza3NbcGF0aF0ucHVzaChjYik7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1ldGhvZDogc3luY1xuICAgICAqKi9cbiAgICBzeW5jOiBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLmRvbmUgPSBmYWxzZTtcblxuICAgICAgaWYgKCF0aGlzLmRvVGFza3MoKSkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb2xsZWN0VGFza3MoKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhpcy5kb1Rhc2tzKCk7XG4gICAgICAgICAgfSBjYXRjaChlKSB7XG4gICAgICAgICAgICBsb2coJ1tTeW5jXSBkb1Rhc2tzIGVycm9yJywgZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9LmJpbmQodGhpcyksIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgbG9nKCdbU3luY10gU3luYyBlcnJvcicsIGUpO1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTG9jYWwgY2FjaGUgdW5hdmFpbGFibGUnKTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgICB9XG4gICAgfSxcbiAgfTtcblxuXG5cbiAgdmFyIHN5bmNDeWNsZUNiLCBzeW5jT25Db25uZWN0O1xuICBTeW5jLl9yc19pbml0ID0gZnVuY3Rpb24gKHJlbW90ZVN0b3JhZ2UpIHtcblxuICAgIHN5bmNDeWNsZUNiID0gZnVuY3Rpb24gKCkge1xuICAgICAgLy8gaWYgKCFjb25maWcuY2FjaGUpIHJldHVybiBmYWxzZVxuICAgICAgbG9nKCdbU3luY10gc3luY0N5Y2xlQ2IgY2FsbGluZyBzeW5jQ3ljbGUnKTtcbiAgICAgIGlmIChFbnYuaXNCcm93c2VyKCkpIHtcbiAgICAgICAgaGFuZGxlVmlzaWJpbGl0eS5iaW5kKHJlbW90ZVN0b3JhZ2UpKCk7XG4gICAgICB9XG5cblxuICAgICAgaWYgKCFyZW1vdGVTdG9yYWdlLnN5bmMpIHtcbiAgICAgICAgLy8gQ2FsbCB0aGlzIG5vdyB0aGF0IGFsbCBvdGhlciBtb2R1bGVzIGFyZSBhbHNvIHJlYWR5OlxuICAgICAgICByZW1vdGVTdG9yYWdlLnN5bmMgPSBuZXcgU3luYyhyZW1vdGVTdG9yYWdlLFxuICAgICAgICAgICAgcmVtb3RlU3RvcmFnZS5sb2NhbCwgcmVtb3RlU3RvcmFnZS5yZW1vdGUsIHJlbW90ZVN0b3JhZ2UuYWNjZXNzLFxuICAgICAgICAgICAgcmVtb3RlU3RvcmFnZS5jYWNoaW5nKTtcblxuICAgICAgICBpZiAocmVtb3RlU3RvcmFnZS5zeW5jU3RvcHBlZCkge1xuICAgICAgICAgIGxvZygnW1N5bmNdIEluc3RhbnRpYXRpbmcgc3luYyBzdG9wcGVkJyk7XG4gICAgICAgICAgcmVtb3RlU3RvcmFnZS5zeW5jLnN0b3BwZWQgPSB0cnVlO1xuICAgICAgICAgIGRlbGV0ZSByZW1vdGVTdG9yYWdlLnN5bmNTdG9wcGVkO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGxvZygnW1N5bmNdIHN5bmNDeWNsZUNiIGNhbGxpbmcgc3luY0N5Y2xlJyk7XG4gICAgICByZW1vdGVTdG9yYWdlLnN5bmNDeWNsZSgpO1xuICAgIH07XG5cbiAgICBzeW5jT25Db25uZWN0ID0gZnVuY3Rpb24oKSB7XG4gICAgICByZW1vdGVTdG9yYWdlLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2Nvbm5lY3RlZCcsIHN5bmNPbkNvbm5lY3QpO1xuICAgICAgcmVtb3RlU3RvcmFnZS5zdGFydFN5bmMoKTtcbiAgICB9O1xuXG4gICAgcmVtb3RlU3RvcmFnZS5vbigncmVhZHknLCBzeW5jQ3ljbGVDYik7XG4gICAgcmVtb3RlU3RvcmFnZS5vbignY29ubmVjdGVkJywgc3luY09uQ29ubmVjdCk7XG4gIH07XG5cbiAgU3luYy5fcnNfY2xlYW51cCA9IGZ1bmN0aW9uIChyZW1vdGVTdG9yYWdlKSB7XG4gICAgcmVtb3RlU3RvcmFnZS5zdG9wU3luYygpO1xuICAgIHJlbW90ZVN0b3JhZ2UucmVtb3ZlRXZlbnRMaXN0ZW5lcigncmVhZHknLCBzeW5jQ3ljbGVDYik7XG4gICAgcmVtb3RlU3RvcmFnZS5yZW1vdmVFdmVudExpc3RlbmVyKCdjb25uZWN0ZWQnLCBzeW5jT25Db25uZWN0KTtcblxuICAgIHJlbW90ZVN0b3JhZ2Uuc3luYyA9IHVuZGVmaW5lZFxuICAgIGRlbGV0ZSByZW1vdGVTdG9yYWdlLnN5bmM7XG4gIH07XG5cbiAgXG4gIHZhciBTeW5jRXJyb3IgPSBmdW5jdGlvbiAob3JpZ2luYWxFcnJvcikge1xuICAgIHZhciBtc2cgPSAnU3luYyBmYWlsZWQ6ICc7XG4gICAgaWYgKHR5cGVvZihvcmlnaW5hbEVycm9yKSA9PT0gJ29iamVjdCcgJiYgJ21lc3NhZ2UnIGluIG9yaWdpbmFsRXJyb3IpIHtcbiAgICAgIG1zZyArPSBvcmlnaW5hbEVycm9yLm1lc3NhZ2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIG1zZyArPSBvcmlnaW5hbEVycm9yO1xuICAgIH1cbiAgICB0aGlzLm9yaWdpbmFsRXJyb3IgPSBvcmlnaW5hbEVycm9yO1xuICAgIHRoaXMubWVzc2FnZSA9IG1zZztcbiAgfTtcblxuICBTeW5jRXJyb3IucHJvdG90eXBlID0gbmV3IEVycm9yKCk7XG4gIFN5bmNFcnJvci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBTeW5jRXJyb3I7XG5cbiAgU3luYy5TeW5jRXJyb3IgPSBTeW5jRXJyb3I7XG5cbiAgbW9kdWxlLmV4cG9ydHMgPSBTeW5jO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL3N5bmMuanMiXSwic291cmNlUm9vdCI6IiJ9");

/***/ },
/* 18 */
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';\n\nvar eventHandling = __webpack_require__(3);\n\nvar mode = typeof window !== 'undefined' ? 'browser' : 'node',\n    env = {},\n    isBackground = false;\n\nvar Env = function Env() {\n  return env;\n};\n\nEnv.isBrowser = function () {\n  return mode === \"browser\";\n};\n\nEnv.isNode = function () {\n  return mode === \"node\";\n};\n\nEnv.goBackground = function () {\n  isBackground = true;\n  Env._emit(\"background\");\n};\n\nEnv.goForeground = function () {\n  isBackground = false;\n  Env._emit(\"foreground\");\n};\n\nEnv._rs_init = function (remoteStorage) {\n  eventHandling(Env, \"background\", \"foreground\");\n\n  function visibility() {\n    if (document[env.hiddenProperty]) {\n      Env.goBackground();\n    } else {\n      Env.goForeground();\n    }\n  }\n\n  if (mode === 'browser') {\n    if (typeof document.hidden !== \"undefined\") {\n      env.hiddenProperty = \"hidden\";\n      env.visibilityChangeEvent = \"visibilitychange\";\n    } else if (typeof document.mozHidden !== \"undefined\") {\n      env.hiddenProperty = \"mozHidden\";\n      env.visibilityChangeEvent = \"mozvisibilitychange\";\n    } else if (typeof document.msHidden !== \"undefined\") {\n      env.hiddenProperty = \"msHidden\";\n      env.visibilityChangeEvent = \"msvisibilitychange\";\n    } else if (typeof document.webkitHidden !== \"undefined\") {\n      env.hiddenProperty = \"webkitHidden\";\n      env.visibilityChangeEvent = \"webkitvisibilitychange\";\n    }\n    document.addEventListener(env.visibilityChangeEvent, visibility, false);\n    visibility();\n  }\n};\n\nEnv._rs_cleanup = function (remoteStorage) {};\n\nmodule.exports = Env;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvZW52LmpzP2M5OWIiXSwibmFtZXMiOlsiZXZlbnRIYW5kbGluZyIsInJlcXVpcmUiLCJtb2RlIiwid2luZG93IiwiZW52IiwiaXNCYWNrZ3JvdW5kIiwiRW52IiwiaXNCcm93c2VyIiwiaXNOb2RlIiwiZ29CYWNrZ3JvdW5kIiwiX2VtaXQiLCJnb0ZvcmVncm91bmQiLCJfcnNfaW5pdCIsInJlbW90ZVN0b3JhZ2UiLCJ2aXNpYmlsaXR5IiwiZG9jdW1lbnQiLCJoaWRkZW5Qcm9wZXJ0eSIsImhpZGRlbiIsInZpc2liaWxpdHlDaGFuZ2VFdmVudCIsIm1vekhpZGRlbiIsIm1zSGlkZGVuIiwid2Via2l0SGlkZGVuIiwiYWRkRXZlbnRMaXN0ZW5lciIsIl9yc19jbGVhbnVwIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJtYXBwaW5ncyI6Ijs7QUFBRSxJQUFJQSxnQkFBZ0IsbUJBQUFDLENBQVEsQ0FBUixDQUFwQjs7QUFFQSxJQUFJQyxPQUFPLE9BQU9DLE1BQVAsS0FBbUIsV0FBbkIsR0FBaUMsU0FBakMsR0FBNkMsTUFBeEQ7QUFBQSxJQUNJQyxNQUFNLEVBRFY7QUFBQSxJQUVJQyxlQUFlLEtBRm5COztBQUtBLElBQUlDLE1BQU0sU0FBTkEsR0FBTSxHQUFZO0FBQ3BCLFNBQU9GLEdBQVA7QUFDRCxDQUZEOztBQUlBRSxJQUFJQyxTQUFKLEdBQWdCLFlBQVk7QUFDMUIsU0FBT0wsU0FBUyxTQUFoQjtBQUNELENBRkQ7O0FBSUFJLElBQUlFLE1BQUosR0FBYSxZQUFZO0FBQ3ZCLFNBQU9OLFNBQVMsTUFBaEI7QUFDRCxDQUZEOztBQUlBSSxJQUFJRyxZQUFKLEdBQW1CLFlBQVk7QUFDN0JKLGlCQUFlLElBQWY7QUFDQUMsTUFBSUksS0FBSixDQUFVLFlBQVY7QUFDRCxDQUhEOztBQUtBSixJQUFJSyxZQUFKLEdBQW1CLFlBQVk7QUFDN0JOLGlCQUFlLEtBQWY7QUFDQUMsTUFBSUksS0FBSixDQUFVLFlBQVY7QUFDRCxDQUhEOztBQUtBSixJQUFJTSxRQUFKLEdBQWUsVUFBVUMsYUFBVixFQUF5QjtBQUN0Q2IsZ0JBQWNNLEdBQWQsRUFBbUIsWUFBbkIsRUFBaUMsWUFBakM7O0FBRUEsV0FBU1EsVUFBVCxHQUFzQjtBQUNwQixRQUFJQyxTQUFTWCxJQUFJWSxjQUFiLENBQUosRUFBa0M7QUFDaENWLFVBQUlHLFlBQUo7QUFDRCxLQUZELE1BRU87QUFDTEgsVUFBSUssWUFBSjtBQUNEO0FBQ0Y7O0FBRUQsTUFBS1QsU0FBUyxTQUFkLEVBQXlCO0FBQ3ZCLFFBQUssT0FBT2EsU0FBU0UsTUFBaEIsS0FBNEIsV0FBakMsRUFBK0M7QUFDN0NiLFVBQUlZLGNBQUosR0FBcUIsUUFBckI7QUFDQVosVUFBSWMscUJBQUosR0FBNEIsa0JBQTVCO0FBQ0QsS0FIRCxNQUdPLElBQUssT0FBT0gsU0FBU0ksU0FBaEIsS0FBK0IsV0FBcEMsRUFBa0Q7QUFDdkRmLFVBQUlZLGNBQUosR0FBcUIsV0FBckI7QUFDQVosVUFBSWMscUJBQUosR0FBNEIscUJBQTVCO0FBQ0QsS0FITSxNQUdBLElBQUssT0FBT0gsU0FBU0ssUUFBaEIsS0FBOEIsV0FBbkMsRUFBaUQ7QUFDdERoQixVQUFJWSxjQUFKLEdBQXFCLFVBQXJCO0FBQ0FaLFVBQUljLHFCQUFKLEdBQTRCLG9CQUE1QjtBQUNELEtBSE0sTUFHQSxJQUFLLE9BQU9ILFNBQVNNLFlBQWhCLEtBQWtDLFdBQXZDLEVBQXFEO0FBQzFEakIsVUFBSVksY0FBSixHQUFxQixjQUFyQjtBQUNBWixVQUFJYyxxQkFBSixHQUE0Qix3QkFBNUI7QUFDRDtBQUNESCxhQUFTTyxnQkFBVCxDQUEwQmxCLElBQUljLHFCQUE5QixFQUFxREosVUFBckQsRUFBaUUsS0FBakU7QUFDQUE7QUFDRDtBQUNGLENBNUJEOztBQThCQVIsSUFBSWlCLFdBQUosR0FBa0IsVUFBVVYsYUFBVixFQUF5QixDQUMxQyxDQUREOztBQUlBVyxPQUFPQyxPQUFQLEdBQWlCbkIsR0FBakIiLCJmaWxlIjoiMTguanMiLCJzb3VyY2VzQ29udGVudCI6WyIgIHZhciBldmVudEhhbmRsaW5nID0gcmVxdWlyZSgnLi9ldmVudGhhbmRsaW5nJyk7XG4gIFxuICB2YXIgbW9kZSA9IHR5cGVvZih3aW5kb3cpICE9PSAndW5kZWZpbmVkJyA/ICdicm93c2VyJyA6ICdub2RlJyxcbiAgICAgIGVudiA9IHt9LFxuICAgICAgaXNCYWNrZ3JvdW5kID0gZmFsc2U7XG5cblxuICB2YXIgRW52ID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBlbnY7XG4gIH07XG5cbiAgRW52LmlzQnJvd3NlciA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gbW9kZSA9PT0gXCJicm93c2VyXCI7XG4gIH07XG5cbiAgRW52LmlzTm9kZSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gbW9kZSA9PT0gXCJub2RlXCI7XG4gIH07XG5cbiAgRW52LmdvQmFja2dyb3VuZCA9IGZ1bmN0aW9uICgpIHtcbiAgICBpc0JhY2tncm91bmQgPSB0cnVlO1xuICAgIEVudi5fZW1pdChcImJhY2tncm91bmRcIik7XG4gIH07XG5cbiAgRW52LmdvRm9yZWdyb3VuZCA9IGZ1bmN0aW9uICgpIHtcbiAgICBpc0JhY2tncm91bmQgPSBmYWxzZTtcbiAgICBFbnYuX2VtaXQoXCJmb3JlZ3JvdW5kXCIpO1xuICB9O1xuXG4gIEVudi5fcnNfaW5pdCA9IGZ1bmN0aW9uIChyZW1vdGVTdG9yYWdlKSB7XG4gICAgZXZlbnRIYW5kbGluZyhFbnYsIFwiYmFja2dyb3VuZFwiLCBcImZvcmVncm91bmRcIik7XG5cbiAgICBmdW5jdGlvbiB2aXNpYmlsaXR5KCkge1xuICAgICAgaWYgKGRvY3VtZW50W2Vudi5oaWRkZW5Qcm9wZXJ0eV0pIHtcbiAgICAgICAgRW52LmdvQmFja2dyb3VuZCgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgRW52LmdvRm9yZWdyb3VuZCgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICggbW9kZSA9PT0gJ2Jyb3dzZXInKSB7XG4gICAgICBpZiAoIHR5cGVvZihkb2N1bWVudC5oaWRkZW4pICE9PSBcInVuZGVmaW5lZFwiICkge1xuICAgICAgICBlbnYuaGlkZGVuUHJvcGVydHkgPSBcImhpZGRlblwiO1xuICAgICAgICBlbnYudmlzaWJpbGl0eUNoYW5nZUV2ZW50ID0gXCJ2aXNpYmlsaXR5Y2hhbmdlXCI7XG4gICAgICB9IGVsc2UgaWYgKCB0eXBlb2YoZG9jdW1lbnQubW96SGlkZGVuKSAhPT0gXCJ1bmRlZmluZWRcIiApIHtcbiAgICAgICAgZW52LmhpZGRlblByb3BlcnR5ID0gXCJtb3pIaWRkZW5cIjtcbiAgICAgICAgZW52LnZpc2liaWxpdHlDaGFuZ2VFdmVudCA9IFwibW96dmlzaWJpbGl0eWNoYW5nZVwiO1xuICAgICAgfSBlbHNlIGlmICggdHlwZW9mKGRvY3VtZW50Lm1zSGlkZGVuKSAhPT0gXCJ1bmRlZmluZWRcIiApIHtcbiAgICAgICAgZW52LmhpZGRlblByb3BlcnR5ID0gXCJtc0hpZGRlblwiO1xuICAgICAgICBlbnYudmlzaWJpbGl0eUNoYW5nZUV2ZW50ID0gXCJtc3Zpc2liaWxpdHljaGFuZ2VcIjtcbiAgICAgIH0gZWxzZSBpZiAoIHR5cGVvZihkb2N1bWVudC53ZWJraXRIaWRkZW4pICE9PSBcInVuZGVmaW5lZFwiICkge1xuICAgICAgICBlbnYuaGlkZGVuUHJvcGVydHkgPSBcIndlYmtpdEhpZGRlblwiO1xuICAgICAgICBlbnYudmlzaWJpbGl0eUNoYW5nZUV2ZW50ID0gXCJ3ZWJraXR2aXNpYmlsaXR5Y2hhbmdlXCI7XG4gICAgICB9XG4gICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKGVudi52aXNpYmlsaXR5Q2hhbmdlRXZlbnQsIHZpc2liaWxpdHksIGZhbHNlKTtcbiAgICAgIHZpc2liaWxpdHkoKTtcbiAgICB9XG4gIH07XG5cbiAgRW52Ll9yc19jbGVhbnVwID0gZnVuY3Rpb24gKHJlbW90ZVN0b3JhZ2UpIHtcbiAgfTtcblxuXG4gIG1vZHVsZS5leHBvcnRzID0gRW52O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2Vudi5qcyJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ },
/* 19 */
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\n/**\n * Class: RemoteStorage.GoogleDrive\n *\n * WORK IN PROGRESS, NOT RECOMMENDED FOR PRODUCTION USE\n *\n * To use this backend, you need to specify the app's client ID like so:\n *\n * (start code)\n *\n * remoteStorage.setApiKeys('googledrive', {\n *   clientId: 'your-client-id'\n * });\n *\n * (end code)\n *\n * An client ID can be obtained by registering your app in the Google\n * Developers Console: https://developers.google.com/drive/web/auth/web-client\n *\n * Docs: https://developers.google.com/drive/web/auth/web-client#create_a_client_id_and_client_secret\n **/\n\nvar Authorize = __webpack_require__(7);\nvar WireClient = __webpack_require__(12);\nvar eventHandling = __webpack_require__(3);\nvar util = __webpack_require__(2);\n\nvar BASE_URL = 'https://www.googleapis.com';\nvar AUTH_URL = 'https://accounts.google.com/o/oauth2/auth';\nvar AUTH_SCOPE = 'https://www.googleapis.com/auth/drive';\n\nvar GD_DIR_MIME_TYPE = 'application/vnd.google-apps.folder';\nvar RS_DIR_MIME_TYPE = 'application/json; charset=UTF-8';\n\nvar isFolder = util.isFolder;\n\nfunction buildQueryString(params) {\n  return Object.keys(params).map(function (key) {\n    return encodeURIComponent(key) + '=' + encodeURIComponent(params[key]);\n  }).join('&');\n}\n\nfunction fileNameFromMeta(meta) {\n  return encodeURIComponent(meta.title) + (meta.mimeType === GD_DIR_MIME_TYPE ? '/' : '');\n}\n\nfunction metaTitleFromFileName(filename) {\n  if (filename.substr(-1) === '/') {\n    filename = filename.substr(0, filename.length - 1);\n  }\n  return decodeURIComponent(filename);\n}\n\nfunction parentPath(path) {\n  return path.replace(/[^\\/]+\\/?$/, '');\n}\n\nfunction baseName(path) {\n  var parts = path.split('/');\n  if (path.substr(-1) === '/') {\n    return parts[parts.length - 2] + '/';\n  } else {\n    return parts[parts.length - 1];\n  }\n}\n\nvar Cache = function Cache(maxAge) {\n  this.maxAge = maxAge;\n  this._items = {};\n};\n\nCache.prototype = {\n  get: function get(key) {\n    var item = this._items[key];\n    var now = new Date().getTime();\n    return item && item.t >= now - this.maxAge ? item.v : undefined;\n  },\n\n  set: function set(key, value) {\n    this._items[key] = {\n      v: value,\n      t: new Date().getTime()\n    };\n  }\n};\n\nvar GoogleDrive = function GoogleDrive(remoteStorage, clientId) {\n\n  eventHandling(this, 'change', 'connected', 'wire-busy', 'wire-done', 'not-connected');\n\n  this.rs = remoteStorage;\n  this.clientId = clientId;\n\n  this._fileIdCache = new Cache(60 * 5); // ids expire after 5 minutes (is this a good idea?)\n};\n\nGoogleDrive.prototype = {\n  connected: false,\n  online: true,\n\n  configure: function configure(settings) {\n    // Settings parameter compatible with WireClient\n    if (settings.token) {\n      localStorage['remotestorage:googledrive:token'] = settings.token;\n      this.token = settings.token;\n      this.connected = true;\n      this._emit('connected');\n    } else {\n      this.connected = false;\n      delete this.token;\n      delete localStorage['remotestorage:googledrive:token'];\n    }\n  },\n\n  connect: function connect() {\n    this.rs.setBackend('googledrive');\n    Authorize(this.rs, AUTH_URL, AUTH_SCOPE, String(Authorize.getLocation()), this.clientId);\n  },\n\n  stopWaitingForToken: function stopWaitingForToken() {\n    if (!this.connected) {\n      this._emit('not-connected');\n    }\n  },\n\n  get: function get(path, options) {\n    if (path.substr(-1) === '/') {\n      return this._getFolder(path, options);\n    } else {\n      return this._getFile(path, options);\n    }\n  },\n\n  put: function put(path, body, contentType, options) {\n    var self = this;\n    function putDone(response) {\n      if (response.status >= 200 && response.status < 300) {\n        var meta = JSON.parse(response.responseText);\n        var etagWithoutQuotes = meta.etag.substring(1, meta.etag.length - 1);\n        return Promise.resolve({ statusCode: 200, contentType: meta.mimeType, revision: etagWithoutQuotes });\n      } else if (response.status === 412) {\n        return Promise.resolve({ statusCode: 412, revision: 'conflict' });\n      } else {\n        return Promise.reject(\"PUT failed with status \" + response.status + \" (\" + response.responseText + \")\");\n      }\n    }\n    return self._getFileId(path).then(function (id) {\n      if (id) {\n        if (options && options.ifNoneMatch === '*') {\n          return putDone({ status: 412 });\n        }\n        return self._updateFile(id, path, body, contentType, options).then(putDone);\n      } else {\n        return self._createFile(path, body, contentType, options).then(putDone);\n      }\n    });\n  },\n\n  'delete': function _delete(path, options) {\n    var self = this;\n    return self._getFileId(path).then(function (id) {\n      if (!id) {\n        // File doesn't exist. Ignore.\n        return Promise.resolve({ statusCode: 200 });\n      }\n\n      return self._getMeta(id).then(function (meta) {\n        var etagWithoutQuotes;\n        if ((typeof meta === 'undefined' ? 'undefined' : _typeof(meta)) === 'object' && typeof meta.etag === 'string') {\n          etagWithoutQuotes = meta.etag.substring(1, meta.etag.length - 1);\n        }\n        if (options && options.ifMatch && options.ifMatch !== etagWithoutQuotes) {\n          return { statusCode: 412, revision: etagWithoutQuotes };\n        }\n\n        return self._request('DELETE', BASE_URL + '/drive/v2/files/' + id, {}).then(function (response) {\n          if (response.status === 200 || response.status === 204) {\n            return { statusCode: 200 };\n          } else {\n            return Promise.reject(\"Delete failed: \" + response.status + \" (\" + response.responseText + \")\");\n          }\n        });\n      });\n    });\n  },\n\n  _updateFile: function _updateFile(id, path, body, contentType, options) {\n    var self = this;\n    var metadata = {\n      mimeType: contentType\n    };\n    var headers = {\n      'Content-Type': 'application/json; charset=UTF-8'\n    };\n\n    if (options && options.ifMatch) {\n      headers['If-Match'] = '\"' + options.ifMatch + '\"';\n    }\n\n    return self._request('PUT', BASE_URL + '/upload/drive/v2/files/' + id + '?uploadType=resumable', {\n      body: JSON.stringify(metadata),\n      headers: headers\n    }).then(function (response) {\n      if (response.status === 412) {\n        return response;\n      } else {\n        return self._request('PUT', response.getResponseHeader('Location'), {\n          body: contentType.match(/^application\\/json/) ? JSON.stringify(body) : body\n        });\n      }\n    });\n  },\n\n  _createFile: function _createFile(path, body, contentType, options) {\n    var self = this;\n    return self._getParentId(path).then(function (parentId) {\n      var fileName = baseName(path);\n      var metadata = {\n        title: metaTitleFromFileName(fileName),\n        mimeType: contentType,\n        parents: [{\n          kind: \"drive#fileLink\",\n          id: parentId\n        }]\n      };\n      return self._request('POST', BASE_URL + '/upload/drive/v2/files?uploadType=resumable', {\n        body: JSON.stringify(metadata),\n        headers: {\n          'Content-Type': 'application/json; charset=UTF-8'\n        }\n      }).then(function (response) {\n        return self._request('POST', response.getResponseHeader('Location'), {\n          body: contentType.match(/^application\\/json/) ? JSON.stringify(body) : body\n        });\n      });\n    });\n  },\n\n  _getFile: function _getFile(path, options) {\n    var self = this;\n    return self._getFileId(path).then(function (id) {\n      return self._getMeta(id).then(function (meta) {\n        var etagWithoutQuotes;\n        if ((typeof meta === 'undefined' ? 'undefined' : _typeof(meta)) === 'object' && typeof meta.etag === 'string') {\n          etagWithoutQuotes = meta.etag.substring(1, meta.etag.length - 1);\n        }\n\n        if (options && options.ifNoneMatch && etagWithoutQuotes === options.ifNoneMatch) {\n          return Promise.resolve({ statusCode: 304 });\n        }\n\n        var options2 = {};\n        if (!meta.downloadUrl) {\n          if (meta.exportLinks && meta.exportLinks['text/html']) {\n            // Documents that were generated inside GoogleDocs have no\n            // downloadUrl, but you can export them to text/html instead:\n            meta.mimeType += ';export=text/html';\n            meta.downloadUrl = meta.exportLinks['text/html'];\n          } else {\n            // empty file\n            return Promise.resolve({ statusCode: 200, body: '', contentType: meta.mimeType, revision: etagWithoutQuotes });\n          }\n        }\n\n        if (meta.mimeType.match(/charset=binary/)) {\n          options2.responseType = 'blob';\n        }\n        return self._request('GET', meta.downloadUrl, options2).then(function (response) {\n          var body = response.response;\n          if (meta.mimeType.match(/^application\\/json/)) {\n            try {\n              body = JSON.parse(body);\n            } catch (e) {}\n          }\n          return Promise.resolve({ statusCode: 200, body: body, contentType: meta.mimeType, revision: etagWithoutQuotes });\n        });\n      });\n    });\n  },\n\n  _getFolder: function _getFolder(path, options) {\n    var self = this;\n    return self._getFileId(path).then(function (id) {\n      var query, fields, data, etagWithoutQuotes, itemsMap;\n      if (!id) {\n        return Promise.resolve({ statusCode: 404 });\n      }\n\n      query = '\\'' + id + '\\' in parents';\n      fields = 'items(downloadUrl,etag,fileSize,id,mimeType,title)';\n      return self._request('GET', BASE_URL + '/drive/v2/files?' + 'q=' + encodeURIComponent(query) + '&fields=' + encodeURIComponent(fields) + '&maxResults=1000', {}).then(function (response) {\n        if (response.status !== 200) {\n          return Promise.reject('request failed or something: ' + response.status);\n        }\n\n        try {\n          data = JSON.parse(response.responseText);\n        } catch (e) {\n          return Promise.reject('non-JSON response from GoogleDrive');\n        }\n\n        itemsMap = {};\n        for (var i = 0, len = data.items.length; i < len; i++) {\n          etagWithoutQuotes = data.items[i].etag.substring(1, data.items[i].etag.length - 1);\n          if (data.items[i].mimeType === GD_DIR_MIME_TYPE) {\n            self._fileIdCache.set(path + data.items[i].title + '/', data.items[i].id);\n            itemsMap[data.items[i].title + '/'] = {\n              ETag: etagWithoutQuotes\n            };\n          } else {\n            self._fileIdCache.set(path + data.items[i].title, data.items[i].id);\n            itemsMap[data.items[i].title] = {\n              ETag: etagWithoutQuotes,\n              'Content-Type': data.items[i].mimeType,\n              'Content-Length': data.items[i].fileSize\n            };\n          }\n        }\n        // FIXME: add revision of folder!\n        return Promise.resolve({ statusCode: 200, body: itemsMap, contentType: RS_DIR_MIME_TYPE, revision: undefined });\n      });\n    });\n  },\n\n  _getParentId: function _getParentId(path) {\n    var foldername = parentPath(path);\n    var self = this;\n    return self._getFileId(foldername).then(function (parentId) {\n      if (parentId) {\n        return Promise.resolve(parentId);\n      } else {\n        return self._createFolder(foldername);\n      }\n    });\n  },\n\n  _createFolder: function _createFolder(path) {\n    var self = this;\n    return self._getParentId(path).then(function (parentId) {\n      return self._request('POST', BASE_URL + '/drive/v2/files', {\n        body: JSON.stringify({\n          title: metaTitleFromFileName(baseName(path)),\n          mimeType: GD_DIR_MIME_TYPE,\n          parents: [{\n            id: parentId\n          }]\n        }),\n        headers: {\n          'Content-Type': 'application/json; charset=UTF-8'\n        }\n      }).then(function (response) {\n        var meta = JSON.parse(response.responseText);\n        return Promise.resolve(meta.id);\n      });\n    });\n  },\n\n  _getFileId: function _getFileId(path) {\n    var self = this;\n    var id;\n    if (path === '/') {\n      // \"root\" is a special alias for the fileId of the root folder\n      return Promise.resolve('root');\n    } else if (id = this._fileIdCache.get(path)) {\n      // id is cached.\n      return Promise.resolve(id);\n    }\n    // id is not cached (or file doesn't exist).\n    // load parent folder listing to propagate / update id cache.\n    return self._getFolder(parentPath(path)).then(function () {\n      id = self._fileIdCache.get(path);\n      if (!id) {\n        if (path.substr(-1) === '/') {\n          return self._createFolder(path).then(function () {\n            return self._getFileId(path);\n          });\n        } else {\n          return Promise.resolve();\n        }\n        return;\n      }\n      return Promise.resolve(id);\n    });\n  },\n\n  _getMeta: function _getMeta(id) {\n    return this._request('GET', BASE_URL + '/drive/v2/files/' + id, {}).then(function (response) {\n      if (response.status === 200) {\n        return Promise.resolve(JSON.parse(response.responseText));\n      } else {\n        return Promise.reject(\"request (getting metadata for \" + id + \") failed with status: \" + response.status);\n      }\n    });\n  },\n\n  /**\n   * Method: info\n   *\n   * Fetches the user's info from dropbox and returns a promise for it.\n   *\n   * Returns:\n   *\n   *   A promise to the user's info\n   */\n  info: function info() {\n    var url = BASE_URL + '/drive/v2/about';\n    // requesting user info(mainly for userAdress)\n    return this._request('GET', url, {}).then(function (resp) {\n      try {\n        var info = JSON.parse(resp.responseText);\n        return Promise.resolve(info);\n      } catch (e) {\n        return Promise.reject(e);\n      }\n    });\n  },\n\n  _request: function _request(method, url, options) {\n    var self = this;\n\n    if (!options.headers) {\n      options.headers = {};\n    }\n    options.headers['Authorization'] = 'Bearer ' + self.token;\n\n    this._emit('wire-busy', {\n      method: method,\n      isFolder: isFolder(url)\n    });\n\n    return WireClient.request.call(this, method, url, options).then(function (xhr) {\n      // Google tokens expire from time to time...\n      if (xhr && xhr.status === 401) {\n        self.connect();\n        return;\n      } else {\n        if (!self.online) {\n          self.online = true;\n          self.rs._emit('network-online');\n        }\n        self._emit('wire-done', {\n          method: method,\n          isFolder: isFolder(url),\n          success: true\n        });\n\n        return Promise.resolve(xhr);\n      }\n    }, function (error) {\n      if (self.online) {\n        self.online = false;\n        self.rs._emit('network-offline');\n      }\n      self._emit('wire-done', {\n        method: method,\n        isFolder: isFolder(url),\n        success: false\n      });\n\n      return Promise.reject(error);\n    });\n  }\n};\n\nGoogleDrive._rs_init = function (remoteStorage) {\n  var config = remoteStorage.apiKeys.googledrive;\n  if (config) {\n    remoteStorage.googledrive = new GoogleDrive(remoteStorage, config.clientId);\n    if (remoteStorage.backend === 'googledrive') {\n      remoteStorage._origRemote = remoteStorage.remote;\n      remoteStorage.remote = remoteStorage.googledrive;\n    }\n  }\n};\n\nGoogleDrive._rs_supported = function (rs) {\n  return true;\n};\n\nGoogleDrive._rs_cleanup = function (remoteStorage) {\n  remoteStorage.setBackend(undefined);\n  if (remoteStorage._origRemote) {\n    remoteStorage.remote = remoteStorage._origRemote;\n    delete remoteStorage._origRemote;\n  }\n};\n\nmodule.exports = GoogleDrive;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvZ29vZ2xlZHJpdmUuanM/MTJkZiJdLCJuYW1lcyI6WyJBdXRob3JpemUiLCJyZXF1aXJlIiwiV2lyZUNsaWVudCIsImV2ZW50SGFuZGxpbmciLCJ1dGlsIiwiQkFTRV9VUkwiLCJBVVRIX1VSTCIsIkFVVEhfU0NPUEUiLCJHRF9ESVJfTUlNRV9UWVBFIiwiUlNfRElSX01JTUVfVFlQRSIsImlzRm9sZGVyIiwiYnVpbGRRdWVyeVN0cmluZyIsInBhcmFtcyIsIk9iamVjdCIsImtleXMiLCJtYXAiLCJrZXkiLCJlbmNvZGVVUklDb21wb25lbnQiLCJqb2luIiwiZmlsZU5hbWVGcm9tTWV0YSIsIm1ldGEiLCJ0aXRsZSIsIm1pbWVUeXBlIiwibWV0YVRpdGxlRnJvbUZpbGVOYW1lIiwiZmlsZW5hbWUiLCJzdWJzdHIiLCJsZW5ndGgiLCJkZWNvZGVVUklDb21wb25lbnQiLCJwYXJlbnRQYXRoIiwicGF0aCIsInJlcGxhY2UiLCJiYXNlTmFtZSIsInBhcnRzIiwic3BsaXQiLCJDYWNoZSIsIm1heEFnZSIsIl9pdGVtcyIsInByb3RvdHlwZSIsImdldCIsIml0ZW0iLCJub3ciLCJEYXRlIiwiZ2V0VGltZSIsInQiLCJ2IiwidW5kZWZpbmVkIiwic2V0IiwidmFsdWUiLCJHb29nbGVEcml2ZSIsInJlbW90ZVN0b3JhZ2UiLCJjbGllbnRJZCIsInJzIiwiX2ZpbGVJZENhY2hlIiwiY29ubmVjdGVkIiwib25saW5lIiwiY29uZmlndXJlIiwic2V0dGluZ3MiLCJ0b2tlbiIsImxvY2FsU3RvcmFnZSIsIl9lbWl0IiwiY29ubmVjdCIsInNldEJhY2tlbmQiLCJTdHJpbmciLCJnZXRMb2NhdGlvbiIsInN0b3BXYWl0aW5nRm9yVG9rZW4iLCJvcHRpb25zIiwiX2dldEZvbGRlciIsIl9nZXRGaWxlIiwicHV0IiwiYm9keSIsImNvbnRlbnRUeXBlIiwic2VsZiIsInB1dERvbmUiLCJyZXNwb25zZSIsInN0YXR1cyIsIkpTT04iLCJwYXJzZSIsInJlc3BvbnNlVGV4dCIsImV0YWdXaXRob3V0UXVvdGVzIiwiZXRhZyIsInN1YnN0cmluZyIsIlByb21pc2UiLCJyZXNvbHZlIiwic3RhdHVzQ29kZSIsInJldmlzaW9uIiwicmVqZWN0IiwiX2dldEZpbGVJZCIsInRoZW4iLCJpZCIsImlmTm9uZU1hdGNoIiwiX3VwZGF0ZUZpbGUiLCJfY3JlYXRlRmlsZSIsIl9nZXRNZXRhIiwiaWZNYXRjaCIsIl9yZXF1ZXN0IiwibWV0YWRhdGEiLCJoZWFkZXJzIiwic3RyaW5naWZ5IiwiZ2V0UmVzcG9uc2VIZWFkZXIiLCJtYXRjaCIsIl9nZXRQYXJlbnRJZCIsInBhcmVudElkIiwiZmlsZU5hbWUiLCJwYXJlbnRzIiwia2luZCIsIm9wdGlvbnMyIiwiZG93bmxvYWRVcmwiLCJleHBvcnRMaW5rcyIsInJlc3BvbnNlVHlwZSIsImUiLCJxdWVyeSIsImZpZWxkcyIsImRhdGEiLCJpdGVtc01hcCIsImkiLCJsZW4iLCJpdGVtcyIsIkVUYWciLCJmaWxlU2l6ZSIsImZvbGRlcm5hbWUiLCJfY3JlYXRlRm9sZGVyIiwiaW5mbyIsInVybCIsInJlc3AiLCJtZXRob2QiLCJyZXF1ZXN0IiwiY2FsbCIsInhociIsInN1Y2Nlc3MiLCJlcnJvciIsIl9yc19pbml0IiwiY29uZmlnIiwiYXBpS2V5cyIsImdvb2dsZWRyaXZlIiwiYmFja2VuZCIsIl9vcmlnUmVtb3RlIiwicmVtb3RlIiwiX3JzX3N1cHBvcnRlZCIsIl9yc19jbGVhbnVwIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJtYXBwaW5ncyI6Ijs7OztBQUNFOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFxQkEsSUFBSUEsWUFBWSxtQkFBQUMsQ0FBUSxDQUFSLENBQWhCO0FBQ0EsSUFBSUMsYUFBYSxtQkFBQUQsQ0FBUSxFQUFSLENBQWpCO0FBQ0EsSUFBSUUsZ0JBQWdCLG1CQUFBRixDQUFRLENBQVIsQ0FBcEI7QUFDQSxJQUFJRyxPQUFPLG1CQUFBSCxDQUFRLENBQVIsQ0FBWDs7QUFFQSxJQUFJSSxXQUFXLDRCQUFmO0FBQ0EsSUFBSUMsV0FBVywyQ0FBZjtBQUNBLElBQUlDLGFBQWEsdUNBQWpCOztBQUVBLElBQUlDLG1CQUFtQixvQ0FBdkI7QUFDQSxJQUFJQyxtQkFBbUIsaUNBQXZCOztBQUVBLElBQUlDLFdBQVdOLEtBQUtNLFFBQXBCOztBQUVBLFNBQVNDLGdCQUFULENBQTBCQyxNQUExQixFQUFrQztBQUNoQyxTQUFPQyxPQUFPQyxJQUFQLENBQVlGLE1BQVosRUFBb0JHLEdBQXBCLENBQXdCLFVBQVVDLEdBQVYsRUFBZTtBQUM1QyxXQUFPQyxtQkFBbUJELEdBQW5CLElBQTBCLEdBQTFCLEdBQWdDQyxtQkFBbUJMLE9BQU9JLEdBQVAsQ0FBbkIsQ0FBdkM7QUFDRCxHQUZNLEVBRUpFLElBRkksQ0FFQyxHQUZELENBQVA7QUFHRDs7QUFFRCxTQUFTQyxnQkFBVCxDQUEwQkMsSUFBMUIsRUFBZ0M7QUFDOUIsU0FBT0gsbUJBQW1CRyxLQUFLQyxLQUF4QixLQUFrQ0QsS0FBS0UsUUFBTCxLQUFrQmQsZ0JBQWxCLEdBQXFDLEdBQXJDLEdBQTJDLEVBQTdFLENBQVA7QUFDRDs7QUFFRCxTQUFTZSxxQkFBVCxDQUErQkMsUUFBL0IsRUFBeUM7QUFDdkMsTUFBSUEsU0FBU0MsTUFBVCxDQUFnQixDQUFDLENBQWpCLE1BQXdCLEdBQTVCLEVBQWlDO0FBQy9CRCxlQUFXQSxTQUFTQyxNQUFULENBQWdCLENBQWhCLEVBQW1CRCxTQUFTRSxNQUFULEdBQWtCLENBQXJDLENBQVg7QUFDRDtBQUNELFNBQU9DLG1CQUFtQkgsUUFBbkIsQ0FBUDtBQUNEOztBQUVELFNBQVNJLFVBQVQsQ0FBb0JDLElBQXBCLEVBQTBCO0FBQ3hCLFNBQU9BLEtBQUtDLE9BQUwsQ0FBYSxZQUFiLEVBQTJCLEVBQTNCLENBQVA7QUFDRDs7QUFFRCxTQUFTQyxRQUFULENBQWtCRixJQUFsQixFQUF3QjtBQUN0QixNQUFJRyxRQUFRSCxLQUFLSSxLQUFMLENBQVcsR0FBWCxDQUFaO0FBQ0EsTUFBSUosS0FBS0osTUFBTCxDQUFZLENBQUMsQ0FBYixNQUFvQixHQUF4QixFQUE2QjtBQUMzQixXQUFPTyxNQUFNQSxNQUFNTixNQUFOLEdBQWEsQ0FBbkIsSUFBc0IsR0FBN0I7QUFDRCxHQUZELE1BRU87QUFDTCxXQUFPTSxNQUFNQSxNQUFNTixNQUFOLEdBQWEsQ0FBbkIsQ0FBUDtBQUNEO0FBQ0Y7O0FBRUQsSUFBSVEsUUFBUSxTQUFSQSxLQUFRLENBQVVDLE1BQVYsRUFBa0I7QUFDNUIsT0FBS0EsTUFBTCxHQUFjQSxNQUFkO0FBQ0EsT0FBS0MsTUFBTCxHQUFjLEVBQWQ7QUFDRCxDQUhEOztBQUtBRixNQUFNRyxTQUFOLEdBQWtCO0FBQ2hCQyxPQUFLLGFBQVV0QixHQUFWLEVBQWU7QUFDbEIsUUFBSXVCLE9BQU8sS0FBS0gsTUFBTCxDQUFZcEIsR0FBWixDQUFYO0FBQ0EsUUFBSXdCLE1BQU0sSUFBSUMsSUFBSixHQUFXQyxPQUFYLEVBQVY7QUFDQSxXQUFRSCxRQUFRQSxLQUFLSSxDQUFMLElBQVdILE1BQU0sS0FBS0wsTUFBL0IsR0FBMENJLEtBQUtLLENBQS9DLEdBQW1EQyxTQUExRDtBQUNELEdBTGU7O0FBT2hCQyxPQUFLLGFBQVU5QixHQUFWLEVBQWUrQixLQUFmLEVBQXNCO0FBQ3pCLFNBQUtYLE1BQUwsQ0FBWXBCLEdBQVosSUFBbUI7QUFDakI0QixTQUFHRyxLQURjO0FBRWpCSixTQUFHLElBQUlGLElBQUosR0FBV0MsT0FBWDtBQUZjLEtBQW5CO0FBSUQ7QUFaZSxDQUFsQjs7QUFlQSxJQUFJTSxjQUFjLFNBQWRBLFdBQWMsQ0FBVUMsYUFBVixFQUF5QkMsUUFBekIsRUFBbUM7O0FBRW5EL0MsZ0JBQWMsSUFBZCxFQUFvQixRQUFwQixFQUE4QixXQUE5QixFQUEyQyxXQUEzQyxFQUF3RCxXQUF4RCxFQUFxRSxlQUFyRTs7QUFFQSxPQUFLZ0QsRUFBTCxHQUFVRixhQUFWO0FBQ0EsT0FBS0MsUUFBTCxHQUFnQkEsUUFBaEI7O0FBRUEsT0FBS0UsWUFBTCxHQUFvQixJQUFJbEIsS0FBSixDQUFVLEtBQUssQ0FBZixDQUFwQixDQVBtRCxDQU9aO0FBQ3hDLENBUkQ7O0FBVUFjLFlBQVlYLFNBQVosR0FBd0I7QUFDdEJnQixhQUFXLEtBRFc7QUFFdEJDLFVBQVEsSUFGYzs7QUFJdEJDLGFBQVcsbUJBQVVDLFFBQVYsRUFBb0I7QUFBRTtBQUMvQixRQUFJQSxTQUFTQyxLQUFiLEVBQW9CO0FBQ2xCQyxtQkFBYSxpQ0FBYixJQUFrREYsU0FBU0MsS0FBM0Q7QUFDQSxXQUFLQSxLQUFMLEdBQWFELFNBQVNDLEtBQXRCO0FBQ0EsV0FBS0osU0FBTCxHQUFpQixJQUFqQjtBQUNBLFdBQUtNLEtBQUwsQ0FBVyxXQUFYO0FBQ0QsS0FMRCxNQUtPO0FBQ0wsV0FBS04sU0FBTCxHQUFpQixLQUFqQjtBQUNBLGFBQU8sS0FBS0ksS0FBWjtBQUNBLGFBQU9DLGFBQWEsaUNBQWIsQ0FBUDtBQUNEO0FBQ0YsR0FmcUI7O0FBaUJ0QkUsV0FBUyxtQkFBWTtBQUNuQixTQUFLVCxFQUFMLENBQVFVLFVBQVIsQ0FBbUIsYUFBbkI7QUFDQTdELGNBQVUsS0FBS21ELEVBQWYsRUFBbUI3QyxRQUFuQixFQUE2QkMsVUFBN0IsRUFBeUN1RCxPQUFPOUQsVUFBVStELFdBQVYsRUFBUCxDQUF6QyxFQUEwRSxLQUFLYixRQUEvRTtBQUNELEdBcEJxQjs7QUFzQnRCYyx1QkFBcUIsK0JBQVk7QUFDL0IsUUFBSSxDQUFDLEtBQUtYLFNBQVYsRUFBcUI7QUFDbkIsV0FBS00sS0FBTCxDQUFXLGVBQVg7QUFDRDtBQUNGLEdBMUJxQjs7QUE0QnRCckIsT0FBSyxhQUFVVCxJQUFWLEVBQWdCb0MsT0FBaEIsRUFBeUI7QUFDNUIsUUFBSXBDLEtBQUtKLE1BQUwsQ0FBWSxDQUFDLENBQWIsTUFBb0IsR0FBeEIsRUFBNkI7QUFDM0IsYUFBTyxLQUFLeUMsVUFBTCxDQUFnQnJDLElBQWhCLEVBQXNCb0MsT0FBdEIsQ0FBUDtBQUNELEtBRkQsTUFFTztBQUNMLGFBQU8sS0FBS0UsUUFBTCxDQUFjdEMsSUFBZCxFQUFvQm9DLE9BQXBCLENBQVA7QUFDRDtBQUNGLEdBbENxQjs7QUFvQ3RCRyxPQUFLLGFBQVV2QyxJQUFWLEVBQWdCd0MsSUFBaEIsRUFBc0JDLFdBQXRCLEVBQW1DTCxPQUFuQyxFQUE0QztBQUMvQyxRQUFJTSxPQUFPLElBQVg7QUFDQSxhQUFTQyxPQUFULENBQWlCQyxRQUFqQixFQUEyQjtBQUN6QixVQUFJQSxTQUFTQyxNQUFULElBQW1CLEdBQW5CLElBQTBCRCxTQUFTQyxNQUFULEdBQWtCLEdBQWhELEVBQXFEO0FBQ25ELFlBQUl0RCxPQUFPdUQsS0FBS0MsS0FBTCxDQUFXSCxTQUFTSSxZQUFwQixDQUFYO0FBQ0EsWUFBSUMsb0JBQW9CMUQsS0FBSzJELElBQUwsQ0FBVUMsU0FBVixDQUFvQixDQUFwQixFQUF1QjVELEtBQUsyRCxJQUFMLENBQVVyRCxNQUFWLEdBQWlCLENBQXhDLENBQXhCO0FBQ0EsZUFBT3VELFFBQVFDLE9BQVIsQ0FBZ0IsRUFBQ0MsWUFBWSxHQUFiLEVBQWtCYixhQUFhbEQsS0FBS0UsUUFBcEMsRUFBOEM4RCxVQUFVTixpQkFBeEQsRUFBaEIsQ0FBUDtBQUNELE9BSkQsTUFJTyxJQUFJTCxTQUFTQyxNQUFULEtBQW9CLEdBQXhCLEVBQTZCO0FBQ2xDLGVBQU9PLFFBQVFDLE9BQVIsQ0FBZ0IsRUFBQ0MsWUFBWSxHQUFiLEVBQWtCQyxVQUFVLFVBQTVCLEVBQWhCLENBQVA7QUFDRCxPQUZNLE1BRUE7QUFDTCxlQUFPSCxRQUFRSSxNQUFSLENBQWUsNEJBQTRCWixTQUFTQyxNQUFyQyxHQUE4QyxJQUE5QyxHQUFxREQsU0FBU0ksWUFBOUQsR0FBNkUsR0FBNUYsQ0FBUDtBQUNEO0FBQ0Y7QUFDRCxXQUFPTixLQUFLZSxVQUFMLENBQWdCekQsSUFBaEIsRUFBc0IwRCxJQUF0QixDQUEyQixVQUFVQyxFQUFWLEVBQWM7QUFDOUMsVUFBSUEsRUFBSixFQUFRO0FBQ04sWUFBSXZCLFdBQVlBLFFBQVF3QixXQUFSLEtBQXdCLEdBQXhDLEVBQThDO0FBQzVDLGlCQUFPakIsUUFBUSxFQUFFRSxRQUFRLEdBQVYsRUFBUixDQUFQO0FBQ0Q7QUFDRCxlQUFPSCxLQUFLbUIsV0FBTCxDQUFpQkYsRUFBakIsRUFBcUIzRCxJQUFyQixFQUEyQndDLElBQTNCLEVBQWlDQyxXQUFqQyxFQUE4Q0wsT0FBOUMsRUFBdURzQixJQUF2RCxDQUE0RGYsT0FBNUQsQ0FBUDtBQUNELE9BTEQsTUFLTztBQUNMLGVBQU9ELEtBQUtvQixXQUFMLENBQWlCOUQsSUFBakIsRUFBdUJ3QyxJQUF2QixFQUE2QkMsV0FBN0IsRUFBMENMLE9BQTFDLEVBQW1Ec0IsSUFBbkQsQ0FBd0RmLE9BQXhELENBQVA7QUFDRDtBQUNGLEtBVE0sQ0FBUDtBQVVELEdBM0RxQjs7QUE2RHRCLFlBQVUsaUJBQVUzQyxJQUFWLEVBQWdCb0MsT0FBaEIsRUFBeUI7QUFDakMsUUFBSU0sT0FBTyxJQUFYO0FBQ0EsV0FBT0EsS0FBS2UsVUFBTCxDQUFnQnpELElBQWhCLEVBQXNCMEQsSUFBdEIsQ0FBMkIsVUFBVUMsRUFBVixFQUFjO0FBQzlDLFVBQUksQ0FBQ0EsRUFBTCxFQUFTO0FBQ1A7QUFDQSxlQUFPUCxRQUFRQyxPQUFSLENBQWdCLEVBQUNDLFlBQVksR0FBYixFQUFoQixDQUFQO0FBQ0Q7O0FBRUQsYUFBT1osS0FBS3FCLFFBQUwsQ0FBY0osRUFBZCxFQUFrQkQsSUFBbEIsQ0FBdUIsVUFBVW5FLElBQVYsRUFBZ0I7QUFDNUMsWUFBSTBELGlCQUFKO0FBQ0EsWUFBSyxRQUFPMUQsSUFBUCx5Q0FBT0EsSUFBUCxPQUFnQixRQUFqQixJQUErQixPQUFPQSxLQUFLMkQsSUFBWixLQUFxQixRQUF4RCxFQUFtRTtBQUNqRUQsOEJBQW9CMUQsS0FBSzJELElBQUwsQ0FBVUMsU0FBVixDQUFvQixDQUFwQixFQUF1QjVELEtBQUsyRCxJQUFMLENBQVVyRCxNQUFWLEdBQWlCLENBQXhDLENBQXBCO0FBQ0Q7QUFDRCxZQUFJdUMsV0FBV0EsUUFBUTRCLE9BQW5CLElBQStCNUIsUUFBUTRCLE9BQVIsS0FBb0JmLGlCQUF2RCxFQUEyRTtBQUN6RSxpQkFBTyxFQUFDSyxZQUFZLEdBQWIsRUFBa0JDLFVBQVVOLGlCQUE1QixFQUFQO0FBQ0Q7O0FBRUQsZUFBT1AsS0FBS3VCLFFBQUwsQ0FBYyxRQUFkLEVBQXdCekYsV0FBVyxrQkFBWCxHQUFnQ21GLEVBQXhELEVBQTRELEVBQTVELEVBQWdFRCxJQUFoRSxDQUFxRSxVQUFVZCxRQUFWLEVBQW9CO0FBQzlGLGNBQUlBLFNBQVNDLE1BQVQsS0FBb0IsR0FBcEIsSUFBMkJELFNBQVNDLE1BQVQsS0FBb0IsR0FBbkQsRUFBd0Q7QUFDdEQsbUJBQU8sRUFBQ1MsWUFBWSxHQUFiLEVBQVA7QUFDRCxXQUZELE1BRU87QUFDTCxtQkFBT0YsUUFBUUksTUFBUixDQUFlLG9CQUFvQlosU0FBU0MsTUFBN0IsR0FBc0MsSUFBdEMsR0FBNkNELFNBQVNJLFlBQXRELEdBQXFFLEdBQXBGLENBQVA7QUFDRDtBQUNGLFNBTk0sQ0FBUDtBQU9ELE9BaEJNLENBQVA7QUFpQkQsS0F2Qk0sQ0FBUDtBQXdCRCxHQXZGcUI7O0FBeUZ0QmEsZUFBYSxxQkFBVUYsRUFBVixFQUFjM0QsSUFBZCxFQUFvQndDLElBQXBCLEVBQTBCQyxXQUExQixFQUF1Q0wsT0FBdkMsRUFBZ0Q7QUFDM0QsUUFBSU0sT0FBTyxJQUFYO0FBQ0EsUUFBSXdCLFdBQVc7QUFDYnpFLGdCQUFVZ0Q7QUFERyxLQUFmO0FBR0EsUUFBSTBCLFVBQVU7QUFDWixzQkFBZ0I7QUFESixLQUFkOztBQUlBLFFBQUkvQixXQUFXQSxRQUFRNEIsT0FBdkIsRUFBZ0M7QUFDOUJHLGNBQVEsVUFBUixJQUFzQixNQUFNL0IsUUFBUTRCLE9BQWQsR0FBd0IsR0FBOUM7QUFDRDs7QUFFRCxXQUFPdEIsS0FBS3VCLFFBQUwsQ0FBYyxLQUFkLEVBQXFCekYsV0FBVyx5QkFBWCxHQUF1Q21GLEVBQXZDLEdBQTRDLHVCQUFqRSxFQUEwRjtBQUMvRm5CLFlBQU1NLEtBQUtzQixTQUFMLENBQWVGLFFBQWYsQ0FEeUY7QUFFL0ZDLGVBQVNBO0FBRnNGLEtBQTFGLEVBR0pULElBSEksQ0FHQyxVQUFVZCxRQUFWLEVBQW9CO0FBQzFCLFVBQUlBLFNBQVNDLE1BQVQsS0FBb0IsR0FBeEIsRUFBNkI7QUFDM0IsZUFBUUQsUUFBUjtBQUNELE9BRkQsTUFFTztBQUNMLGVBQU9GLEtBQUt1QixRQUFMLENBQWMsS0FBZCxFQUFxQnJCLFNBQVN5QixpQkFBVCxDQUEyQixVQUEzQixDQUFyQixFQUE2RDtBQUNsRTdCLGdCQUFNQyxZQUFZNkIsS0FBWixDQUFrQixvQkFBbEIsSUFBMEN4QixLQUFLc0IsU0FBTCxDQUFlNUIsSUFBZixDQUExQyxHQUFpRUE7QUFETCxTQUE3RCxDQUFQO0FBR0Q7QUFDRixLQVhNLENBQVA7QUFZRCxHQWxIcUI7O0FBb0h0QnNCLGVBQWEscUJBQVU5RCxJQUFWLEVBQWdCd0MsSUFBaEIsRUFBc0JDLFdBQXRCLEVBQW1DTCxPQUFuQyxFQUE0QztBQUN2RCxRQUFJTSxPQUFPLElBQVg7QUFDQSxXQUFPQSxLQUFLNkIsWUFBTCxDQUFrQnZFLElBQWxCLEVBQXdCMEQsSUFBeEIsQ0FBNkIsVUFBVWMsUUFBVixFQUFvQjtBQUN0RCxVQUFJQyxXQUFXdkUsU0FBU0YsSUFBVCxDQUFmO0FBQ0EsVUFBSWtFLFdBQVc7QUFDYjFFLGVBQU9FLHNCQUFzQitFLFFBQXRCLENBRE07QUFFYmhGLGtCQUFVZ0QsV0FGRztBQUdiaUMsaUJBQVMsQ0FBQztBQUNSQyxnQkFBTSxnQkFERTtBQUVSaEIsY0FBSWE7QUFGSSxTQUFEO0FBSEksT0FBZjtBQVFBLGFBQU85QixLQUFLdUIsUUFBTCxDQUFjLE1BQWQsRUFBc0J6RixXQUFXLDZDQUFqQyxFQUFnRjtBQUNyRmdFLGNBQU1NLEtBQUtzQixTQUFMLENBQWVGLFFBQWYsQ0FEK0U7QUFFckZDLGlCQUFTO0FBQ1AsMEJBQWdCO0FBRFQ7QUFGNEUsT0FBaEYsRUFLSlQsSUFMSSxDQUtDLFVBQVVkLFFBQVYsRUFBb0I7QUFDMUIsZUFBT0YsS0FBS3VCLFFBQUwsQ0FBYyxNQUFkLEVBQXNCckIsU0FBU3lCLGlCQUFULENBQTJCLFVBQTNCLENBQXRCLEVBQThEO0FBQ25FN0IsZ0JBQU1DLFlBQVk2QixLQUFaLENBQWtCLG9CQUFsQixJQUEwQ3hCLEtBQUtzQixTQUFMLENBQWU1QixJQUFmLENBQTFDLEdBQWlFQTtBQURKLFNBQTlELENBQVA7QUFHRCxPQVRNLENBQVA7QUFVRCxLQXBCTSxDQUFQO0FBcUJELEdBM0lxQjs7QUE2SXRCRixZQUFVLGtCQUFVdEMsSUFBVixFQUFnQm9DLE9BQWhCLEVBQXlCO0FBQ2pDLFFBQUlNLE9BQU8sSUFBWDtBQUNBLFdBQU9BLEtBQUtlLFVBQUwsQ0FBZ0J6RCxJQUFoQixFQUFzQjBELElBQXRCLENBQTJCLFVBQVVDLEVBQVYsRUFBYztBQUM5QyxhQUFPakIsS0FBS3FCLFFBQUwsQ0FBY0osRUFBZCxFQUFrQkQsSUFBbEIsQ0FBdUIsVUFBVW5FLElBQVYsRUFBZ0I7QUFDNUMsWUFBSTBELGlCQUFKO0FBQ0EsWUFBSSxRQUFPMUQsSUFBUCx5Q0FBT0EsSUFBUCxPQUFpQixRQUFqQixJQUE2QixPQUFPQSxLQUFLMkQsSUFBWixLQUFzQixRQUF2RCxFQUFpRTtBQUMvREQsOEJBQW9CMUQsS0FBSzJELElBQUwsQ0FBVUMsU0FBVixDQUFvQixDQUFwQixFQUF1QjVELEtBQUsyRCxJQUFMLENBQVVyRCxNQUFWLEdBQWlCLENBQXhDLENBQXBCO0FBQ0Q7O0FBRUQsWUFBSXVDLFdBQVdBLFFBQVF3QixXQUFuQixJQUFtQ1gsc0JBQXNCYixRQUFRd0IsV0FBckUsRUFBbUY7QUFDakYsaUJBQU9SLFFBQVFDLE9BQVIsQ0FBZ0IsRUFBQ0MsWUFBWSxHQUFiLEVBQWhCLENBQVA7QUFDRDs7QUFFRCxZQUFJc0IsV0FBVyxFQUFmO0FBQ0EsWUFBSSxDQUFDckYsS0FBS3NGLFdBQVYsRUFBdUI7QUFDckIsY0FBSXRGLEtBQUt1RixXQUFMLElBQW9CdkYsS0FBS3VGLFdBQUwsQ0FBaUIsV0FBakIsQ0FBeEIsRUFBdUQ7QUFDckQ7QUFDQTtBQUNBdkYsaUJBQUtFLFFBQUwsSUFBaUIsbUJBQWpCO0FBQ0FGLGlCQUFLc0YsV0FBTCxHQUFtQnRGLEtBQUt1RixXQUFMLENBQWlCLFdBQWpCLENBQW5CO0FBQ0QsV0FMRCxNQUtPO0FBQ0w7QUFDQSxtQkFBTzFCLFFBQVFDLE9BQVIsQ0FBZ0IsRUFBQ0MsWUFBWSxHQUFiLEVBQWtCZCxNQUFNLEVBQXhCLEVBQTRCQyxhQUFhbEQsS0FBS0UsUUFBOUMsRUFBd0Q4RCxVQUFVTixpQkFBbEUsRUFBaEIsQ0FBUDtBQUNEO0FBQ0Y7O0FBRUQsWUFBSTFELEtBQUtFLFFBQUwsQ0FBYzZFLEtBQWQsQ0FBb0IsZ0JBQXBCLENBQUosRUFBMkM7QUFDekNNLG1CQUFTRyxZQUFULEdBQXdCLE1BQXhCO0FBQ0Q7QUFDRCxlQUFPckMsS0FBS3VCLFFBQUwsQ0FBYyxLQUFkLEVBQXFCMUUsS0FBS3NGLFdBQTFCLEVBQXVDRCxRQUF2QyxFQUFpRGxCLElBQWpELENBQXNELFVBQVVkLFFBQVYsRUFBb0I7QUFDL0UsY0FBSUosT0FBT0ksU0FBU0EsUUFBcEI7QUFDQSxjQUFJckQsS0FBS0UsUUFBTCxDQUFjNkUsS0FBZCxDQUFvQixvQkFBcEIsQ0FBSixFQUErQztBQUM3QyxnQkFBSTtBQUNGOUIscUJBQU9NLEtBQUtDLEtBQUwsQ0FBV1AsSUFBWCxDQUFQO0FBQ0QsYUFGRCxDQUVFLE9BQU13QyxDQUFOLEVBQVMsQ0FBRTtBQUNkO0FBQ0QsaUJBQU81QixRQUFRQyxPQUFSLENBQWdCLEVBQUNDLFlBQVksR0FBYixFQUFrQmQsTUFBTUEsSUFBeEIsRUFBOEJDLGFBQWFsRCxLQUFLRSxRQUFoRCxFQUEwRDhELFVBQVVOLGlCQUFwRSxFQUFoQixDQUFQO0FBQ0QsU0FSTSxDQUFQO0FBU0QsT0FuQ00sQ0FBUDtBQW9DRCxLQXJDTSxDQUFQO0FBc0NELEdBckxxQjs7QUF1THRCWixjQUFZLG9CQUFVckMsSUFBVixFQUFnQm9DLE9BQWhCLEVBQXlCO0FBQ25DLFFBQUlNLE9BQU8sSUFBWDtBQUNBLFdBQU9BLEtBQUtlLFVBQUwsQ0FBZ0J6RCxJQUFoQixFQUFzQjBELElBQXRCLENBQTJCLFVBQVVDLEVBQVYsRUFBYztBQUM5QyxVQUFJc0IsS0FBSixFQUFXQyxNQUFYLEVBQW1CQyxJQUFuQixFQUF5QmxDLGlCQUF6QixFQUE0Q21DLFFBQTVDO0FBQ0EsVUFBSSxDQUFFekIsRUFBTixFQUFVO0FBQ1IsZUFBT1AsUUFBUUMsT0FBUixDQUFnQixFQUFDQyxZQUFZLEdBQWIsRUFBaEIsQ0FBUDtBQUNEOztBQUVEMkIsY0FBUSxPQUFPdEIsRUFBUCxHQUFZLGVBQXBCO0FBQ0F1QixlQUFTLG9EQUFUO0FBQ0EsYUFBT3hDLEtBQUt1QixRQUFMLENBQWMsS0FBZCxFQUFxQnpGLFdBQVcsa0JBQVgsR0FDdEIsSUFEc0IsR0FDZlksbUJBQW1CNkYsS0FBbkIsQ0FEZSxHQUV0QixVQUZzQixHQUVUN0YsbUJBQW1COEYsTUFBbkIsQ0FGUyxHQUd0QixrQkFIQyxFQUlILEVBSkcsRUFLTnhCLElBTE0sQ0FLRCxVQUFVZCxRQUFWLEVBQW9CO0FBQ3hCLFlBQUlBLFNBQVNDLE1BQVQsS0FBb0IsR0FBeEIsRUFBNkI7QUFDM0IsaUJBQU9PLFFBQVFJLE1BQVIsQ0FBZSxrQ0FBa0NaLFNBQVNDLE1BQTFELENBQVA7QUFDRDs7QUFFRCxZQUFJO0FBQ0ZzQyxpQkFBT3JDLEtBQUtDLEtBQUwsQ0FBV0gsU0FBU0ksWUFBcEIsQ0FBUDtBQUNELFNBRkQsQ0FFRSxPQUFNZ0MsQ0FBTixFQUFTO0FBQ1QsaUJBQU81QixRQUFRSSxNQUFSLENBQWUsb0NBQWYsQ0FBUDtBQUNEOztBQUVENEIsbUJBQVcsRUFBWDtBQUNBLGFBQUssSUFBSUMsSUFBSSxDQUFSLEVBQVdDLE1BQU1ILEtBQUtJLEtBQUwsQ0FBVzFGLE1BQWpDLEVBQXlDd0YsSUFBSUMsR0FBN0MsRUFBa0RELEdBQWxELEVBQXVEO0FBQ3JEcEMsOEJBQW9Ca0MsS0FBS0ksS0FBTCxDQUFXRixDQUFYLEVBQWNuQyxJQUFkLENBQW1CQyxTQUFuQixDQUE2QixDQUE3QixFQUFnQ2dDLEtBQUtJLEtBQUwsQ0FBV0YsQ0FBWCxFQUFjbkMsSUFBZCxDQUFtQnJELE1BQW5CLEdBQTBCLENBQTFELENBQXBCO0FBQ0EsY0FBSXNGLEtBQUtJLEtBQUwsQ0FBV0YsQ0FBWCxFQUFjNUYsUUFBZCxLQUEyQmQsZ0JBQS9CLEVBQWlEO0FBQy9DK0QsaUJBQUtuQixZQUFMLENBQWtCTixHQUFsQixDQUFzQmpCLE9BQU9tRixLQUFLSSxLQUFMLENBQVdGLENBQVgsRUFBYzdGLEtBQXJCLEdBQTZCLEdBQW5ELEVBQXdEMkYsS0FBS0ksS0FBTCxDQUFXRixDQUFYLEVBQWMxQixFQUF0RTtBQUNBeUIscUJBQVNELEtBQUtJLEtBQUwsQ0FBV0YsQ0FBWCxFQUFjN0YsS0FBZCxHQUFzQixHQUEvQixJQUFzQztBQUNwQ2dHLG9CQUFNdkM7QUFEOEIsYUFBdEM7QUFHRCxXQUxELE1BS087QUFDTFAsaUJBQUtuQixZQUFMLENBQWtCTixHQUFsQixDQUFzQmpCLE9BQU9tRixLQUFLSSxLQUFMLENBQVdGLENBQVgsRUFBYzdGLEtBQTNDLEVBQWtEMkYsS0FBS0ksS0FBTCxDQUFXRixDQUFYLEVBQWMxQixFQUFoRTtBQUNBeUIscUJBQVNELEtBQUtJLEtBQUwsQ0FBV0YsQ0FBWCxFQUFjN0YsS0FBdkIsSUFBZ0M7QUFDOUJnRyxvQkFBTXZDLGlCQUR3QjtBQUU5Qiw4QkFBZ0JrQyxLQUFLSSxLQUFMLENBQVdGLENBQVgsRUFBYzVGLFFBRkE7QUFHOUIsZ0NBQWtCMEYsS0FBS0ksS0FBTCxDQUFXRixDQUFYLEVBQWNJO0FBSEYsYUFBaEM7QUFLRDtBQUNGO0FBQ0Q7QUFDQSxlQUFPckMsUUFBUUMsT0FBUixDQUFnQixFQUFDQyxZQUFZLEdBQWIsRUFBa0JkLE1BQU00QyxRQUF4QixFQUFrQzNDLGFBQWE3RCxnQkFBL0MsRUFBaUUyRSxVQUFVdkMsU0FBM0UsRUFBaEIsQ0FBUDtBQUNELE9BbkNNLENBQVA7QUFvQ0QsS0E1Q00sQ0FBUDtBQTZDRCxHQXRPcUI7O0FBd090QnVELGdCQUFjLHNCQUFVdkUsSUFBVixFQUFnQjtBQUM1QixRQUFJMEYsYUFBYTNGLFdBQVdDLElBQVgsQ0FBakI7QUFDQSxRQUFJMEMsT0FBTyxJQUFYO0FBQ0EsV0FBT0EsS0FBS2UsVUFBTCxDQUFnQmlDLFVBQWhCLEVBQTRCaEMsSUFBNUIsQ0FBaUMsVUFBVWMsUUFBVixFQUFvQjtBQUMxRCxVQUFJQSxRQUFKLEVBQWM7QUFDWixlQUFPcEIsUUFBUUMsT0FBUixDQUFnQm1CLFFBQWhCLENBQVA7QUFDRCxPQUZELE1BRU87QUFDTCxlQUFPOUIsS0FBS2lELGFBQUwsQ0FBbUJELFVBQW5CLENBQVA7QUFDRDtBQUNGLEtBTk0sQ0FBUDtBQU9ELEdBbFBxQjs7QUFvUHRCQyxpQkFBZSx1QkFBVTNGLElBQVYsRUFBZ0I7QUFDN0IsUUFBSTBDLE9BQU8sSUFBWDtBQUNBLFdBQU9BLEtBQUs2QixZQUFMLENBQWtCdkUsSUFBbEIsRUFBd0IwRCxJQUF4QixDQUE2QixVQUFVYyxRQUFWLEVBQW9CO0FBQ3RELGFBQU85QixLQUFLdUIsUUFBTCxDQUFjLE1BQWQsRUFBc0J6RixXQUFXLGlCQUFqQyxFQUFvRDtBQUN6RGdFLGNBQU1NLEtBQUtzQixTQUFMLENBQWU7QUFDbkI1RSxpQkFBT0Usc0JBQXNCUSxTQUFTRixJQUFULENBQXRCLENBRFk7QUFFbkJQLG9CQUFVZCxnQkFGUztBQUduQitGLG1CQUFTLENBQUM7QUFDUmYsZ0JBQUlhO0FBREksV0FBRDtBQUhVLFNBQWYsQ0FEbUQ7QUFRekRMLGlCQUFTO0FBQ1AsMEJBQWdCO0FBRFQ7QUFSZ0QsT0FBcEQsRUFXSlQsSUFYSSxDQVdDLFVBQVVkLFFBQVYsRUFBb0I7QUFDMUIsWUFBSXJELE9BQU91RCxLQUFLQyxLQUFMLENBQVdILFNBQVNJLFlBQXBCLENBQVg7QUFDQSxlQUFPSSxRQUFRQyxPQUFSLENBQWdCOUQsS0FBS29FLEVBQXJCLENBQVA7QUFDRCxPQWRNLENBQVA7QUFlRCxLQWhCTSxDQUFQO0FBaUJELEdBdlFxQjs7QUF5UXRCRixjQUFZLG9CQUFVekQsSUFBVixFQUFnQjtBQUMxQixRQUFJMEMsT0FBTyxJQUFYO0FBQ0EsUUFBSWlCLEVBQUo7QUFDQSxRQUFJM0QsU0FBUyxHQUFiLEVBQWtCO0FBQ2hCO0FBQ0EsYUFBT29ELFFBQVFDLE9BQVIsQ0FBZ0IsTUFBaEIsQ0FBUDtBQUNELEtBSEQsTUFHTyxJQUFLTSxLQUFLLEtBQUtwQyxZQUFMLENBQWtCZCxHQUFsQixDQUFzQlQsSUFBdEIsQ0FBVixFQUF3QztBQUM3QztBQUNBLGFBQU9vRCxRQUFRQyxPQUFSLENBQWdCTSxFQUFoQixDQUFQO0FBQ0Q7QUFDRDtBQUNBO0FBQ0EsV0FBT2pCLEtBQUtMLFVBQUwsQ0FBZ0J0QyxXQUFXQyxJQUFYLENBQWhCLEVBQWtDMEQsSUFBbEMsQ0FBdUMsWUFBWTtBQUN4REMsV0FBS2pCLEtBQUtuQixZQUFMLENBQWtCZCxHQUFsQixDQUFzQlQsSUFBdEIsQ0FBTDtBQUNBLFVBQUksQ0FBQzJELEVBQUwsRUFBUztBQUNQLFlBQUkzRCxLQUFLSixNQUFMLENBQVksQ0FBQyxDQUFiLE1BQW9CLEdBQXhCLEVBQTZCO0FBQzNCLGlCQUFPOEMsS0FBS2lELGFBQUwsQ0FBbUIzRixJQUFuQixFQUF5QjBELElBQXpCLENBQThCLFlBQVk7QUFDL0MsbUJBQU9oQixLQUFLZSxVQUFMLENBQWdCekQsSUFBaEIsQ0FBUDtBQUNELFdBRk0sQ0FBUDtBQUdELFNBSkQsTUFJTztBQUNMLGlCQUFPb0QsUUFBUUMsT0FBUixFQUFQO0FBQ0Q7QUFDRDtBQUNEO0FBQ0QsYUFBT0QsUUFBUUMsT0FBUixDQUFnQk0sRUFBaEIsQ0FBUDtBQUNELEtBYk0sQ0FBUDtBQWNELEdBblNxQjs7QUFxU3RCSSxZQUFVLGtCQUFVSixFQUFWLEVBQWM7QUFDdEIsV0FBTyxLQUFLTSxRQUFMLENBQWMsS0FBZCxFQUFxQnpGLFdBQVcsa0JBQVgsR0FBZ0NtRixFQUFyRCxFQUF5RCxFQUF6RCxFQUE2REQsSUFBN0QsQ0FBa0UsVUFBVWQsUUFBVixFQUFvQjtBQUMzRixVQUFJQSxTQUFTQyxNQUFULEtBQW9CLEdBQXhCLEVBQTZCO0FBQzNCLGVBQU9PLFFBQVFDLE9BQVIsQ0FBZ0JQLEtBQUtDLEtBQUwsQ0FBV0gsU0FBU0ksWUFBcEIsQ0FBaEIsQ0FBUDtBQUNELE9BRkQsTUFFTztBQUNMLGVBQU9JLFFBQVFJLE1BQVIsQ0FBZSxtQ0FBbUNHLEVBQW5DLEdBQXdDLHdCQUF4QyxHQUFtRWYsU0FBU0MsTUFBM0YsQ0FBUDtBQUNEO0FBQ0YsS0FOTSxDQUFQO0FBT0QsR0E3U3FCOztBQStTdEI7Ozs7Ozs7OztBQVNBK0MsUUFBTSxnQkFBWTtBQUNoQixRQUFJQyxNQUFNckgsV0FBVyxpQkFBckI7QUFDQTtBQUNBLFdBQU8sS0FBS3lGLFFBQUwsQ0FBYyxLQUFkLEVBQXFCNEIsR0FBckIsRUFBMEIsRUFBMUIsRUFBOEJuQyxJQUE5QixDQUFtQyxVQUFVb0MsSUFBVixFQUFlO0FBQ3ZELFVBQUk7QUFDRixZQUFJRixPQUFPOUMsS0FBS0MsS0FBTCxDQUFXK0MsS0FBSzlDLFlBQWhCLENBQVg7QUFDQSxlQUFPSSxRQUFRQyxPQUFSLENBQWdCdUMsSUFBaEIsQ0FBUDtBQUNELE9BSEQsQ0FHRSxPQUFPWixDQUFQLEVBQVU7QUFDVixlQUFPNUIsUUFBUUksTUFBUixDQUFld0IsQ0FBZixDQUFQO0FBQ0Q7QUFDRixLQVBNLENBQVA7QUFRRCxHQW5VcUI7O0FBc1V0QmYsWUFBVSxrQkFBVThCLE1BQVYsRUFBa0JGLEdBQWxCLEVBQXVCekQsT0FBdkIsRUFBZ0M7QUFDeEMsUUFBSU0sT0FBTyxJQUFYOztBQUVBLFFBQUksQ0FBRU4sUUFBUStCLE9BQWQsRUFBdUI7QUFBRS9CLGNBQVErQixPQUFSLEdBQWtCLEVBQWxCO0FBQXVCO0FBQ2hEL0IsWUFBUStCLE9BQVIsQ0FBZ0IsZUFBaEIsSUFBbUMsWUFBWXpCLEtBQUtkLEtBQXBEOztBQUVBLFNBQUtFLEtBQUwsQ0FBVyxXQUFYLEVBQXdCO0FBQ3RCaUUsY0FBUUEsTUFEYztBQUV0QmxILGdCQUFVQSxTQUFTZ0gsR0FBVDtBQUZZLEtBQXhCOztBQUtBLFdBQU94SCxXQUFXMkgsT0FBWCxDQUFtQkMsSUFBbkIsQ0FBd0IsSUFBeEIsRUFBOEJGLE1BQTlCLEVBQXNDRixHQUF0QyxFQUEyQ3pELE9BQTNDLEVBQW9Ec0IsSUFBcEQsQ0FBeUQsVUFBU3dDLEdBQVQsRUFBYztBQUM1RTtBQUNBLFVBQUlBLE9BQU9BLElBQUlyRCxNQUFKLEtBQWUsR0FBMUIsRUFBK0I7QUFDN0JILGFBQUtYLE9BQUw7QUFDQTtBQUNELE9BSEQsTUFHTztBQUNMLFlBQUksQ0FBQ1csS0FBS2pCLE1BQVYsRUFBa0I7QUFDaEJpQixlQUFLakIsTUFBTCxHQUFjLElBQWQ7QUFDQWlCLGVBQUtwQixFQUFMLENBQVFRLEtBQVIsQ0FBYyxnQkFBZDtBQUNEO0FBQ0RZLGFBQUtaLEtBQUwsQ0FBVyxXQUFYLEVBQXdCO0FBQ3RCaUUsa0JBQVFBLE1BRGM7QUFFdEJsSCxvQkFBVUEsU0FBU2dILEdBQVQsQ0FGWTtBQUd0Qk0sbUJBQVM7QUFIYSxTQUF4Qjs7QUFNQSxlQUFPL0MsUUFBUUMsT0FBUixDQUFnQjZDLEdBQWhCLENBQVA7QUFDRDtBQUNGLEtBbEJNLEVBa0JKLFVBQVNFLEtBQVQsRUFBZ0I7QUFDakIsVUFBSTFELEtBQUtqQixNQUFULEVBQWlCO0FBQ2ZpQixhQUFLakIsTUFBTCxHQUFjLEtBQWQ7QUFDQWlCLGFBQUtwQixFQUFMLENBQVFRLEtBQVIsQ0FBYyxpQkFBZDtBQUNEO0FBQ0RZLFdBQUtaLEtBQUwsQ0FBVyxXQUFYLEVBQXdCO0FBQ3RCaUUsZ0JBQVFBLE1BRGM7QUFFdEJsSCxrQkFBVUEsU0FBU2dILEdBQVQsQ0FGWTtBQUd0Qk0saUJBQVM7QUFIYSxPQUF4Qjs7QUFNQSxhQUFPL0MsUUFBUUksTUFBUixDQUFlNEMsS0FBZixDQUFQO0FBQ0QsS0E5Qk0sQ0FBUDtBQStCRDtBQWhYcUIsQ0FBeEI7O0FBbVhBakYsWUFBWWtGLFFBQVosR0FBdUIsVUFBVWpGLGFBQVYsRUFBeUI7QUFDOUMsTUFBSWtGLFNBQVNsRixjQUFjbUYsT0FBZCxDQUFzQkMsV0FBbkM7QUFDQSxNQUFJRixNQUFKLEVBQVk7QUFDVmxGLGtCQUFjb0YsV0FBZCxHQUE0QixJQUFJckYsV0FBSixDQUFnQkMsYUFBaEIsRUFBK0JrRixPQUFPakYsUUFBdEMsQ0FBNUI7QUFDQSxRQUFJRCxjQUFjcUYsT0FBZCxLQUEwQixhQUE5QixFQUE2QztBQUMzQ3JGLG9CQUFjc0YsV0FBZCxHQUE0QnRGLGNBQWN1RixNQUExQztBQUNBdkYsb0JBQWN1RixNQUFkLEdBQXVCdkYsY0FBY29GLFdBQXJDO0FBQ0Q7QUFDRjtBQUNGLENBVEQ7O0FBV0FyRixZQUFZeUYsYUFBWixHQUE0QixVQUFVdEYsRUFBVixFQUFjO0FBQ3hDLFNBQU8sSUFBUDtBQUNELENBRkQ7O0FBSUFILFlBQVkwRixXQUFaLEdBQTBCLFVBQVV6RixhQUFWLEVBQXlCO0FBQ2pEQSxnQkFBY1ksVUFBZCxDQUF5QmhCLFNBQXpCO0FBQ0EsTUFBSUksY0FBY3NGLFdBQWxCLEVBQStCO0FBQzdCdEYsa0JBQWN1RixNQUFkLEdBQXVCdkYsY0FBY3NGLFdBQXJDO0FBQ0EsV0FBT3RGLGNBQWNzRixXQUFyQjtBQUNEO0FBQ0YsQ0FORDs7QUFTQUksT0FBT0MsT0FBUCxHQUFpQjVGLFdBQWpCIiwiZmlsZSI6IjE5LmpzIiwic291cmNlc0NvbnRlbnQiOlsiXG4gIC8qKlxuICAgKiBDbGFzczogUmVtb3RlU3RvcmFnZS5Hb29nbGVEcml2ZVxuICAgKlxuICAgKiBXT1JLIElOIFBST0dSRVNTLCBOT1QgUkVDT01NRU5ERUQgRk9SIFBST0RVQ1RJT04gVVNFXG4gICAqXG4gICAqIFRvIHVzZSB0aGlzIGJhY2tlbmQsIHlvdSBuZWVkIHRvIHNwZWNpZnkgdGhlIGFwcCdzIGNsaWVudCBJRCBsaWtlIHNvOlxuICAgKlxuICAgKiAoc3RhcnQgY29kZSlcbiAgICpcbiAgICogcmVtb3RlU3RvcmFnZS5zZXRBcGlLZXlzKCdnb29nbGVkcml2ZScsIHtcbiAgICogICBjbGllbnRJZDogJ3lvdXItY2xpZW50LWlkJ1xuICAgKiB9KTtcbiAgICpcbiAgICogKGVuZCBjb2RlKVxuICAgKlxuICAgKiBBbiBjbGllbnQgSUQgY2FuIGJlIG9idGFpbmVkIGJ5IHJlZ2lzdGVyaW5nIHlvdXIgYXBwIGluIHRoZSBHb29nbGVcbiAgICogRGV2ZWxvcGVycyBDb25zb2xlOiBodHRwczovL2RldmVsb3BlcnMuZ29vZ2xlLmNvbS9kcml2ZS93ZWIvYXV0aC93ZWItY2xpZW50XG4gICAqXG4gICAqIERvY3M6IGh0dHBzOi8vZGV2ZWxvcGVycy5nb29nbGUuY29tL2RyaXZlL3dlYi9hdXRoL3dlYi1jbGllbnQjY3JlYXRlX2FfY2xpZW50X2lkX2FuZF9jbGllbnRfc2VjcmV0XG4gICAqKi9cblxuICB2YXIgQXV0aG9yaXplID0gcmVxdWlyZSgnLi9hdXRob3JpemUnKTtcbiAgdmFyIFdpcmVDbGllbnQgPSByZXF1aXJlKCcuL3dpcmVjbGllbnQnKTtcbiAgdmFyIGV2ZW50SGFuZGxpbmcgPSByZXF1aXJlKCcuL2V2ZW50aGFuZGxpbmcnKTtcbiAgdmFyIHV0aWwgPSByZXF1aXJlKCcuL3V0aWwnKTtcblxuICB2YXIgQkFTRV9VUkwgPSAnaHR0cHM6Ly93d3cuZ29vZ2xlYXBpcy5jb20nO1xuICB2YXIgQVVUSF9VUkwgPSAnaHR0cHM6Ly9hY2NvdW50cy5nb29nbGUuY29tL28vb2F1dGgyL2F1dGgnO1xuICB2YXIgQVVUSF9TQ09QRSA9ICdodHRwczovL3d3dy5nb29nbGVhcGlzLmNvbS9hdXRoL2RyaXZlJztcblxuICB2YXIgR0RfRElSX01JTUVfVFlQRSA9ICdhcHBsaWNhdGlvbi92bmQuZ29vZ2xlLWFwcHMuZm9sZGVyJztcbiAgdmFyIFJTX0RJUl9NSU1FX1RZUEUgPSAnYXBwbGljYXRpb24vanNvbjsgY2hhcnNldD1VVEYtOCc7XG5cbiAgdmFyIGlzRm9sZGVyID0gdXRpbC5pc0ZvbGRlcjtcblxuICBmdW5jdGlvbiBidWlsZFF1ZXJ5U3RyaW5nKHBhcmFtcykge1xuICAgIHJldHVybiBPYmplY3Qua2V5cyhwYXJhbXMpLm1hcChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICByZXR1cm4gZW5jb2RlVVJJQ29tcG9uZW50KGtleSkgKyAnPScgKyBlbmNvZGVVUklDb21wb25lbnQocGFyYW1zW2tleV0pO1xuICAgIH0pLmpvaW4oJyYnKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZpbGVOYW1lRnJvbU1ldGEobWV0YSkge1xuICAgIHJldHVybiBlbmNvZGVVUklDb21wb25lbnQobWV0YS50aXRsZSkgKyAobWV0YS5taW1lVHlwZSA9PT0gR0RfRElSX01JTUVfVFlQRSA/ICcvJyA6ICcnKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG1ldGFUaXRsZUZyb21GaWxlTmFtZShmaWxlbmFtZSkge1xuICAgIGlmIChmaWxlbmFtZS5zdWJzdHIoLTEpID09PSAnLycpIHtcbiAgICAgIGZpbGVuYW1lID0gZmlsZW5hbWUuc3Vic3RyKDAsIGZpbGVuYW1lLmxlbmd0aCAtIDEpO1xuICAgIH1cbiAgICByZXR1cm4gZGVjb2RlVVJJQ29tcG9uZW50KGZpbGVuYW1lKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcmVudFBhdGgocGF0aCkge1xuICAgIHJldHVybiBwYXRoLnJlcGxhY2UoL1teXFwvXStcXC8/JC8sICcnKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGJhc2VOYW1lKHBhdGgpIHtcbiAgICB2YXIgcGFydHMgPSBwYXRoLnNwbGl0KCcvJyk7XG4gICAgaWYgKHBhdGguc3Vic3RyKC0xKSA9PT0gJy8nKSB7XG4gICAgICByZXR1cm4gcGFydHNbcGFydHMubGVuZ3RoLTJdKycvJztcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHBhcnRzW3BhcnRzLmxlbmd0aC0xXTtcbiAgICB9XG4gIH1cblxuICB2YXIgQ2FjaGUgPSBmdW5jdGlvbiAobWF4QWdlKSB7XG4gICAgdGhpcy5tYXhBZ2UgPSBtYXhBZ2U7XG4gICAgdGhpcy5faXRlbXMgPSB7fTtcbiAgfTtcblxuICBDYWNoZS5wcm90b3R5cGUgPSB7XG4gICAgZ2V0OiBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICB2YXIgaXRlbSA9IHRoaXMuX2l0ZW1zW2tleV07XG4gICAgICB2YXIgbm93ID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gICAgICByZXR1cm4gKGl0ZW0gJiYgaXRlbS50ID49IChub3cgLSB0aGlzLm1heEFnZSkpID8gaXRlbS52IDogdW5kZWZpbmVkO1xuICAgIH0sXG5cbiAgICBzZXQ6IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gICAgICB0aGlzLl9pdGVtc1trZXldID0ge1xuICAgICAgICB2OiB2YWx1ZSxcbiAgICAgICAgdDogbmV3IERhdGUoKS5nZXRUaW1lKClcbiAgICAgIH07XG4gICAgfVxuICB9O1xuXG4gIHZhciBHb29nbGVEcml2ZSA9IGZ1bmN0aW9uIChyZW1vdGVTdG9yYWdlLCBjbGllbnRJZCkge1xuXG4gICAgZXZlbnRIYW5kbGluZyh0aGlzLCAnY2hhbmdlJywgJ2Nvbm5lY3RlZCcsICd3aXJlLWJ1c3knLCAnd2lyZS1kb25lJywgJ25vdC1jb25uZWN0ZWQnKTtcblxuICAgIHRoaXMucnMgPSByZW1vdGVTdG9yYWdlO1xuICAgIHRoaXMuY2xpZW50SWQgPSBjbGllbnRJZDtcblxuICAgIHRoaXMuX2ZpbGVJZENhY2hlID0gbmV3IENhY2hlKDYwICogNSk7IC8vIGlkcyBleHBpcmUgYWZ0ZXIgNSBtaW51dGVzIChpcyB0aGlzIGEgZ29vZCBpZGVhPylcbiAgfTtcblxuICBHb29nbGVEcml2ZS5wcm90b3R5cGUgPSB7XG4gICAgY29ubmVjdGVkOiBmYWxzZSxcbiAgICBvbmxpbmU6IHRydWUsXG5cbiAgICBjb25maWd1cmU6IGZ1bmN0aW9uIChzZXR0aW5ncykgeyAvLyBTZXR0aW5ncyBwYXJhbWV0ZXIgY29tcGF0aWJsZSB3aXRoIFdpcmVDbGllbnRcbiAgICAgIGlmIChzZXR0aW5ncy50b2tlbikge1xuICAgICAgICBsb2NhbFN0b3JhZ2VbJ3JlbW90ZXN0b3JhZ2U6Z29vZ2xlZHJpdmU6dG9rZW4nXSA9IHNldHRpbmdzLnRva2VuO1xuICAgICAgICB0aGlzLnRva2VuID0gc2V0dGluZ3MudG9rZW47XG4gICAgICAgIHRoaXMuY29ubmVjdGVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5fZW1pdCgnY29ubmVjdGVkJyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmNvbm5lY3RlZCA9IGZhbHNlO1xuICAgICAgICBkZWxldGUgdGhpcy50b2tlbjtcbiAgICAgICAgZGVsZXRlIGxvY2FsU3RvcmFnZVsncmVtb3Rlc3RvcmFnZTpnb29nbGVkcml2ZTp0b2tlbiddO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBjb25uZWN0OiBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLnJzLnNldEJhY2tlbmQoJ2dvb2dsZWRyaXZlJyk7XG4gICAgICBBdXRob3JpemUodGhpcy5ycywgQVVUSF9VUkwsIEFVVEhfU0NPUEUsIFN0cmluZyhBdXRob3JpemUuZ2V0TG9jYXRpb24oKSksIHRoaXMuY2xpZW50SWQpO1xuICAgIH0sXG5cbiAgICBzdG9wV2FpdGluZ0ZvclRva2VuOiBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoIXRoaXMuY29ubmVjdGVkKSB7XG4gICAgICAgIHRoaXMuX2VtaXQoJ25vdC1jb25uZWN0ZWQnKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgZ2V0OiBmdW5jdGlvbiAocGF0aCwgb3B0aW9ucykge1xuICAgICAgaWYgKHBhdGguc3Vic3RyKC0xKSA9PT0gJy8nKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9nZXRGb2xkZXIocGF0aCwgb3B0aW9ucyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdGhpcy5fZ2V0RmlsZShwYXRoLCBvcHRpb25zKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgcHV0OiBmdW5jdGlvbiAocGF0aCwgYm9keSwgY29udGVudFR5cGUsIG9wdGlvbnMpIHtcbiAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgIGZ1bmN0aW9uIHB1dERvbmUocmVzcG9uc2UpIHtcbiAgICAgICAgaWYgKHJlc3BvbnNlLnN0YXR1cyA+PSAyMDAgJiYgcmVzcG9uc2Uuc3RhdHVzIDwgMzAwKSB7XG4gICAgICAgICAgdmFyIG1ldGEgPSBKU09OLnBhcnNlKHJlc3BvbnNlLnJlc3BvbnNlVGV4dCk7XG4gICAgICAgICAgdmFyIGV0YWdXaXRob3V0UXVvdGVzID0gbWV0YS5ldGFnLnN1YnN0cmluZygxLCBtZXRhLmV0YWcubGVuZ3RoLTEpO1xuICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoe3N0YXR1c0NvZGU6IDIwMCwgY29udGVudFR5cGU6IG1ldGEubWltZVR5cGUsIHJldmlzaW9uOiBldGFnV2l0aG91dFF1b3Rlc30pO1xuICAgICAgICB9IGVsc2UgaWYgKHJlc3BvbnNlLnN0YXR1cyA9PT0gNDEyKSB7XG4gICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh7c3RhdHVzQ29kZTogNDEyLCByZXZpc2lvbjogJ2NvbmZsaWN0J30pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChcIlBVVCBmYWlsZWQgd2l0aCBzdGF0dXMgXCIgKyByZXNwb25zZS5zdGF0dXMgKyBcIiAoXCIgKyByZXNwb25zZS5yZXNwb25zZVRleHQgKyBcIilcIik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBzZWxmLl9nZXRGaWxlSWQocGF0aCkudGhlbihmdW5jdGlvbiAoaWQpIHtcbiAgICAgICAgaWYgKGlkKSB7XG4gICAgICAgICAgaWYgKG9wdGlvbnMgJiYgKG9wdGlvbnMuaWZOb25lTWF0Y2ggPT09ICcqJykpIHtcbiAgICAgICAgICAgIHJldHVybiBwdXREb25lKHsgc3RhdHVzOiA0MTIgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBzZWxmLl91cGRhdGVGaWxlKGlkLCBwYXRoLCBib2R5LCBjb250ZW50VHlwZSwgb3B0aW9ucykudGhlbihwdXREb25lKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gc2VsZi5fY3JlYXRlRmlsZShwYXRoLCBib2R5LCBjb250ZW50VHlwZSwgb3B0aW9ucykudGhlbihwdXREb25lKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSxcblxuICAgICdkZWxldGUnOiBmdW5jdGlvbiAocGF0aCwgb3B0aW9ucykge1xuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgcmV0dXJuIHNlbGYuX2dldEZpbGVJZChwYXRoKS50aGVuKGZ1bmN0aW9uIChpZCkge1xuICAgICAgICBpZiAoIWlkKSB7XG4gICAgICAgICAgLy8gRmlsZSBkb2Vzbid0IGV4aXN0LiBJZ25vcmUuXG4gICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh7c3RhdHVzQ29kZTogMjAwfSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gc2VsZi5fZ2V0TWV0YShpZCkudGhlbihmdW5jdGlvbiAobWV0YSkge1xuICAgICAgICAgIHZhciBldGFnV2l0aG91dFF1b3RlcztcbiAgICAgICAgICBpZiAoKHR5cGVvZiBtZXRhID09PSAnb2JqZWN0JykgJiYgKHR5cGVvZiBtZXRhLmV0YWcgPT09ICdzdHJpbmcnKSkge1xuICAgICAgICAgICAgZXRhZ1dpdGhvdXRRdW90ZXMgPSBtZXRhLmV0YWcuc3Vic3RyaW5nKDEsIG1ldGEuZXRhZy5sZW5ndGgtMSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMuaWZNYXRjaCAmJiAob3B0aW9ucy5pZk1hdGNoICE9PSBldGFnV2l0aG91dFF1b3RlcykpIHtcbiAgICAgICAgICAgIHJldHVybiB7c3RhdHVzQ29kZTogNDEyLCByZXZpc2lvbjogZXRhZ1dpdGhvdXRRdW90ZXN9O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBzZWxmLl9yZXF1ZXN0KCdERUxFVEUnLCBCQVNFX1VSTCArICcvZHJpdmUvdjIvZmlsZXMvJyArIGlkLCB7fSkudGhlbihmdW5jdGlvbiAocmVzcG9uc2UpIHtcbiAgICAgICAgICAgIGlmIChyZXNwb25zZS5zdGF0dXMgPT09IDIwMCB8fCByZXNwb25zZS5zdGF0dXMgPT09IDIwNCkge1xuICAgICAgICAgICAgICByZXR1cm4ge3N0YXR1c0NvZGU6IDIwMH07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoXCJEZWxldGUgZmFpbGVkOiBcIiArIHJlc3BvbnNlLnN0YXR1cyArIFwiIChcIiArIHJlc3BvbnNlLnJlc3BvbnNlVGV4dCArIFwiKVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9LFxuXG4gICAgX3VwZGF0ZUZpbGU6IGZ1bmN0aW9uIChpZCwgcGF0aCwgYm9keSwgY29udGVudFR5cGUsIG9wdGlvbnMpIHtcbiAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgIHZhciBtZXRhZGF0YSA9IHtcbiAgICAgICAgbWltZVR5cGU6IGNvbnRlbnRUeXBlXG4gICAgICB9O1xuICAgICAgdmFyIGhlYWRlcnMgPSB7XG4gICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbjsgY2hhcnNldD1VVEYtOCdcbiAgICAgIH07XG5cbiAgICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMuaWZNYXRjaCkge1xuICAgICAgICBoZWFkZXJzWydJZi1NYXRjaCddID0gJ1wiJyArIG9wdGlvbnMuaWZNYXRjaCArICdcIic7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzZWxmLl9yZXF1ZXN0KCdQVVQnLCBCQVNFX1VSTCArICcvdXBsb2FkL2RyaXZlL3YyL2ZpbGVzLycgKyBpZCArICc/dXBsb2FkVHlwZT1yZXN1bWFibGUnLCB7XG4gICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KG1ldGFkYXRhKSxcbiAgICAgICAgaGVhZGVyczogaGVhZGVyc1xuICAgICAgfSkudGhlbihmdW5jdGlvbiAocmVzcG9uc2UpIHtcbiAgICAgICAgaWYgKHJlc3BvbnNlLnN0YXR1cyA9PT0gNDEyKSB7XG4gICAgICAgICAgcmV0dXJuIChyZXNwb25zZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIHNlbGYuX3JlcXVlc3QoJ1BVVCcsIHJlc3BvbnNlLmdldFJlc3BvbnNlSGVhZGVyKCdMb2NhdGlvbicpLCB7XG4gICAgICAgICAgICBib2R5OiBjb250ZW50VHlwZS5tYXRjaCgvXmFwcGxpY2F0aW9uXFwvanNvbi8pID8gSlNPTi5zdHJpbmdpZnkoYm9keSkgOiBib2R5XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0sXG5cbiAgICBfY3JlYXRlRmlsZTogZnVuY3Rpb24gKHBhdGgsIGJvZHksIGNvbnRlbnRUeXBlLCBvcHRpb25zKSB7XG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICByZXR1cm4gc2VsZi5fZ2V0UGFyZW50SWQocGF0aCkudGhlbihmdW5jdGlvbiAocGFyZW50SWQpIHtcbiAgICAgICAgdmFyIGZpbGVOYW1lID0gYmFzZU5hbWUocGF0aCk7XG4gICAgICAgIHZhciBtZXRhZGF0YSA9IHtcbiAgICAgICAgICB0aXRsZTogbWV0YVRpdGxlRnJvbUZpbGVOYW1lKGZpbGVOYW1lKSxcbiAgICAgICAgICBtaW1lVHlwZTogY29udGVudFR5cGUsXG4gICAgICAgICAgcGFyZW50czogW3tcbiAgICAgICAgICAgIGtpbmQ6IFwiZHJpdmUjZmlsZUxpbmtcIixcbiAgICAgICAgICAgIGlkOiBwYXJlbnRJZFxuICAgICAgICAgIH1dXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBzZWxmLl9yZXF1ZXN0KCdQT1NUJywgQkFTRV9VUkwgKyAnL3VwbG9hZC9kcml2ZS92Mi9maWxlcz91cGxvYWRUeXBlPXJlc3VtYWJsZScsIHtcbiAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShtZXRhZGF0YSksXG4gICAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uOyBjaGFyc2V0PVVURi04J1xuICAgICAgICAgIH1cbiAgICAgICAgfSkudGhlbihmdW5jdGlvbiAocmVzcG9uc2UpIHtcbiAgICAgICAgICByZXR1cm4gc2VsZi5fcmVxdWVzdCgnUE9TVCcsIHJlc3BvbnNlLmdldFJlc3BvbnNlSGVhZGVyKCdMb2NhdGlvbicpLCB7XG4gICAgICAgICAgICBib2R5OiBjb250ZW50VHlwZS5tYXRjaCgvXmFwcGxpY2F0aW9uXFwvanNvbi8pID8gSlNPTi5zdHJpbmdpZnkoYm9keSkgOiBib2R5XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfSxcblxuICAgIF9nZXRGaWxlOiBmdW5jdGlvbiAocGF0aCwgb3B0aW9ucykge1xuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgcmV0dXJuIHNlbGYuX2dldEZpbGVJZChwYXRoKS50aGVuKGZ1bmN0aW9uIChpZCkge1xuICAgICAgICByZXR1cm4gc2VsZi5fZ2V0TWV0YShpZCkudGhlbihmdW5jdGlvbiAobWV0YSkge1xuICAgICAgICAgIHZhciBldGFnV2l0aG91dFF1b3RlcztcbiAgICAgICAgICBpZiAodHlwZW9mKG1ldGEpID09PSAnb2JqZWN0JyAmJiB0eXBlb2YobWV0YS5ldGFnKSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGV0YWdXaXRob3V0UXVvdGVzID0gbWV0YS5ldGFnLnN1YnN0cmluZygxLCBtZXRhLmV0YWcubGVuZ3RoLTEpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMuaWZOb25lTWF0Y2ggJiYgKGV0YWdXaXRob3V0UXVvdGVzID09PSBvcHRpb25zLmlmTm9uZU1hdGNoKSkge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh7c3RhdHVzQ29kZTogMzA0fSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIG9wdGlvbnMyID0ge307XG4gICAgICAgICAgaWYgKCFtZXRhLmRvd25sb2FkVXJsKSB7XG4gICAgICAgICAgICBpZiAobWV0YS5leHBvcnRMaW5rcyAmJiBtZXRhLmV4cG9ydExpbmtzWyd0ZXh0L2h0bWwnXSkge1xuICAgICAgICAgICAgICAvLyBEb2N1bWVudHMgdGhhdCB3ZXJlIGdlbmVyYXRlZCBpbnNpZGUgR29vZ2xlRG9jcyBoYXZlIG5vXG4gICAgICAgICAgICAgIC8vIGRvd25sb2FkVXJsLCBidXQgeW91IGNhbiBleHBvcnQgdGhlbSB0byB0ZXh0L2h0bWwgaW5zdGVhZDpcbiAgICAgICAgICAgICAgbWV0YS5taW1lVHlwZSArPSAnO2V4cG9ydD10ZXh0L2h0bWwnO1xuICAgICAgICAgICAgICBtZXRhLmRvd25sb2FkVXJsID0gbWV0YS5leHBvcnRMaW5rc1sndGV4dC9odG1sJ107XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAvLyBlbXB0eSBmaWxlXG4gICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoe3N0YXR1c0NvZGU6IDIwMCwgYm9keTogJycsIGNvbnRlbnRUeXBlOiBtZXRhLm1pbWVUeXBlLCByZXZpc2lvbjogZXRhZ1dpdGhvdXRRdW90ZXN9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAobWV0YS5taW1lVHlwZS5tYXRjaCgvY2hhcnNldD1iaW5hcnkvKSkge1xuICAgICAgICAgICAgb3B0aW9uczIucmVzcG9uc2VUeXBlID0gJ2Jsb2InO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gc2VsZi5fcmVxdWVzdCgnR0VUJywgbWV0YS5kb3dubG9hZFVybCwgb3B0aW9uczIpLnRoZW4oZnVuY3Rpb24gKHJlc3BvbnNlKSB7XG4gICAgICAgICAgICB2YXIgYm9keSA9IHJlc3BvbnNlLnJlc3BvbnNlO1xuICAgICAgICAgICAgaWYgKG1ldGEubWltZVR5cGUubWF0Y2goL15hcHBsaWNhdGlvblxcL2pzb24vKSkge1xuICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGJvZHkgPSBKU09OLnBhcnNlKGJvZHkpO1xuICAgICAgICAgICAgICB9IGNhdGNoKGUpIHt9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHtzdGF0dXNDb2RlOiAyMDAsIGJvZHk6IGJvZHksIGNvbnRlbnRUeXBlOiBtZXRhLm1pbWVUeXBlLCByZXZpc2lvbjogZXRhZ1dpdGhvdXRRdW90ZXN9KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9LFxuXG4gICAgX2dldEZvbGRlcjogZnVuY3Rpb24gKHBhdGgsIG9wdGlvbnMpIHtcbiAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgIHJldHVybiBzZWxmLl9nZXRGaWxlSWQocGF0aCkudGhlbihmdW5jdGlvbiAoaWQpIHtcbiAgICAgICAgdmFyIHF1ZXJ5LCBmaWVsZHMsIGRhdGEsIGV0YWdXaXRob3V0UXVvdGVzLCBpdGVtc01hcDtcbiAgICAgICAgaWYgKCEgaWQpIHtcbiAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHtzdGF0dXNDb2RlOiA0MDR9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHF1ZXJ5ID0gJ1xcJycgKyBpZCArICdcXCcgaW4gcGFyZW50cyc7XG4gICAgICAgIGZpZWxkcyA9ICdpdGVtcyhkb3dubG9hZFVybCxldGFnLGZpbGVTaXplLGlkLG1pbWVUeXBlLHRpdGxlKSc7XG4gICAgICAgIHJldHVybiBzZWxmLl9yZXF1ZXN0KCdHRVQnLCBCQVNFX1VSTCArICcvZHJpdmUvdjIvZmlsZXM/J1xuICAgICAgICAgICAgKyAncT0nICsgZW5jb2RlVVJJQ29tcG9uZW50KHF1ZXJ5KVxuICAgICAgICAgICAgKyAnJmZpZWxkcz0nICsgZW5jb2RlVVJJQ29tcG9uZW50KGZpZWxkcylcbiAgICAgICAgICAgICsgJyZtYXhSZXN1bHRzPTEwMDAnLFxuICAgICAgICAgICAge30pXG4gICAgICAgIC50aGVuKGZ1bmN0aW9uIChyZXNwb25zZSkge1xuICAgICAgICAgIGlmIChyZXNwb25zZS5zdGF0dXMgIT09IDIwMCkge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KCdyZXF1ZXN0IGZhaWxlZCBvciBzb21ldGhpbmc6ICcgKyByZXNwb25zZS5zdGF0dXMpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBkYXRhID0gSlNPTi5wYXJzZShyZXNwb25zZS5yZXNwb25zZVRleHQpO1xuICAgICAgICAgIH0gY2F0Y2goZSkge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KCdub24tSlNPTiByZXNwb25zZSBmcm9tIEdvb2dsZURyaXZlJyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaXRlbXNNYXAgPSB7fTtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gZGF0YS5pdGVtcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgZXRhZ1dpdGhvdXRRdW90ZXMgPSBkYXRhLml0ZW1zW2ldLmV0YWcuc3Vic3RyaW5nKDEsIGRhdGEuaXRlbXNbaV0uZXRhZy5sZW5ndGgtMSk7XG4gICAgICAgICAgICBpZiAoZGF0YS5pdGVtc1tpXS5taW1lVHlwZSA9PT0gR0RfRElSX01JTUVfVFlQRSkge1xuICAgICAgICAgICAgICBzZWxmLl9maWxlSWRDYWNoZS5zZXQocGF0aCArIGRhdGEuaXRlbXNbaV0udGl0bGUgKyAnLycsIGRhdGEuaXRlbXNbaV0uaWQpO1xuICAgICAgICAgICAgICBpdGVtc01hcFtkYXRhLml0ZW1zW2ldLnRpdGxlICsgJy8nXSA9IHtcbiAgICAgICAgICAgICAgICBFVGFnOiBldGFnV2l0aG91dFF1b3Rlc1xuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgc2VsZi5fZmlsZUlkQ2FjaGUuc2V0KHBhdGggKyBkYXRhLml0ZW1zW2ldLnRpdGxlLCBkYXRhLml0ZW1zW2ldLmlkKTtcbiAgICAgICAgICAgICAgaXRlbXNNYXBbZGF0YS5pdGVtc1tpXS50aXRsZV0gPSB7XG4gICAgICAgICAgICAgICAgRVRhZzogZXRhZ1dpdGhvdXRRdW90ZXMsXG4gICAgICAgICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6IGRhdGEuaXRlbXNbaV0ubWltZVR5cGUsXG4gICAgICAgICAgICAgICAgJ0NvbnRlbnQtTGVuZ3RoJzogZGF0YS5pdGVtc1tpXS5maWxlU2l6ZVxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBGSVhNRTogYWRkIHJldmlzaW9uIG9mIGZvbGRlciFcbiAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHtzdGF0dXNDb2RlOiAyMDAsIGJvZHk6IGl0ZW1zTWFwLCBjb250ZW50VHlwZTogUlNfRElSX01JTUVfVFlQRSwgcmV2aXNpb246IHVuZGVmaW5lZH0pO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH0sXG5cbiAgICBfZ2V0UGFyZW50SWQ6IGZ1bmN0aW9uIChwYXRoKSB7XG4gICAgICB2YXIgZm9sZGVybmFtZSA9IHBhcmVudFBhdGgocGF0aCk7XG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICByZXR1cm4gc2VsZi5fZ2V0RmlsZUlkKGZvbGRlcm5hbWUpLnRoZW4oZnVuY3Rpb24gKHBhcmVudElkKSB7XG4gICAgICAgIGlmIChwYXJlbnRJZCkge1xuICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUocGFyZW50SWQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBzZWxmLl9jcmVhdGVGb2xkZXIoZm9sZGVybmFtZSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0sXG5cbiAgICBfY3JlYXRlRm9sZGVyOiBmdW5jdGlvbiAocGF0aCkge1xuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgcmV0dXJuIHNlbGYuX2dldFBhcmVudElkKHBhdGgpLnRoZW4oZnVuY3Rpb24gKHBhcmVudElkKSB7XG4gICAgICAgIHJldHVybiBzZWxmLl9yZXF1ZXN0KCdQT1NUJywgQkFTRV9VUkwgKyAnL2RyaXZlL3YyL2ZpbGVzJywge1xuICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICAgIHRpdGxlOiBtZXRhVGl0bGVGcm9tRmlsZU5hbWUoYmFzZU5hbWUocGF0aCkpLFxuICAgICAgICAgICAgbWltZVR5cGU6IEdEX0RJUl9NSU1FX1RZUEUsXG4gICAgICAgICAgICBwYXJlbnRzOiBbe1xuICAgICAgICAgICAgICBpZDogcGFyZW50SWRcbiAgICAgICAgICAgIH1dXG4gICAgICAgICAgfSksXG4gICAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uOyBjaGFyc2V0PVVURi04J1xuICAgICAgICAgIH1cbiAgICAgICAgfSkudGhlbihmdW5jdGlvbiAocmVzcG9uc2UpIHtcbiAgICAgICAgICB2YXIgbWV0YSA9IEpTT04ucGFyc2UocmVzcG9uc2UucmVzcG9uc2VUZXh0KTtcbiAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKG1ldGEuaWQpO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH0sXG5cbiAgICBfZ2V0RmlsZUlkOiBmdW5jdGlvbiAocGF0aCkge1xuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgdmFyIGlkO1xuICAgICAgaWYgKHBhdGggPT09ICcvJykge1xuICAgICAgICAvLyBcInJvb3RcIiBpcyBhIHNwZWNpYWwgYWxpYXMgZm9yIHRoZSBmaWxlSWQgb2YgdGhlIHJvb3QgZm9sZGVyXG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoJ3Jvb3QnKTtcbiAgICAgIH0gZWxzZSBpZiAoKGlkID0gdGhpcy5fZmlsZUlkQ2FjaGUuZ2V0KHBhdGgpKSkge1xuICAgICAgICAvLyBpZCBpcyBjYWNoZWQuXG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoaWQpO1xuICAgICAgfVxuICAgICAgLy8gaWQgaXMgbm90IGNhY2hlZCAob3IgZmlsZSBkb2Vzbid0IGV4aXN0KS5cbiAgICAgIC8vIGxvYWQgcGFyZW50IGZvbGRlciBsaXN0aW5nIHRvIHByb3BhZ2F0ZSAvIHVwZGF0ZSBpZCBjYWNoZS5cbiAgICAgIHJldHVybiBzZWxmLl9nZXRGb2xkZXIocGFyZW50UGF0aChwYXRoKSkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlkID0gc2VsZi5fZmlsZUlkQ2FjaGUuZ2V0KHBhdGgpO1xuICAgICAgICBpZiAoIWlkKSB7XG4gICAgICAgICAgaWYgKHBhdGguc3Vic3RyKC0xKSA9PT0gJy8nKSB7XG4gICAgICAgICAgICByZXR1cm4gc2VsZi5fY3JlYXRlRm9sZGVyKHBhdGgpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICByZXR1cm4gc2VsZi5fZ2V0RmlsZUlkKHBhdGgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoaWQpO1xuICAgICAgfSk7XG4gICAgfSxcblxuICAgIF9nZXRNZXRhOiBmdW5jdGlvbiAoaWQpIHtcbiAgICAgIHJldHVybiB0aGlzLl9yZXF1ZXN0KCdHRVQnLCBCQVNFX1VSTCArICcvZHJpdmUvdjIvZmlsZXMvJyArIGlkLCB7fSkudGhlbihmdW5jdGlvbiAocmVzcG9uc2UpIHtcbiAgICAgICAgaWYgKHJlc3BvbnNlLnN0YXR1cyA9PT0gMjAwKSB7XG4gICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShKU09OLnBhcnNlKHJlc3BvbnNlLnJlc3BvbnNlVGV4dCkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChcInJlcXVlc3QgKGdldHRpbmcgbWV0YWRhdGEgZm9yIFwiICsgaWQgKyBcIikgZmFpbGVkIHdpdGggc3RhdHVzOiBcIiArIHJlc3BvbnNlLnN0YXR1cyk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNZXRob2Q6IGluZm9cbiAgICAgKlxuICAgICAqIEZldGNoZXMgdGhlIHVzZXIncyBpbmZvIGZyb20gZHJvcGJveCBhbmQgcmV0dXJucyBhIHByb21pc2UgZm9yIGl0LlxuICAgICAqXG4gICAgICogUmV0dXJuczpcbiAgICAgKlxuICAgICAqICAgQSBwcm9taXNlIHRvIHRoZSB1c2VyJ3MgaW5mb1xuICAgICAqL1xuICAgIGluZm86IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciB1cmwgPSBCQVNFX1VSTCArICcvZHJpdmUvdjIvYWJvdXQnO1xuICAgICAgLy8gcmVxdWVzdGluZyB1c2VyIGluZm8obWFpbmx5IGZvciB1c2VyQWRyZXNzKVxuICAgICAgcmV0dXJuIHRoaXMuX3JlcXVlc3QoJ0dFVCcsIHVybCwge30pLnRoZW4oZnVuY3Rpb24gKHJlc3Ape1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHZhciBpbmZvID0gSlNPTi5wYXJzZShyZXNwLnJlc3BvbnNlVGV4dCk7XG4gICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShpbmZvKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSxcblxuXG4gICAgX3JlcXVlc3Q6IGZ1bmN0aW9uIChtZXRob2QsIHVybCwgb3B0aW9ucykge1xuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgICBpZiAoISBvcHRpb25zLmhlYWRlcnMpIHsgb3B0aW9ucy5oZWFkZXJzID0ge307IH1cbiAgICAgIG9wdGlvbnMuaGVhZGVyc1snQXV0aG9yaXphdGlvbiddID0gJ0JlYXJlciAnICsgc2VsZi50b2tlbjtcblxuICAgICAgdGhpcy5fZW1pdCgnd2lyZS1idXN5Jywge1xuICAgICAgICBtZXRob2Q6IG1ldGhvZCxcbiAgICAgICAgaXNGb2xkZXI6IGlzRm9sZGVyKHVybClcbiAgICAgIH0pO1xuXG4gICAgICByZXR1cm4gV2lyZUNsaWVudC5yZXF1ZXN0LmNhbGwodGhpcywgbWV0aG9kLCB1cmwsIG9wdGlvbnMpLnRoZW4oZnVuY3Rpb24oeGhyKSB7XG4gICAgICAgIC8vIEdvb2dsZSB0b2tlbnMgZXhwaXJlIGZyb20gdGltZSB0byB0aW1lLi4uXG4gICAgICAgIGlmICh4aHIgJiYgeGhyLnN0YXR1cyA9PT0gNDAxKSB7XG4gICAgICAgICAgc2VsZi5jb25uZWN0KCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmICghc2VsZi5vbmxpbmUpIHtcbiAgICAgICAgICAgIHNlbGYub25saW5lID0gdHJ1ZTtcbiAgICAgICAgICAgIHNlbGYucnMuX2VtaXQoJ25ldHdvcmstb25saW5lJyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHNlbGYuX2VtaXQoJ3dpcmUtZG9uZScsIHtcbiAgICAgICAgICAgIG1ldGhvZDogbWV0aG9kLFxuICAgICAgICAgICAgaXNGb2xkZXI6IGlzRm9sZGVyKHVybCksXG4gICAgICAgICAgICBzdWNjZXNzOiB0cnVlXG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHhocik7XG4gICAgICAgIH1cbiAgICAgIH0sIGZ1bmN0aW9uKGVycm9yKSB7XG4gICAgICAgIGlmIChzZWxmLm9ubGluZSkge1xuICAgICAgICAgIHNlbGYub25saW5lID0gZmFsc2U7XG4gICAgICAgICAgc2VsZi5ycy5fZW1pdCgnbmV0d29yay1vZmZsaW5lJyk7XG4gICAgICAgIH1cbiAgICAgICAgc2VsZi5fZW1pdCgnd2lyZS1kb25lJywge1xuICAgICAgICAgIG1ldGhvZDogbWV0aG9kLFxuICAgICAgICAgIGlzRm9sZGVyOiBpc0ZvbGRlcih1cmwpLFxuICAgICAgICAgIHN1Y2Nlc3M6IGZhbHNlXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlcnJvcik7XG4gICAgICB9KTtcbiAgICB9XG4gIH07XG5cbiAgR29vZ2xlRHJpdmUuX3JzX2luaXQgPSBmdW5jdGlvbiAocmVtb3RlU3RvcmFnZSkge1xuICAgIHZhciBjb25maWcgPSByZW1vdGVTdG9yYWdlLmFwaUtleXMuZ29vZ2xlZHJpdmU7XG4gICAgaWYgKGNvbmZpZykge1xuICAgICAgcmVtb3RlU3RvcmFnZS5nb29nbGVkcml2ZSA9IG5ldyBHb29nbGVEcml2ZShyZW1vdGVTdG9yYWdlLCBjb25maWcuY2xpZW50SWQpO1xuICAgICAgaWYgKHJlbW90ZVN0b3JhZ2UuYmFja2VuZCA9PT0gJ2dvb2dsZWRyaXZlJykge1xuICAgICAgICByZW1vdGVTdG9yYWdlLl9vcmlnUmVtb3RlID0gcmVtb3RlU3RvcmFnZS5yZW1vdGU7XG4gICAgICAgIHJlbW90ZVN0b3JhZ2UucmVtb3RlID0gcmVtb3RlU3RvcmFnZS5nb29nbGVkcml2ZTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgR29vZ2xlRHJpdmUuX3JzX3N1cHBvcnRlZCA9IGZ1bmN0aW9uIChycykge1xuICAgIHJldHVybiB0cnVlO1xuICB9O1xuXG4gIEdvb2dsZURyaXZlLl9yc19jbGVhbnVwID0gZnVuY3Rpb24gKHJlbW90ZVN0b3JhZ2UpIHtcbiAgICByZW1vdGVTdG9yYWdlLnNldEJhY2tlbmQodW5kZWZpbmVkKTtcbiAgICBpZiAocmVtb3RlU3RvcmFnZS5fb3JpZ1JlbW90ZSkge1xuICAgICAgcmVtb3RlU3RvcmFnZS5yZW1vdGUgPSByZW1vdGVTdG9yYWdlLl9vcmlnUmVtb3RlO1xuICAgICAgZGVsZXRlIHJlbW90ZVN0b3JhZ2UuX29yaWdSZW1vdGU7XG4gICAgfVxuICB9O1xuXG5cbiAgbW9kdWxlLmV4cG9ydHMgPSBHb29nbGVEcml2ZTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9nb29nbGVkcml2ZS5qcyJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ },
/* 20 */
/***/ function(module, exports, __webpack_require__) {

	eval("/* WEBPACK VAR INJECTION */(function(global) {'use strict';\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar log = __webpack_require__(4);\nvar util = __webpack_require__(2);\nvar WebFinger = __webpack_require__(21);\n\n// feature detection flags\nvar haveXMLHttpRequest, hasLocalStorage;\n// used to store settings in localStorage\nvar SETTINGS_KEY = 'remotestorage:discover';\n// cache loaded from localStorage\nvar cachedInfo = {};\n\n/**\n * Class: RemoteStorage.Discover\n *\n * This function deals with the Webfinger lookup, discovering a connecting\n * user's storage details.\n *\n * The discovery timeout can be configured via\n * `RemoteStorage.config.discoveryTimeout` (in ms).\n *\n * Arguments:\n *\n *   userAddress - user@host\n *\n * Returns:\n *\n * A promise for an object with the following properties.\n *\n *   href - Storage base URL,\n *   storageType - Storage type,\n *   authUrl - OAuth URL,\n *   properties - Webfinger link properties\n **/\n\nvar Discover = function Discover(userAddress) {\n  if (userAddress in cachedInfo) {\n    return Promise.resolve(cachedInfo[userAddress]);\n  }\n\n  var webFinger = new WebFinger({\n    tls_only: false,\n    uri_fallback: true,\n    request_timeout: 5000\n  });\n\n  var pending = Promise.defer();\n\n  webFinger.lookup(userAddress, function (err, response) {\n    if (err) {\n      return pending.reject(err);\n    } else if (_typeof(response.idx.links.remotestorage) !== 'object' || typeof response.idx.links.remotestorage.length !== 'number' || response.idx.links.remotestorage.length <= 0) {\n      log(\"[Discover] WebFinger record for \" + userAddress + \" does not have remotestorage defined in the links section \", JSON.stringify(response.json));\n      return pending.reject(\"WebFinger record for \" + userAddress + \" does not have remotestorage defined in the links section.\");\n    }\n\n    var rs = response.idx.links.remotestorage[0];\n    var authURL = rs.properties['http://tools.ietf.org/html/rfc6749#section-4.2'] || rs.properties['auth-endpoint'];\n    var storageType = rs.properties['http://remotestorage.io/spec/version'] || rs.type;\n\n    // cache fetched data\n    cachedInfo[userAddress] = { href: rs.href, storageType: storageType, authURL: authURL, properties: rs.properties };\n\n    if (hasLocalStorage) {\n      localStorage[SETTINGS_KEY] = JSON.stringify({ cache: cachedInfo });\n    }\n\n    return pending.resolve(cachedInfo[userAddress]);\n  });\n\n  return pending.promise;\n};\n\nDiscover.DiscoveryError = function (message) {\n  Error.apply(this, arguments);\n  this.message = message;\n};\n\nDiscover.DiscoveryError.prototype = Object.create(Error.prototype);\n\nDiscover._rs_init = function (remoteStorage) {\n  hasLocalStorage = util.localStorageAvailable();\n  if (hasLocalStorage) {\n    var settings;\n    try {\n      settings = JSON.parse(localStorage[SETTINGS_KEY]);\n    } catch (e) {}\n    if (settings) {\n      cachedInfo = settings.cache;\n    }\n  }\n};\n\nDiscover._rs_supported = function () {\n  haveXMLHttpRequest = !!global.XMLHttpRequest;\n  return haveXMLHttpRequest;\n};\n\nDiscover._rs_cleanup = function () {\n  if (hasLocalStorage) {\n    delete localStorage[SETTINGS_KEY];\n  }\n};\n\nmodule.exports = Discover;\n/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvZGlzY292ZXIuanM/MTQyOSJdLCJuYW1lcyI6WyJsb2ciLCJyZXF1aXJlIiwidXRpbCIsIldlYkZpbmdlciIsImhhdmVYTUxIdHRwUmVxdWVzdCIsImhhc0xvY2FsU3RvcmFnZSIsIlNFVFRJTkdTX0tFWSIsImNhY2hlZEluZm8iLCJEaXNjb3ZlciIsInVzZXJBZGRyZXNzIiwiUHJvbWlzZSIsInJlc29sdmUiLCJ3ZWJGaW5nZXIiLCJ0bHNfb25seSIsInVyaV9mYWxsYmFjayIsInJlcXVlc3RfdGltZW91dCIsInBlbmRpbmciLCJkZWZlciIsImxvb2t1cCIsImVyciIsInJlc3BvbnNlIiwicmVqZWN0IiwiaWR4IiwibGlua3MiLCJyZW1vdGVzdG9yYWdlIiwibGVuZ3RoIiwiSlNPTiIsInN0cmluZ2lmeSIsImpzb24iLCJycyIsImF1dGhVUkwiLCJwcm9wZXJ0aWVzIiwic3RvcmFnZVR5cGUiLCJ0eXBlIiwiaHJlZiIsImxvY2FsU3RvcmFnZSIsImNhY2hlIiwicHJvbWlzZSIsIkRpc2NvdmVyeUVycm9yIiwibWVzc2FnZSIsIkVycm9yIiwiYXBwbHkiLCJhcmd1bWVudHMiLCJwcm90b3R5cGUiLCJPYmplY3QiLCJjcmVhdGUiLCJfcnNfaW5pdCIsInJlbW90ZVN0b3JhZ2UiLCJsb2NhbFN0b3JhZ2VBdmFpbGFibGUiLCJzZXR0aW5ncyIsInBhcnNlIiwiZSIsIl9yc19zdXBwb3J0ZWQiLCJnbG9iYWwiLCJYTUxIdHRwUmVxdWVzdCIsIl9yc19jbGVhbnVwIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJtYXBwaW5ncyI6Ijs7OztBQUFFLElBQUlBLE1BQU0sbUJBQUFDLENBQVEsQ0FBUixDQUFWO0FBQ0EsSUFBSUMsT0FBTyxtQkFBQUQsQ0FBUSxDQUFSLENBQVg7QUFDQSxJQUFJRSxZQUFZLG1CQUFBRixDQUFRLEVBQVIsQ0FBaEI7O0FBRUE7QUFDQSxJQUFJRyxrQkFBSixFQUF3QkMsZUFBeEI7QUFDQTtBQUNBLElBQUlDLGVB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QUFTYixLQUF0QjtBQUNEO0FBQ0Y7QUFDRixDQVREOztBQVdBNUIsU0FBUzRDLGFBQVQsR0FBeUIsWUFBWTtBQUNuQ2hELHVCQUFxQixDQUFDLENBQUVpRCxPQUFPQyxjQUEvQjtBQUNBLFNBQU9sRCxrQkFBUDtBQUNELENBSEQ7O0FBS0FJLFNBQVMrQyxXQUFULEdBQXVCLFlBQVk7QUFDakMsTUFBSWxELGVBQUosRUFBcUI7QUFDbkIsV0FBTzhCLGFBQWE3QixZQUFiLENBQVA7QUFDRDtBQUNGLENBSkQ7O0FBT0FrRCxPQUFPQyxPQUFQLEdBQWlCakQsUUFBakIsQyIsImZpbGUiOiIyMC5qcyIsInNvdXJjZXNDb250ZW50IjpbIiAgdmFyIGxvZyA9IHJlcXVpcmUoJy4vbG9nJyk7XG4gIHZhciB1dGlsID0gcmVxdWlyZSgnLi91dGlsJyk7XG4gIHZhciBXZWJGaW5nZXIgPSByZXF1aXJlKCd3ZWJmaW5nZXIuanMnKTtcblxuICAvLyBmZWF0dXJlIGRldGVjdGlvbiBmbGFnc1xuICB2YXIgaGF2ZVhNTEh0dHBSZXF1ZXN0LCBoYXNMb2NhbFN0b3JhZ2U7XG4gIC8vIHVzZWQgdG8gc3RvcmUgc2V0dGluZ3MgaW4gbG9jYWxTdG9yYWdlXG4gIHZhciBTRVRUSU5HU19LRVkgPSAncmVtb3Rlc3RvcmFnZTpkaXNjb3Zlcic7XG4gIC8vIGNhY2hlIGxvYWRlZCBmcm9tIGxvY2FsU3RvcmFnZVxuICB2YXIgY2FjaGVkSW5mbyA9IHt9O1xuXG4gIC8qKlxuICAgKiBDbGFzczogUmVtb3RlU3RvcmFnZS5EaXNjb3ZlclxuICAgKlxuICAgKiBUaGlzIGZ1bmN0aW9uIGRlYWxzIHdpdGggdGhlIFdlYmZpbmdlciBsb29rdXAsIGRpc2NvdmVyaW5nIGEgY29ubmVjdGluZ1xuICAgKiB1c2VyJ3Mgc3RvcmFnZSBkZXRhaWxzLlxuICAgKlxuICAgKiBUaGUgZGlzY292ZXJ5IHRpbWVvdXQgY2FuIGJlIGNvbmZpZ3VyZWQgdmlhXG4gICAqIGBSZW1vdGVTdG9yYWdlLmNvbmZpZy5kaXNjb3ZlcnlUaW1lb3V0YCAoaW4gbXMpLlxuICAgKlxuICAgKiBBcmd1bWVudHM6XG4gICAqXG4gICAqICAgdXNlckFkZHJlc3MgLSB1c2VyQGhvc3RcbiAgICpcbiAgICogUmV0dXJuczpcbiAgICpcbiAgICogQSBwcm9taXNlIGZvciBhbiBvYmplY3Qgd2l0aCB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXMuXG4gICAqXG4gICAqICAgaHJlZiAtIFN0b3JhZ2UgYmFzZSBVUkwsXG4gICAqICAgc3RvcmFnZVR5cGUgLSBTdG9yYWdlIHR5cGUsXG4gICAqICAgYXV0aFVybCAtIE9BdXRoIFVSTCxcbiAgICogICBwcm9wZXJ0aWVzIC0gV2ViZmluZ2VyIGxpbmsgcHJvcGVydGllc1xuICAgKiovXG5cbiAgdmFyIERpc2NvdmVyID0gZnVuY3Rpb24gKHVzZXJBZGRyZXNzKSB7XG4gICAgaWYgKHVzZXJBZGRyZXNzIGluIGNhY2hlZEluZm8pIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoY2FjaGVkSW5mb1t1c2VyQWRkcmVzc10pO1xuICAgIH1cblxuICAgIHZhciB3ZWJGaW5nZXIgPSBuZXcgV2ViRmluZ2VyKHtcbiAgICAgIHRsc19vbmx5OiBmYWxzZSxcbiAgICAgIHVyaV9mYWxsYmFjazogdHJ1ZSxcbiAgICAgIHJlcXVlc3RfdGltZW91dDogNTAwMFxuICAgIH0pO1xuXG4gICAgdmFyIHBlbmRpbmcgPSBQcm9taXNlLmRlZmVyKCk7XG5cbiAgICB3ZWJGaW5nZXIubG9va3VwKHVzZXJBZGRyZXNzLCBmdW5jdGlvbiAoZXJyLCByZXNwb25zZSkge1xuICAgICAgaWYgKGVycikge1xuICAgICAgICByZXR1cm4gcGVuZGluZy5yZWplY3QoZXJyKTtcbiAgICAgIH0gZWxzZSBpZiAoKHR5cGVvZiByZXNwb25zZS5pZHgubGlua3MucmVtb3Rlc3RvcmFnZSAhPT0gJ29iamVjdCcpIHx8XG4gICAgICAgICAgICAgICAgICh0eXBlb2YgcmVzcG9uc2UuaWR4LmxpbmtzLnJlbW90ZXN0b3JhZ2UubGVuZ3RoICE9PSAnbnVtYmVyJykgfHxcbiAgICAgICAgICAgICAgICAgKHJlc3BvbnNlLmlkeC5saW5rcy5yZW1vdGVzdG9yYWdlLmxlbmd0aCA8PSAwKSkge1xuICAgICAgICBsb2coXCJbRGlzY292ZXJdIFdlYkZpbmdlciByZWNvcmQgZm9yIFwiICsgdXNlckFkZHJlc3MgKyBcIiBkb2VzIG5vdCBoYXZlIHJlbW90ZXN0b3JhZ2UgZGVmaW5lZCBpbiB0aGUgbGlua3Mgc2VjdGlvbiBcIiwgSlNPTi5zdHJpbmdpZnkocmVzcG9uc2UuanNvbikpO1xuICAgICAgICByZXR1cm4gcGVuZGluZy5yZWplY3QoXCJXZWJGaW5nZXIgcmVjb3JkIGZvciBcIiArIHVzZXJBZGRyZXNzICsgXCIgZG9lcyBub3QgaGF2ZSByZW1vdGVzdG9yYWdlIGRlZmluZWQgaW4gdGhlIGxpbmtzIHNlY3Rpb24uXCIpO1xuICAgICAgfVxuXG4gICAgICB2YXIgcnMgPSByZXNwb25zZS5pZHgubGlua3MucmVtb3Rlc3RvcmFnZVswXTtcbiAgICAgIHZhciBhdXRoVVJMID0gcnMucHJvcGVydGllc1snaHR0cDovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNjc0OSNzZWN0aW9uLTQuMiddIHx8XG4gICAgICAgICAgICAgICAgICAgIHJzLnByb3BlcnRpZXNbJ2F1dGgtZW5kcG9pbnQnXTtcbiAgICAgIHZhciBzdG9yYWdlVHlwZSA9IHJzLnByb3BlcnRpZXNbJ2h0dHA6Ly9yZW1vdGVzdG9yYWdlLmlvL3NwZWMvdmVyc2lvbiddIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICBycy50eXBlO1xuXG4gICAgICAvLyBjYWNoZSBmZXRjaGVkIGRhdGFcbiAgICAgIGNhY2hlZEluZm9bdXNlckFkZHJlc3NdID0geyBocmVmOiBycy5ocmVmLCBzdG9yYWdlVHlwZTogc3RvcmFnZVR5cGUsIGF1dGhVUkw6IGF1dGhVUkwsIHByb3BlcnRpZXM6IHJzLnByb3BlcnRpZXMgfTtcblxuICAgICAgaWYgKGhhc0xvY2FsU3RvcmFnZSkge1xuICAgICAgICBsb2NhbFN0b3JhZ2VbU0VUVElOR1NfS0VZXSA9IEpTT04uc3RyaW5naWZ5KHsgY2FjaGU6IGNhY2hlZEluZm8gfSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBwZW5kaW5nLnJlc29sdmUoY2FjaGVkSW5mb1t1c2VyQWRkcmVzc10pO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHBlbmRpbmcucHJvbWlzZTtcbiAgfTtcblxuXG4gIERpc2NvdmVyLkRpc2NvdmVyeUVycm9yID0gZnVuY3Rpb24gKG1lc3NhZ2UpIHtcbiAgICBFcnJvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XG4gIH07XG5cbiAgRGlzY292ZXIuRGlzY292ZXJ5RXJyb3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShFcnJvci5wcm90b3R5cGUpO1xuXG5cbiAgRGlzY292ZXIuX3JzX2luaXQgPSBmdW5jdGlvbiAocmVtb3RlU3RvcmFnZSkge1xuICAgIGhhc0xvY2FsU3RvcmFnZSA9IHV0aWwubG9jYWxTdG9yYWdlQXZhaWxhYmxlKCk7XG4gICAgaWYgKGhhc0xvY2FsU3RvcmFnZSkge1xuICAgICAgdmFyIHNldHRpbmdzO1xuICAgICAgdHJ5IHsgc2V0dGluZ3MgPSBKU09OLnBhcnNlKGxvY2FsU3RvcmFnZVtTRVRUSU5HU19LRVldKTsgfSBjYXRjaChlKSB7fVxuICAgICAgaWYgKHNldHRpbmdzKSB7XG4gICAgICAgIGNhY2hlZEluZm8gPSBzZXR0aW5ncy5jYWNoZTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgRGlzY292ZXIuX3JzX3N1cHBvcnRlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICBoYXZlWE1MSHR0cFJlcXVlc3QgPSAhISBnbG9iYWwuWE1MSHR0cFJlcXVlc3Q7XG4gICAgcmV0dXJuIGhhdmVYTUxIdHRwUmVxdWVzdDtcbiAgfTtcblxuICBEaXNjb3Zlci5fcnNfY2xlYW51cCA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoaGFzTG9jYWxTdG9yYWdlKSB7XG4gICAgICBkZWxldGUgbG9jYWxTdG9yYWdlW1NFVFRJTkdTX0tFWV07XG4gICAgfVxuICB9O1xuXG5cbiAgbW9kdWxlLmV4cG9ydHMgPSBEaXNjb3ZlcjtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9kaXNjb3Zlci5qcyJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ },
/* 21 */
/***/ function(module, exports, __webpack_require__) {

	eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/* global define */\n/*!\n * webfinger.js\n *   version 2.6.0\n *   http://github.com/silverbucket/webfinger.js\n *\n * Developed and Maintained by:\n *   Nick Jennings <nick@silverbucket.net> 2012 - 2016\n *\n * webfinger.js is released under the AGPL (see LICENSE).\n *\n * You don't have to do anything special to choose one license or the other and you don't\n * have to notify anyone which license you are using.\n * Please see the corresponding license file for details of these licenses.\n * You are free to use, modify and distribute this software, but all copyright\n * information must remain.\n *\n */\nif (typeof XMLHttpRequest === 'undefined') {\n  XMLHttpRequest = __webpack_require__(22).XMLHttpRequest;\n}\n\n(function (global) {\n\n  // URI to property name map\n  var LINK_URI_MAPS = {\n    'http://webfist.org/spec/rel': 'webfist',\n    'http://webfinger.net/rel/avatar': 'avatar',\n    'remotestorage': 'remotestorage',\n    'http://tools.ietf.org/id/draft-dejong-remotestorage': 'remotestorage',\n    'remoteStorage': 'remotestorage',\n    'http://www.packetizer.com/rel/share': 'share',\n    'http://webfinger.net/rel/profile-page': 'profile',\n    'me': 'profile',\n    'vcard': 'vcard',\n    'blog': 'blog',\n    'http://packetizer.com/rel/blog': 'blog',\n    'http://schemas.google.com/g/2010#updates-from': 'updates',\n    'https://camlistore.org/rel/server': 'camilstore'\n  };\n\n  var LINK_PROPERTIES = {\n    'avatar': [],\n    'remotestorage': [],\n    'blog': [],\n    'vcard': [],\n    'updates': [],\n    'share': [],\n    'profile': [],\n    'webfist': [],\n    'camlistore': []\n  };\n\n  // list of endpoints to try, fallback from beginning to end.\n  var URIS = ['webfinger', 'host-meta', 'host-meta.json'];\n\n  function generateErrorObject(obj) {\n    obj.toString = function () {\n      return this.message;\n    };\n    return obj;\n  }\n\n  // given a URL ensures it's HTTPS.\n  // returns false for null string or non-HTTPS URL.\n  function isSecure(url) {\n    if (typeof url !== 'string') {\n      return false;\n    }\n    var parts = url.split('://');\n    if (parts[0] === 'https') {\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * Function: WebFinger\n   *\n   * WebFinger constructor\n   *\n   * Returns:\n   *\n   *   return WebFinger object\n   */\n  function WebFinger(config) {\n    if (typeof config !== 'object') {\n      config = {};\n    }\n\n    this.config = {\n      tls_only:         (typeof config.tls_only !== 'undefined') ? config.tls_only : true,\n      webfist_fallback: (typeof config.webfist_fallback !== 'undefined') ? config.webfist_fallback : false,\n      uri_fallback:     (typeof config.uri_fallback !== 'undefined') ? config.uri_fallback : false,\n      request_timeout:  (typeof config.request_timeout !== 'undefined') ? config.request_timeout : 10000\n    };\n  }\n\n  // make an http request and look for JRD response, fails if request fails\n  // or response not json.\n  WebFinger.prototype.__fetchJRD = function (url, errorHandler, sucessHandler) {\n    var self = this;\n\n    var xhr = new XMLHttpRequest();\n    xhr.timeout = this.config.request_timeout;\n\n    function __processState() {\n      if (xhr.status === 200) {\n        if (self.__isValidJSON(xhr.responseText)) {\n          return sucessHandler(xhr.responseText);\n        } else {\n          return errorHandler(generateErrorObject({\n            message: 'invalid json',\n            url: url,\n            status: xhr.status\n          }));\n        }\n      } else if (xhr.status === 404) {\n        return errorHandler(generateErrorObject({\n          message: 'resource not found',\n          url: url,\n          status: xhr.status\n        }));\n      } else if ((xhr.status >= 301) && (xhr.status <= 302)) {\n        var location = xhr.getResponseHeader('Location');\n        if (isSecure(location)) {\n          return __makeRequest(location); // follow redirect\n        } else {\n          return errorHandler(generateErrorObject({\n            message: 'no redirect URL found',\n            url: url,\n            status: xhr.status\n          }));\n        }\n      } else {\n        return errorHandler(generateErrorObject({\n          message: 'error during request',\n          url: url,\n          status: xhr.status\n        }));\n      }\n    }\n\n    function __makeRequest() {\n      xhr.onreadystatechange = function () {\n        if (xhr.readyState === 4) {\n          __processState();\n        }\n      };\n\n      xhr.onload = function () {\n        __processState();\n      };\n\n      xhr.ontimeout = function () {\n        return errorHandler(generateErrorObject({\n          message: 'request timed out',\n          url: url,\n          status: xhr.status\n        }));\n      };\n\n      xhr.open('GET', url, true);\n      xhr.setRequestHeader('Accept', 'application/jrd+json, application/json');\n      xhr.send();\n    }\n\n    return __makeRequest();\n  };\n\n  WebFinger.prototype.__isValidJSON = function (str) {\n    try {\n      JSON.parse(str);\n    } catch (e) {\n      return false;\n    }\n    return true;\n  };\n\n  WebFinger.prototype.__isLocalhost = function (host) {\n    var local = /^localhost(\\.localdomain)?(\\:[0-9]+)?$/;\n    return local.test(host);\n  };\n\n  // processes JRD object as if it's a webfinger response object\n  // looks for known properties and adds them to profile datat struct.\n  WebFinger.prototype.__processJRD = function (URL, JRD, errorHandler, successHandler) {\n    var parsedJRD = JSON.parse(JRD);\n    if ((typeof parsedJRD !== 'object') ||\n        (typeof parsedJRD.links !== 'object')) {\n      if (typeof parsedJRD.error !== 'undefined') {\n        return errorHandler(generateErrorObject({ message: parsedJRD.error, request: URL }));\n      } else {\n        return errorHandler(generateErrorObject({ message: 'unknown response from server', request: URL }));\n      }\n    }\n\n    var links = parsedJRD.links;\n    var result = {  // webfinger JRD - object, json, and our own indexing\n      object: parsedJRD,\n      json: JRD,\n      idx: {}\n    };\n\n    result.idx.properties = {\n      'name': undefined\n    };\n    result.idx.links = JSON.parse(JSON.stringify(LINK_PROPERTIES));\n\n    // process links\n    links.map(function (link, i) {\n      if (LINK_URI_MAPS.hasOwnProperty(link.rel)) {\n        if (result.idx.links[LINK_URI_MAPS[link.rel]]) {\n          var entry = {};\n          Object.keys(link).map(function (item, n) {\n            entry[item] = link[item];\n          });\n          result.idx.links[LINK_URI_MAPS[link.rel]].push(entry);\n        }\n      }\n    });\n\n    // process properties\n    var props = JSON.parse(JRD).properties;\n    for (var key in props) {\n      if (props.hasOwnProperty(key)) {\n        if (key === 'http://packetizer.com/ns/name') {\n          result.idx.properties.name = props[key];\n        }\n      }\n    }\n    return successHandler(result);\n  };\n\n  WebFinger.prototype.lookup = function (address, cb) {\n    if (typeof address !== 'string') {\n      throw new Error('first parameter must be a user address');\n    } else if (typeof cb !== 'function') {\n      throw new Error('second parameter must be a callback');\n    }\n\n    var self = this;\n    var host = '';\n    if (address.indexOf('://') > -1) {\n      // other uri format\n      host = address.replace(/ /g,'').split('://')[1];\n    } else {\n      // useraddress\n      host = address.replace(/ /g,'').split('@')[1];\n    }\n    var uri_index = 0;      // track which URIS we've tried already\n    var protocol = 'https'; // we use https by default\n\n    if (self.__isLocalhost(host)) {\n      protocol = 'http';\n    }\n\n    function __buildURL() {\n      var uri = '';\n      if (! address.split('://')[1]) {\n        // the URI has not been defined, default to acct\n        uri = 'acct:';\n      }\n      return protocol + '://' + host + '/.well-known/' +\n             URIS[uri_index] + '?resource=' + uri + address;\n    }\n\n    // control flow for failures, what to do in various cases, etc.\n    function __fallbackChecks(err) {\n      if ((self.config.uri_fallback) && (host !== 'webfist.org') && (uri_index !== URIS.length - 1)) { // we have uris left to try\n        uri_index = uri_index + 1;\n        return __call();\n      } else if ((!self.config.tls_only) && (protocol === 'https')) { // try normal http\n        uri_index = 0;\n        protocol = 'http';\n        return __call();\n      } else if ((self.config.webfist_fallback) && (host !== 'webfist.org')) { // webfist attempt\n        uri_index = 0;\n        protocol = 'http';\n        host = 'webfist.org';\n        // webfist will\n        // 1. make a query to the webfist server for the users account\n        // 2. from the response, get a link to the actual webfinger json data\n        //    (stored somewhere in control of the user)\n        // 3. make a request to that url and get the json\n        // 4. process it like a normal webfinger response\n        var URL = __buildURL();\n        self.__fetchJRD(URL, cb, function (data) { // get link to users JRD\n          self.__processJRD(URL, data, cb, function (result) {\n            if ((typeof result.idx.links.webfist === 'object') &&\n                (typeof result.idx.links.webfist[0].href === 'string')) {\n              self.__fetchJRD(result.idx.links.webfist[0].href, cb, function (JRD) {\n                self.__processJRD(URL, JRD, cb, function (result) {\n                  return cb(null, cb);\n                });\n              });\n            }\n          });\n        });\n      } else {\n        return cb(err);\n      }\n    }\n\n    function __call() {\n      // make request\n      var URL = __buildURL();\n      self.__fetchJRD(URL, __fallbackChecks, function (JRD) {\n        self.__processJRD(URL, JRD, cb, function (result) { cb(null, result); });\n      });\n    }\n\n    return setTimeout(__call, 0);\n  };\n\n  WebFinger.prototype.lookupLink = function (address, rel, cb) {\n    if (LINK_PROPERTIES.hasOwnProperty(rel)) {\n      this.lookup(address, function (err, p) {\n        var links  = p.idx.links[rel];\n        if (err) {\n          return cb(err);\n        } else if (links.length === 0) {\n          return cb('no links found with rel=\"' + rel + '\"');\n        } else {\n          return cb(null, links[0]);\n        }\n      });\n    } else {\n      return cb('unsupported rel ' + rel);\n    }\n  };\n\n\n\n  // AMD support\n  if (true) {\n      !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function () { return WebFinger; }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  // CommonJS and Node.js module support.\n  } else if (typeof exports !== 'undefined') {\n    // Support Node.js specific `module.exports` (which can be a function)\n    if (typeof module !== 'undefined' && module.exports) {\n        exports = module.exports = WebFinger;\n    }\n    // But always support CommonJS module 1.1.1 spec (`exports` cannot be a function)\n    exports.WebFinger = WebFinger;\n  } else {\n    // browser <script> support\n    global.WebFinger = WebFinger;\n  }\n})(this);\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3dlYmZpbmdlci5qcy9zcmMvd2ViZmluZ2VyLmpzPzExYTUiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekMsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELHlDQUF5QztBQUMxRixPQUFPO0FBQ1AsaURBQWlELHdEQUF3RDtBQUN6RztBQUNBOztBQUVBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QiwyQkFBMkI7O0FBRTNCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHNHQUFzRztBQUN0RztBQUNBO0FBQ0EsT0FBTyw4REFBOEQ7QUFDckU7QUFDQTtBQUNBO0FBQ0EsT0FBTyx1RUFBdUU7QUFDOUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0Q7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGVBQWU7QUFDZjtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRCxrQkFBa0IsRUFBRTtBQUMvRSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBLHdGQUE4QixrQkFBa0IsRUFBRTtBQUNsRDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsQ0FBQyIsImZpbGUiOiIyMS5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qIGdsb2JhbCBkZWZpbmUgKi9cbi8qIVxuICogd2ViZmluZ2VyLmpzXG4gKiAgIHZlcnNpb24gMi42LjBcbiAqICAgaHR0cDovL2dpdGh1Yi5jb20vc2lsdmVyYnVja2V0L3dlYmZpbmdlci5qc1xuICpcbiAqIERldmVsb3BlZCBhbmQgTWFpbnRhaW5lZCBieTpcbiAqICAgTmljayBKZW5uaW5ncyA8bmlja0BzaWx2ZXJidWNrZXQubmV0PiAyMDEyIC0gMjAxNlxuICpcbiAqIHdlYmZpbmdlci5qcyBpcyByZWxlYXNlZCB1bmRlciB0aGUgQUdQTCAoc2VlIExJQ0VOU0UpLlxuICpcbiAqIFlvdSBkb24ndCBoYXZlIHRvIGRvIGFueXRoaW5nIHNwZWNpYWwgdG8gY2hvb3NlIG9uZSBsaWNlbnNlIG9yIHRoZSBvdGhlciBhbmQgeW91IGRvbid0XG4gKiBoYXZlIHRvIG5vdGlmeSBhbnlvbmUgd2hpY2ggbGljZW5zZSB5b3UgYXJlIHVzaW5nLlxuICogUGxlYXNlIHNlZSB0aGUgY29ycmVzcG9uZGluZyBsaWNlbnNlIGZpbGUgZm9yIGRldGFpbHMgb2YgdGhlc2UgbGljZW5zZXMuXG4gKiBZb3UgYXJlIGZyZWUgdG8gdXNlLCBtb2RpZnkgYW5kIGRpc3RyaWJ1dGUgdGhpcyBzb2Z0d2FyZSwgYnV0IGFsbCBjb3B5cmlnaHRcbiAqIGluZm9ybWF0aW9uIG11c3QgcmVtYWluLlxuICpcbiAqL1xuaWYgKHR5cGVvZiBYTUxIdHRwUmVxdWVzdCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgWE1MSHR0cFJlcXVlc3QgPSByZXF1aXJlKCd4bWxodHRwcmVxdWVzdCcpLlhNTEh0dHBSZXF1ZXN0O1xufVxuXG4oZnVuY3Rpb24gKGdsb2JhbCkge1xuXG4gIC8vIFVSSSB0byBwcm9wZXJ0eSBuYW1lIG1hcFxuICB2YXIgTElOS19VUklfTUFQUyA9IHtcbiAgICAnaHR0cDovL3dlYmZpc3Qub3JnL3NwZWMvcmVsJzogJ3dlYmZpc3QnLFxuICAgICdodHRwOi8vd2ViZmluZ2VyLm5ldC9yZWwvYXZhdGFyJzogJ2F2YXRhcicsXG4gICAgJ3JlbW90ZXN0b3JhZ2UnOiAncmVtb3Rlc3RvcmFnZScsXG4gICAgJ2h0dHA6Ly90b29scy5pZXRmLm9yZy9pZC9kcmFmdC1kZWpvbmctcmVtb3Rlc3RvcmFnZSc6ICdyZW1vdGVzdG9yYWdlJyxcbiAgICAncmVtb3RlU3RvcmFnZSc6ICdyZW1vdGVzdG9yYWdlJyxcbiAgICAnaHR0cDovL3d3dy5wYWNrZXRpemVyLmNvbS9yZWwvc2hhcmUnOiAnc2hhcmUnLFxuICAgICdodHRwOi8vd2ViZmluZ2VyLm5ldC9yZWwvcHJvZmlsZS1wYWdlJzogJ3Byb2ZpbGUnLFxuICAgICdtZSc6ICdwcm9maWxlJyxcbiAgICAndmNhcmQnOiAndmNhcmQnLFxuICAgICdibG9nJzogJ2Jsb2cnLFxuICAgICdodHRwOi8vcGFja2V0aXplci5jb20vcmVsL2Jsb2cnOiAnYmxvZycsXG4gICAgJ2h0dHA6Ly9zY2hlbWFzLmdvb2dsZS5jb20vZy8yMDEwI3VwZGF0ZXMtZnJvbSc6ICd1cGRhdGVzJyxcbiAgICAnaHR0cHM6Ly9jYW1saXN0b3JlLm9yZy9yZWwvc2VydmVyJzogJ2NhbWlsc3RvcmUnXG4gIH07XG5cbiAgdmFyIExJTktfUFJPUEVSVElFUyA9IHtcbiAgICAnYXZhdGFyJzogW10sXG4gICAgJ3JlbW90ZXN0b3JhZ2UnOiBbXSxcbiAgICAnYmxvZyc6IFtdLFxuICAgICd2Y2FyZCc6IFtdLFxuICAgICd1cGRhdGVzJzogW10sXG4gICAgJ3NoYXJlJzogW10sXG4gICAgJ3Byb2ZpbGUnOiBbXSxcbiAgICAnd2ViZmlzdCc6IFtdLFxuICAgICdjYW1saXN0b3JlJzogW11cbiAgfTtcblxuICAvLyBsaXN0IG9mIGVuZHBvaW50cyB0byB0cnksIGZhbGxiYWNrIGZyb20gYmVnaW5uaW5nIHRvIGVuZC5cbiAgdmFyIFVSSVMgPSBbJ3dlYmZpbmdlcicsICdob3N0LW1ldGEnLCAnaG9zdC1tZXRhLmpzb24nXTtcblxuICBmdW5jdGlvbiBnZW5lcmF0ZUVycm9yT2JqZWN0KG9iaikge1xuICAgIG9iai50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLm1lc3NhZ2U7XG4gICAgfTtcbiAgICByZXR1cm4gb2JqO1xuICB9XG5cbiAgLy8gZ2l2ZW4gYSBVUkwgZW5zdXJlcyBpdCdzIEhUVFBTLlxuICAvLyByZXR1cm5zIGZhbHNlIGZvciBudWxsIHN0cmluZyBvciBub24tSFRUUFMgVVJMLlxuICBmdW5jdGlvbiBpc1NlY3VyZSh1cmwpIHtcbiAgICBpZiAodHlwZW9mIHVybCAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdmFyIHBhcnRzID0gdXJsLnNwbGl0KCc6Ly8nKTtcbiAgICBpZiAocGFydHNbMF0gPT09ICdodHRwcycpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogRnVuY3Rpb246IFdlYkZpbmdlclxuICAgKlxuICAgKiBXZWJGaW5nZXIgY29uc3RydWN0b3JcbiAgICpcbiAgICogUmV0dXJuczpcbiAgICpcbiAgICogICByZXR1cm4gV2ViRmluZ2VyIG9iamVjdFxuICAgKi9cbiAgZnVuY3Rpb24gV2ViRmluZ2VyKGNvbmZpZykge1xuICAgIGlmICh0eXBlb2YgY29uZmlnICE9PSAnb2JqZWN0Jykge1xuICAgICAgY29uZmlnID0ge307XG4gICAgfVxuXG4gICAgdGhpcy5jb25maWcgPSB7XG4gICAgICB0bHNfb25seTogICAgICAgICAodHlwZW9mIGNvbmZpZy50bHNfb25seSAhPT0gJ3VuZGVmaW5lZCcpID8gY29uZmlnLnRsc19vbmx5IDogdHJ1ZSxcbiAgICAgIHdlYmZpc3RfZmFsbGJhY2s6ICh0eXBlb2YgY29uZmlnLndlYmZpc3RfZmFsbGJhY2sgIT09ICd1bmRlZmluZWQnKSA/IGNvbmZpZy53ZWJmaXN0X2ZhbGxiYWNrIDogZmFsc2UsXG4gICAgICB1cmlfZmFsbGJhY2s6ICAgICAodHlwZW9mIGNvbmZpZy51cmlfZmFsbGJhY2sgIT09ICd1bmRlZmluZWQnKSA/IGNvbmZpZy51cmlfZmFsbGJhY2sgOiBmYWxzZSxcbiAgICAgIHJlcXVlc3RfdGltZW91dDogICh0eXBlb2YgY29uZmlnLnJlcXVlc3RfdGltZW91dCAhPT0gJ3VuZGVmaW5lZCcpID8gY29uZmlnLnJlcXVlc3RfdGltZW91dCA6IDEwMDAwXG4gICAgfTtcbiAgfVxuXG4gIC8vIG1ha2UgYW4gaHR0cCByZXF1ZXN0IGFuZCBsb29rIGZvciBKUkQgcmVzcG9uc2UsIGZhaWxzIGlmIHJlcXVlc3QgZmFpbHNcbiAgLy8gb3IgcmVzcG9uc2Ugbm90IGpzb24uXG4gIFdlYkZpbmdlci5wcm90b3R5cGUuX19mZXRjaEpSRCA9IGZ1bmN0aW9uICh1cmwsIGVycm9ySGFuZGxlciwgc3VjZXNzSGFuZGxlcikge1xuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIHZhciB4aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcbiAgICB4aHIudGltZW91dCA9IHRoaXMuY29uZmlnLnJlcXVlc3RfdGltZW91dDtcblxuICAgIGZ1bmN0aW9uIF9fcHJvY2Vzc1N0YXRlKCkge1xuICAgICAgaWYgKHhoci5zdGF0dXMgPT09IDIwMCkge1xuICAgICAgICBpZiAoc2VsZi5fX2lzVmFsaWRKU09OKHhoci5yZXNwb25zZVRleHQpKSB7XG4gICAgICAgICAgcmV0dXJuIHN1Y2Vzc0hhbmRsZXIoeGhyLnJlc3BvbnNlVGV4dCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIGVycm9ySGFuZGxlcihnZW5lcmF0ZUVycm9yT2JqZWN0KHtcbiAgICAgICAgICAgIG1lc3NhZ2U6ICdpbnZhbGlkIGpzb24nLFxuICAgICAgICAgICAgdXJsOiB1cmwsXG4gICAgICAgICAgICBzdGF0dXM6IHhoci5zdGF0dXNcbiAgICAgICAgICB9KSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoeGhyLnN0YXR1cyA9PT0gNDA0KSB7XG4gICAgICAgIHJldHVybiBlcnJvckhhbmRsZXIoZ2VuZXJhdGVFcnJvck9iamVjdCh7XG4gICAgICAgICAgbWVzc2FnZTogJ3Jlc291cmNlIG5vdCBmb3VuZCcsXG4gICAgICAgICAgdXJsOiB1cmwsXG4gICAgICAgICAgc3RhdHVzOiB4aHIuc3RhdHVzXG4gICAgICAgIH0pKTtcbiAgICAgIH0gZWxzZSBpZiAoKHhoci5zdGF0dXMgPj0gMzAxKSAmJiAoeGhyLnN0YXR1cyA8PSAzMDIpKSB7XG4gICAgICAgIHZhciBsb2NhdGlvbiA9IHhoci5nZXRSZXNwb25zZUhlYWRlcignTG9jYXRpb24nKTtcbiAgICAgICAgaWYgKGlzU2VjdXJlKGxvY2F0aW9uKSkge1xuICAgICAgICAgIHJldHVybiBfX21ha2VSZXF1ZXN0KGxvY2F0aW9uKTsgLy8gZm9sbG93IHJlZGlyZWN0XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIGVycm9ySGFuZGxlcihnZW5lcmF0ZUVycm9yT2JqZWN0KHtcbiAgICAgICAgICAgIG1lc3NhZ2U6ICdubyByZWRpcmVjdCBVUkwgZm91bmQnLFxuICAgICAgICAgICAgdXJsOiB1cmwsXG4gICAgICAgICAgICBzdGF0dXM6IHhoci5zdGF0dXNcbiAgICAgICAgICB9KSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBlcnJvckhhbmRsZXIoZ2VuZXJhdGVFcnJvck9iamVjdCh7XG4gICAgICAgICAgbWVzc2FnZTogJ2Vycm9yIGR1cmluZyByZXF1ZXN0JyxcbiAgICAgICAgICB1cmw6IHVybCxcbiAgICAgICAgICBzdGF0dXM6IHhoci5zdGF0dXNcbiAgICAgICAgfSkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIF9fbWFrZVJlcXVlc3QoKSB7XG4gICAgICB4aHIub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoeGhyLnJlYWR5U3RhdGUgPT09IDQpIHtcbiAgICAgICAgICBfX3Byb2Nlc3NTdGF0ZSgpO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICB4aHIub25sb2FkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBfX3Byb2Nlc3NTdGF0ZSgpO1xuICAgICAgfTtcblxuICAgICAgeGhyLm9udGltZW91dCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGVycm9ySGFuZGxlcihnZW5lcmF0ZUVycm9yT2JqZWN0KHtcbiAgICAgICAgICBtZXNzYWdlOiAncmVxdWVzdCB0aW1lZCBvdXQnLFxuICAgICAgICAgIHVybDogdXJsLFxuICAgICAgICAgIHN0YXR1czogeGhyLnN0YXR1c1xuICAgICAgICB9KSk7XG4gICAgICB9O1xuXG4gICAgICB4aHIub3BlbignR0VUJywgdXJsLCB0cnVlKTtcbiAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKCdBY2NlcHQnLCAnYXBwbGljYXRpb24vanJkK2pzb24sIGFwcGxpY2F0aW9uL2pzb24nKTtcbiAgICAgIHhoci5zZW5kKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIF9fbWFrZVJlcXVlc3QoKTtcbiAgfTtcblxuICBXZWJGaW5nZXIucHJvdG90eXBlLl9faXNWYWxpZEpTT04gPSBmdW5jdGlvbiAoc3RyKSB7XG4gICAgdHJ5IHtcbiAgICAgIEpTT04ucGFyc2Uoc3RyKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9O1xuXG4gIFdlYkZpbmdlci5wcm90b3R5cGUuX19pc0xvY2FsaG9zdCA9IGZ1bmN0aW9uIChob3N0KSB7XG4gICAgdmFyIGxvY2FsID0gL15sb2NhbGhvc3QoXFwubG9jYWxkb21haW4pPyhcXDpbMC05XSspPyQvO1xuICAgIHJldHVybiBsb2NhbC50ZXN0KGhvc3QpO1xuICB9O1xuXG4gIC8vIHByb2Nlc3NlcyBKUkQgb2JqZWN0IGFzIGlmIGl0J3MgYSB3ZWJmaW5nZXIgcmVzcG9uc2Ugb2JqZWN0XG4gIC8vIGxvb2tzIGZvciBrbm93biBwcm9wZXJ0aWVzIGFuZCBhZGRzIHRoZW0gdG8gcHJvZmlsZSBkYXRhdCBzdHJ1Y3QuXG4gIFdlYkZpbmdlci5wcm90b3R5cGUuX19wcm9jZXNzSlJEID0gZnVuY3Rpb24gKFVSTCwgSlJELCBlcnJvckhhbmRsZXIsIHN1Y2Nlc3NIYW5kbGVyKSB7XG4gICAgdmFyIHBhcnNlZEpSRCA9IEpTT04ucGFyc2UoSlJEKTtcbiAgICBpZiAoKHR5cGVvZiBwYXJzZWRKUkQgIT09ICdvYmplY3QnKSB8fFxuICAgICAgICAodHlwZW9mIHBhcnNlZEpSRC5saW5rcyAhPT0gJ29iamVjdCcpKSB7XG4gICAgICBpZiAodHlwZW9mIHBhcnNlZEpSRC5lcnJvciAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgcmV0dXJuIGVycm9ySGFuZGxlcihnZW5lcmF0ZUVycm9yT2JqZWN0KHsgbWVzc2FnZTogcGFyc2VkSlJELmVycm9yLCByZXF1ZXN0OiBVUkwgfSkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGVycm9ySGFuZGxlcihnZW5lcmF0ZUVycm9yT2JqZWN0KHsgbWVzc2FnZTogJ3Vua25vd24gcmVzcG9uc2UgZnJvbSBzZXJ2ZXInLCByZXF1ZXN0OiBVUkwgfSkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBsaW5rcyA9IHBhcnNlZEpSRC5saW5rcztcbiAgICB2YXIgcmVzdWx0ID0geyAgLy8gd2ViZmluZ2VyIEpSRCAtIG9iamVjdCwganNvbiwgYW5kIG91ciBvd24gaW5kZXhpbmdcbiAgICAgIG9iamVjdDogcGFyc2VkSlJELFxuICAgICAganNvbjogSlJELFxuICAgICAgaWR4OiB7fVxuICAgIH07XG5cbiAgICByZXN1bHQuaWR4LnByb3BlcnRpZXMgPSB7XG4gICAgICAnbmFtZSc6IHVuZGVmaW5lZFxuICAgIH07XG4gICAgcmVzdWx0LmlkeC5saW5rcyA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoTElOS19QUk9QRVJUSUVTKSk7XG5cbiAgICAvLyBwcm9jZXNzIGxpbmtzXG4gICAgbGlua3MubWFwKGZ1bmN0aW9uIChsaW5rLCBpKSB7XG4gICAgICBpZiAoTElOS19VUklfTUFQUy5oYXNPd25Qcm9wZXJ0eShsaW5rLnJlbCkpIHtcbiAgICAgICAgaWYgKHJlc3VsdC5pZHgubGlua3NbTElOS19VUklfTUFQU1tsaW5rLnJlbF1dKSB7XG4gICAgICAgICAgdmFyIGVudHJ5ID0ge307XG4gICAgICAgICAgT2JqZWN0LmtleXMobGluaykubWFwKGZ1bmN0aW9uIChpdGVtLCBuKSB7XG4gICAgICAgICAgICBlbnRyeVtpdGVtXSA9IGxpbmtbaXRlbV07XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcmVzdWx0LmlkeC5saW5rc1tMSU5LX1VSSV9NQVBTW2xpbmsucmVsXV0ucHVzaChlbnRyeSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIHByb2Nlc3MgcHJvcGVydGllc1xuICAgIHZhciBwcm9wcyA9IEpTT04ucGFyc2UoSlJEKS5wcm9wZXJ0aWVzO1xuICAgIGZvciAodmFyIGtleSBpbiBwcm9wcykge1xuICAgICAgaWYgKHByb3BzLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgaWYgKGtleSA9PT0gJ2h0dHA6Ly9wYWNrZXRpemVyLmNvbS9ucy9uYW1lJykge1xuICAgICAgICAgIHJlc3VsdC5pZHgucHJvcGVydGllcy5uYW1lID0gcHJvcHNba2V5XTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc3VjY2Vzc0hhbmRsZXIocmVzdWx0KTtcbiAgfTtcblxuICBXZWJGaW5nZXIucHJvdG90eXBlLmxvb2t1cCA9IGZ1bmN0aW9uIChhZGRyZXNzLCBjYikge1xuICAgIGlmICh0eXBlb2YgYWRkcmVzcyAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignZmlyc3QgcGFyYW1ldGVyIG11c3QgYmUgYSB1c2VyIGFkZHJlc3MnKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBjYiAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdzZWNvbmQgcGFyYW1ldGVyIG11c3QgYmUgYSBjYWxsYmFjaycpO1xuICAgIH1cblxuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgaG9zdCA9ICcnO1xuICAgIGlmIChhZGRyZXNzLmluZGV4T2YoJzovLycpID4gLTEpIHtcbiAgICAgIC8vIG90aGVyIHVyaSBmb3JtYXRcbiAgICAgIGhvc3QgPSBhZGRyZXNzLnJlcGxhY2UoLyAvZywnJykuc3BsaXQoJzovLycpWzFdO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyB1c2VyYWRkcmVzc1xuICAgICAgaG9zdCA9IGFkZHJlc3MucmVwbGFjZSgvIC9nLCcnKS5zcGxpdCgnQCcpWzFdO1xuICAgIH1cbiAgICB2YXIgdXJpX2luZGV4ID0gMDsgICAgICAvLyB0cmFjayB3aGljaCBVUklTIHdlJ3ZlIHRyaWVkIGFscmVhZHlcbiAgICB2YXIgcHJvdG9jb2wgPSAnaHR0cHMnOyAvLyB3ZSB1c2UgaHR0cHMgYnkgZGVmYXVsdFxuXG4gICAgaWYgKHNlbGYuX19pc0xvY2FsaG9zdChob3N0KSkge1xuICAgICAgcHJvdG9jb2wgPSAnaHR0cCc7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gX19idWlsZFVSTCgpIHtcbiAgICAgIHZhciB1cmkgPSAnJztcbiAgICAgIGlmICghIGFkZHJlc3Muc3BsaXQoJzovLycpWzFdKSB7XG4gICAgICAgIC8vIHRoZSBVUkkgaGFzIG5vdCBiZWVuIGRlZmluZWQsIGRlZmF1bHQgdG8gYWNjdFxuICAgICAgICB1cmkgPSAnYWNjdDonO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHByb3RvY29sICsgJzovLycgKyBob3N0ICsgJy8ud2VsbC1rbm93bi8nICtcbiAgICAgICAgICAgICBVUklTW3VyaV9pbmRleF0gKyAnP3Jlc291cmNlPScgKyB1cmkgKyBhZGRyZXNzO1xuICAgIH1cblxuICAgIC8vIGNvbnRyb2wgZmxvdyBmb3IgZmFpbHVyZXMsIHdoYXQgdG8gZG8gaW4gdmFyaW91cyBjYXNlcywgZXRjLlxuICAgIGZ1bmN0aW9uIF9fZmFsbGJhY2tDaGVja3MoZXJyKSB7XG4gICAgICBpZiAoKHNlbGYuY29uZmlnLnVyaV9mYWxsYmFjaykgJiYgKGhvc3QgIT09ICd3ZWJmaXN0Lm9yZycpICYmICh1cmlfaW5kZXggIT09IFVSSVMubGVuZ3RoIC0gMSkpIHsgLy8gd2UgaGF2ZSB1cmlzIGxlZnQgdG8gdHJ5XG4gICAgICAgIHVyaV9pbmRleCA9IHVyaV9pbmRleCArIDE7XG4gICAgICAgIHJldHVybiBfX2NhbGwoKTtcbiAgICAgIH0gZWxzZSBpZiAoKCFzZWxmLmNvbmZpZy50bHNfb25seSkgJiYgKHByb3RvY29sID09PSAnaHR0cHMnKSkgeyAvLyB0cnkgbm9ybWFsIGh0dHBcbiAgICAgICAgdXJpX2luZGV4ID0gMDtcbiAgICAgICAgcHJvdG9jb2wgPSAnaHR0cCc7XG4gICAgICAgIHJldHVybiBfX2NhbGwoKTtcbiAgICAgIH0gZWxzZSBpZiAoKHNlbGYuY29uZmlnLndlYmZpc3RfZmFsbGJhY2spICYmIChob3N0ICE9PSAnd2ViZmlzdC5vcmcnKSkgeyAvLyB3ZWJmaXN0IGF0dGVtcHRcbiAgICAgICAgdXJpX2luZGV4ID0gMDtcbiAgICAgICAgcHJvdG9jb2wgPSAnaHR0cCc7XG4gICAgICAgIGhvc3QgPSAnd2ViZmlzdC5vcmcnO1xuICAgICAgICAvLyB3ZWJmaXN0IHdpbGxcbiAgICAgICAgLy8gMS4gbWFrZSBhIHF1ZXJ5IHRvIHRoZSB3ZWJmaXN0IHNlcnZlciBmb3IgdGhlIHVzZXJzIGFjY291bnRcbiAgICAgICAgLy8gMi4gZnJvbSB0aGUgcmVzcG9uc2UsIGdldCBhIGxpbmsgdG8gdGhlIGFjdHVhbCB3ZWJmaW5nZXIganNvbiBkYXRhXG4gICAgICAgIC8vICAgIChzdG9yZWQgc29tZXdoZXJlIGluIGNvbnRyb2wgb2YgdGhlIHVzZXIpXG4gICAgICAgIC8vIDMuIG1ha2UgYSByZXF1ZXN0IHRvIHRoYXQgdXJsIGFuZCBnZXQgdGhlIGpzb25cbiAgICAgICAgLy8gNC4gcHJvY2VzcyBpdCBsaWtlIGEgbm9ybWFsIHdlYmZpbmdlciByZXNwb25zZVxuICAgICAgICB2YXIgVVJMID0gX19idWlsZFVSTCgpO1xuICAgICAgICBzZWxmLl9fZmV0Y2hKUkQoVVJMLCBjYiwgZnVuY3Rpb24gKGRhdGEpIHsgLy8gZ2V0IGxpbmsgdG8gdXNlcnMgSlJEXG4gICAgICAgICAgc2VsZi5fX3Byb2Nlc3NKUkQoVVJMLCBkYXRhLCBjYiwgZnVuY3Rpb24gKHJlc3VsdCkge1xuICAgICAgICAgICAgaWYgKCh0eXBlb2YgcmVzdWx0LmlkeC5saW5rcy53ZWJmaXN0ID09PSAnb2JqZWN0JykgJiZcbiAgICAgICAgICAgICAgICAodHlwZW9mIHJlc3VsdC5pZHgubGlua3Mud2ViZmlzdFswXS5ocmVmID09PSAnc3RyaW5nJykpIHtcbiAgICAgICAgICAgICAgc2VsZi5fX2ZldGNoSlJEKHJlc3VsdC5pZHgubGlua3Mud2ViZmlzdFswXS5ocmVmLCBjYiwgZnVuY3Rpb24gKEpSRCkge1xuICAgICAgICAgICAgICAgIHNlbGYuX19wcm9jZXNzSlJEKFVSTCwgSlJELCBjYiwgZnVuY3Rpb24gKHJlc3VsdCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGNiKG51bGwsIGNiKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGNiKGVycik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gX19jYWxsKCkge1xuICAgICAgLy8gbWFrZSByZXF1ZXN0XG4gICAgICB2YXIgVVJMID0gX19idWlsZFVSTCgpO1xuICAgICAgc2VsZi5fX2ZldGNoSlJEKFVSTCwgX19mYWxsYmFja0NoZWNrcywgZnVuY3Rpb24gKEpSRCkge1xuICAgICAgICBzZWxmLl9fcHJvY2Vzc0pSRChVUkwsIEpSRCwgY2IsIGZ1bmN0aW9uIChyZXN1bHQpIHsgY2IobnVsbCwgcmVzdWx0KTsgfSk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gc2V0VGltZW91dChfX2NhbGwsIDApO1xuICB9O1xuXG4gIFdlYkZpbmdlci5wcm90b3R5cGUubG9va3VwTGluayA9IGZ1bmN0aW9uIChhZGRyZXNzLCByZWwsIGNiKSB7XG4gICAgaWYgKExJTktfUFJPUEVSVElFUy5oYXNPd25Qcm9wZXJ0eShyZWwpKSB7XG4gICAgICB0aGlzLmxvb2t1cChhZGRyZXNzLCBmdW5jdGlvbiAoZXJyLCBwKSB7XG4gICAgICAgIHZhciBsaW5rcyAgPSBwLmlkeC5saW5rc1tyZWxdO1xuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgcmV0dXJuIGNiKGVycik7XG4gICAgICAgIH0gZWxzZSBpZiAobGlua3MubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgcmV0dXJuIGNiKCdubyBsaW5rcyBmb3VuZCB3aXRoIHJlbD1cIicgKyByZWwgKyAnXCInKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gY2IobnVsbCwgbGlua3NbMF0pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGNiKCd1bnN1cHBvcnRlZCByZWwgJyArIHJlbCk7XG4gICAgfVxuICB9O1xuXG5cblxuICAvLyBBTUQgc3VwcG9ydFxuICBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XG4gICAgICBkZWZpbmUoW10sIGZ1bmN0aW9uICgpIHsgcmV0dXJuIFdlYkZpbmdlcjsgfSk7XG4gIC8vIENvbW1vbkpTIGFuZCBOb2RlLmpzIG1vZHVsZSBzdXBwb3J0LlxuICB9IGVsc2UgaWYgKHR5cGVvZiBleHBvcnRzICE9PSAndW5kZWZpbmVkJykge1xuICAgIC8vIFN1cHBvcnQgTm9kZS5qcyBzcGVjaWZpYyBgbW9kdWxlLmV4cG9ydHNgICh3aGljaCBjYW4gYmUgYSBmdW5jdGlvbilcbiAgICBpZiAodHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgJiYgbW9kdWxlLmV4cG9ydHMpIHtcbiAgICAgICAgZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gV2ViRmluZ2VyO1xuICAgIH1cbiAgICAvLyBCdXQgYWx3YXlzIHN1cHBvcnQgQ29tbW9uSlMgbW9kdWxlIDEuMS4xIHNwZWMgKGBleHBvcnRzYCBjYW5ub3QgYmUgYSBmdW5jdGlvbilcbiAgICBleHBvcnRzLldlYkZpbmdlciA9IFdlYkZpbmdlcjtcbiAgfSBlbHNlIHtcbiAgICAvLyBicm93c2VyIDxzY3JpcHQ+IHN1cHBvcnRcbiAgICBnbG9iYWwuV2ViRmluZ2VyID0gV2ViRmluZ2VyO1xuICB9XG59KSh0aGlzKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi93ZWJmaW5nZXIuanMvc3JjL3dlYmZpbmdlci5qc1xuLy8gbW9kdWxlIGlkID0gMjFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ },
/* 22 */
/***/ function(module, exports) {

	eval("module.exports = __WEBPACK_EXTERNAL_MODULE_22__;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vZXh0ZXJuYWwgXCJ4bWxodHRwcmVxdWVzdFwiP2FkYTgiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEiLCJmaWxlIjoiMjIuanMiLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfMjJfXztcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyBleHRlcm5hbCBcInhtbGh0dHByZXF1ZXN0XCJcbi8vIG1vZHVsZSBpZCA9IDIyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ },
/* 23 */
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar log = __webpack_require__(4);\n\nfunction shareFirst(path) {\n  return this.backend === 'dropbox' && path.match(/^\\/public\\/.*[^\\/]$/);\n}\n\nvar SyncedGetPutDelete = {\n  get: function get(path, maxAge) {\n    if (this.local) {\n      if (maxAge === undefined) {\n        if (_typeof(this.remote) === 'object' && this.remote.connected && this.remote.online) {\n          maxAge = 2 * this.getSyncInterval();\n        } else {\n          log('Not setting default maxAge, because remote is offline or not connected');\n          maxAge = false;\n        }\n      }\n      var maxAgeInvalid = function maxAgeInvalid(maxAge) {\n        return maxAge !== false && typeof maxAge !== 'number';\n      };\n\n      if (maxAgeInvalid(maxAge)) {\n        return Promise.reject('Argument \\'maxAge\\' must be false or a number');\n      }\n      return this.local.get(path, maxAge, this.sync.queueGetRequest.bind(this.sync));\n    } else {\n      return this.remote.get(path);\n    }\n  },\n\n  put: function put(path, body, contentType) {\n    if (shareFirst.bind(this)(path)) {\n      return SyncedGetPutDelete._wrapBusyDone.call(this, this.remote.put(path, body, contentType));\n    } else if (this.local) {\n      return this.local.put(path, body, contentType);\n    } else {\n      return SyncedGetPutDelete._wrapBusyDone.call(this, this.remote.put(path, body, contentType));\n    }\n  },\n\n  'delete': function _delete(path) {\n    if (this.local) {\n      return this.local.delete(path);\n    } else {\n      return SyncedGetPutDelete._wrapBusyDone.call(this, this.remote.delete(path));\n    }\n  },\n\n  _wrapBusyDone: function _wrapBusyDone(result) {\n    var self = this;\n    this._emit('wire-busy');\n    return result.then(function (r) {\n      self._emit('wire-done', { success: true });\n      return Promise.resolve(r);\n    }, function (err) {\n      self._emit('wire-done', { success: false });\n      return Promise.reject(err);\n    });\n  }\n};\n\nmodule.exports = SyncedGetPutDelete;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvc3luY2VkZ2V0cHV0ZGVsZXRlLmpzPzkyNjQiXSwibmFtZXMiOlsibG9nIiwicmVxdWlyZSIsInNoYXJlRmlyc3QiLCJwYXRoIiwiYmFja2VuZCIsIm1hdGNoIiwiU3luY2VkR2V0UHV0RGVsZXRlIiwiZ2V0IiwibWF4QWdlIiwibG9jYWwiLCJ1bmRlZmluZWQiLCJyZW1vdGUiLCJjb25uZWN0ZWQiLCJvbmxpbmUiLCJnZXRTeW5jSW50ZXJ2YWwiLCJtYXhBZ2VJbnZhbGlkIiwiUHJvbWlzZSIsInJlamVjdCIsInN5bmMiLCJxdWV1ZUdldFJlcXVlc3QiLCJiaW5kIiwicHV0IiwiYm9keSIsImNvbnRlbnRUeXBlIiwiX3dyYXBCdXN5RG9uZSIsImNhbGwiLCJkZWxldGUiLCJyZXN1bHQiLCJzZWxmIiwiX2VtaXQiLCJ0aGVuIiwiciIsInN1Y2Nlc3MiLCJyZXNvbHZlIiwiZXJyIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJtYXBwaW5ncyI6Ijs7OztBQUNBLElBQUlBLE1BQU0sbUJBQUFDLENBQVEsQ0FBUixDQUFWOztBQUVBLFNBQVNDLFVBQVQsQ0FBb0JDLElBQXBCLEVBQTBCO0FBQ3hCLFNBQVMsS0FBS0MsT0FBTCxLQUFpQixTQUFqQixJQUNBRCxLQUFLRSxLQUFMLENBQVcscUJBQVgsQ0FEVDtBQUVEOztBQUVELElBQUlDLHFCQUFxQjtBQUN2QkMsT0FBSyxhQUFVSixJQUFWLEVBQWdCSyxNQUFoQixFQUF3QjtBQUMzQixRQUFJLEtBQUtDLEtBQVQsRUFBZ0I7QUFDZCxVQUFJRCxXQUFXRSxTQUFmLEVBQTBCO0FBQ3hCLFlBQUssUUFBTyxLQUFLQyxNQUFaLE1BQXVCLFFBQXhCLElBQ0MsS0FBS0EsTUFBTCxDQUFZQyxTQURiLElBQzBCLEtBQUtELE1BQUwsQ0FBWUUsTUFEMUMsRUFDa0Q7QUFDaERMLG1CQUFTLElBQUUsS0FBS00sZUFBTCxFQUFYO0FBQ0QsU0FIRCxNQUdPO0FBQ0xkLGNBQUksd0VBQUo7QUFDQVEsbUJBQVMsS0FBVDtBQUNEO0FBQ0Y7QUFDRCxVQUFJTyxnQkFBZ0IsU0FBaEJBLGFBQWdCLENBQVVQLE1BQVYsRUFBa0I7QUFDcEMsZUFBT0EsV0FBVyxLQUFYLElBQW9CLE9BQU9BLE1BQVAsS0FBbUIsUUFBOUM7QUFDRCxPQUZEOztBQUlBLFVBQUlPLGNBQWNQLE1BQWQsQ0FBSixFQUEyQjtBQUN6QixlQUFPUSxRQUFRQyxNQUFSLENBQWUsK0NBQWYsQ0FBUDtBQUNEO0FBQ0QsYUFBTyxLQUFLUixLQUFMLENBQVdGLEdBQVgsQ0FBZUosSUFBZixFQUFxQkssTUFBckIsRUFBNkIsS0FBS1UsSUFBTCxDQUFVQyxlQUFWLENBQTBCQyxJQUExQixDQUErQixLQUFLRixJQUFwQyxDQUE3QixDQUFQO0FBQ0QsS0FsQkQsTUFrQk87QUFDTCxhQUFPLEtBQUtQLE1BQUwsQ0FBWUosR0FBWixDQUFnQkosSUFBaEIsQ0FBUDtBQUNEO0FBQ0YsR0F2QnNCOztBQXlCdkJrQixPQUFLLGFBQVVsQixJQUFWLEVBQWdCbUIsSUFBaEIsRUFBc0JDLFdBQXRCLEVBQW1DO0FBQ3RDLFFBQUlyQixXQUFXa0IsSUFBWCxDQUFnQixJQUFoQixFQUFzQmpCLElBQXRCLENBQUosRUFBaUM7QUFDL0IsYUFBT0csbUJBQW1Ca0IsYUFBbkIsQ0FBaUNDLElBQWpDLENBQXNDLElBQXRDLEVBQTRDLEtBQUtkLE1BQUwsQ0FBWVUsR0FBWixDQUFnQmxCLElBQWhCLEVBQXNCbUIsSUFBdEIsRUFBNEJDLFdBQTVCLENBQTVDLENBQVA7QUFDRCxLQUZELE1BR0ssSUFBSSxLQUFLZCxLQUFULEVBQWdCO0FBQ25CLGFBQU8sS0FBS0EsS0FBTCxDQUFXWSxHQUFYLENBQWVsQixJQUFmLEVBQXFCbUIsSUFBckIsRUFBMkJDLFdBQTNCLENBQVA7QUFDRCxLQUZJLE1BRUU7QUFDTCxhQUFPakIsbUJBQW1Ca0IsYUFBbkIsQ0FBaUNDLElBQWpDLENBQXNDLElBQXRDLEVBQTRDLEtBQUtkLE1BQUwsQ0FBWVUsR0FBWixDQUFnQmxCLElBQWhCLEVBQXNCbUIsSUFBdEIsRUFBNEJDLFdBQTVCLENBQTVDLENBQVA7QUFDRDtBQUNGLEdBbENzQjs7QUFvQ3ZCLFlBQVUsaUJBQVVwQixJQUFWLEVBQWdCO0FBQ3hCLFFBQUksS0FBS00sS0FBVCxFQUFnQjtBQUNkLGFBQU8sS0FBS0EsS0FBTCxDQUFXaUIsTUFBWCxDQUFrQnZCLElBQWxCLENBQVA7QUFDRCxLQUZELE1BRU87QUFDTCxhQUFPRyxtQkFBbUJrQixhQUFuQixDQUFpQ0MsSUFBakMsQ0FBc0MsSUFBdEMsRUFBNEMsS0FBS2QsTUFBTCxDQUFZZSxNQUFaLENBQW1CdkIsSUFBbkIsQ0FBNUMsQ0FBUDtBQUNEO0FBQ0YsR0ExQ3NCOztBQTRDdkJxQixpQkFBZSx1QkFBVUcsTUFBVixFQUFrQjtBQUMvQixRQUFJQyxPQUFPLElBQVg7QUFDQSxTQUFLQyxLQUFMLENBQVcsV0FBWDtBQUNBLFdBQU9GLE9BQU9HLElBQVAsQ0FBWSxVQUFVQyxDQUFWLEVBQWE7QUFDOUJILFdBQUtDLEtBQUwsQ0FBVyxXQUFYLEVBQXdCLEVBQUVHLFNBQVMsSUFBWCxFQUF4QjtBQUNBLGFBQU9oQixRQUFRaUIsT0FBUixDQUFnQkYsQ0FBaEIsQ0FBUDtBQUNELEtBSE0sRUFHSixVQUFVRyxHQUFWLEVBQWU7QUFDaEJOLFdBQUtDLEtBQUwsQ0FBVyxXQUFYLEVBQXdCLEVBQUVHLFNBQVMsS0FBWCxFQUF4QjtBQUNBLGFBQU9oQixRQUFRQyxNQUFSLENBQWVpQixHQUFmLENBQVA7QUFDRCxLQU5NLENBQVA7QUFPRDtBQXREc0IsQ0FBekI7O0FBeURBQyxPQUFPQyxPQUFQLEdBQWlCOUIsa0JBQWpCIiwiZmlsZSI6IjIzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiXG52YXIgbG9nID0gcmVxdWlyZSgnLi9sb2cnKTtcblxuZnVuY3Rpb24gc2hhcmVGaXJzdChwYXRoKSB7XG4gIHJldHVybiAoIHRoaXMuYmFja2VuZCA9PT0gJ2Ryb3Bib3gnICYmXG4gICAgICAgICAgIHBhdGgubWF0Y2goL15cXC9wdWJsaWNcXC8uKlteXFwvXSQvKSApO1xufVxuXG52YXIgU3luY2VkR2V0UHV0RGVsZXRlID0ge1xuICBnZXQ6IGZ1bmN0aW9uIChwYXRoLCBtYXhBZ2UpIHtcbiAgICBpZiAodGhpcy5sb2NhbCkge1xuICAgICAgaWYgKG1heEFnZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmICgodHlwZW9mIHRoaXMucmVtb3RlID09PSAnb2JqZWN0JykgJiZcbiAgICAgICAgICAgICB0aGlzLnJlbW90ZS5jb25uZWN0ZWQgJiYgdGhpcy5yZW1vdGUub25saW5lKSB7XG4gICAgICAgICAgbWF4QWdlID0gMip0aGlzLmdldFN5bmNJbnRlcnZhbCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGxvZygnTm90IHNldHRpbmcgZGVmYXVsdCBtYXhBZ2UsIGJlY2F1c2UgcmVtb3RlIGlzIG9mZmxpbmUgb3Igbm90IGNvbm5lY3RlZCcpO1xuICAgICAgICAgIG1heEFnZSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB2YXIgbWF4QWdlSW52YWxpZCA9IGZ1bmN0aW9uIChtYXhBZ2UpIHtcbiAgICAgICAgcmV0dXJuIG1heEFnZSAhPT0gZmFsc2UgJiYgdHlwZW9mKG1heEFnZSkgIT09ICdudW1iZXInO1xuICAgICAgfTtcblxuICAgICAgaWYgKG1heEFnZUludmFsaWQobWF4QWdlKSkge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoJ0FyZ3VtZW50IFxcJ21heEFnZVxcJyBtdXN0IGJlIGZhbHNlIG9yIGEgbnVtYmVyJyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5sb2NhbC5nZXQocGF0aCwgbWF4QWdlLCB0aGlzLnN5bmMucXVldWVHZXRSZXF1ZXN0LmJpbmQodGhpcy5zeW5jKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLnJlbW90ZS5nZXQocGF0aCk7XG4gICAgfVxuICB9LFxuXG4gIHB1dDogZnVuY3Rpb24gKHBhdGgsIGJvZHksIGNvbnRlbnRUeXBlKSB7XG4gICAgaWYgKHNoYXJlRmlyc3QuYmluZCh0aGlzKShwYXRoKSkge1xuICAgICAgcmV0dXJuIFN5bmNlZEdldFB1dERlbGV0ZS5fd3JhcEJ1c3lEb25lLmNhbGwodGhpcywgdGhpcy5yZW1vdGUucHV0KHBhdGgsIGJvZHksIGNvbnRlbnRUeXBlKSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHRoaXMubG9jYWwpIHtcbiAgICAgIHJldHVybiB0aGlzLmxvY2FsLnB1dChwYXRoLCBib2R5LCBjb250ZW50VHlwZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBTeW5jZWRHZXRQdXREZWxldGUuX3dyYXBCdXN5RG9uZS5jYWxsKHRoaXMsIHRoaXMucmVtb3RlLnB1dChwYXRoLCBib2R5LCBjb250ZW50VHlwZSkpO1xuICAgIH1cbiAgfSxcblxuICAnZGVsZXRlJzogZnVuY3Rpb24gKHBhdGgpIHtcbiAgICBpZiAodGhpcy5sb2NhbCkge1xuICAgICAgcmV0dXJuIHRoaXMubG9jYWwuZGVsZXRlKHBhdGgpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gU3luY2VkR2V0UHV0RGVsZXRlLl93cmFwQnVzeURvbmUuY2FsbCh0aGlzLCB0aGlzLnJlbW90ZS5kZWxldGUocGF0aCkpO1xuICAgIH1cbiAgfSxcblxuICBfd3JhcEJ1c3lEb25lOiBmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHRoaXMuX2VtaXQoJ3dpcmUtYnVzeScpO1xuICAgIHJldHVybiByZXN1bHQudGhlbihmdW5jdGlvbiAocikge1xuICAgICAgc2VsZi5fZW1pdCgnd2lyZS1kb25lJywgeyBzdWNjZXNzOiB0cnVlIH0pO1xuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShyKTtcbiAgICB9LCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICBzZWxmLl9lbWl0KCd3aXJlLWRvbmUnLCB7IHN1Y2Nlc3M6IGZhbHNlIH0pO1xuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGVycik7XG4gICAgfSk7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gU3luY2VkR2V0UHV0RGVsZXRlO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL3N5bmNlZGdldHB1dGRlbGV0ZS5qcyJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ },
/* 24 */
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';\n\nvar _module$exports;\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nvar util = __webpack_require__(2);\nvar log = __webpack_require__(4);\nvar SyncedGetPutDelete = __webpack_require__(23);\nvar config = __webpack_require__(5);\n\nvar featuresDone = 0;\nvar features = [];\nvar readyFired = false;\n\nvar featureModules = {\n  // 'WireClient': require('./wireclient'),\n  'I18n': __webpack_require__(25),\n  'Dropbox': __webpack_require__(6),\n  'GoogleDrive': __webpack_require__(19),\n  'Access': __webpack_require__(26),\n  'Caching': __webpack_require__(27),\n  'Discover': __webpack_require__(20),\n  'Authorize': __webpack_require__(7),\n  'IndexedDB': __webpack_require__(28),\n  'LocalStorage': __webpack_require__(30),\n  'InMemoryStorage': __webpack_require__(31),\n  'Sync': __webpack_require__(17),\n  'BaseClient': __webpack_require__(8),\n  'Env': __webpack_require__(18)\n};\n\nfunction loadFeatures() {\n  featuresDone = 0;\n  features = [];\n  readyFired = false;\n\n  this._allLoaded = false;\n  for (var featureName in featureModules) {\n    // TOFIX this has to push the promised return value into an\n    // array of promises and use Promise.all to emit `ready`\n    // instead of increment a counter of loaded features.\n    this.loadFeature(featureName);\n  }\n}\n\n/**\n * Method: hasFeature\n *\n * Checks whether a feature is enabled or not within remoteStorage.\n * Returns a boolean.\n *\n * Parameters:\n *   name - Capitalized name of the feature. e.g. Authorize, or IndexedDB\n *\n * Example:\n *   (start code)\n *   if (remoteStorage.hasFeature('LocalStorage')) {\n *     console.log('LocalStorage is enabled!');\n *   }\n *   (end code)\n *\n */\nfunction hasFeature(feature) {\n  for (var i = features.length - 1; i >= 0; i--) {\n    if (features[i].name === feature) {\n      return features[i].supported;\n    }\n  }\n  return false;\n}\n\nfunction loadFeature(featureName) {\n  var _this = this;\n\n  var feature = featureModules[featureName];\n  var supported = !feature._rs_supported || feature._rs_supported();\n\n  if (!config.cache && featureName === 'Sync') {\n    supported = false;\n  }\n  // log(`[RemoteStorage] [FEATURE ${featureName}] initializing ...`);\n\n  if ((typeof supported === 'undefined' ? 'undefined' : _typeof(supported)) === 'object') {\n    supported.then(function () {\n      _this.featureSupported(featureName, true);\n      _this.initFeature(featureName);\n    }, function () {\n      _this.featureSupported(featureName, false);\n    });\n  } else if (typeof supported === 'boolean') {\n    this.featureSupported(featureName, supported);\n    if (supported) {\n      this.initFeature(featureName);\n    }\n  } else {\n    this.featureSupported(featureName, false);\n  }\n}\n\nfunction initFeature(featureName) {\n  var _this2 = this;\n\n  var feature = featureModules[featureName];\n  var initResult = void 0;\n  try {\n    initResult = feature._rs_init(this);\n  } catch (e) {\n    this.featureFailed(featureName, e);\n    return;\n  }\n\n  if ((typeof initResult === 'undefined' ? 'undefined' : _typeof(initResult)) === 'object' && typeof initResult.then === 'function') {\n    initResult.then(function () {\n      _this2.featureInitialized(featureName);\n    }, function (err) {\n      _this2.featureFailed(featureName, err);\n    });\n  } else {\n    this.featureInitialized(featureName);\n  }\n}\n\nfunction featureFailed(featureName, err) {\n  // log(`[RemoteStorage] [FEATURE ${featureName}] initialization failed (${err})`);\n  this.featureDone();\n}\n\nfunction featureSupported(featureName, success) {\n  // log(`[RemoteStorage] [FEATURE ${featureName}]  ${success ? '' : ' not'} supported`);\n  if (!success) {\n    this.featureDone();\n  }\n}\n\nfunction featureInitialized(featureName) {\n  log('[RemoteStorage] [FEATURE ' + featureName + '] initialized.');\n  features.push({\n    name: featureName,\n    init: featureModules[featureName]._rs_init,\n    supported: true,\n    cleanup: featureModules[featureName]._rs_cleanup\n  });\n  this.featureDone();\n}\n\nfunction featureDone() {\n  featuresDone++;\n  if (featuresDone === Object.keys(featureModules).length) {\n    setTimeout(this.featuresLoaded.bind(this), 0);\n  }\n}\n\nfunction _setCachingModule() {\n  var cachingModules = ['IndexedDB', 'LocalStorage', 'InMemoryStorage'];\n\n  cachingModules.some(function (cachingLayer) {\n    if (features.some(function (feature) {\n      return feature.name === cachingLayer;\n    })) {\n      features.local = featureModules[cachingLayer];\n      return true;\n    }\n  });\n}\n\nfunction _fireReady() {\n  try {\n    if (!readyFired) {\n      this._emit('ready');\n      readyFired = true;\n    }\n  } catch (e) {\n    console.error(\"'ready' failed: \", e, e.stack);\n    this._emit('error', e);\n  }\n}\n\nfunction featuresLoaded() {\n  var _this3 = this;\n\n  log('[REMOTESTORAGE] All features loaded !');\n\n  this._setCachingModule();\n  this.local = config.cache && features.local && new features.local();\n\n  // this.remote set by WireClient._rs_init as lazy property on\n  // RS.prototype\n\n  if (this.local && this.remote) {\n    this._setGPD(SyncedGetPutDelete, this);\n    this._bindChange(this.local);\n  } else if (this.remote) {\n    this._setGPD(this.remote, this.remote);\n  }\n  if (this.remote) {\n    this.remote.on('connected', function () {\n      _this3._fireReady();\n      _this3._emit('connected');\n    });\n    this.remote.on('not-connected', function () {\n      _this3._fireReady();\n      _this3._emit('not-connected');\n    });\n    if (this.remote.connected) {\n      this._fireReady();\n      this._emit('connected');\n    }\n\n    if (!this.hasFeature('Authorize')) {\n      this.remote.stopWaitingForToken();\n    }\n  }\n\n  this._collectCleanupFunctions();\n\n  try {\n    this._allLoaded = true;\n    this._emit('features-loaded');\n  } catch (exc) {\n    util.logError(exc);\n    this._emit('error', exc);\n  }\n  this._processPending();\n}\n\nfunction _collectCleanupFunctions() {\n  this._cleanups = [];\n  for (var i = 0; i < features.length; i++) {\n    var cleanup = features[i].cleanup;\n    if (typeof cleanup === 'function') {\n      this._cleanups.push(cleanup);\n    }\n  }\n}\n\nmodule.exports = (_module$exports = {\n  features: features,\n  loadFeature: loadFeature,\n  initFeature: initFeature,\n  loadFeatures: loadFeatures,\n  featureSupported: featureSupported,\n  featuresDone: featuresDone,\n  featureDone: featureDone,\n  featuresLoaded: featuresLoaded,\n  featureInitialized: featureInitialized,\n  featureFailed: featureFailed\n}, _defineProperty(_module$exports, 'featureSupported', featureSupported), _defineProperty(_module$exports, 'hasFeature', hasFeature), _defineProperty(_module$exports, '_setCachingModule', _setCachingModule), _defineProperty(_module$exports, '_collectCleanupFunctions', _collectCleanupFunctions), _defineProperty(_module$exports, '_fireReady', _fireReady), _module$exports);\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvZmVhdHVyZXMuanM/MmM1NSJdLCJuYW1lcyI6WyJ1dGlsIiwicmVxdWlyZSIsImxvZyIsIlN5bmNlZEdldFB1dERlbGV0ZSIsImNvbmZpZyIsImZlYXR1cmVzRG9uZSIsImZlYXR1cmVzIiwicmVhZHlGaXJlZCIsImZlYXR1cmVNb2R1bGVzIiwibG9hZEZlYXR1cmVzIiwiX2FsbExvYWRlZCIsImZlYXR1cmVOYW1lIiwibG9hZEZlYXR1cmUiLCJoYXNGZWF0dXJlIiwiZmVhdHVyZSIsImkiLCJsZW5ndGgiLCJuYW1lIiwic3VwcG9ydGVkIiwiX3JzX3N1cHBvcnRlZCIsImNhY2hlIiwidGhlbiIsImZlYXR1cmVTdXBwb3J0ZWQiLCJpbml0RmVhdHVyZSIsImluaXRSZXN1bHQiLCJfcnNfaW5pdCIsImUiLCJmZWF0dXJlRmFpbGVkIiwiZmVhdHVyZUluaXRpYWxpemVkIiwiZXJyIiwiZmVhdHVyZURvbmUiLCJzdWNjZXNzIiwicHVzaCIsImluaXQiLCJjbGVhbnVwIiwiX3JzX2NsZWFudXAiLCJPYmplY3QiLCJrZXlzIiwic2V0VGltZW91dCIsImZlYXR1cmVzTG9hZGVkIiwiYmluZCIsIl9zZXRDYWNoaW5nTW9kdWxlIiwiY2FjaGluZ01vZHVsZXMiLCJzb21lIiwiY2FjaGluZ0xheWVyIiwibG9jYWwiLCJfZmlyZVJlYWR5IiwiX2VtaXQiLCJjb25zb2xlIiwiZXJyb3IiLCJzdGFjayIsInJlbW90ZSIsIl9zZXRHUEQiLCJfYmluZENoYW5nZSIsIm9uIiwiY29ubmVjdGVkIiwic3RvcFdhaXRpbmdGb3JUb2tlbiIsIl9jb2xsZWN0Q2xlYW51cEZ1bmN0aW9ucyIsImV4YyIsImxvZ0Vycm9yIiwiX3Byb2Nlc3NQZW5kaW5nIiwiX2NsZWFudXBzIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7O0FBRUEsSUFBTUEsT0FBTyxtQkFBQUMsQ0FBUSxDQUFSLENBQWI7QUFDQSxJQUFNQyxNQUFNLG1CQUFBRCxDQUFRLENBQVIsQ0FBWjtBQUNBLElBQU1FLHFCQUFxQixtQkFBQUYsQ0FBUSxFQUFSLENBQTNCO0FBQ0EsSUFBTUcsU0FBUyxtQkFBQUgsQ0FBUSxDQUFSLENBQWY7O0FBRUEsSUFBSUksZUFBZSxDQUFuQjtBQUNBLElBQUlDLFdBQVcsRUFBZjtBQUNBLElBQUlDLGFBQWEsS0FBakI7O0FBR0EsSUFBSUMsaUJBQWlCO0FBQ25CO0FBQ0EsVUFBUSxtQkFBQVAsQ0FBUSxFQUFSLENBRlc7QUFHbkIsYUFBVyxtQkFBQUEsQ0FBUSxDQUFSLENBSFE7QUFJbkIsaUJBQWUsbUJBQUFBLENBQVEsRUFBUixDQUpJO0FBS25CLFlBQVUsbUJBQUFBLENBQVEsRUFBUixDQUxTO0FBTW5CLGFBQVcsbUJBQUFBLENBQVEsRUFBUixDQU5RO0FBT25CLGNBQVksbUJBQUFBLENBQVEsRUFBUixDQVBPO0FBUW5CLGVBQWEsbUJBQUFBLENBQVEsQ0FBUixDQVJNO0FBU25CLGVBQWEsbUJBQUFBLENBQVEsRUFBUixDQVRNO0FBVW5CLGtCQUFnQixtQkFBQUEsQ0FBUSxFQUFSLENBVkc7QUFXbkIscUJBQW1CLG1CQUFBQSxDQUFRLEVBQVIsQ0FYQTtBQVluQixVQUFRLG1CQUFBQSxDQUFRLEVBQVIsQ0FaVztBQWFuQixnQkFBYyxtQkFBQUEsQ0FBUSxDQUFSLENBYks7QUFjbkIsU0FBTyxtQkFBQUEsQ0FBUSxFQUFSO0FBZFksQ0FBckI7O0FBaUJBLFNBQVNRLFlBQVQsR0FBd0I7QUFDdEJKLGlCQUFlLENBQWY7QUFDQUMsYUFBVyxFQUFYO0FBQ0FDLGVBQWEsS0FBYjs7QUFFQSxPQUFLRyxVQUFMLEdBQWtCLEtBQWxCO0FBQ0EsT0FBSyxJQUFJQyxXQUFULElBQXdCSCxjQUF4QixFQUF3QztBQUN0QztBQUNBO0FBQ0E7QUFDQSxTQUFLSSxXQUFMLENBQWlCRCxXQUFqQjtBQUNEO0FBQ0Y7O0FBRUc7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBaUJKLFNBQVNFLFVBQVQsQ0FBb0JDLE9BQXBCLEVBQTZCO0FBQzNCLE9BQUssSUFBSUMsSUFBSVQsU0FBU1UsTUFBVCxHQUFrQixDQUEvQixFQUFrQ0QsS0FBSyxDQUF2QyxFQUEwQ0EsR0FBMUMsRUFBK0M7QUFDN0MsUUFBSVQsU0FBU1MsQ0FBVCxFQUFZRSxJQUFaLEtBQXFCSCxPQUF6QixFQUFrQztBQUNoQyxhQUFPUixTQUFTUyxDQUFULEVBQVlHLFNBQW5CO0FBQ0Q7QUFDRjtBQUNELFNBQU8sS0FBUDtBQUNEOztBQUVELFNBQVNOLFdBQVQsQ0FBcUJELFdBQXJCLEVBQWtDO0FBQUE7O0FBQ2hDLE1BQU1HLFVBQVVOLGVBQWVHLFdBQWYsQ0FBaEI7QUFDQSxNQUFJTyxZQUFZLENBQUNKLFFBQVFLLGFBQVQsSUFBMEJMLFFBQVFLLGFBQVIsRUFBMUM7O0FBRUEsTUFBSSxDQUFDZixPQUFPZ0IsS0FBUixJQUFpQlQsZ0JBQWdCLE1BQXJDLEVBQTZDO0FBQzNDTyxnQkFBWSxLQUFaO0FBQ0Q7QUFDRDs7QUFFQSxNQUFJLFFBQU9BLFNBQVAseUNBQU9BLFNBQVAsT0FBcUIsUUFBekIsRUFBbUM7QUFDakNBLGNBQVVHLElBQVYsQ0FBZ0IsWUFBTTtBQUNwQixZQUFLQyxnQkFBTCxDQUFzQlgsV0FBdEIsRUFBbUMsSUFBbkM7QUFDQSxZQUFLWSxXQUFMLENBQWlCWixXQUFqQjtBQUNELEtBSEQsRUFHRyxZQUFNO0FBQ1AsWUFBS1csZ0JBQUwsQ0FBc0JYLFdBQXRCLEVBQW1DLEtBQW5DO0FBQ0QsS0FMRDtBQU1ELEdBUEQsTUFPTyxJQUFJLE9BQU9PLFNBQVAsS0FBcUIsU0FBekIsRUFBb0M7QUFDekMsU0FBS0ksZ0JBQUwsQ0FBc0JYLFdBQXRCLEVBQW1DTyxTQUFuQztBQUNBLFFBQUlBLFNBQUosRUFBZTtBQUNiLFdBQUtLLFdBQUwsQ0FBaUJaLFdBQWpCO0FBQ0Q7QUFDRixHQUxNLE1BS0E7QUFDTCxTQUFLVyxnQkFBTCxDQUFzQlgsV0FBdEIsRUFBbUMsS0FBbkM7QUFDRDtBQUNGOztBQUVELFNBQVNZLFdBQVQsQ0FBcUJaLFdBQXJCLEVBQWtDO0FBQUE7O0FBQ2hDLE1BQU1HLFVBQVVOLGVBQWVHLFdBQWYsQ0FBaEI7QUFDQSxNQUFJYSxtQkFBSjtBQUNBLE1BQUk7QUFDRkEsaUJBQWFWLFFBQVFXLFFBQVIsQ0FBaUIsSUFBakIsQ0FBYjtBQUNELEdBRkQsQ0FFRSxPQUFNQyxDQUFOLEVBQVM7QUFDVCxTQUFLQyxhQUFMLENBQW1CaEIsV0FBbkIsRUFBZ0NlLENBQWhDO0FBQ0E7QUFDRDs7QUFFRCxNQUFJLFFBQU9GLFVBQVAseUNBQU9BLFVBQVAsT0FBdUIsUUFBdkIsSUFBbUMsT0FBT0EsV0FBV0gsSUFBbEIsS0FBNEIsVUFBbkUsRUFBK0U7QUFDN0VHLGVBQVdILElBQVgsQ0FDRSxZQUFNO0FBQUUsYUFBS08sa0JBQUwsQ0FBd0JqQixXQUF4QjtBQUF1QyxLQURqRCxFQUVFLFVBQUNrQixHQUFELEVBQVM7QUFBRSxhQUFLRixhQUFMLENBQW1CaEIsV0FBbkIsRUFBZ0NrQixHQUFoQztBQUF1QyxLQUZwRDtBQUlELEdBTEQsTUFLTztBQUNMLFNBQUtELGtCQUFMLENBQXdCakIsV0FBeEI7QUFDRDtBQUNGOztBQUVELFNBQVNnQixhQUFULENBQXVCaEIsV0FBdkIsRUFBb0NrQixHQUFwQyxFQUF5QztBQUN2QztBQUNBLE9BQUtDLFdBQUw7QUFDRDs7QUFHRCxTQUFTUixnQkFBVCxDQUEwQlgsV0FBMUIsRUFBdUNvQixPQUF2QyxFQUFnRDtBQUM5QztBQUNBLE1BQUksQ0FBQ0EsT0FBTCxFQUFjO0FBQ1osU0FBS0QsV0FBTDtBQUNEO0FBQ0Y7O0FBRUQsU0FBU0Ysa0JBQVQsQ0FBNEJqQixXQUE1QixFQUF5QztBQUN2Q1Qsb0NBQWdDUyxXQUFoQztBQUNBTCxXQUFTMEIsSUFBVCxDQUFjO0FBQ1pmLFVBQU9OLFdBREs7QUFFWnNCLFVBQVF6QixlQUFlRyxXQUFmLEVBQTRCYyxRQUZ4QjtBQUdaUCxlQUFZLElBSEE7QUFJWmdCLGFBQVUxQixlQUFlRyxXQUFmLEVBQTRCd0I7QUFKMUIsR0FBZDtBQU1BLE9BQUtMLFdBQUw7QUFDRDs7QUFFRCxTQUFTQSxXQUFULEdBQXdCO0FBQ3RCekI7QUFDQSxNQUFJQSxpQkFBaUIrQixPQUFPQyxJQUFQLENBQVk3QixjQUFaLEVBQTRCUSxNQUFqRCxFQUF5RDtBQUN2RHNCLGVBQVcsS0FBS0MsY0FBTCxDQUFvQkMsSUFBcEIsQ0FBeUIsSUFBekIsQ0FBWCxFQUEyQyxDQUEzQztBQUNEO0FBQ0Y7O0FBRUQsU0FBU0MsaUJBQVQsR0FBOEI7QUFDNUIsTUFBTUMsaUJBQWlCLENBQUMsV0FBRCxFQUFjLGNBQWQsRUFBOEIsaUJBQTlCLENBQXZCOztBQUVBQSxpQkFBZUMsSUFBZixDQUFxQix3QkFBZ0I7QUFDbkMsUUFBSXJDLFNBQVNxQyxJQUFULENBQWM7QUFBQSxhQUFXN0IsUUFBUUcsSUFBUixLQUFpQjJCLFlBQTVCO0FBQUEsS0FBZCxDQUFKLEVBQTZEO0FBQzNEdEMsZUFBU3VDLEtBQVQsR0FBaUJyQyxlQUFlb0MsWUFBZixDQUFqQjtBQUNBLGFBQU8sSUFBUDtBQUNEO0FBQ0YsR0FMRDtBQU1EOztBQUdELFNBQVNFLFVBQVQsR0FBc0I7QUFDcEIsTUFBSTtBQUNGLFFBQUksQ0FBQ3ZDLFVBQUwsRUFBaUI7QUFDZixXQUFLd0MsS0FBTCxDQUFXLE9BQVg7QUFDQXhDLG1CQUFhLElBQWI7QUFDRDtBQUNGLEdBTEQsQ0FLRSxPQUFNbUIsQ0FBTixFQUFTO0FBQ1RzQixZQUFRQyxLQUFSLENBQWMsa0JBQWQsRUFBa0N2QixDQUFsQyxFQUFxQ0EsRUFBRXdCLEtBQXZDO0FBQ0EsU0FBS0gsS0FBTCxDQUFXLE9BQVgsRUFBb0JyQixDQUFwQjtBQUNEO0FBQ0Y7O0FBRUQsU0FBU2EsY0FBVCxHQUEyQjtBQUFBOztBQUMxQnJDOztBQUVBLE9BQUt1QyxpQkFBTDtBQUNDLE9BQUtJLEtBQUwsR0FBYXpDLE9BQU9nQixLQUFQLElBQWdCZCxTQUFTdUMsS0FBekIsSUFBa0MsSUFBSXZDLFNBQVN1QyxLQUFiLEVBQS9DOztBQUVBO0FBQ0E7O0FBRUEsTUFBSSxLQUFLQSxLQUFMLElBQWMsS0FBS00sTUFBdkIsRUFBK0I7QUFDN0IsU0FBS0MsT0FBTCxDQUFhakQsa0JBQWIsRUFBaUMsSUFBakM7QUFDQSxTQUFLa0QsV0FBTCxDQUFpQixLQUFLUixLQUF0QjtBQUNELEdBSEQsTUFHTyxJQUFJLEtBQUtNLE1BQVQsRUFBaUI7QUFDdEIsU0FBS0MsT0FBTCxDQUFhLEtBQUtELE1BQWxCLEVBQTBCLEtBQUtBLE1BQS9CO0FBQ0Q7QUFDRCxNQUFJLEtBQUtBLE1BQVQsRUFBaUI7QUFDZixTQUFLQSxNQUFMLENBQVlHLEVBQVosQ0FBZSxXQUFmLEVBQTRCLFlBQU07QUFDaEMsYUFBS1IsVUFBTDtBQUNBLGFBQUtDLEtBQUwsQ0FBVyxXQUFYO0FBQ0QsS0FIRDtBQUlBLFNBQUtJLE1BQUwsQ0FBWUcsRUFBWixDQUFlLGVBQWYsRUFBZ0MsWUFBTTtBQUNwQyxhQUFLUixVQUFMO0FBQ0EsYUFBS0MsS0FBTCxDQUFXLGVBQVg7QUFDRCxLQUhEO0FBSUEsUUFBSSxLQUFLSSxNQUFMLENBQVlJLFNBQWhCLEVBQTJCO0FBQ3pCLFdBQUtULFVBQUw7QUFDQSxXQUFLQyxLQUFMLENBQVcsV0FBWDtBQUNEOztBQUVELFFBQUksQ0FBQyxLQUFLbEMsVUFBTCxDQUFnQixXQUFoQixDQUFMLEVBQW1DO0FBQ2pDLFdBQUtzQyxNQUFMLENBQVlLLG1CQUFaO0FBQ0Q7QUFDRjs7QUFFRCxPQUFLQyx3QkFBTDs7QUFFQSxNQUFJO0FBQ0YsU0FBSy9DLFVBQUwsR0FBa0IsSUFBbEI7QUFDQSxTQUFLcUMsS0FBTCxDQUFXLGlCQUFYO0FBQ0QsR0FIRCxDQUdFLE9BQU1XLEdBQU4sRUFBVztBQUNYMUQsU0FBSzJELFFBQUwsQ0FBY0QsR0FBZDtBQUNBLFNBQUtYLEtBQUwsQ0FBVyxPQUFYLEVBQW9CVyxHQUFwQjtBQUNEO0FBQ0QsT0FBS0UsZUFBTDtBQUNEOztBQUVELFNBQVNILHdCQUFULEdBQXFDO0FBQ25DLE9BQUtJLFNBQUwsR0FBaUIsRUFBakI7QUFDQSxPQUFLLElBQUk5QyxJQUFFLENBQVgsRUFBY0EsSUFBSVQsU0FBU1UsTUFBM0IsRUFBbUNELEdBQW5DLEVBQXdDO0FBQ3RDLFFBQUltQixVQUFVNUIsU0FBU1MsQ0FBVCxFQUFZbUIsT0FBMUI7QUFDQSxRQUFJLE9BQU9BLE9BQVAsS0FBb0IsVUFBeEIsRUFBb0M7QUFDbEMsV0FBSzJCLFNBQUwsQ0FBZTdCLElBQWYsQ0FBb0JFLE9BQXBCO0FBQ0Q7QUFDRjtBQUNGOztBQUVENEIsT0FBT0MsT0FBUDtBQUNDekQsb0JBREQ7QUFFQ00sMEJBRkQ7QUFHQ1csMEJBSEQ7QUFJQ2QsNEJBSkQ7QUFLQ2Esb0NBTEQ7QUFNQ2pCLDRCQU5EO0FBT0N5QiwwQkFQRDtBQVFDUyxnQ0FSRDtBQVNDWCx3Q0FURDtBQVVDRDtBQVZELHdEQVdDTCxnQkFYRCxrREFZQ1QsVUFaRCx5REFhQzRCLGlCQWJELGdFQWNDZ0Isd0JBZEQsa0RBZUNYLFVBZkQiLCJmaWxlIjoiMjQuanMiLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmNvbnN0IHV0aWwgPSByZXF1aXJlKCcuL3V0aWwnKTtcbmNvbnN0IGxvZyA9IHJlcXVpcmUoJy4vbG9nJyk7XG5jb25zdCBTeW5jZWRHZXRQdXREZWxldGUgPSByZXF1aXJlKCcuL3N5bmNlZGdldHB1dGRlbGV0ZScpO1xuY29uc3QgY29uZmlnID0gcmVxdWlyZSgnLi9jb25maWcnKTtcblxubGV0IGZlYXR1cmVzRG9uZSA9IDA7XG5sZXQgZmVhdHVyZXMgPSBbXTtcbmxldCByZWFkeUZpcmVkID0gZmFsc2U7XG5cblxubGV0IGZlYXR1cmVNb2R1bGVzID0ge1xuICAvLyAnV2lyZUNsaWVudCc6IHJlcXVpcmUoJy4vd2lyZWNsaWVudCcpLFxuICAnSTE4bic6IHJlcXVpcmUoJy4vaTE4bicpLFxuICAnRHJvcGJveCc6IHJlcXVpcmUoJy4vZHJvcGJveCcpLFxuICAnR29vZ2xlRHJpdmUnOiByZXF1aXJlKCcuL2dvb2dsZWRyaXZlJyksXG4gICdBY2Nlc3MnOiByZXF1aXJlKCcuL2FjY2VzcycpLFxuICAnQ2FjaGluZyc6IHJlcXVpcmUoJy4vY2FjaGluZycpLFxuICAnRGlzY292ZXInOiByZXF1aXJlKCcuL2Rpc2NvdmVyJyksXG4gICdBdXRob3JpemUnOiByZXF1aXJlKCcuL2F1dGhvcml6ZScpLFxuICAnSW5kZXhlZERCJzogcmVxdWlyZSgnLi9pbmRleGVkZGInKSxcbiAgJ0xvY2FsU3RvcmFnZSc6IHJlcXVpcmUoJy4vbG9jYWxzdG9yYWdlJyksXG4gICdJbk1lbW9yeVN0b3JhZ2UnOiByZXF1aXJlKCcuL2lubWVtb3J5c3RvcmFnZScpLFxuICAnU3luYyc6IHJlcXVpcmUoJy4vc3luYycpLFxuICAnQmFzZUNsaWVudCc6IHJlcXVpcmUoJy4vYmFzZWNsaWVudCcpLFxuICAnRW52JzogcmVxdWlyZSgnLi9lbnYnKVxufTtcblxuZnVuY3Rpb24gbG9hZEZlYXR1cmVzKCkge1xuICBmZWF0dXJlc0RvbmUgPSAwO1xuICBmZWF0dXJlcyA9IFtdO1xuICByZWFkeUZpcmVkID0gZmFsc2U7XG4gIFxuICB0aGlzLl9hbGxMb2FkZWQgPSBmYWxzZTtcbiAgZm9yIChsZXQgZmVhdHVyZU5hbWUgaW4gZmVhdHVyZU1vZHVsZXMpIHtcbiAgICAvLyBUT0ZJWCB0aGlzIGhhcyB0byBwdXNoIHRoZSBwcm9taXNlZCByZXR1cm4gdmFsdWUgaW50byBhblxuICAgIC8vIGFycmF5IG9mIHByb21pc2VzIGFuZCB1c2UgUHJvbWlzZS5hbGwgdG8gZW1pdCBgcmVhZHlgXG4gICAgLy8gaW5zdGVhZCBvZiBpbmNyZW1lbnQgYSBjb3VudGVyIG9mIGxvYWRlZCBmZWF0dXJlcy5cbiAgICB0aGlzLmxvYWRGZWF0dXJlKGZlYXR1cmVOYW1lKVxuICB9XG59XG5cbiAgICAvKipcbiAgICAgKiBNZXRob2Q6IGhhc0ZlYXR1cmVcbiAgICAgKlxuICAgICAqIENoZWNrcyB3aGV0aGVyIGEgZmVhdHVyZSBpcyBlbmFibGVkIG9yIG5vdCB3aXRoaW4gcmVtb3RlU3RvcmFnZS5cbiAgICAgKiBSZXR1cm5zIGEgYm9vbGVhbi5cbiAgICAgKlxuICAgICAqIFBhcmFtZXRlcnM6XG4gICAgICogICBuYW1lIC0gQ2FwaXRhbGl6ZWQgbmFtZSBvZiB0aGUgZmVhdHVyZS4gZS5nLiBBdXRob3JpemUsIG9yIEluZGV4ZWREQlxuICAgICAqXG4gICAgICogRXhhbXBsZTpcbiAgICAgKiAgIChzdGFydCBjb2RlKVxuICAgICAqICAgaWYgKHJlbW90ZVN0b3JhZ2UuaGFzRmVhdHVyZSgnTG9jYWxTdG9yYWdlJykpIHtcbiAgICAgKiAgICAgY29uc29sZS5sb2coJ0xvY2FsU3RvcmFnZSBpcyBlbmFibGVkIScpO1xuICAgICAqICAgfVxuICAgICAqICAgKGVuZCBjb2RlKVxuICAgICAqXG4gICAgICovXG5mdW5jdGlvbiBoYXNGZWF0dXJlKGZlYXR1cmUpIHtcbiAgZm9yICh2YXIgaSA9IGZlYXR1cmVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgaWYgKGZlYXR1cmVzW2ldLm5hbWUgPT09IGZlYXR1cmUpIHtcbiAgICAgIHJldHVybiBmZWF0dXJlc1tpXS5zdXBwb3J0ZWQ7XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gbG9hZEZlYXR1cmUoZmVhdHVyZU5hbWUpIHtcbiAgY29uc3QgZmVhdHVyZSA9IGZlYXR1cmVNb2R1bGVzW2ZlYXR1cmVOYW1lXTtcbiAgbGV0IHN1cHBvcnRlZCA9ICFmZWF0dXJlLl9yc19zdXBwb3J0ZWQgfHwgZmVhdHVyZS5fcnNfc3VwcG9ydGVkKCk7XG5cbiAgaWYgKCFjb25maWcuY2FjaGUgJiYgZmVhdHVyZU5hbWUgPT09ICdTeW5jJykge1xuICAgIHN1cHBvcnRlZCA9IGZhbHNlO1xuICB9XG4gIC8vIGxvZyhgW1JlbW90ZVN0b3JhZ2VdIFtGRUFUVVJFICR7ZmVhdHVyZU5hbWV9XSBpbml0aWFsaXppbmcgLi4uYCk7XG5cbiAgaWYgKHR5cGVvZiBzdXBwb3J0ZWQgPT09ICdvYmplY3QnKSB7XG4gICAgc3VwcG9ydGVkLnRoZW4oICgpID0+IHtcbiAgICAgIHRoaXMuZmVhdHVyZVN1cHBvcnRlZChmZWF0dXJlTmFtZSwgdHJ1ZSk7XG4gICAgICB0aGlzLmluaXRGZWF0dXJlKGZlYXR1cmVOYW1lKTtcbiAgICB9LCAoKSA9PiB7XG4gICAgICB0aGlzLmZlYXR1cmVTdXBwb3J0ZWQoZmVhdHVyZU5hbWUsIGZhbHNlKTtcbiAgICB9KTtcbiAgfSBlbHNlIGlmICh0eXBlb2Ygc3VwcG9ydGVkID09PSAnYm9vbGVhbicpIHtcbiAgICB0aGlzLmZlYXR1cmVTdXBwb3J0ZWQoZmVhdHVyZU5hbWUsIHN1cHBvcnRlZCk7XG4gICAgaWYgKHN1cHBvcnRlZCkge1xuICAgICAgdGhpcy5pbml0RmVhdHVyZShmZWF0dXJlTmFtZSk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHRoaXMuZmVhdHVyZVN1cHBvcnRlZChmZWF0dXJlTmFtZSwgZmFsc2UpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGluaXRGZWF0dXJlKGZlYXR1cmVOYW1lKSB7XG4gIGNvbnN0IGZlYXR1cmUgPSBmZWF0dXJlTW9kdWxlc1tmZWF0dXJlTmFtZV1cbiAgbGV0IGluaXRSZXN1bHQ7XG4gIHRyeSB7XG4gICAgaW5pdFJlc3VsdCA9IGZlYXR1cmUuX3JzX2luaXQodGhpcyk7XG4gIH0gY2F0Y2goZSkge1xuICAgIHRoaXMuZmVhdHVyZUZhaWxlZChmZWF0dXJlTmFtZSwgZSk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKHR5cGVvZihpbml0UmVzdWx0KSA9PT0gJ29iamVjdCcgJiYgdHlwZW9mKGluaXRSZXN1bHQudGhlbikgPT09ICdmdW5jdGlvbicpIHtcbiAgICBpbml0UmVzdWx0LnRoZW4oXG4gICAgICAoKSA9PiB7IHRoaXMuZmVhdHVyZUluaXRpYWxpemVkKGZlYXR1cmVOYW1lKTsgfSxcbiAgICAgIChlcnIpID0+IHsgdGhpcy5mZWF0dXJlRmFpbGVkKGZlYXR1cmVOYW1lLCBlcnIpOyB9XG4gICAgKTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLmZlYXR1cmVJbml0aWFsaXplZChmZWF0dXJlTmFtZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZmVhdHVyZUZhaWxlZChmZWF0dXJlTmFtZSwgZXJyKSB7XG4gIC8vIGxvZyhgW1JlbW90ZVN0b3JhZ2VdIFtGRUFUVVJFICR7ZmVhdHVyZU5hbWV9XSBpbml0aWFsaXphdGlvbiBmYWlsZWQgKCR7ZXJyfSlgKTtcbiAgdGhpcy5mZWF0dXJlRG9uZSgpO1xufVxuXG5cbmZ1bmN0aW9uIGZlYXR1cmVTdXBwb3J0ZWQoZmVhdHVyZU5hbWUsIHN1Y2Nlc3MpIHtcbiAgLy8gbG9nKGBbUmVtb3RlU3RvcmFnZV0gW0ZFQVRVUkUgJHtmZWF0dXJlTmFtZX1dICAke3N1Y2Nlc3MgPyAnJyA6ICcgbm90J30gc3VwcG9ydGVkYCk7XG4gIGlmICghc3VjY2Vzcykge1xuICAgIHRoaXMuZmVhdHVyZURvbmUoKVxuICB9XG59XG5cbmZ1bmN0aW9uIGZlYXR1cmVJbml0aWFsaXplZChmZWF0dXJlTmFtZSkge1xuICBsb2coYFtSZW1vdGVTdG9yYWdlXSBbRkVBVFVSRSAke2ZlYXR1cmVOYW1lfV0gaW5pdGlhbGl6ZWQuYCk7XG4gIGZlYXR1cmVzLnB1c2goe1xuICAgIG5hbWUgOiBmZWF0dXJlTmFtZSxcbiAgICBpbml0IDogIGZlYXR1cmVNb2R1bGVzW2ZlYXR1cmVOYW1lXS5fcnNfaW5pdCxcbiAgICBzdXBwb3J0ZWQgOiB0cnVlLFxuICAgIGNsZWFudXAgOiBmZWF0dXJlTW9kdWxlc1tmZWF0dXJlTmFtZV0uX3JzX2NsZWFudXBcbiAgfSk7XG4gIHRoaXMuZmVhdHVyZURvbmUoKTtcbn1cblxuZnVuY3Rpb24gZmVhdHVyZURvbmUgKCkge1xuICBmZWF0dXJlc0RvbmUrKztcbiAgaWYgKGZlYXR1cmVzRG9uZSA9PT0gT2JqZWN0LmtleXMoZmVhdHVyZU1vZHVsZXMpLmxlbmd0aCkge1xuICAgIHNldFRpbWVvdXQodGhpcy5mZWF0dXJlc0xvYWRlZC5iaW5kKHRoaXMpLCAwKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBfc2V0Q2FjaGluZ01vZHVsZSAoKSB7XG4gIGNvbnN0IGNhY2hpbmdNb2R1bGVzID0gWydJbmRleGVkREInLCAnTG9jYWxTdG9yYWdlJywgJ0luTWVtb3J5U3RvcmFnZSddO1xuXG4gIGNhY2hpbmdNb2R1bGVzLnNvbWUoIGNhY2hpbmdMYXllciA9PiB7XG4gICAgaWYgKGZlYXR1cmVzLnNvbWUoZmVhdHVyZSA9PiBmZWF0dXJlLm5hbWUgPT09IGNhY2hpbmdMYXllcikpIHtcbiAgICAgIGZlYXR1cmVzLmxvY2FsID0gZmVhdHVyZU1vZHVsZXNbY2FjaGluZ0xheWVyXTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfSk7XG59XG5cblxuZnVuY3Rpb24gX2ZpcmVSZWFkeSgpIHtcbiAgdHJ5IHtcbiAgICBpZiAoIXJlYWR5RmlyZWQpIHtcbiAgICAgIHRoaXMuX2VtaXQoJ3JlYWR5Jyk7XG4gICAgICByZWFkeUZpcmVkID0gdHJ1ZTtcbiAgICB9XG4gIH0gY2F0Y2goZSkge1xuICAgIGNvbnNvbGUuZXJyb3IoXCIncmVhZHknIGZhaWxlZDogXCIsIGUsIGUuc3RhY2spO1xuICAgIHRoaXMuX2VtaXQoJ2Vycm9yJywgZSk7XG4gIH1cbn1cdCAgIFxuXG5mdW5jdGlvbiBmZWF0dXJlc0xvYWRlZCAoKSB7XG5cdGxvZyhgW1JFTU9URVNUT1JBR0VdIEFsbCBmZWF0dXJlcyBsb2FkZWQgIWApXG5cdFxuXHR0aGlzLl9zZXRDYWNoaW5nTW9kdWxlKClcbiAgdGhpcy5sb2NhbCA9IGNvbmZpZy5jYWNoZSAmJiBmZWF0dXJlcy5sb2NhbCAmJiBuZXcgZmVhdHVyZXMubG9jYWwoKTtcblxuICAvLyB0aGlzLnJlbW90ZSBzZXQgYnkgV2lyZUNsaWVudC5fcnNfaW5pdCBhcyBsYXp5IHByb3BlcnR5IG9uXG4gIC8vIFJTLnByb3RvdHlwZVxuXG4gIGlmICh0aGlzLmxvY2FsICYmIHRoaXMucmVtb3RlKSB7XG4gICAgdGhpcy5fc2V0R1BEKFN5bmNlZEdldFB1dERlbGV0ZSwgdGhpcyk7XG4gICAgdGhpcy5fYmluZENoYW5nZSh0aGlzLmxvY2FsKTtcbiAgfSBlbHNlIGlmICh0aGlzLnJlbW90ZSkge1xuICAgIHRoaXMuX3NldEdQRCh0aGlzLnJlbW90ZSwgdGhpcy5yZW1vdGUpO1xuICB9XG4gIGlmICh0aGlzLnJlbW90ZSkge1xuICAgIHRoaXMucmVtb3RlLm9uKCdjb25uZWN0ZWQnLCAoKSA9PiB7XG4gICAgICB0aGlzLl9maXJlUmVhZHkoKTtcbiAgICAgIHRoaXMuX2VtaXQoJ2Nvbm5lY3RlZCcpO1xuICAgIH0pO1xuICAgIHRoaXMucmVtb3RlLm9uKCdub3QtY29ubmVjdGVkJywgKCkgPT4ge1xuICAgICAgdGhpcy5fZmlyZVJlYWR5KCk7XG4gICAgICB0aGlzLl9lbWl0KCdub3QtY29ubmVjdGVkJyk7XG4gICAgfSk7XG4gICAgaWYgKHRoaXMucmVtb3RlLmNvbm5lY3RlZCkge1xuICAgICAgdGhpcy5fZmlyZVJlYWR5KCk7XG4gICAgICB0aGlzLl9lbWl0KCdjb25uZWN0ZWQnKTtcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMuaGFzRmVhdHVyZSgnQXV0aG9yaXplJykpIHtcbiAgICAgIHRoaXMucmVtb3RlLnN0b3BXYWl0aW5nRm9yVG9rZW4oKTtcbiAgICB9XG4gIH1cblxuICB0aGlzLl9jb2xsZWN0Q2xlYW51cEZ1bmN0aW9ucygpO1xuXG4gIHRyeSB7XG4gICAgdGhpcy5fYWxsTG9hZGVkID0gdHJ1ZTtcbiAgICB0aGlzLl9lbWl0KCdmZWF0dXJlcy1sb2FkZWQnKTtcbiAgfSBjYXRjaChleGMpIHtcbiAgICB1dGlsLmxvZ0Vycm9yKGV4Yyk7XG4gICAgdGhpcy5fZW1pdCgnZXJyb3InLCBleGMpO1xuICB9XG4gIHRoaXMuX3Byb2Nlc3NQZW5kaW5nKCk7XG59XG5cbmZ1bmN0aW9uIF9jb2xsZWN0Q2xlYW51cEZ1bmN0aW9ucyAoKSB7XG4gIHRoaXMuX2NsZWFudXBzID0gW107XG4gIGZvciAobGV0IGk9MDsgaSA8IGZlYXR1cmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgbGV0IGNsZWFudXAgPSBmZWF0dXJlc1tpXS5jbGVhbnVwO1xuICAgIGlmICh0eXBlb2YoY2xlYW51cCkgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRoaXMuX2NsZWFudXBzLnB1c2goY2xlYW51cCk7XG4gICAgfVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuXHRmZWF0dXJlcyxcblx0bG9hZEZlYXR1cmUsXG5cdGluaXRGZWF0dXJlLFxuXHRsb2FkRmVhdHVyZXMsXG5cdGZlYXR1cmVTdXBwb3J0ZWQsXG5cdGZlYXR1cmVzRG9uZSxcblx0ZmVhdHVyZURvbmUsXG5cdGZlYXR1cmVzTG9hZGVkLFxuXHRmZWF0dXJlSW5pdGlhbGl6ZWQsXG5cdGZlYXR1cmVGYWlsZWQsXG5cdGZlYXR1cmVTdXBwb3J0ZWQsXG5cdGhhc0ZlYXR1cmUsXG5cdF9zZXRDYWNoaW5nTW9kdWxlLFxuXHRfY29sbGVjdENsZWFudXBGdW5jdGlvbnMsXG5cdF9maXJlUmVhZHlcbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9mZWF0dXJlcy5qcyJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ },
/* 25 */
/***/ function(module, exports) {

	eval("\"use strict\";\n\n/**\n * Class: I18n\n *\n * TODO add documentation\n **/\n\nvar dictionary = {\n  \"view_info\": 'This app allows you to use your own storage. <a href=\"http://remotestorage.io/\" target=\"_blank\">Learn more!</a>',\n  \"view_connect\": \"<strong>Connect</strong> remote storage\",\n  \"view_connecting\": \"Connecting <strong>%s</strong>\",\n  \"view_offline\": \"Offline\",\n  \"view_error_occured\": \"Sorry! An error occured.\",\n  \"view_invalid_key\": \"Wrong key!\",\n  \"view_confirm_reset\": \"Are you sure you want to reset everything? This will clear your local data and reload the page.\",\n  \"view_get_me_out\": \"Get me out of here!\",\n  \"view_error_plz_report\": 'If this problem persists, please <a href=\"http://remotestorage.io/community/\" target=\"_blank\">let us know</a>!',\n  \"view_unauthorized\": \"Unauthorized! Click here to reconnect.\"\n};\n\nvar I18n = {\n\n  translate: function translate() {\n    var str = arguments[0],\n        params = Array.prototype.splice.call(arguments, 1);\n\n    if (typeof dictionary[str] !== \"string\") {\n      throw \"Unknown translation string: \" + str;\n    } else {\n      str = dictionary[str];\n    }\n    return str.replace(/%s/g, function () {\n      return params.shift();\n    });\n  },\n\n  getDictionary: function getDictionary() {\n    return dictionary;\n  },\n\n  setDictionary: function setDictionary(newDictionary) {\n    dictionary = newDictionary;\n  },\n\n  _rs_init: function _rs_init() {}\n};\n\nmodule.exports = I18n;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvaTE4bi5qcz9mNTNjIl0sIm5hbWVzIjpbImRpY3Rpb25hcnkiLCJJMThuIiwidHJhbnNsYXRlIiwic3RyIiwiYXJndW1lbnRzIiwicGFyYW1zIiwiQXJyYXkiLCJwcm90b3R5cGUiLCJzcGxpY2UiLCJjYWxsIiwicmVwbGFjZSIsInNoaWZ0IiwiZ2V0RGljdGlvbmFyeSIsInNldERpY3Rpb25hcnkiLCJuZXdEaWN0aW9uYXJ5IiwiX3JzX2luaXQiLCJtb2R1bGUiLCJleHBvcnRzIl0sIm1hcHBpbmdzIjoiOztBQUFFOzs7Ozs7QUFNQSxJQUFJQSxhQUFhO0FBQ2YsZUFBYSxpSEFERTtBQUVmLGtCQUFnQix5Q0FGRDtBQUdmLHFCQUFtQixnQ0FISjtBQUlmLGtCQUFnQixTQUpEO0FBS2Ysd0JBQXNCLDBCQUxQO0FBTWYsc0JBQW9CLFlBTkw7QUFPZix3QkFBc0IsaUdBUFA7QUFRZixxQkFBbUIscUJBUko7QUFTZiwyQkFBeUIsZ0hBVFY7QUFVZix1QkFBcUI7QUFWTixDQUFqQjs7QUFhRixJQUFJQyxPQUFPOztBQUVQQyxhQUFXLHFCQUFZO0FBQ3JCLFFBQUlDLE1BQVNDLFVBQVUsQ0FBVixDQUFiO0FBQUEsUUFDSUMsU0FBU0MsTUFBTUMsU0FBTixDQUFnQkMsTUFBaEIsQ0FBdUJDLElBQXZCLENBQTRCTCxTQUE1QixFQUF1QyxDQUF2QyxDQURiOztBQUdBLFFBQUksT0FBT0osV0FBV0csR0FBWCxDQUFQLEtBQTJCLFFBQS9CLEVBQXlDO0FBQ3ZDLFlBQU0saUNBQWlDQSxHQUF2QztBQUNELEtBRkQsTUFFTztBQUNMQSxZQUFNSCxXQUFXRyxHQUFYLENBQU47QUFDRDtBQUNELFdBQVFBLElBQUlPLE9BQUosQ0FBWSxLQUFaLEVBQW1CLFlBQVc7QUFBRSxhQUFPTCxPQUFPTSxLQUFQLEVBQVA7QUFBd0IsS0FBeEQsQ0FBUjtBQUNELEdBWk07O0FBY1BDLGlCQUFlLHlCQUFZO0FBQ3pCLFdBQU9aLFVBQVA7QUFDRCxHQWhCTTs7QUFrQlBhLGlCQUFlLHVCQUFVQyxhQUFWLEVBQXlCO0FBQ3RDZCxpQkFBYWMsYUFBYjtBQUNELEdBcEJNOztBQXNCUEMsWUFBVSxvQkFBVyxDQUNwQjtBQXZCTSxDQUFYOztBQTBCRUMsT0FBT0MsT0FBUCxHQUFpQmhCLElBQWpCIiwiZmlsZSI6IjI1LmpzIiwic291cmNlc0NvbnRlbnQiOlsiICAvKipcbiAgICogQ2xhc3M6IEkxOG5cbiAgICpcbiAgICogVE9ETyBhZGQgZG9jdW1lbnRhdGlvblxuICAgKiovXG5cbiAgdmFyIGRpY3Rpb25hcnkgPSB7XG4gICAgXCJ2aWV3X2luZm9cIjogJ1RoaXMgYXBwIGFsbG93cyB5b3UgdG8gdXNlIHlvdXIgb3duIHN0b3JhZ2UuIDxhIGhyZWY9XCJodHRwOi8vcmVtb3Rlc3RvcmFnZS5pby9cIiB0YXJnZXQ9XCJfYmxhbmtcIj5MZWFybiBtb3JlITwvYT4nLFxuICAgIFwidmlld19jb25uZWN0XCI6IFwiPHN0cm9uZz5Db25uZWN0PC9zdHJvbmc+IHJlbW90ZSBzdG9yYWdlXCIsXG4gICAgXCJ2aWV3X2Nvbm5lY3RpbmdcIjogXCJDb25uZWN0aW5nIDxzdHJvbmc+JXM8L3N0cm9uZz5cIixcbiAgICBcInZpZXdfb2ZmbGluZVwiOiBcIk9mZmxpbmVcIixcbiAgICBcInZpZXdfZXJyb3Jfb2NjdXJlZFwiOiBcIlNvcnJ5ISBBbiBlcnJvciBvY2N1cmVkLlwiLFxuICAgIFwidmlld19pbnZhbGlkX2tleVwiOiBcIldyb25nIGtleSFcIixcbiAgICBcInZpZXdfY29uZmlybV9yZXNldFwiOiBcIkFyZSB5b3Ugc3VyZSB5b3Ugd2FudCB0byByZXNldCBldmVyeXRoaW5nPyBUaGlzIHdpbGwgY2xlYXIgeW91ciBsb2NhbCBkYXRhIGFuZCByZWxvYWQgdGhlIHBhZ2UuXCIsXG4gICAgXCJ2aWV3X2dldF9tZV9vdXRcIjogXCJHZXQgbWUgb3V0IG9mIGhlcmUhXCIsXG4gICAgXCJ2aWV3X2Vycm9yX3Bsel9yZXBvcnRcIjogJ0lmIHRoaXMgcHJvYmxlbSBwZXJzaXN0cywgcGxlYXNlIDxhIGhyZWY9XCJodHRwOi8vcmVtb3Rlc3RvcmFnZS5pby9jb21tdW5pdHkvXCIgdGFyZ2V0PVwiX2JsYW5rXCI+bGV0IHVzIGtub3c8L2E+IScsXG4gICAgXCJ2aWV3X3VuYXV0aG9yaXplZFwiOiBcIlVuYXV0aG9yaXplZCEgQ2xpY2sgaGVyZSB0byByZWNvbm5lY3QuXCJcbiAgfTtcblxudmFyIEkxOG4gPSB7XG5cbiAgICB0cmFuc2xhdGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBzdHIgICAgPSBhcmd1bWVudHNbMF0sXG4gICAgICAgICAgcGFyYW1zID0gQXJyYXkucHJvdG90eXBlLnNwbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG5cbiAgICAgIGlmICh0eXBlb2YgZGljdGlvbmFyeVtzdHJdICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHRocm93IFwiVW5rbm93biB0cmFuc2xhdGlvbiBzdHJpbmc6IFwiICsgc3RyO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RyID0gZGljdGlvbmFyeVtzdHJdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIChzdHIucmVwbGFjZSgvJXMvZywgZnVuY3Rpb24gKCl7IHJldHVybiBwYXJhbXMuc2hpZnQoKTsgfSkpO1xuICAgIH0sXG5cbiAgICBnZXREaWN0aW9uYXJ5OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gZGljdGlvbmFyeTtcbiAgICB9LFxuXG4gICAgc2V0RGljdGlvbmFyeTogZnVuY3Rpb24gKG5ld0RpY3Rpb25hcnkpIHtcbiAgICAgIGRpY3Rpb25hcnkgPSBuZXdEaWN0aW9uYXJ5O1xuICAgIH0sXG5cbiAgICBfcnNfaW5pdDogZnVuY3Rpb24oKSB7XG4gICAgfVxuICB9O1xuXG4gIG1vZHVsZS5leHBvcnRzID0gSTE4bjtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvaTE4bi5qcyJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ },
/* 26 */
/***/ function(module, exports) {

	eval("'use strict';\n\nvar SETTINGS_KEY = \"remotestorage:access\";\n\n/**\n * Class: RemoteStorage.Access\n *\n * Keeps track of claimed access and scopes.\n */\nvar Access = function Access() {\n  this.reset();\n};\n\nAccess.prototype = {\n\n  /**\n   * Method: claim\n   *\n   * Claim access on a given scope with given mode.\n   *\n   * Parameters:\n   *   scope - An access scope, such as \"contacts\" or \"calendar\"\n   *   mode  - Access mode. Either \"r\" for read-only or \"rw\" for read/write\n   *\n   * Example:\n   *   (start code)\n   *   remoteStorage.access.claim('contacts', 'r');\n   *   remoteStorage.access.claim('pictures', 'rw');\n   *   (end code)\n   *\n   * Root access:\n   *   Claiming root access, meaning complete access to all files and folders\n   *   of a storage, can be done using an asterisk:\n   *\n   *   (start code)\n   *   remoteStorage.access.claim('*', 'rw');\n   *   (end code)\n   */\n  claim: function claim(scope, mode) {\n    if (typeof scope !== 'string' || scope.indexOf('/') !== -1 || scope.length === 0) {\n      throw new Error('Scope should be a non-empty string without forward slashes');\n    }\n    if (!mode.match(/^rw?$/)) {\n      throw new Error('Mode should be either \\'r\\' or \\'rw\\'');\n    }\n    this._adjustRootPaths(scope);\n    this.scopeModeMap[scope] = mode;\n  },\n\n  get: function get(scope) {\n    return this.scopeModeMap[scope];\n  },\n\n  remove: function remove(scope) {\n    var savedMap = {};\n    var name;\n    for (name in this.scopeModeMap) {\n      savedMap[name] = this.scopeModeMap[name];\n    }\n    this.reset();\n    delete savedMap[scope];\n    for (name in savedMap) {\n      this.set(name, savedMap[name]);\n    }\n  },\n\n  /**\n   * Verify permission for a given scope.\n   */\n  checkPermission: function checkPermission(scope, mode) {\n    var actualMode = this.get(scope);\n    return actualMode && (mode === 'r' || actualMode === 'rw');\n  },\n\n  /**\n   * Verify permission for a given path.\n   */\n  checkPathPermission: function checkPathPermission(path, mode) {\n    if (this.checkPermission('*', mode)) {\n      return true;\n    }\n    return !!this.checkPermission(this._getModuleName(path), mode);\n  },\n\n  reset: function reset() {\n    this.rootPaths = [];\n    this.scopeModeMap = {};\n  },\n\n  /**\n   * Return the module name for a given path.\n   */\n  _getModuleName: function _getModuleName(path) {\n    if (path[0] !== '/') {\n      throw new Error('Path should start with a slash');\n    }\n    var moduleMatch = path.replace(/^\\/public/, '').match(/^\\/([^\\/]*)\\//);\n    return moduleMatch ? moduleMatch[1] : '*';\n  },\n\n  _adjustRootPaths: function _adjustRootPaths(newScope) {\n    if ('*' in this.scopeModeMap || newScope === '*') {\n      this.rootPaths = ['/'];\n    } else if (!(newScope in this.scopeModeMap)) {\n      this.rootPaths.push('/' + newScope + '/');\n      this.rootPaths.push('/public/' + newScope + '/');\n    }\n  },\n\n  _scopeNameForParameter: function _scopeNameForParameter(scope) {\n    if (scope.name === '*' && this.storageType) {\n      if (this.storageType === '2012.04') {\n        return '';\n      } else if (this.storageType.match(/remotestorage-0[01]/)) {\n        return 'root';\n      }\n    }\n    return scope.name;\n  },\n\n  setStorageType: function setStorageType(type) {\n    this.storageType = type;\n  }\n};\n\n/**\n * Property: scopes\n *\n * Holds an array of claimed scopes in the form\n * > { name: \"<scope-name>\", mode: \"<mode>\" }\n */\nObject.defineProperty(Access.prototype, 'scopes', {\n  get: function get() {\n    return Object.keys(this.scopeModeMap).map(function (key) {\n      return { name: key, mode: this.scopeModeMap[key] };\n    }.bind(this));\n  }\n});\n\nObject.defineProperty(Access.prototype, 'scopeParameter', {\n  get: function get() {\n    return this.scopes.map(function (scope) {\n      return this._scopeNameForParameter(scope) + ':' + scope.mode;\n    }.bind(this)).join(' ');\n  }\n});\n\nAccess._rs_init = function () {};\n\nmodule.exports = Access;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvYWNjZXNzLmpzPzcwN2MiXSwibmFtZXMiOlsiU0VUVElOR1NfS0VZIiwiQWNjZXNzIiwicmVzZXQiLCJwcm90b3R5cGUiLCJjbGFpbSIsInNjb3BlIiwibW9kZSIsImluZGV4T2YiLCJsZW5ndGgiLCJFcnJvciIsIm1hdGNoIiwiX2FkanVzdFJvb3RQYXRocyIsInNjb3BlTW9kZU1hcCIsImdldCIsInJlbW92ZSIsInNhdmVkTWFwIiwibmFtZSIsInNldCIsImNoZWNrUGVybWlzc2lvbiIsImFjdHVhbE1vZGUiLCJjaGVja1BhdGhQZXJtaXNzaW9uIiwicGF0aCIsIl9nZXRNb2R1bGVOYW1lIiwicm9vdFBhdGhzIiwibW9kdWxlTWF0Y2giLCJyZXBsYWNlIiwibmV3U2NvcGUiLCJwdXNoIiwiX3Njb3BlTmFtZUZvclBhcmFtZXRlciIsInN0b3JhZ2VUeXBlIiwic2V0U3RvcmFnZVR5cGUiLCJ0eXBlIiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJrZXlzIiwibWFwIiwia2V5IiwiYmluZCIsInNjb3BlcyIsImpvaW4iLCJfcnNfaW5pdCIsIm1vZHVsZSIsImV4cG9ydHMiXSwibWFwcGluZ3MiOiI7O0FBQUUsSUFBSUEsZUFBZSxzQkFBbkI7O0FBRUE7Ozs7O0FBS0EsSUFBSUMsU0FBUyxTQUFUQSxNQUFTLEdBQVc7QUFDdEIsT0FBS0MsS0FBTDtBQUNELENBRkQ7O0FBSUFELE9BQU9FLFNBQVAsR0FBbUI7O0FBRWpCOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQXVCQUMsU0FBTyxlQUFTQyxLQUFULEVBQWdCQyxJQUFoQixFQUFzQjtBQUMzQixRQUFJLE9BQU9ELEtBQVAsS0FBa0IsUUFBbEIsSUFBOEJBLE1BQU1FLE9BQU4sQ0FBYyxHQUFkLE1BQXVCLENBQUMsQ0FBdEQsSUFBMkRGLE1BQU1HLE1BQU4sS0FBaUIsQ0FBaEYsRUFBbUY7QUFDakYsWUFBTSxJQUFJQyxLQUFKLENBQVUsNERBQVYsQ0FBTjtBQUNEO0FBQ0Qs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Z2U6YWNjZXNzXCI7XG5cbiAgLyoqXG4gICAqIENsYXNzOiBSZW1vdGVTdG9yYWdlLkFjY2Vzc1xuICAgKlxuICAgKiBLZWVwcyB0cmFjayBvZiBjbGFpbWVkIGFjY2VzcyBhbmQgc2NvcGVzLlxuICAgKi9cbiAgdmFyIEFjY2VzcyA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMucmVzZXQoKTtcbiAgfTtcblxuICBBY2Nlc3MucHJvdG90eXBlID0ge1xuXG4gICAgLyoqXG4gICAgICogTWV0aG9kOiBjbGFpbVxuICAgICAqXG4gICAgICogQ2xhaW0gYWNjZXNzIG9uIGEgZ2l2ZW4gc2NvcGUgd2l0aCBnaXZlbiBtb2RlLlxuICAgICAqXG4gICAgICogUGFyYW1ldGVyczpcbiAgICAgKiAgIHNjb3BlIC0gQW4gYWNjZXNzIHNjb3BlLCBzdWNoIGFzIFwiY29udGFjdHNcIiBvciBcImNhbGVuZGFyXCJcbiAgICAgKiAgIG1vZGUgIC0gQWNjZXNzIG1vZGUuIEVpdGhlciBcInJcIiBmb3IgcmVhZC1vbmx5IG9yIFwicndcIiBmb3IgcmVhZC93cml0ZVxuICAgICAqXG4gICAgICogRXhhbXBsZTpcbiAgICAgKiAgIChzdGFydCBjb2RlKVxuICAgICAqICAgcmVtb3RlU3RvcmFnZS5hY2Nlc3MuY2xhaW0oJ2NvbnRhY3RzJywgJ3InKTtcbiAgICAgKiAgIHJlbW90ZVN0b3JhZ2UuYWNjZXNzLmNsYWltKCdwaWN0dXJlcycsICdydycpO1xuICAgICAqICAgKGVuZCBjb2RlKVxuICAgICAqXG4gICAgICogUm9vdCBhY2Nlc3M6XG4gICAgICogICBDbGFpbWluZyByb290IGFjY2VzcywgbWVhbmluZyBjb21wbGV0ZSBhY2Nlc3MgdG8gYWxsIGZpbGVzIGFuZCBmb2xkZXJzXG4gICAgICogICBvZiBhIHN0b3JhZ2UsIGNhbiBiZSBkb25lIHVzaW5nIGFuIGFzdGVyaXNrOlxuICAgICAqXG4gICAgICogICAoc3RhcnQgY29kZSlcbiAgICAgKiAgIHJlbW90ZVN0b3JhZ2UuYWNjZXNzLmNsYWltKCcqJywgJ3J3Jyk7XG4gICAgICogICAoZW5kIGNvZGUpXG4gICAgICovXG4gICAgY2xhaW06IGZ1bmN0aW9uKHNjb3BlLCBtb2RlKSB7XG4gICAgICBpZiAodHlwZW9mKHNjb3BlKSAhPT0gJ3N0cmluZycgfHwgc2NvcGUuaW5kZXhPZignLycpICE9PSAtMSB8fCBzY29wZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdTY29wZSBzaG91bGQgYmUgYSBub24tZW1wdHkgc3RyaW5nIHdpdGhvdXQgZm9yd2FyZCBzbGFzaGVzJyk7XG4gICAgICB9XG4gICAgICBpZiAoIW1vZGUubWF0Y2goL15ydz8kLykpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNb2RlIHNob3VsZCBiZSBlaXRoZXIgXFwnclxcJyBvciBcXCdyd1xcJycpO1xuICAgICAgfVxuICAgICAgdGhpcy5fYWRqdXN0Um9vdFBhdGhzKHNjb3BlKTtcbiAgICAgIHRoaXMuc2NvcGVNb2RlTWFwW3Njb3BlXSA9IG1vZGU7XG4gICAgfSxcblxuICAgIGdldDogZnVuY3Rpb24oc2NvcGUpIHtcbiAgICAgIHJldHVybiB0aGlzLnNjb3BlTW9kZU1hcFtzY29wZV07XG4gICAgfSxcblxuICAgIHJlbW92ZTogZnVuY3Rpb24oc2NvcGUpIHtcbiAgICAgIHZhciBzYXZlZE1hcCA9IHt9O1xuICAgICAgdmFyIG5hbWU7XG4gICAgICBmb3IgKG5hbWUgaW4gdGhpcy5zY29wZU1vZGVNYXApIHtcbiAgICAgICAgc2F2ZWRNYXBbbmFtZV0gPSB0aGlzLnNjb3BlTW9kZU1hcFtuYW1lXTtcbiAgICAgIH1cbiAgICAgIHRoaXMucmVzZXQoKTtcbiAgICAgIGRlbGV0ZSBzYXZlZE1hcFtzY29wZV07XG4gICAgICBmb3IgKG5hbWUgaW4gc2F2ZWRNYXApIHtcbiAgICAgICAgdGhpcy5zZXQobmFtZSwgc2F2ZWRNYXBbbmFtZV0pO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBWZXJpZnkgcGVybWlzc2lvbiBmb3IgYSBnaXZlbiBzY29wZS5cbiAgICAgKi9cbiAgICBjaGVja1Blcm1pc3Npb246IGZ1bmN0aW9uKHNjb3BlLCBtb2RlKSB7XG4gICAgICB2YXIgYWN0dWFsTW9kZSA9IHRoaXMuZ2V0KHNjb3BlKTtcbiAgICAgIHJldHVybiBhY3R1YWxNb2RlICYmIChtb2RlID09PSAncicgfHwgYWN0dWFsTW9kZSA9PT0gJ3J3Jyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFZlcmlmeSBwZXJtaXNzaW9uIGZvciBhIGdpdmVuIHBhdGguXG4gICAgICovXG4gICAgY2hlY2tQYXRoUGVybWlzc2lvbjogZnVuY3Rpb24ocGF0aCwgbW9kZSkge1xuICAgICAgaWYgKHRoaXMuY2hlY2tQZXJtaXNzaW9uKCcqJywgbW9kZSkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gISF0aGlzLmNoZWNrUGVybWlzc2lvbih0aGlzLl9nZXRNb2R1bGVOYW1lKHBhdGgpLCBtb2RlKTtcbiAgICB9LFxuXG4gICAgcmVzZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5yb290UGF0aHMgPSBbXTtcbiAgICAgIHRoaXMuc2NvcGVNb2RlTWFwID0ge307XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybiB0aGUgbW9kdWxlIG5hbWUgZm9yIGEgZ2l2ZW4gcGF0aC5cbiAgICAgKi9cbiAgICBfZ2V0TW9kdWxlTmFtZTogZnVuY3Rpb24ocGF0aCkge1xuICAgICAgaWYgKHBhdGhbMF0gIT09ICcvJykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1BhdGggc2hvdWxkIHN0YXJ0IHdpdGggYSBzbGFzaCcpO1xuICAgICAgfVxuICAgICAgdmFyIG1vZHVsZU1hdGNoID0gcGF0aC5yZXBsYWNlKC9eXFwvcHVibGljLywgJycpLm1hdGNoKC9eXFwvKFteXFwvXSopXFwvLyk7XG4gICAgICByZXR1cm4gbW9kdWxlTWF0Y2ggPyBtb2R1bGVNYXRjaFsxXSA6ICcqJztcbiAgICB9LFxuXG4gICAgX2FkanVzdFJvb3RQYXRoczogZnVuY3Rpb24obmV3U2NvcGUpIHtcbiAgICAgIGlmICgnKicgaW4gdGhpcy5zY29wZU1vZGVNYXAgfHwgbmV3U2NvcGUgPT09ICcqJykge1xuICAgICAgICB0aGlzLnJvb3RQYXRocyA9IFsnLyddO1xuICAgICAgfSBlbHNlIGlmICghIChuZXdTY29wZSBpbiB0aGlzLnNjb3BlTW9kZU1hcCkpIHtcbiAgICAgICAgdGhpcy5yb290UGF0aHMucHVzaCgnLycgKyBuZXdTY29wZSArICcvJyk7XG4gICAgICAgIHRoaXMucm9vdFBhdGhzLnB1c2goJy9wdWJsaWMvJyArIG5ld1Njb3BlICsgJy8nKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgX3Njb3BlTmFtZUZvclBhcmFtZXRlcjogZnVuY3Rpb24oc2NvcGUpIHtcbiAgICAgIGlmIChzY29wZS5uYW1lID09PSAnKicgJiYgdGhpcy5zdG9yYWdlVHlwZSkge1xuICAgICAgICBpZiAodGhpcy5zdG9yYWdlVHlwZSA9PT0gJzIwMTIuMDQnKSB7XG4gICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuc3RvcmFnZVR5cGUubWF0Y2goL3JlbW90ZXN0b3JhZ2UtMFswMV0vKSkge1xuICAgICAgICAgIHJldHVybiAncm9vdCc7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBzY29wZS5uYW1lO1xuICAgIH0sXG5cbiAgICBzZXRTdG9yYWdlVHlwZTogZnVuY3Rpb24odHlwZSkge1xuICAgICAgdGhpcy5zdG9yYWdlVHlwZSA9IHR5cGU7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBQcm9wZXJ0eTogc2NvcGVzXG4gICAqXG4gICAqIEhvbGRzIGFuIGFycmF5IG9mIGNsYWltZWQgc2NvcGVzIGluIHRoZSBmb3JtXG4gICAqID4geyBuYW1lOiBcIjxzY29wZS1uYW1lPlwiLCBtb2RlOiBcIjxtb2RlPlwiIH1cbiAgICovXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBY2Nlc3MucHJvdG90eXBlLCAnc2NvcGVzJywge1xuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gT2JqZWN0LmtleXModGhpcy5zY29wZU1vZGVNYXApLm1hcChmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgcmV0dXJuIHsgbmFtZToga2V5LCBtb2RlOiB0aGlzLnNjb3BlTW9kZU1hcFtrZXldIH07XG4gICAgICB9LmJpbmQodGhpcykpO1xuICAgIH1cbiAgfSk7XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEFjY2Vzcy5wcm90b3R5cGUsICdzY29wZVBhcmFtZXRlcicsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuc2NvcGVzLm1hcChmdW5jdGlvbihzY29wZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc2NvcGVOYW1lRm9yUGFyYW1ldGVyKHNjb3BlKSArICc6JyArIHNjb3BlLm1vZGU7XG4gICAgICB9LmJpbmQodGhpcykpLmpvaW4oJyAnKTtcbiAgICB9XG4gIH0pO1xuXG5cbiAgQWNjZXNzLl9yc19pbml0ID0gZnVuY3Rpb24oKSB7fTtcblxuICBtb2R1bGUuZXhwb3J0cyA9IEFjY2VzcztcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9hY2Nlc3MuanMiXSwic291cmNlUm9vdCI6IiJ9");

/***/ },
/* 27 */
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';\n\n/**\n * Class: RemoteStorage.Caching\n *\n * Holds/manages caching configuration.\n *\n * Caching strategies:\n *\n *   For each subtree, you can set the caching strategy to 'ALL',\n *   'SEEN' (default), and 'FLUSH'.\n *\n *   - 'ALL' means that once all outgoing changes have been pushed, sync\n *         will start retrieving nodes to cache pro-actively. If a local\n *         copy exists of everything, it will check on each sync whether\n *         the ETag of the root folder changed, and retrieve remote changes\n *         if they exist.\n *   - 'SEEN' does this only for documents and folders that have been either\n *         read from or written to at least once since connecting to the current\n *         remote backend, plus their parent/ancestor folders up to the root\n *         (to make tree-based sync possible).\n *   - 'FLUSH' will only cache outgoing changes, and forget them as soon as\n *         they have been saved to remote successfully.\n *\n **/\n\nvar util = __webpack_require__(2);\nvar log = __webpack_require__(4);\n\nvar containingFolder = util.containingFolder;\n\nvar Caching = function Caching() {\n  this.reset();\n};\n\nCaching.prototype = {\n  pendingActivations: [],\n\n  /**\n   * Method: set\n   *\n   * Configure caching for a given path explicitly.\n   *\n   * Not needed when using <enable>/<disable>.\n   *\n   * Parameters:\n   *   path     - Path to cache\n   *   strategy - Caching strategy. One of 'ALL', 'SEEN', or 'FLUSH'.\n   *\n   * Example:\n   *   (start code)\n   *   remoteStorage.caching.set('/bookmarks/archive')\n   */\n  set: function set(path, strategy) {\n    if (typeof path !== 'string') {\n      throw new Error('path should be a string');\n    }\n    if (!util.isFolder(path)) {\n      throw new Error('path should be a folder');\n    }\n    if (this._remoteStorage && this._remoteStorage.access && !this._remoteStorage.access.checkPathPermission(path, 'r')) {\n      throw new Error('No access to path \"' + path + '\". You have to claim access to it first.');\n    }\n    if (!strategy.match(/^(FLUSH|SEEN|ALL)$/)) {\n      throw new Error(\"strategy should be 'FLUSH', 'SEEN', or 'ALL'\");\n    }\n\n    this._rootPaths[path] = strategy;\n\n    if (strategy === 'ALL') {\n      if (this.activateHandler) {\n        this.activateHandler(path);\n      } else {\n        this.pendingActivations.push(path);\n      }\n    }\n  },\n\n  /**\n   * Method: enable\n   *\n   * Enable caching for a given path.\n   *\n   * Uses caching strategy 'ALL'.\n   *\n   * Parameters:\n   *   path - Path to enable caching for\n   */\n  enable: function enable(path) {\n    this.set(path, 'ALL');\n  },\n\n  /**\n   * Method: disable\n   *\n   * Disable caching for a given path.\n   *\n   * Uses caching strategy 'FLUSH' (meaning items are only cached until\n   * successfully pushed to the remote).\n   *\n   * Parameters:\n   *   path - Path to disable caching for\n   */\n  disable: function disable(path) {\n    this.set(path, 'FLUSH');\n  },\n\n  /**\n   * Method: onActivate\n   *\n   * Set a callback for when caching is activated for a path.\n   *\n   * Parameters:\n   *   callback - Callback function\n   */\n  onActivate: function onActivate(cb) {\n    var i;\n    log('[Caching] Setting activate handler', cb, this.pendingActivations);\n    this.activateHandler = cb;\n    for (i = 0; i < this.pendingActivations.length; i++) {\n      cb(this.pendingActivations[i]);\n    }\n    delete this.pendingActivations;\n  },\n\n  /**\n   * Method: checkPath\n   *\n   * Retrieve caching setting for a given path, or its next parent\n   * with a caching strategy set.\n   *\n   * Parameters:\n   *   path - Path to retrieve setting for\n   **/\n  checkPath: function checkPath(path) {\n    if (this._rootPaths[path] !== undefined) {\n      return this._rootPaths[path];\n    } else if (path === '/') {\n      return 'SEEN';\n    } else {\n      return this.checkPath(containingFolder(path));\n    }\n  },\n\n  /**\n   * Method: reset\n   *\n   * Reset the state of caching by deleting all caching information.\n   **/\n  reset: function reset() {\n    this._rootPaths = {};\n    this._remoteStorage = null;\n  }\n};\n\nCaching._rs_init = function (remoteStorage) {\n  this._remoteStorage = remoteStorage;\n};\n\nmodule.exports = Caching;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvY2FjaGluZy5qcz9kMGY4Il0sIm5hbWVzIjpbInV0aWwiLCJyZXF1aXJlIiwibG9nIiwiY29udGFpbmluZ0ZvbGRlciIsIkNhY2hpbmciLCJyZXNldCIsInByb3RvdHlwZSIsInBlbmRpbmdBY3RpdmF0aW9ucyIsInNldCIsInBhdGgiLCJzdHJhdGVneSIsIkVycm9yIiwiaXNGb2xkZXIiLCJfcmVtb3RlU3RvcmFnZSIsImFjY2VzcyIsImNoZWNrUGF0aFBlcm1pc3Npb24iLCJtYXRjaCIsIl9yb290UGF0aHMiLCJhY3RpdmF0ZUhhbmRsZXIiLCJwdXNoIiwiZW5hYmxlIiwiZGlzYWJsZSIsIm9uQWN0aXZhdGUiLCJjYiIsImkiLCJsZW5ndGgiLCJjaGVja1BhdGgiLCJ1bmRlZmluZWQiLCJfcnNfaW5pdCIsInJlbW90ZVN0b3JhZ2UiLCJtb2R1bGUiLCJleHBvcnRzIl0sIm1hcHBpbmdzIjoiOztBQUFFOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUF3QkEsSUFBSUEsT0FBTyxtQkFBQUMsQ0FBUSxDQUFSLENBQVg7QUFDQSxJQUFJQyxNQUFNLG1CQUFBRCxDQUFRLENBQVIsQ0FBVjs7QUFFQSxJQUFJRSxtQkFBbUJILEtBQUtHLGdCQUE1Qjs7QUFFQSxJQUFJQyxVQUFVLFNBQVZBLE9BQVUsR0FBWTtBQUN4QixPQUFLQyxLQUFMO0FBQ0QsQ0FGRDs7QUFJQUQsUUFBUUUsU0FBUixHQUFvQjtBQUNsQkMsc0JBQW9CLEVBREY7O0FBR2xCOzs7Ozs7Ozs7Ozs7Ozs7QUFlQUMsT0FBSyxhQUFVQyxJQUFWLEVBQWdCQyxRQUFoQixFQUEwQjtBQUM3QixRQUFJLE9BQU9ELElBQVAsS0FBZ0IsUUFBcEIsRUFBOEI7QUFDNUIsWUFBTSxJQUFJRSxLQUFKLENBQVUseUJBQVYsQ0FBTjtBQUNEO0FBQ0QsUUFBSSxDQUFDWCxLQUFLWSxRQUFMLENBQWNILElBQWQsQ0FBTCxFQUEwQjtBQUN4QixZQUFNLElBQUlFLEtBQUosQ0FBVSx5QkFBVixDQUFOO0FBQ0Q7QUFDRCxRQUFJLEtBQUtFLGNBQUwsSUFBdUIsS0FBS0EsY0FBTCxDQUFvQkMsTUFBM0MsSUFDQSxDQUFDLEtBQUtELGNBQUwsQ0FBb0JDLE1BQXBCLENBQTJCQyxtQkFBM0IsQ0FBK0NOLElBQS9DLEVBQXFELEdBQXJELENBREwsRUFDZ0U7QUFDOUQsWUFBTSxJQUFJRSxLQUFKLENBQVUsd0JBQXNCRixJQUF0QixHQUEyQiwwQ0FBckMsQ0FBTjtBQUNEO0FBQ0QsUUFBSSxDQUFDQyxTQUFTTSxLQUFULENBQWUsb0JBQWYsQ0FBTCxFQUEyQztBQUN6QyxZQUFNLElBQUlMLEtBQUosQ0FBVSw4Q0FBVixDQUFOO0FBQ0Q7O0FBRUQsU0FBS00sVUFBTCxDQUFnQlIsSUFBaEIsSUFBd0JDLFFBQXhCOztBQUVBLFFBQUlBLGFBQWEsS0FBakIsRUFBd0I7QUFDdEIsVUFBSSxLQUFLUSxlQUFULEVBQTBCO0FBQ3hCLGFBQUtBLGVBQUwsQ0FBcUJULElBQXJCO0FBQ0QsT0FGRCxNQUVPO0FBQ0wsYUFBS0Ysa0JBQUwsQ0FBd0JZLElBQXhCLENBQTZCVixJQUE3QjtBQUNEO0FBQ0Y7QUFDRixHQTFDaUI7O0FBNENsQjs7Ozs7Ozs7OztBQVVBVyxVQUFRLGdCQUFVWCxJQUFWLEVBQWdCO0FBQ3RCLFNBQUtELEdBQUwsQ0FBU0MsSUFBVCxFQUFlLEtBQWY7QUFDRCxHQXhEaUI7O0FBMERsQjs7Ozs7Ozs7Ozs7QUFXQVksV0FBUyxpQkFBVVosSUFBVixFQUFnQjtBQUN2QixTQUFLRCxHQUFMLENBQVNDLElBQVQsRUFBZSxPQUFmO0FBQ0QsR0F2RWlCOztBQXlFbEI7Ozs7Ozs7O0FBUUFhLGNBQVksb0JBQVVDLEVBQVYsRUFBYztBQUN4QixRQUFJQyxDQUFKO0FBQ0F0QixRQUFJLG9DQUFKLEVBQTBDcUIsRUFBMUMsRUFBOEMsS0FBS2hCLGtCQUFuRDtBQUNBLFNBQUtXLGVBQUwsR0FBdUJLLEVBQXZCO0FBQ0EsU0FBS0MsSUFBRSxDQUFQLEVBQVVBLElBQUUsS0FBS2pCLGtCQUFMLENBQXdCa0IsTUFBcEMsRUFBNENELEdBQTVDLEVBQWlEO0FBQy9DRCxTQUFHLEtBQUtoQixrQkFBTCxDQUF3QmlCLENBQXhCLENBQUg7QUFDRDtBQUNELFdBQU8sS0FBS2pCLGtCQUFaO0FBQ0QsR0F6RmlCOztBQTJGbEI7Ozs7Ozs7OztBQVNBbUIsYUFBVyxtQkFBVWpCLElBQVYsRUFBZ0I7QUFDekIsUUFBSSxLQUFLUSxVQUFMLENBQWdCUixJQUFoQixNQUEwQmtCLFNBQTlCLEVBQXlDO0FBQ3ZDLGFBQU8sS0FBS1YsVUFBTCxDQUFnQlIsSUFBaEIsQ0FBUDtBQUNELEtBRkQsTUFFTyxJQUFJQSxTQUFTLEdBQWIsRUFBa0I7QUFDdkIsYUFBTyxNQUFQO0FBQ0QsS0FGTSxNQUVBO0FBQ0wsYUFBTyxLQUFLaUIsU0FBTCxDQUFldkIsaUJBQWlCTSxJQUFqQixDQUFmLENBQVA7QUFDRDtBQUNGLEdBNUdpQjs7QUE4R2xCOzs7OztBQUtBSixTQUFPLGlCQUFZO0FBQ2pCLFNBQUtZLFVBQUwsR0FBa0IsRUFBbEI7QUFDQSxTQUFLSixjQUFMLEdBQXNCLElBQXRCO0FBQ0Q7QUF0SGlCLENBQXBCOztBQTBIQVQsUUFBUXdCLFFBQVIsR0FBbUIsVUFBVUMsYUFBVixFQUF5QjtBQUMxQyxPQUFLaEIsY0FBTCxHQUFzQmdCLGFBQXRCO0FBQ0QsQ0FGRDs7QUFJRkMsT0FBT0MsT0FBUCxHQUFpQjNCLE9BQWpCIiwiZmlsZSI6IjI3LmpzIiwic291cmNlc0NvbnRlbnQiOlsiICAvKipcbiAgICogQ2xhc3M6IFJlbW90ZVN0b3JhZ2UuQ2FjaGluZ1xuICAgKlxuICAgKiBIb2xkcy9tYW5hZ2VzIGNhY2hpbmcgY29uZmlndXJhdGlvbi5cbiAgICpcbiAgICogQ2FjaGluZyBzdHJhdGVnaWVzOlxuICAgKlxuICAgKiAgIEZvciBlYWNoIHN1YnRyZWUsIHlvdSBjYW4gc2V0IHRoZSBjYWNoaW5nIHN0cmF0ZWd5IHRvICdBTEwnLFxuICAgKiAgICdTRUVOJyAoZGVmYXVsdCksIGFuZCAnRkxVU0gnLlxuICAgKlxuICAgKiAgIC0gJ0FMTCcgbWVhbnMgdGhhdCBvbmNlIGFsbCBvdXRnb2luZyBjaGFuZ2VzIGhhdmUgYmVlbiBwdXNoZWQsIHN5bmNcbiAgICogICAgICAgICB3aWxsIHN0YXJ0IHJldHJpZXZpbmcgbm9kZXMgdG8gY2FjaGUgcHJvLWFjdGl2ZWx5LiBJZiBhIGxvY2FsXG4gICAqICAgICAgICAgY29weSBleGlzdHMgb2YgZXZlcnl0aGluZywgaXQgd2lsbCBjaGVjayBvbiBlYWNoIHN5bmMgd2hldGhlclxuICAgKiAgICAgICAgIHRoZSBFVGFnIG9mIHRoZSByb290IGZvbGRlciBjaGFuZ2VkLCBhbmQgcmV0cmlldmUgcmVtb3RlIGNoYW5nZXNcbiAgICogICAgICAgICBpZiB0aGV5IGV4aXN0LlxuICAgKiAgIC0gJ1NFRU4nIGRvZXMgdGhpcyBvbmx5IGZvciBkb2N1bWVudHMgYW5kIGZvbGRlcnMgdGhhdCBoYXZlIGJlZW4gZWl0aGVyXG4gICAqICAgICAgICAgcmVhZCBmcm9tIG9yIHdyaXR0ZW4gdG8gYXQgbGVhc3Qgb25jZSBzaW5jZSBjb25uZWN0aW5nIHRvIHRoZSBjdXJyZW50XG4gICAqICAgICAgICAgcmVtb3RlIGJhY2tlbmQsIHBsdXMgdGhlaXIgcGFyZW50L2FuY2VzdG9yIGZvbGRlcnMgdXAgdG8gdGhlIHJvb3RcbiAgICogICAgICAgICAodG8gbWFrZSB0cmVlLWJhc2VkIHN5bmMgcG9zc2libGUpLlxuICAgKiAgIC0gJ0ZMVVNIJyB3aWxsIG9ubHkgY2FjaGUgb3V0Z29pbmcgY2hhbmdlcywgYW5kIGZvcmdldCB0aGVtIGFzIHNvb24gYXNcbiAgICogICAgICAgICB0aGV5IGhhdmUgYmVlbiBzYXZlZCB0byByZW1vdGUgc3VjY2Vzc2Z1bGx5LlxuICAgKlxuICAgKiovXG5cbiAgdmFyIHV0aWwgPSByZXF1aXJlKCcuL3V0aWwnKTtcbiAgdmFyIGxvZyA9IHJlcXVpcmUoJy4vbG9nJyk7XG5cbiAgdmFyIGNvbnRhaW5pbmdGb2xkZXIgPSB1dGlsLmNvbnRhaW5pbmdGb2xkZXI7XG5cbiAgdmFyIENhY2hpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5yZXNldCgpO1xuICB9O1xuXG4gIENhY2hpbmcucHJvdG90eXBlID0ge1xuICAgIHBlbmRpbmdBY3RpdmF0aW9uczogW10sXG5cbiAgICAvKipcbiAgICAgKiBNZXRob2Q6IHNldFxuICAgICAqXG4gICAgICogQ29uZmlndXJlIGNhY2hpbmcgZm9yIGEgZ2l2ZW4gcGF0aCBleHBsaWNpdGx5LlxuICAgICAqXG4gICAgICogTm90IG5lZWRlZCB3aGVuIHVzaW5nIDxlbmFibGU+LzxkaXNhYmxlPi5cbiAgICAgKlxuICAgICAqIFBhcmFtZXRlcnM6XG4gICAgICogICBwYXRoICAgICAtIFBhdGggdG8gY2FjaGVcbiAgICAgKiAgIHN0cmF0ZWd5IC0gQ2FjaGluZyBzdHJhdGVneS4gT25lIG9mICdBTEwnLCAnU0VFTicsIG9yICdGTFVTSCcuXG4gICAgICpcbiAgICAgKiBFeGFtcGxlOlxuICAgICAqICAgKHN0YXJ0IGNvZGUpXG4gICAgICogICByZW1vdGVTdG9yYWdlLmNhY2hpbmcuc2V0KCcvYm9va21hcmtzL2FyY2hpdmUnKVxuICAgICAqL1xuICAgIHNldDogZnVuY3Rpb24gKHBhdGgsIHN0cmF0ZWd5KSB7XG4gICAgICBpZiAodHlwZW9mIHBhdGggIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigncGF0aCBzaG91bGQgYmUgYSBzdHJpbmcnKTtcbiAgICAgIH1cbiAgICAgIGlmICghdXRpbC5pc0ZvbGRlcihwYXRoKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3BhdGggc2hvdWxkIGJlIGEgZm9sZGVyJyk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5fcmVtb3RlU3RvcmFnZSAmJiB0aGlzLl9yZW1vdGVTdG9yYWdlLmFjY2VzcyAmJlxuICAgICAgICAgICF0aGlzLl9yZW1vdGVTdG9yYWdlLmFjY2Vzcy5jaGVja1BhdGhQZXJtaXNzaW9uKHBhdGgsICdyJykpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBhY2Nlc3MgdG8gcGF0aCBcIicrcGF0aCsnXCIuIFlvdSBoYXZlIHRvIGNsYWltIGFjY2VzcyB0byBpdCBmaXJzdC4nKTtcbiAgICAgIH1cbiAgICAgIGlmICghc3RyYXRlZ3kubWF0Y2goL14oRkxVU0h8U0VFTnxBTEwpJC8pKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcInN0cmF0ZWd5IHNob3VsZCBiZSAnRkxVU0gnLCAnU0VFTicsIG9yICdBTEwnXCIpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9yb290UGF0aHNbcGF0aF0gPSBzdHJhdGVneTtcblxuICAgICAgaWYgKHN0cmF0ZWd5ID09PSAnQUxMJykge1xuICAgICAgICBpZiAodGhpcy5hY3RpdmF0ZUhhbmRsZXIpIHtcbiAgICAgICAgICB0aGlzLmFjdGl2YXRlSGFuZGxlcihwYXRoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLnBlbmRpbmdBY3RpdmF0aW9ucy5wdXNoKHBhdGgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1ldGhvZDogZW5hYmxlXG4gICAgICpcbiAgICAgKiBFbmFibGUgY2FjaGluZyBmb3IgYSBnaXZlbiBwYXRoLlxuICAgICAqXG4gICAgICogVXNlcyBjYWNoaW5nIHN0cmF0ZWd5ICdBTEwnLlxuICAgICAqXG4gICAgICogUGFyYW1ldGVyczpcbiAgICAgKiAgIHBhdGggLSBQYXRoIHRvIGVuYWJsZSBjYWNoaW5nIGZvclxuICAgICAqL1xuICAgIGVuYWJsZTogZnVuY3Rpb24gKHBhdGgpIHtcbiAgICAgIHRoaXMuc2V0KHBhdGgsICdBTEwnKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTWV0aG9kOiBkaXNhYmxlXG4gICAgICpcbiAgICAgKiBEaXNhYmxlIGNhY2hpbmcgZm9yIGEgZ2l2ZW4gcGF0aC5cbiAgICAgKlxuICAgICAqIFVzZXMgY2FjaGluZyBzdHJhdGVneSAnRkxVU0gnIChtZWFuaW5nIGl0ZW1zIGFyZSBvbmx5IGNhY2hlZCB1bnRpbFxuICAgICAqIHN1Y2Nlc3NmdWxseSBwdXNoZWQgdG8gdGhlIHJlbW90ZSkuXG4gICAgICpcbiAgICAgKiBQYXJhbWV0ZXJzOlxuICAgICAqICAgcGF0aCAtIFBhdGggdG8gZGlzYWJsZSBjYWNoaW5nIGZvclxuICAgICAqL1xuICAgIGRpc2FibGU6IGZ1bmN0aW9uIChwYXRoKSB7XG4gICAgICB0aGlzLnNldChwYXRoLCAnRkxVU0gnKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTWV0aG9kOiBvbkFjdGl2YXRlXG4gICAgICpcbiAgICAgKiBTZXQgYSBjYWxsYmFjayBmb3Igd2hlbiBjYWNoaW5nIGlzIGFjdGl2YXRlZCBmb3IgYSBwYXRoLlxuICAgICAqXG4gICAgICogUGFyYW1ldGVyczpcbiAgICAgKiAgIGNhbGxiYWNrIC0gQ2FsbGJhY2sgZnVuY3Rpb25cbiAgICAgKi9cbiAgICBvbkFjdGl2YXRlOiBmdW5jdGlvbiAoY2IpIHtcbiAgICAgIHZhciBpO1xuICAgICAgbG9nKCdbQ2FjaGluZ10gU2V0dGluZyBhY3RpdmF0ZSBoYW5kbGVyJywgY2IsIHRoaXMucGVuZGluZ0FjdGl2YXRpb25zKTtcbiAgICAgIHRoaXMuYWN0aXZhdGVIYW5kbGVyID0gY2I7XG4gICAgICBmb3IgKGk9MDsgaTx0aGlzLnBlbmRpbmdBY3RpdmF0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjYih0aGlzLnBlbmRpbmdBY3RpdmF0aW9uc1tpXSk7XG4gICAgICB9XG4gICAgICBkZWxldGUgdGhpcy5wZW5kaW5nQWN0aXZhdGlvbnM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1ldGhvZDogY2hlY2tQYXRoXG4gICAgICpcbiAgICAgKiBSZXRyaWV2ZSBjYWNoaW5nIHNldHRpbmcgZm9yIGEgZ2l2ZW4gcGF0aCwgb3IgaXRzIG5leHQgcGFyZW50XG4gICAgICogd2l0aCBhIGNhY2hpbmcgc3RyYXRlZ3kgc2V0LlxuICAgICAqXG4gICAgICogUGFyYW1ldGVyczpcbiAgICAgKiAgIHBhdGggLSBQYXRoIHRvIHJldHJpZXZlIHNldHRpbmcgZm9yXG4gICAgICoqL1xuICAgIGNoZWNrUGF0aDogZnVuY3Rpb24gKHBhdGgpIHtcbiAgICAgIGlmICh0aGlzLl9yb290UGF0aHNbcGF0aF0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcm9vdFBhdGhzW3BhdGhdO1xuICAgICAgfSBlbHNlIGlmIChwYXRoID09PSAnLycpIHtcbiAgICAgICAgcmV0dXJuICdTRUVOJztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNoZWNrUGF0aChjb250YWluaW5nRm9sZGVyKHBhdGgpKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTWV0aG9kOiByZXNldFxuICAgICAqXG4gICAgICogUmVzZXQgdGhlIHN0YXRlIG9mIGNhY2hpbmcgYnkgZGVsZXRpbmcgYWxsIGNhY2hpbmcgaW5mb3JtYXRpb24uXG4gICAgICoqL1xuICAgIHJlc2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLl9yb290UGF0aHMgPSB7fTtcbiAgICAgIHRoaXMuX3JlbW90ZVN0b3JhZ2UgPSBudWxsO1xuICAgIH1cbiAgfTtcblxuXG4gIENhY2hpbmcuX3JzX2luaXQgPSBmdW5jdGlvbiAocmVtb3RlU3RvcmFnZSkge1xuICAgIHRoaXMuX3JlbW90ZVN0b3JhZ2UgPSByZW1vdGVTdG9yYWdlO1xuICB9O1xuXG5tb2R1bGUuZXhwb3J0cyA9IENhY2hpbmc7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvY2FjaGluZy5qcyJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ },
/* 28 */
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\n/**\n * Class: RemoteStorage.IndexedDB\n *\n *\n * IndexedDB Interface\n * -------------------\n *\n * TODO rewrite, doesn't expose GPD anymore, it's in cachinglayer now\n *\n * This file exposes a get/put/delete interface, accessing data in an IndexedDB.\n *\n * There are multiple parts to this interface:\n *\n *   The RemoteStorage integration:\n *     - RemoteStorage.IndexedDB._rs_supported() determines if IndexedDB support\n *       is available. If it isn't, RemoteStorage won't initialize the feature.\n *     - RemoteStorage.IndexedDB._rs_init() initializes the feature. It returns\n *       a promise that is fulfilled as soon as the database has been opened and\n *       migrated.\n *\n *   The storage interface (RemoteStorage.IndexedDB object):\n *     - Usually this is accessible via \"remoteStorage.local\"\n *     - #get() takes a path and returns a promise.\n *     - #put() takes a path, body and contentType and also returns a promise.\n *     - #delete() takes a path and also returns a promise.\n *     - #on('change', ...) events, being fired whenever something changes in\n *       the storage. Change events roughly follow the StorageEvent pattern.\n *       They have \"oldValue\" and \"newValue\" properties, which can be used to\n *       distinguish create/update/delete operations and analyze changes in\n *       change handlers. In addition they carry a \"origin\" property, which\n *       is either \"window\", \"local\", or \"remote\". \"remote\" events are fired\n *       whenever a change comes in from RemoteStorage.Sync.\n *\n *   The sync interface (also on RemoteStorage.IndexedDB object):\n *     - #getNodes([paths]) returns the requested nodes in a promise.\n *     - #setNodes(map) stores all the nodes given in the (path -> node) map.\n *\n */\n\nvar log = __webpack_require__(4);\nvar cachingLayer = __webpack_require__(29);\nvar eventHandling = __webpack_require__(3);\nvar util = __webpack_require__(2);\n\nvar DB_VERSION = 2;\n\nvar DEFAULT_DB_NAME = 'remotestorage';\nvar DEFAULT_DB;\n\nvar IndexedDB = function IndexedDB(database) {\n  this.db = database || DEFAULT_DB;\n\n  if (!this.db) {\n    log(\"[IndexedDB] Failed to open DB\");\n    return undefined;\n  }\n\n  cachingLayer(this);\n  eventHandling(this, 'change', 'local-events-done');\n\n  this.getsRunning = 0;\n  this.putsRunning = 0;\n\n  /**\n   * Property: changesQueued\n   *\n   * Given a node for which uncommitted changes exist, this cache\n   * stores either the entire uncommitted node, or false for a deletion.\n   * The node's path is used as the key.\n   *\n   * changesQueued stores changes for which no IndexedDB transaction has\n   * been started yet.\n   */\n  this.changesQueued = {};\n\n  /**\n   * Property: changesRunning\n   *\n   * Given a node for which uncommitted changes exist, this cache\n   * stores either the entire uncommitted node, or false for a deletion.\n   * The node's path is used as the key.\n   *\n   * At any time there is at most one IndexedDB transaction running.\n   * changesRunning stores the changes that are included in that currently\n   * running IndexedDB transaction, or if none is running, of the last one\n   * that ran.\n   */\n  this.changesRunning = {};\n};\n\nIndexedDB.prototype = {\n  getNodes: function getNodes(paths) {\n    var misses = [],\n        fromCache = {};\n    for (var i = 0, len = paths.length; i < len; i++) {\n      if (this.changesQueued[paths[i]] !== undefined) {\n        fromCache[paths[i]] = util.deepClone(this.changesQueued[paths[i]] || undefined);\n      } else if (this.changesRunning[paths[i]] !== undefined) {\n        fromCache[paths[i]] = util.deepClone(this.changesRunning[paths[i]] || undefined);\n      } else {\n        misses.push(paths[i]);\n      }\n    }\n    if (misses.length > 0) {\n      return this.getNodesFromDb(misses).then(function (nodes) {\n        for (var i in fromCache) {\n          nodes[i] = fromCache[i];\n        }\n        return nodes;\n      });\n    } else {\n      return Promise.resolve(fromCache);\n    }\n  },\n\n  setNodes: function setNodes(nodes) {\n    for (var i in nodes) {\n      this.changesQueued[i] = nodes[i] || false;\n    }\n    this.maybeFlush();\n    return Promise.resolve();\n  },\n\n  maybeFlush: function maybeFlush() {\n    if (this.putsRunning === 0) {\n      this.flushChangesQueued();\n    } else {\n      if (!this.commitSlownessWarning) {\n        this.commitSlownessWarning = setInterval(function () {\n          console.log('WARNING: waited more than 10 seconds for previous commit to finish');\n        }, 10000);\n      }\n    }\n  },\n\n  flushChangesQueued: function flushChangesQueued() {\n    if (this.commitSlownessWarning) {\n      clearInterval(this.commitSlownessWarning);\n      this.commitSlownessWarning = null;\n    }\n    if (Object.keys(this.changesQueued).length > 0) {\n      this.changesRunning = this.changesQueued;\n      this.changesQueued = {};\n      this.setNodesInDb(this.changesRunning).then(this.flushChangesQueued.bind(this));\n    }\n  },\n\n  getNodesFromDb: function getNodesFromDb(paths) {\n    var pending = Promise.defer();\n    var transaction = this.db.transaction(['nodes'], 'readonly');\n    var nodes = transaction.objectStore('nodes');\n    var retrievedNodes = {};\n    var startTime = new Date().getTime();\n\n    this.getsRunning++;\n\n    paths.map(function (path, i) {\n      nodes.get(path).onsuccess = function (evt) {\n        retrievedNodes[path] = evt.target.result;\n      };\n    });\n\n    transaction.oncomplete = function () {\n      pending.resolve(retrievedNodes);\n      this.getsRunning--;\n    }.bind(this);\n\n    transaction.onerror = transaction.onabort = function () {\n      pending.reject('get transaction error/abort');\n      this.getsRunning--;\n    }.bind(this);\n\n    return pending.promise;\n  },\n\n  setNodesInDb: function setNodesInDb(nodes) {\n    var pending = Promise.defer();\n    var transaction = this.db.transaction(['nodes'], 'readwrite');\n    var nodesStore = transaction.objectStore('nodes');\n    var startTime = new Date().getTime();\n\n    this.putsRunning++;\n\n    log('[IndexedDB] Starting put', nodes, this.putsRunning);\n\n    for (var path in nodes) {\n      var node = nodes[path];\n      if ((typeof node === 'undefined' ? 'undefined' : _typeof(node)) === 'object') {\n        try {\n          nodesStore.put(node);\n        } catch (e) {\n          log('[IndexedDB] Error while putting', node, e);\n          throw e;\n        }\n      } else {\n        try {\n          nodesStore.delete(path);\n        } catch (e) {\n          log('[IndexedDB] Error while removing', nodesStore, node, e);\n          throw e;\n        }\n      }\n    }\n\n    transaction.oncomplete = function () {\n      this.putsRunning--;\n      log('[IndexedDB] Finished put', nodes, this.putsRunning, new Date().getTime() - startTime + 'ms');\n      pending.resolve();\n    }.bind(this);\n\n    transaction.onerror = function () {\n      this.putsRunning--;\n      pending.reject('transaction error');\n    }.bind(this);\n\n    transaction.onabort = function () {\n      pending.reject('transaction abort');\n      this.putsRunning--;\n    }.bind(this);\n\n    return pending.promise;\n  },\n\n  reset: function reset(callback) {\n    var dbName = this.db.name;\n    var self = this;\n\n    this.db.close();\n\n    IndexedDB.clean(this.db.name, function () {\n      IndexedDB.open(dbName, function (err, other) {\n        if (err) {\n          log('[IndexedDB] Error while resetting local storage', err);\n        } else {\n          // hacky!\n          self.db = other;\n        }\n        if (typeof callback === 'function') {\n          callback(self);\n        }\n      });\n    });\n  },\n\n  forAllNodes: function forAllNodes(cb) {\n    var pending = Promise.defer();\n    var transaction = this.db.transaction(['nodes'], 'readonly');\n    var cursorReq = transaction.objectStore('nodes').openCursor();\n\n    cursorReq.onsuccess = function (evt) {\n      var cursor = evt.target.result;\n\n      if (cursor) {\n        cb(this.migrate(cursor.value));\n        cursor.continue();\n      } else {\n        pending.resolve();\n      }\n    }.bind(this);\n\n    return pending.promise;\n  },\n\n  closeDB: function closeDB() {\n    this.db.close();\n  }\n\n};\n\nIndexedDB.open = function (name, callback) {\n  var timer = setTimeout(function () {\n    callback(\"timeout trying to open db\");\n  }, 10000);\n\n  try {\n    var req = indexedDB.open(name, DB_VERSION);\n\n    req.onerror = function () {\n      log('[IndexedDB] Opening DB failed', req);\n\n      clearTimeout(timer);\n      callback(req.error);\n    };\n\n    req.onupgradeneeded = function (event) {\n      var db = req.result;\n\n      log(\"[IndexedDB] Upgrade: from \", event.oldVersion, \" to \", event.newVersion);\n\n      if (event.oldVersion !== 1) {\n        log(\"[IndexedDB] Creating object store: nodes\");\n        db.createObjectStore('nodes', { keyPath: 'path' });\n      }\n\n      log(\"[IndexedDB] Creating object store: changes\");\n\n      db.createObjectStore('changes', { keyPath: 'path' });\n    };\n\n    req.onsuccess = function () {\n      clearTimeout(timer);\n\n      // check if all object stores exist\n      var db = req.result;\n      if (!db.objectStoreNames.contains('nodes') || !db.objectStoreNames.contains('changes')) {\n        log(\"[IndexedDB] Missing object store. Resetting the database.\");\n        IndexedDB.clean(name, function () {\n          IndexedDB.open(name, callback);\n        });\n        return;\n      }\n\n      callback(null, req.result);\n    };\n  } catch (error) {\n    log(\"[IndexedDB] Failed to open database: \" + error);\n    log(\"[IndexedDB] Resetting database and trying again.\");\n\n    clearTimeout(timer);\n\n    IndexedDB.clean(name, function () {\n      IndexedDB.open(name, callback);\n    });\n  };\n};\n\nIndexedDB.clean = function (databaseName, callback) {\n  var req = indexedDB.deleteDatabase(databaseName);\n\n  req.onsuccess = function () {\n    log('[IndexedDB] Done removing DB');\n    callback();\n  };\n\n  req.onerror = req.onabort = function (evt) {\n    console.error('Failed to remove database \"' + databaseName + '\"', evt);\n  };\n};\n\nIndexedDB._rs_init = function (remoteStorage) {\n  var pending = Promise.defer();\n\n  IndexedDB.open(DEFAULT_DB_NAME, function (err, db) {\n    if (err) {\n      pending.reject(err);\n    } else {\n      DEFAULT_DB = db;\n      db.onerror = function () {\n        remoteStorage._emit('error', err);\n      };\n      pending.resolve();\n    }\n  });\n\n  return pending.promise;\n};\n\nIndexedDB._rs_supported = function () {\n  var pending = Promise.defer();\n  var context = util.getGlobalContext();\n\n  // context.indexedDB = context.indexedDB    || context.webkitIndexedDB ||\n  //                    context.mozIndexedDB || context.oIndexedDB      ||\n  //                    context.msIndexedDB;\n\n  // Detect browsers with known IndexedDb issues (e.g. Android pre-4.4)\n  var poorIndexedDbSupport = false;\n  if (typeof navigator !== 'undefined' && navigator.userAgent.match(/Android (2|3|4\\.[0-3])/)) {\n    // Chrome and Firefox support IndexedDB\n    if (!navigator.userAgent.match(/Chrome|Firefox/)) {\n      poorIndexedDbSupport = true;\n    }\n  }\n\n  if ('indexedDB' in context && !poorIndexedDbSupport) {\n    try {\n      var check = indexedDB.open(\"rs-check\");\n      check.onerror = function (event) {\n        pending.reject();\n      };\n      check.onsuccess = function (event) {\n        check.result.close();\n        indexedDB.deleteDatabase(\"rs-check\");\n        pending.resolve();\n      };\n    } catch (e) {\n      pending.reject();\n    }\n  } else {\n    pending.reject();\n  }\n\n  return pending.promise;\n};\n\nIndexedDB._rs_cleanup = function (remoteStorage) {\n  var pending = Promise.defer();\n\n  if (remoteStorage.local) {\n    remoteStorage.local.closeDB();\n  }\n\n  IndexedDB.clean(DEFAULT_DB_NAME, function () {\n    pending.resolve();\n  });\n\n  return pending.promise;\n};\n\nmodule.exports = IndexedDB;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvaW5kZXhlZGRiLmpzPzZhZGIiXSwibmFtZXMiOlsibG9nIiwicmVxdWlyZSIsImNhY2hpbmdMYXllciIsImV2ZW50SGFuZGxpbmciLCJ1dGlsIiwiREJfVkVSU0lPTiIsIkRFRkFVTFRfREJfTkFNRSIsIkRFRkFVTFRfREIiLCJJbmRleGVkREIiLCJkYXRhYmFzZSIsImRiIiwidW5kZWZpbmVkIiwiZ2V0c1J1bm5pbmciLCJwdXRzUnVubmluZyIsImNoYW5nZXNRdWV1ZWQiLCJjaGFuZ2VzUnVubmluZyIsInByb3RvdHlwZSIsImdldE5vZGVzIiwicGF0aHMiLCJtaXNzZXMiLCJmcm9tQ2FjaGUiLCJpIiwibGVuIiwibGVuZ3RoIiwiZGVlcENsb25lIiwicHVzaCIsImdldE5vZGVzRnJvbURiIiwidGhlbiIsIm5vZGVzIiwiUHJvbWlzZSIsInJlc29sdmUiLCJzZXROb2RlcyIsIm1heWJlRmx1c2giLCJmbHVzaENoYW5nZXNRdWV1ZWQiLCJjb21taXRTbG93bmVzc1dhcm5pbmciLCJzZXRJbnRlcnZhbCIsImNvbnNvbGUiLCJjbGVhckludGVydmFsIiwiT2JqZWN0Iiwia2V5cyIsInNldE5vZGVzSW5EYiIsImJpbmQiLCJwZW5kaW5nIiwiZGVmZXIiLCJ0cmFuc2FjdGlvbiIsIm9iamVjdFN0b3JlIiwicmV0cmlldmVkTm9kZXMiLCJzdGFydFRpbWUiLCJEYXRlIiwiZ2V0VGltZSIsIm1hcCIsInBhdGgiLCJnZXQiLCJvbnN1Y2Nlc3MiLCJldnQiLCJ0YXJnZXQiLCJyZXN1bHQiLCJvbmNvbXBsZXRlIiwib25lcnJvciIsIm9uYWJvcnQiLCJyZWplY3QiLCJwcm9taXNlIiwibm9kZXNTdG9yZSIsIm5vZGUiLCJwdXQiLCJlIiwiZGVsZXRlIiwicmVzZXQiLCJjYWxsYmFjayIsImRiTmFtZSIsIm5hbWUiLCJzZWxmIiwiY2xvc2UiLCJjbGVhbiIsIm9wZW4iLCJlcnIiLCJvdGhlciIsImZvckFsbE5vZGVzIiwiY2IiLCJjdXJzb3JSZXEiLCJvcGVuQ3Vyc29yIiwiY3Vyc29yIiwibWlncmF0ZSIsInZhbHVlIiwiY29udGludWUiLCJjbG9zZURCIiwidGltZXIiLCJzZXRUaW1lb3V0IiwicmVxIiwiaW5kZXhlZERCIiwiY2xlYXJUaW1lb3V0IiwiZXJyb3IiLCJvbnVwZ3JhZGVuZWVkZWQiLCJldmVudCIsIm9sZFZlcnNpb24iLCJuZXdWZXJzaW9uIiwiY3JlYXRlT2JqZWN0U3RvcmUiLCJrZXlQYXRoIiwib2JqZWN0U3RvcmVOYW1lcyIsImNvbnRhaW5zIiwiZGF0YWJhc2VOYW1lIiwiZGVsZXRlRGF0YWJhc2UiLCJfcnNfaW5pdCIsInJlbW90ZVN0b3JhZ2UiLCJfZW1pdCIsIl9yc19zdXBwb3J0ZWQiLCJjb250ZXh0IiwiZ2V0R2xvYmFsQ29udGV4dCIsInBvb3JJbmRleGVkRGJTdXBwb3J0IiwibmF2aWdhdG9yIiwidXNlckFnZW50IiwibWF0Y2giLCJjaGVjayIsIl9yc19jbGVhbnVwIiwibG9jYWwiLCJtb2R1bGUiLCJleHBvcnRzIl0sIm1hcHBpbmdzIjoiOzs7O0FBQ0U7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQXVDQSxJQUFJQSxNQUFNLG1CQUFBQyxDQUFRLENBQVIsQ0FBVjtBQUNBLElBQUlDLGVBQWUsbUJBQUFELENBQVEsRUFBUixDQUFuQjtBQUNBLElBQUlFLGdCQUFnQixtQkFBQUYsQ0FBUSxDQUFSLENBQXBCO0FBQ0EsSUFBSUcsT0FBTyxtQkFBQUgsQ0FBUSxDQUFSLENBQVg7O0FBRUEsSUFBSUksYUFBYSxDQUFqQjs7QUFFQSxJQUFJQyxrQkFBa0IsZUFBdEI7QUFDQSxJQUFJQyxVQUFKOztBQUVBLElBQUlDLFlBQVksU0FBWkEsU0FBWSxDQUFVQyxRQUFWLEVBQW9CO0FBQ2xDLE9BQUtDLEVBQUwsR0FBVUQsWUFBWUYsVUFBdEI7O0FBRUEsTUFBSSxDQUFDLEtBQUtHLEVBQVYsRUFBYztBQUNaVixRQUFJLCtCQUFKO0FBQ0EsV0FBT1csU0FBUDtBQUNEOztBQUVEVCxlQUFhLElBQWI7QUFDQUMsZ0JBQWMsSUFBZCxFQUFvQixRQUFwQixFQUE4QixtQkFBOUI7O0FBRUEsT0FBS1MsV0FBTCxHQUFtQixDQUFuQjtBQUNBLE9BQUtDLFdBQUwsR0FBbUIsQ0FBbkI7O0FBRUE7Ozs7Ozs7Ozs7QUFVQSxPQUFLQyxhQUFMLEdBQXFCLEVBQXJCOztBQUVBOzs7Ozs7Ozs7Ozs7QUFZQSxPQUFLQyxjQUFMLEdBQXNCLEVBQXRCO0FBQ0QsQ0F2Q0Q7O0FBeUNBUCxVQUFVUSxTQUFWLEdBQXNCO0FBQ3BCQyxZQUFVLGtCQUFVQyxLQUFWLEVBQWlCO0FBQ3pCLFFBQUlDLFNBQVMsRUFBYjtBQUFBLFFBQWlCQyxZQUFZLEVBQTdCO0FBQ0EsU0FBSyxJQUFJQyxJQUFJLENBQVIsRUFBV0MsTUFBTUosTUFBTUssTUFBNUIsRUFBb0NGLElBQUlDLEdBQXhDLEVBQTZDRCxHQUE3QyxFQUFrRDtBQUNoRCxVQUFJLEtBQUtQLGFBQUwsQ0FBbUJJLE1BQU1HLENBQU4sQ0FBbkIsTUFBaUNWLFNBQXJDLEVBQWdEO0FBQzlDUyxrQkFBVUYsTUFBTUcsQ0FBTixDQUFWLElBQXNCakIsS0FBS29CLFNBQUwsQ0FBZSxLQUFLVixhQUFMLENBQW1CSSxNQUFNRyxDQUFOLENBQW5CLEtBQWdDVixTQUEvQyxDQUF0QjtBQUNELE9BRkQsTUFFTyxJQUFHLEtBQUtJLGNBQUwsQ0FBb0JHLE1BQU1HLENBQU4sQ0FBcEIsTUFBa0NWLFNBQXJDLEVBQWdEO0FBQ3JEUyxrQkFBVUYsTUFBTUcsQ0FBTixDQUFWLElBQXNCakIsS0FBS29CLFNBQUwsQ0FBZSxLQUFLVCxjQUFMLENBQW9CRyxNQUFNRyxDQUFOLENBQXBCLEtBQWlDVixTQUFoRCxDQUF0QjtBQUNELE9BRk0sTUFFQTtBQUNMUSxlQUFPTSxJQUFQLENBQVlQLE1BQU1HLENBQU4sQ0FBWjtBQUNEO0FBQ0Y7QUFDRCxRQUFJRixPQUFPSSxNQUFQLEdBQWdCLENBQXBCLEVBQXVCO0FBQ3JCLGFBQU8sS0FBS0csY0FBTCxDQUFvQlAsTUFBcEIsRUFBNEJRLElBQTVCLENBQWlDLFVBQVVDLEtBQVYsRUFBaUI7QUFDdkQsYUFBSyxJQUFJUCxDQUFULElBQWNELFNBQWQsRUFBeUI7QUFDdkJRLGdCQUFNUCxDQUFOLElBQVdELFVBQVVDLENBQVYsQ0FBWDtBQUNEO0FBQ0QsZUFBT08sS0FBUDtBQUNELE9BTE0sQ0FBUDtBQU1ELEtBUEQsTUFPTztBQUNMLGFBQU9DLFFBQVFDLE9BQVIsQ0FBZ0JWLFNBQWhCLENBQVA7QUFDRDtBQUNGLEdBdEJtQjs7QUF3QnBCVyxZQUFVLGtCQUFVSCxLQUFWLEVBQWlCO0FBQ3pCLFNBQUssSUFBSVAsQ0FBVCxJQUFjTyxLQUFkLEVBQXFCO0FBQ25CLFdBQUtkLGFBQUwsQ0FBbUJPLENBQW5CLElBQXdCTyxNQUFNUCxDQUFOLEtBQVksS0FBcEM7QUFDRDtBQUNELFNBQUtXLFVBQUw7QUFDQSxXQUFPSCxRQUFRQyxPQUFSLEVBQVA7QUFDRCxHQTlCbUI7O0FBZ0NwQkUsY0FBWSxzQkFBWTtBQUN0QixRQUFJLEtBQUtuQixXQUFMLEtBQXFCLENBQXpCLEVBQTRCO0FBQzFCLFdBQUtvQixrQkFBTDtBQUNELEtBRkQsTUFFTztBQUNMLFVBQUksQ0FBQyxLQUFLQyxxQkFBVixFQUFpQztBQUMvQixhQUFLQSxxQkFBTCxHQUE2QkMsWUFBWSxZQUFZO0FBQ25EQyxrQkFBUXBDLEdBQVIsQ0FBWSxvRUFBWjtBQUNELFNBRjRCLEVBRTFCLEtBRjBCLENBQTdCO0FBR0Q7QUFDRjtBQUNGLEdBMUNtQjs7QUE0Q3BCaUMsc0JBQW9CLDhCQUFZO0FBQzlCLFFBQUksS0FBS0MscUJBQVQsRUFBZ0M7QUFDOUJHLG9CQUFjLEtBQUtILHFCQUFuQjtBQUNBLFdBQUtBLHFCQUFMLEdBQTZCLElBQTdCO0FBQ0Q7QUFDRCxRQUFJSSxPQUFPQyxJQUFQLENBQVksS0FBS3pCLGFBQWpCLEVBQWdDUyxNQUFoQyxHQUF5QyxDQUE3QyxFQUFnRDtBQUM5QyxXQUFLUixjQUFMLEdBQXNCLEtBQUtELGFBQTNCO0FBQ0EsV0FBS0EsYUFBTCxHQUFxQixFQUFyQjtBQUNBLFdBQUswQixZQUFMLENBQWtCLEtBQUt6QixjQUF2QixFQUF1Q1ksSUFBdkMsQ0FBNEMsS0FBS00sa0JBQUwsQ0FBd0JRLElBQXhCLENBQTZCLElBQTdCLENBQTVDO0FBQ0Q7QUFDRixHQXREbUI7O0FBd0RwQmYsa0JBQWdCLHdCQUFVUixLQUFWLEVBQWlCO0FBQy9CLFFBQUl3QixVQUFVYixRQUFRYyxLQUFSLEVBQWQ7QUFDQSxRQUFJQyxjQUFjLEtBQUtsQyxFQUFMLENBQVFrQyxXQUFSLENBQW9CLENBQUMsT0FBRCxDQUFwQixFQUErQixVQUEvQixDQUFsQjtBQUNBLFFBQUloQixRQUFRZ0IsWUFBWUMsV0FBWixDQUF3QixPQUF4QixDQUFaO0FBQ0EsUUFBSUMsaUJBQWlCLEVBQXJCO0FBQ0EsUUFBSUMsWUFBWSxJQUFJQyxJQUFKLEdBQVdDLE9BQVgsRUFBaEI7O0FBRUEsU0FBS3JDLFdBQUw7O0FBRUFNLFVBQU1nQyxHQUFOLENBQVUsVUFBVUMsSUFBVixFQUFnQjlCLENBQWhCLEVBQW1CO0FBQzNCTyxZQUFNd0IsR0FBTixDQUFVRCxJQUFWLEVBQWdCRSxTQUFoQixHQUE0QixVQUFVQyxHQUFWLEVBQWU7QUFDekNSLHVCQUFlSyxJQUFmLElBQXVCRyxJQUFJQyxNQUFKLENBQVdDLE1BQWxDO0FBQ0QsT0FGRDtBQUdELEtBSkQ7O0FBTUFaLGdCQUFZYSxVQUFaLEdBQXlCLFlBQVk7QUFDbkNmLGNBQVFaLE9BQVIsQ0FBZ0JnQixjQUFoQjtBQUNBLFdBQUtsQyxXQUFMO0FBQ0QsS0FId0IsQ0FHdkI2QixJQUh1QixDQUdsQixJQUhrQixDQUF6Qjs7QUFLQUcsZ0JBQVljLE9BQVosR0FBc0JkLFlBQVllLE9BQVosR0FBc0IsWUFBWTtBQUN0RGpCLGNBQVFrQixNQUFSLENBQWUsNkJBQWY7QUFDQSxXQUFLaEQsV0FBTDtBQUNELEtBSDJDLENBRzFDNkIsSUFIMEMsQ0FHckMsSUFIcUMsQ0FBNUM7O0FBS0EsV0FBT0MsUUFBUW1CLE9BQWY7QUFDRCxHQWxGbUI7O0FBb0ZwQnJCLGdCQUFjLHNCQUFVWixLQUFWLEVBQWlCO0FBQzdCLFFBQUljLFVBQVViLFFBQVFjLEtBQVIsRUFBZDtBQUNBLFFBQUlDLGNBQWMsS0FBS2xDLEVBQUwsQ0FBUWtDLFdBQVIsQ0FBb0IsQ0FBQyxPQUFELENBQXBCLEVBQStCLFdBQS9CLENBQWxCO0FBQ0EsUUFBSWtCLGFBQWFsQixZQUFZQyxXQUFaLENBQXdCLE9BQXhCLENBQWpCO0FBQ0EsUUFBSUUsWUFBWSxJQUFJQyxJQUFKLEdBQVdDLE9BQVgsRUFBaEI7O0FBRUEsU0FBS3BDLFdBQUw7O0FBRUFiLFFBQUksMEJBQUosRUFBZ0M0QixLQUFoQyxFQUF1QyxLQUFLZixXQUE1Qzs7QUFFQSxTQUFLLElBQUlzQyxJQUFULElBQWlCdkIsS0FBakIsRUFBd0I7QUFDdEIsVUFBSW1DLE9BQU9uQyxNQUFNdUIsSUFBTixDQUFYO0FBQ0EsVUFBRyxRQUFPWSxJQUFQLHlDQUFPQSxJQUFQLE9BQWlCLFFBQXBCLEVBQThCO0FBQzVCLFlBQUk7QUFDRkQscUJBQVdFLEdBQVgsQ0FBZUQsSUFBZjtBQUNELFNBRkQsQ0FFRSxPQUFNRSxDQUFOLEVBQVM7QUFDVGpFLGNBQUksaUNBQUosRUFBdUMrRCxJQUF2QyxFQUE2Q0UsQ0FBN0M7QUFDQSxnQkFBTUEsQ0FBTjtBQUNEO0FBQ0YsT0FQRCxNQU9PO0FBQ0wsWUFBSTtBQUNGSCxxQkFBV0ksTUFBWCxDQUFrQmYsSUFBbEI7QUFDRCxTQUZELENBRUUsT0FBTWMsQ0FBTixFQUFTO0FBQ1RqRSxjQUFJLGtDQUFKLEVBQXdDOEQsVUFBeEMsRUFBb0RDLElBQXBELEVBQTBERSxDQUExRDtBQUNBLGdCQUFNQSxDQUFOO0FBQ0Q7QUFDRjtBQUNGOztBQUVEckIsZ0JBQVlhLFVBQVosR0FBeUIsWUFBWTtBQUNuQyxXQUFLNUMsV0FBTDtBQUNBYixVQUFJLDBCQUFKLEVBQWdDNEIsS0FBaEMsRUFBdUMsS0FBS2YsV0FBNUMsRUFBMEQsSUFBSW1DLElBQUosR0FBV0MsT0FBWCxLQUF1QkYsU0FBeEIsR0FBbUMsSUFBNUY7QUFDQUwsY0FBUVosT0FBUjtBQUNELEtBSndCLENBSXZCVyxJQUp1QixDQUlsQixJQUprQixDQUF6Qjs7QUFNQUcsZ0JBQVljLE9BQVosR0FBc0IsWUFBWTtBQUNoQyxXQUFLN0MsV0FBTDtBQUNBNkIsY0FBUWtCLE1BQVIsQ0FBZSxtQkFBZjtBQUNELEtBSHFCLENBR3BCbkIsSUFIb0IsQ0FHZixJQUhlLENBQXRCOztBQUtBRyxnQkFBWWUsT0FBWixHQUFzQixZQUFZO0FBQ2hDakIsY0FBUWtCLE1BQVIsQ0FBZSxtQkFBZjtBQUNBLFdBQUsvQyxXQUFMO0FBQ0QsS0FIcUIsQ0FHcEI0QixJQUhvQixDQUdmLElBSGUsQ0FBdEI7O0FBS0EsV0FBT0MsUUFBUW1CLE9BQWY7QUFDRCxHQWxJbUI7O0FBb0lwQk0sU0FBTyxlQUFVQyxRQUFWLEVBQW9CO0FBQ3pCLFFBQUlDLFNBQVMsS0FBSzNELEVBQUwsQ0FBUTRELElBQXJCO0FBQ0EsUUFBSUMsT0FBTyxJQUFYOztBQUVBLFNBQUs3RCxFQUFMLENBQVE4RCxLQUFSOztBQUVBaEUsY0FBVWlFLEtBQVYsQ0FBZ0IsS0FBSy9ELEVBQUwsQ0FBUTRELElBQXhCLEVBQThCLFlBQVc7QUFDdkM5RCxnQkFBVWtFLElBQVYsQ0FBZUwsTUFBZixFQUF1QixVQUFVTSxHQUFWLEVBQWVDLEtBQWYsRUFBc0I7QUFDM0MsWUFBSUQsR0FBSixFQUFTO0FBQ1AzRSxjQUFJLGlEQUFKLEVBQXVEMkUsR0FBdkQ7QUFDRCxTQUZELE1BRU87QUFDTDtBQUNBSixlQUFLN0QsRUFBTCxHQUFVa0UsS0FBVjtBQUNEO0FBQ0QsWUFBSSxPQUFPUixRQUFQLEtBQW9CLFVBQXhCLEVBQW9DO0FBQUVBLG1CQUFTRyxJQUFUO0FBQWlCO0FBQ3hELE9BUkQ7QUFTRCxLQVZEO0FBV0QsR0FySm1COztBQXVKcEJNLGVBQWEscUJBQVVDLEVBQVYsRUFBYztBQUN6QixRQUFJcEMsVUFBVWIsUUFBUWMsS0FBUixFQUFkO0FBQ0EsUUFBSUMsY0FBYyxLQUFLbEMsRUFBTCxDQUFRa0MsV0FBUixDQUFvQixDQUFDLE9BQUQsQ0FBcEIsRUFBK0IsVUFBL0IsQ0FBbEI7QUFDQSxRQUFJbUMsWUFBWW5DLFlBQVlDLFdBQVosQ0FBd0IsT0FBeEIsRUFBaUNtQyxVQUFqQyxFQUFoQjs7QUFFQUQsY0FBVTFCLFNBQVYsR0FBc0IsVUFBVUMsR0FBVixFQUFlO0FBQ25DLFVBQUkyQixTQUFTM0IsSUFBSUMsTUFBSixDQUFXQyxNQUF4Qjs7QUFFQSxVQUFJeUIsTUFBSixFQUFZO0FBQ1ZILFdBQUcsS0FBS0ksT0FBTCxDQUFhRCxPQUFPRSxLQUFwQixDQUFIO0FBQ0FGLGVBQU9HLFFBQVA7QUFDRCxPQUhELE1BR087QUFDTDFDLGdCQUFRWixPQUFSO0FBQ0Q7QUFDRixLQVRxQixDQVNwQlcsSUFUb0IsQ0FTZixJQVRlLENBQXRCOztBQVdBLFdBQU9DLFFBQVFtQixPQUFmO0FBQ0QsR0F4S21COztBQTBLcEJ3QixXQUFTLG1CQUFZO0FBQ25CLFNBQUszRSxFQUFMLENBQVE4RCxLQUFSO0FBQ0Q7O0FBNUttQixDQUF0Qjs7QUFnTEFoRSxVQUFVa0UsSUFBVixHQUFpQixVQUFVSixJQUFWLEVBQWdCRixRQUFoQixFQUEwQjtBQUN6QyxNQUFJa0IsUUFBUUMsV0FBVyxZQUFZO0FBQ2pDbkIsYUFBUywyQkFBVDtBQUNELEdBRlcsRUFFVCxLQUZTLENBQVo7O0FBSUEsTUFBSTtBQUNGLFFBQUlvQixNQUFNQyxVQUFVZixJQUFWLENBQWVKLElBQWYsRUFBcUJqRSxVQUFyQixDQUFWOztBQUVBbUYsUUFBSTlCLE9BQUosR0FBYyxZQUFZO0FBQ3hCMUQsVUFBSSwrQkFBSixFQUFxQ3dGLEdBQXJDOztBQUVBRSxtQkFBYUosS0FBYjtBQUNBbEIsZUFBU29CLElBQUlHLEtBQWI7QUFDRCxLQUxEOztBQU9BSCxRQUFJSSxlQUFKLEdBQXNCLFVBQVVDLEtBQVYsRUFBaUI7QUFDckMsVUFBSW5GLEtBQUs4RSxJQUFJaEMsTUFBYjs7QUFFQXhELFVBQUksNEJBQUosRUFBa0M2RixNQUFNQyxVQUF4QyxFQUFvRCxNQUFwRCxFQUE0REQsTUFBTUUsVUFBbEU7O0FBRUEsVUFBSUYsTUFBTUMsVUFBTixLQUFxQixDQUF6QixFQUE0QjtBQUMxQjlGLFlBQUksMENBQUo7QUFDQVUsV0FBR3NGLGlCQUFILENBQXFCLE9BQXJCLEVBQThCLEVBQUVDLFNBQVMsTUFBWCxFQUE5QjtBQUNEOztBQUVEakcsVUFBSSw0Q0FBSjs7QUFFQVUsU0FBR3NGLGlCQUFILENBQXFCLFNBQXJCLEVBQWdDLEVBQUVDLFNBQVMsTUFBWCxFQUFoQztBQUNELEtBYkQ7O0FBZUFULFFBQUluQyxTQUFKLEdBQWdCLFlBQVk7QUFDMUJxQyxtQkFBYUosS0FBYjs7QUFFQTtBQUNBLFVBQUk1RSxLQUFLOEUsSUFBSWhDLE1BQWI7QUFDQSxVQUFHLENBQUM5QyxHQUFHd0YsZ0JBQUgsQ0FBb0JDLFFBQXBCLENBQTZCLE9BQTdCLENBQUQsSUFBMEMsQ0FBQ3pGLEdBQUd3RixnQkFBSCxDQUFvQkMsUUFBcEIsQ0FBNkIsU0FBN0IsQ0FBOUMsRUFBdUY7QUFDckZuRyxZQUFJLDJEQUFKO0FBQ0FRLGtCQUFVaUUsS0FBVixDQUFnQkgsSUFBaEIsRUFBc0IsWUFBVztBQUMvQjlELG9CQUFVa0UsSUFBVixDQUFlSixJQUFmLEVBQXFCRixRQUFyQjtBQUNELFNBRkQ7QUFHQTtBQUNEOztBQUVEQSxlQUFTLElBQVQsRUFBZW9CLElBQUloQyxNQUFuQjtBQUNELEtBZEQ7QUFlRCxHQXhDRCxDQXdDRSxPQUFNbUMsS0FBTixFQUFhO0FBQ2IzRixRQUFJLDBDQUEwQzJGLEtBQTlDO0FBQ0EzRixRQUFJLGtEQUFKOztBQUVBMEYsaUJBQWFKLEtBQWI7O0FBRUE5RSxjQUFVaUUsS0FBVixDQUFnQkgsSUFBaEIsRUFBc0IsWUFBVztBQUMvQjlELGdCQUFVa0UsSUFBVixDQUFlSixJQUFmLEVBQXFCRixRQUFyQjtBQUNELEtBRkQ7QUFHRDtBQUNGLENBdkREOztBQXlEQTVELFVBQVVpRSxLQUFWLEdBQWtCLFVBQVUyQixZQUFWLEVBQXdCaEMsUUFBeEIsRUFBa0M7QUFDbEQsTUFBSW9CLE1BQU1DLFVBQVVZLGNBQVYsQ0FBeUJELFlBQXpCLENBQVY7O0FBRUFaLE1BQUluQyxTQUFKLEdBQWdCLFlBQVk7QUFDMUJyRCxRQUFJLDhCQUFKO0FBQ0FvRTtBQUNELEdBSEQ7O0FBS0FvQixNQUFJOUIsT0FBSixHQUFjOEIsSUFBSTdCLE9BQUosR0FBYyxVQUFVTCxHQUFWLEVBQWU7QUFDekNsQixZQUFRdUQsS0FBUixDQUFjLGdDQUFnQ1MsWUFBaEMsR0FBK0MsR0FBN0QsRUFBa0U5QyxHQUFsRTtBQUNELEdBRkQ7QUFHRCxDQVhEOztBQWFBOUMsVUFBVThGLFFBQVYsR0FBcUIsVUFBVUMsYUFBVixFQUF5QjtBQUM1QyxNQUFJN0QsVUFBVWIsUUFBUWMsS0FBUixFQUFkOztBQUVBbkMsWUFBVWtFLElBQVYsQ0FBZXBFLGVBQWYsRUFBZ0MsVUFBVXFFLEdBQVYsRUFBZWpFLEVBQWYsRUFBbUI7QUFDakQsUUFBSWlFLEdBQUosRUFBUztBQUNQakMsY0FBUWtCLE1BQVIsQ0FBZWUsR0FBZjtBQUNELEtBRkQsTUFFTztBQUNMcEUsbUJBQWFHLEVBQWI7QUFDQUEsU0FBR2dELE9BQUgsR0FBYSxZQUFZO0FBQUU2QyxzQkFBY0MsS0FBZCxDQUFvQixPQUFwQixFQUE2QjdCLEdBQTdCO0FBQW9DLE9BQS9EO0FBQ0FqQyxjQUFRWixPQUFSO0FBQ0Q7QUFDRixHQVJEOztBQVVBLFNBQU9ZLFFBQVFtQixPQUFmO0FBQ0QsQ0FkRDs7QUFnQkFyRCxVQUFVaUcsYUFBVixHQUEwQixZQUFZO0FBQ3BDLE1BQUkvRCxVQUFVYixRQUFRYyxLQUFSLEVBQWQ7QUFDQSxNQUFJK0QsVUFBVXRHLEtBQUt1RyxnQkFBTCxFQUFkOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE1BQUlDLHVCQUF1QixLQUEzQjtBQUNBLE1BQUksT0FBT0MsU0FBUCxLQUFxQixXQUFyQixJQUNBQSxVQUFVQyxTQUFWLENBQW9CQyxLQUFwQixDQUEwQix3QkFBMUIsQ0FESixFQUN5RDtBQUN2RDtBQUNBLFFBQUksQ0FBQ0YsVUFBVUMsU0FBVixDQUFvQkMsS0FBcEIsQ0FBMEIsZ0JBQTFCLENBQUwsRUFBa0Q7QUFDaERILDZCQUF1QixJQUF2QjtBQUNEO0FBQ0Y7O0FBRUQsTUFBSSxlQUFlRixPQUFmLElBQTBCLENBQUNFLG9CQUEvQixFQUFxRDtBQUNuRCxRQUFJO0FBQ0YsVUFBSUksUUFBUXZCLFVBQVVmLElBQVYsQ0FBZSxVQUFmLENBQVo7QUFDQXNDLFlBQU10RCxPQUFOLEdBQWdCLFVBQVVtQyxLQUFWLEVBQWlCO0FBQy9CbkQsZ0JBQVFrQixNQUFSO0FBQ0QsT0FGRDtBQUdBb0QsWUFBTTNELFNBQU4sR0FBa0IsVUFBVXdDLEtBQVYsRUFBaUI7QUFDakNtQixjQUFNeEQsTUFBTixDQUFhZ0IsS0FBYjtBQUNBaUIsa0JBQVVZLGNBQVYsQ0FBeUIsVUFBekI7QUFDQTNELGdCQUFRWixPQUFSO0FBQ0QsT0FKRDtBQUtELEtBVkQsQ0FVRSxPQUFNbUMsQ0FBTixFQUFTO0FBQ1R2QixjQUFRa0IsTUFBUjtBQUNEO0FBQ0YsR0FkRCxNQWNPO0FBQ0xsQixZQUFRa0IsTUFBUjtBQUNEOztBQUVELFNBQU9sQixRQUFRbUIsT0FBZjtBQUNELENBckNEOztBQXVDQXJELFVBQVV5RyxXQUFWLEdBQXdCLFVBQVVWLGFBQVYsRUFBeUI7QUFDL0MsTUFBSTdELFVBQVViLFFBQVFjLEtBQVIsRUFBZDs7QUFFQSxNQUFJNEQsY0FBY1csS0FBbEIsRUFBeUI7QUFDdkJYLGtCQUFjVyxLQUFkLENBQW9CN0IsT0FBcEI7QUFDRDs7QUFFRDdFLFlBQVVpRSxLQUFWLENBQWdCbkUsZUFBaEIsRUFBaUMsWUFBWTtBQUMzQ29DLFlBQVFaLE9BQVI7QUFDRCxHQUZEOztBQUlBLFNBQU9ZLFFBQVFtQixPQUFmO0FBQ0QsQ0FaRDs7QUFlQXNELE9BQU9DLE9BQVAsR0FBaUI1RyxTQUFqQiIsImZpbGUiOiIyOC5qcyIsInNvdXJjZXNDb250ZW50IjpbIlxuICAvKipcbiAgICogQ2xhc3M6IFJlbW90ZVN0b3JhZ2UuSW5kZXhlZERCXG4gICAqXG4gICAqXG4gICAqIEluZGV4ZWREQiBJbnRlcmZhY2VcbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgKlxuICAgKiBUT0RPIHJld3JpdGUsIGRvZXNuJ3QgZXhwb3NlIEdQRCBhbnltb3JlLCBpdCdzIGluIGNhY2hpbmdsYXllciBub3dcbiAgICpcbiAgICogVGhpcyBmaWxlIGV4cG9zZXMgYSBnZXQvcHV0L2RlbGV0ZSBpbnRlcmZhY2UsIGFjY2Vzc2luZyBkYXRhIGluIGFuIEluZGV4ZWREQi5cbiAgICpcbiAgICogVGhlcmUgYXJlIG11bHRpcGxlIHBhcnRzIHRvIHRoaXMgaW50ZXJmYWNlOlxuICAgKlxuICAgKiAgIFRoZSBSZW1vdGVTdG9yYWdlIGludGVncmF0aW9uOlxuICAgKiAgICAgLSBSZW1vdGVTdG9yYWdlLkluZGV4ZWREQi5fcnNfc3VwcG9ydGVkKCkgZGV0ZXJtaW5lcyBpZiBJbmRleGVkREIgc3VwcG9ydFxuICAgKiAgICAgICBpcyBhdmFpbGFibGUuIElmIGl0IGlzbid0LCBSZW1vdGVTdG9yYWdlIHdvbid0IGluaXRpYWxpemUgdGhlIGZlYXR1cmUuXG4gICAqICAgICAtIFJlbW90ZVN0b3JhZ2UuSW5kZXhlZERCLl9yc19pbml0KCkgaW5pdGlhbGl6ZXMgdGhlIGZlYXR1cmUuIEl0IHJldHVybnNcbiAgICogICAgICAgYSBwcm9taXNlIHRoYXQgaXMgZnVsZmlsbGVkIGFzIHNvb24gYXMgdGhlIGRhdGFiYXNlIGhhcyBiZWVuIG9wZW5lZCBhbmRcbiAgICogICAgICAgbWlncmF0ZWQuXG4gICAqXG4gICAqICAgVGhlIHN0b3JhZ2UgaW50ZXJmYWNlIChSZW1vdGVTdG9yYWdlLkluZGV4ZWREQiBvYmplY3QpOlxuICAgKiAgICAgLSBVc3VhbGx5IHRoaXMgaXMgYWNjZXNzaWJsZSB2aWEgXCJyZW1vdGVTdG9yYWdlLmxvY2FsXCJcbiAgICogICAgIC0gI2dldCgpIHRha2VzIGEgcGF0aCBhbmQgcmV0dXJucyBhIHByb21pc2UuXG4gICAqICAgICAtICNwdXQoKSB0YWtlcyBhIHBhdGgsIGJvZHkgYW5kIGNvbnRlbnRUeXBlIGFuZCBhbHNvIHJldHVybnMgYSBwcm9taXNlLlxuICAgKiAgICAgLSAjZGVsZXRlKCkgdGFrZXMgYSBwYXRoIGFuZCBhbHNvIHJldHVybnMgYSBwcm9taXNlLlxuICAgKiAgICAgLSAjb24oJ2NoYW5nZScsIC4uLikgZXZlbnRzLCBiZWluZyBmaXJlZCB3aGVuZXZlciBzb21ldGhpbmcgY2hhbmdlcyBpblxuICAgKiAgICAgICB0aGUgc3RvcmFnZS4gQ2hhbmdlIGV2ZW50cyByb3VnaGx5IGZvbGxvdyB0aGUgU3RvcmFnZUV2ZW50IHBhdHRlcm4uXG4gICAqICAgICAgIFRoZXkgaGF2ZSBcIm9sZFZhbHVlXCIgYW5kIFwibmV3VmFsdWVcIiBwcm9wZXJ0aWVzLCB3aGljaCBjYW4gYmUgdXNlZCB0b1xuICAgKiAgICAgICBkaXN0aW5ndWlzaCBjcmVhdGUvdXBkYXRlL2RlbGV0ZSBvcGVyYXRpb25zIGFuZCBhbmFseXplIGNoYW5nZXMgaW5cbiAgICogICAgICAgY2hhbmdlIGhhbmRsZXJzLiBJbiBhZGRpdGlvbiB0aGV5IGNhcnJ5IGEgXCJvcmlnaW5cIiBwcm9wZXJ0eSwgd2hpY2hcbiAgICogICAgICAgaXMgZWl0aGVyIFwid2luZG93XCIsIFwibG9jYWxcIiwgb3IgXCJyZW1vdGVcIi4gXCJyZW1vdGVcIiBldmVudHMgYXJlIGZpcmVkXG4gICAqICAgICAgIHdoZW5ldmVyIGEgY2hhbmdlIGNvbWVzIGluIGZyb20gUmVtb3RlU3RvcmFnZS5TeW5jLlxuICAgKlxuICAgKiAgIFRoZSBzeW5jIGludGVyZmFjZSAoYWxzbyBvbiBSZW1vdGVTdG9yYWdlLkluZGV4ZWREQiBvYmplY3QpOlxuICAgKiAgICAgLSAjZ2V0Tm9kZXMoW3BhdGhzXSkgcmV0dXJucyB0aGUgcmVxdWVzdGVkIG5vZGVzIGluIGEgcHJvbWlzZS5cbiAgICogICAgIC0gI3NldE5vZGVzKG1hcCkgc3RvcmVzIGFsbCB0aGUgbm9kZXMgZ2l2ZW4gaW4gdGhlIChwYXRoIC0+IG5vZGUpIG1hcC5cbiAgICpcbiAgICovXG5cbiAgdmFyIGxvZyA9IHJlcXVpcmUoJy4vbG9nJyk7XG4gIHZhciBjYWNoaW5nTGF5ZXIgPSByZXF1aXJlKCcuL2NhY2hpbmdsYXllcicpO1xuICB2YXIgZXZlbnRIYW5kbGluZyA9IHJlcXVpcmUoJy4vZXZlbnRoYW5kbGluZycpO1xuICB2YXIgdXRpbCA9IHJlcXVpcmUoJy4vdXRpbCcpO1xuXG4gIHZhciBEQl9WRVJTSU9OID0gMjtcblxuICB2YXIgREVGQVVMVF9EQl9OQU1FID0gJ3JlbW90ZXN0b3JhZ2UnO1xuICB2YXIgREVGQVVMVF9EQjtcblxuICB2YXIgSW5kZXhlZERCID0gZnVuY3Rpb24gKGRhdGFiYXNlKSB7XG4gICAgdGhpcy5kYiA9IGRhdGFiYXNlIHx8IERFRkFVTFRfREI7XG5cbiAgICBpZiAoIXRoaXMuZGIpIHtcbiAgICAgIGxvZyhcIltJbmRleGVkREJdIEZhaWxlZCB0byBvcGVuIERCXCIpO1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICBjYWNoaW5nTGF5ZXIodGhpcyk7XG4gICAgZXZlbnRIYW5kbGluZyh0aGlzLCAnY2hhbmdlJywgJ2xvY2FsLWV2ZW50cy1kb25lJyk7XG5cbiAgICB0aGlzLmdldHNSdW5uaW5nID0gMDtcbiAgICB0aGlzLnB1dHNSdW5uaW5nID0gMDtcblxuICAgIC8qKlxuICAgICAqIFByb3BlcnR5OiBjaGFuZ2VzUXVldWVkXG4gICAgICpcbiAgICAgKiBHaXZlbiBhIG5vZGUgZm9yIHdoaWNoIHVuY29tbWl0dGVkIGNoYW5nZXMgZXhpc3QsIHRoaXMgY2FjaGVcbiAgICAgKiBzdG9yZXMgZWl0aGVyIHRoZSBlbnRpcmUgdW5jb21taXR0ZWQgbm9kZSwgb3IgZmFsc2UgZm9yIGEgZGVsZXRpb24uXG4gICAgICogVGhlIG5vZGUncyBwYXRoIGlzIHVzZWQgYXMgdGhlIGtleS5cbiAgICAgKlxuICAgICAqIGNoYW5nZXNRdWV1ZWQgc3RvcmVzIGNoYW5nZXMgZm9yIHdoaWNoIG5vIEluZGV4ZWREQiB0cmFuc2FjdGlvbiBoYXNcbiAgICAgKiBiZWVuIHN0YXJ0ZWQgeWV0LlxuICAgICAqL1xuICAgIHRoaXMuY2hhbmdlc1F1ZXVlZCA9IHt9O1xuXG4gICAgLyoqXG4gICAgICogUHJvcGVydHk6IGNoYW5nZXNSdW5uaW5nXG4gICAgICpcbiAgICAgKiBHaXZlbiBhIG5vZGUgZm9yIHdoaWNoIHVuY29tbWl0dGVkIGNoYW5nZXMgZXhpc3QsIHRoaXMgY2FjaGVcbiAgICAgKiBzdG9yZXMgZWl0aGVyIHRoZSBlbnRpcmUgdW5jb21taXR0ZWQgbm9kZSwgb3IgZmFsc2UgZm9yIGEgZGVsZXRpb24uXG4gICAgICogVGhlIG5vZGUncyBwYXRoIGlzIHVzZWQgYXMgdGhlIGtleS5cbiAgICAgKlxuICAgICAqIEF0IGFueSB0aW1lIHRoZXJlIGlzIGF0IG1vc3Qgb25lIEluZGV4ZWREQiB0cmFuc2FjdGlvbiBydW5uaW5nLlxuICAgICAqIGNoYW5nZXNSdW5uaW5nIHN0b3JlcyB0aGUgY2hhbmdlcyB0aGF0IGFyZSBpbmNsdWRlZCBpbiB0aGF0IGN1cnJlbnRseVxuICAgICAqIHJ1bm5pbmcgSW5kZXhlZERCIHRyYW5zYWN0aW9uLCBvciBpZiBub25lIGlzIHJ1bm5pbmcsIG9mIHRoZSBsYXN0IG9uZVxuICAgICAqIHRoYXQgcmFuLlxuICAgICAqL1xuICAgIHRoaXMuY2hhbmdlc1J1bm5pbmcgPSB7fTtcbiAgfTtcblxuICBJbmRleGVkREIucHJvdG90eXBlID0ge1xuICAgIGdldE5vZGVzOiBmdW5jdGlvbiAocGF0aHMpIHtcbiAgICAgIHZhciBtaXNzZXMgPSBbXSwgZnJvbUNhY2hlID0ge307XG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gcGF0aHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgaWYgKHRoaXMuY2hhbmdlc1F1ZXVlZFtwYXRoc1tpXV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGZyb21DYWNoZVtwYXRoc1tpXV0gPSB1dGlsLmRlZXBDbG9uZSh0aGlzLmNoYW5nZXNRdWV1ZWRbcGF0aHNbaV1dIHx8IHVuZGVmaW5lZCk7XG4gICAgICAgIH0gZWxzZSBpZih0aGlzLmNoYW5nZXNSdW5uaW5nW3BhdGhzW2ldXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgZnJvbUNhY2hlW3BhdGhzW2ldXSA9IHV0aWwuZGVlcENsb25lKHRoaXMuY2hhbmdlc1J1bm5pbmdbcGF0aHNbaV1dIHx8IHVuZGVmaW5lZCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbWlzc2VzLnB1c2gocGF0aHNbaV0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAobWlzc2VzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0Tm9kZXNGcm9tRGIobWlzc2VzKS50aGVuKGZ1bmN0aW9uIChub2Rlcykge1xuICAgICAgICAgIGZvciAodmFyIGkgaW4gZnJvbUNhY2hlKSB7XG4gICAgICAgICAgICBub2Rlc1tpXSA9IGZyb21DYWNoZVtpXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG5vZGVzO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoZnJvbUNhY2hlKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgc2V0Tm9kZXM6IGZ1bmN0aW9uIChub2Rlcykge1xuICAgICAgZm9yICh2YXIgaSBpbiBub2Rlcykge1xuICAgICAgICB0aGlzLmNoYW5nZXNRdWV1ZWRbaV0gPSBub2Rlc1tpXSB8fCBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHRoaXMubWF5YmVGbHVzaCgpO1xuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgIH0sXG5cbiAgICBtYXliZUZsdXNoOiBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAodGhpcy5wdXRzUnVubmluZyA9PT0gMCkge1xuICAgICAgICB0aGlzLmZsdXNoQ2hhbmdlc1F1ZXVlZCgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKCF0aGlzLmNvbW1pdFNsb3duZXNzV2FybmluZykge1xuICAgICAgICAgIHRoaXMuY29tbWl0U2xvd25lc3NXYXJuaW5nID0gc2V0SW50ZXJ2YWwoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ1dBUk5JTkc6IHdhaXRlZCBtb3JlIHRoYW4gMTAgc2Vjb25kcyBmb3IgcHJldmlvdXMgY29tbWl0IHRvIGZpbmlzaCcpO1xuICAgICAgICAgIH0sIDEwMDAwKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBmbHVzaENoYW5nZXNRdWV1ZWQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICh0aGlzLmNvbW1pdFNsb3duZXNzV2FybmluZykge1xuICAgICAgICBjbGVhckludGVydmFsKHRoaXMuY29tbWl0U2xvd25lc3NXYXJuaW5nKTtcbiAgICAgICAgdGhpcy5jb21taXRTbG93bmVzc1dhcm5pbmcgPSBudWxsO1xuICAgICAgfVxuICAgICAgaWYgKE9iamVjdC5rZXlzKHRoaXMuY2hhbmdlc1F1ZXVlZCkubGVuZ3RoID4gMCkge1xuICAgICAgICB0aGlzLmNoYW5nZXNSdW5uaW5nID0gdGhpcy5jaGFuZ2VzUXVldWVkO1xuICAgICAgICB0aGlzLmNoYW5nZXNRdWV1ZWQgPSB7fTtcbiAgICAgICAgdGhpcy5zZXROb2Rlc0luRGIodGhpcy5jaGFuZ2VzUnVubmluZykudGhlbih0aGlzLmZsdXNoQ2hhbmdlc1F1ZXVlZC5iaW5kKHRoaXMpKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgZ2V0Tm9kZXNGcm9tRGI6IGZ1bmN0aW9uIChwYXRocykge1xuICAgICAgdmFyIHBlbmRpbmcgPSBQcm9taXNlLmRlZmVyKCk7XG4gICAgICB2YXIgdHJhbnNhY3Rpb24gPSB0aGlzLmRiLnRyYW5zYWN0aW9uKFsnbm9kZXMnXSwgJ3JlYWRvbmx5Jyk7XG4gICAgICB2YXIgbm9kZXMgPSB0cmFuc2FjdGlvbi5vYmplY3RTdG9yZSgnbm9kZXMnKTtcbiAgICAgIHZhciByZXRyaWV2ZWROb2RlcyA9IHt9O1xuICAgICAgdmFyIHN0YXJ0VGltZSA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuXG4gICAgICB0aGlzLmdldHNSdW5uaW5nKys7XG5cbiAgICAgIHBhdGhzLm1hcChmdW5jdGlvbiAocGF0aCwgaSkge1xuICAgICAgICBub2Rlcy5nZXQocGF0aCkub25zdWNjZXNzID0gZnVuY3Rpb24gKGV2dCkge1xuICAgICAgICAgIHJldHJpZXZlZE5vZGVzW3BhdGhdID0gZXZ0LnRhcmdldC5yZXN1bHQ7XG4gICAgICAgIH07XG4gICAgICB9KTtcblxuICAgICAgdHJhbnNhY3Rpb24ub25jb21wbGV0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcGVuZGluZy5yZXNvbHZlKHJldHJpZXZlZE5vZGVzKTtcbiAgICAgICAgdGhpcy5nZXRzUnVubmluZy0tO1xuICAgICAgfS5iaW5kKHRoaXMpO1xuXG4gICAgICB0cmFuc2FjdGlvbi5vbmVycm9yID0gdHJhbnNhY3Rpb24ub25hYm9ydCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcGVuZGluZy5yZWplY3QoJ2dldCB0cmFuc2FjdGlvbiBlcnJvci9hYm9ydCcpO1xuICAgICAgICB0aGlzLmdldHNSdW5uaW5nLS07XG4gICAgICB9LmJpbmQodGhpcyk7XG5cbiAgICAgIHJldHVybiBwZW5kaW5nLnByb21pc2U7XG4gICAgfSxcblxuICAgIHNldE5vZGVzSW5EYjogZnVuY3Rpb24gKG5vZGVzKSB7XG4gICAgICB2YXIgcGVuZGluZyA9IFByb21pc2UuZGVmZXIoKTtcbiAgICAgIHZhciB0cmFuc2FjdGlvbiA9IHRoaXMuZGIudHJhbnNhY3Rpb24oWydub2RlcyddLCAncmVhZHdyaXRlJyk7XG4gICAgICB2YXIgbm9kZXNTdG9yZSA9IHRyYW5zYWN0aW9uLm9iamVjdFN0b3JlKCdub2RlcycpO1xuICAgICAgdmFyIHN0YXJ0VGltZSA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuXG4gICAgICB0aGlzLnB1dHNSdW5uaW5nKys7XG5cbiAgICAgIGxvZygnW0luZGV4ZWREQl0gU3RhcnRpbmcgcHV0Jywgbm9kZXMsIHRoaXMucHV0c1J1bm5pbmcpO1xuXG4gICAgICBmb3IgKHZhciBwYXRoIGluIG5vZGVzKSB7XG4gICAgICAgIHZhciBub2RlID0gbm9kZXNbcGF0aF07XG4gICAgICAgIGlmKHR5cGVvZihub2RlKSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgbm9kZXNTdG9yZS5wdXQobm9kZSk7XG4gICAgICAgICAgfSBjYXRjaChlKSB7XG4gICAgICAgICAgICBsb2coJ1tJbmRleGVkREJdIEVycm9yIHdoaWxlIHB1dHRpbmcnLCBub2RlLCBlKTtcbiAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBub2Rlc1N0b3JlLmRlbGV0ZShwYXRoKTtcbiAgICAgICAgICB9IGNhdGNoKGUpIHtcbiAgICAgICAgICAgIGxvZygnW0luZGV4ZWREQl0gRXJyb3Igd2hpbGUgcmVtb3ZpbmcnLCBub2Rlc1N0b3JlLCBub2RlLCBlKTtcbiAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHRyYW5zYWN0aW9uLm9uY29tcGxldGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMucHV0c1J1bm5pbmctLTtcbiAgICAgICAgbG9nKCdbSW5kZXhlZERCXSBGaW5pc2hlZCBwdXQnLCBub2RlcywgdGhpcy5wdXRzUnVubmluZywgKG5ldyBEYXRlKCkuZ2V0VGltZSgpIC0gc3RhcnRUaW1lKSsnbXMnKTtcbiAgICAgICAgcGVuZGluZy5yZXNvbHZlKCk7XG4gICAgICB9LmJpbmQodGhpcyk7XG5cbiAgICAgIHRyYW5zYWN0aW9uLm9uZXJyb3IgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMucHV0c1J1bm5pbmctLTtcbiAgICAgICAgcGVuZGluZy5yZWplY3QoJ3RyYW5zYWN0aW9uIGVycm9yJyk7XG4gICAgICB9LmJpbmQodGhpcyk7XG5cbiAgICAgIHRyYW5zYWN0aW9uLm9uYWJvcnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHBlbmRpbmcucmVqZWN0KCd0cmFuc2FjdGlvbiBhYm9ydCcpO1xuICAgICAgICB0aGlzLnB1dHNSdW5uaW5nLS07XG4gICAgICB9LmJpbmQodGhpcyk7XG5cbiAgICAgIHJldHVybiBwZW5kaW5nLnByb21pc2U7XG4gICAgfSxcblxuICAgIHJlc2V0OiBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICAgIHZhciBkYk5hbWUgPSB0aGlzLmRiLm5hbWU7XG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAgIHRoaXMuZGIuY2xvc2UoKTtcblxuICAgICAgSW5kZXhlZERCLmNsZWFuKHRoaXMuZGIubmFtZSwgZnVuY3Rpb24oKSB7XG4gICAgICAgIEluZGV4ZWREQi5vcGVuKGRiTmFtZSwgZnVuY3Rpb24gKGVyciwgb3RoZXIpIHtcbiAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICBsb2coJ1tJbmRleGVkREJdIEVycm9yIHdoaWxlIHJlc2V0dGluZyBsb2NhbCBzdG9yYWdlJywgZXJyKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gaGFja3khXG4gICAgICAgICAgICBzZWxmLmRiID0gb3RoZXI7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgPT09ICdmdW5jdGlvbicpIHsgY2FsbGJhY2soc2VsZik7IH1cbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9LFxuXG4gICAgZm9yQWxsTm9kZXM6IGZ1bmN0aW9uIChjYikge1xuICAgICAgdmFyIHBlbmRpbmcgPSBQcm9taXNlLmRlZmVyKCk7XG4gICAgICB2YXIgdHJhbnNhY3Rpb24gPSB0aGlzLmRiLnRyYW5zYWN0aW9uKFsnbm9kZXMnXSwgJ3JlYWRvbmx5Jyk7XG4gICAgICB2YXIgY3Vyc29yUmVxID0gdHJhbnNhY3Rpb24ub2JqZWN0U3RvcmUoJ25vZGVzJykub3BlbkN1cnNvcigpO1xuXG4gICAgICBjdXJzb3JSZXEub25zdWNjZXNzID0gZnVuY3Rpb24gKGV2dCkge1xuICAgICAgICB2YXIgY3Vyc29yID0gZXZ0LnRhcmdldC5yZXN1bHQ7XG5cbiAgICAgICAgaWYgKGN1cnNvcikge1xuICAgICAgICAgIGNiKHRoaXMubWlncmF0ZShjdXJzb3IudmFsdWUpKTtcbiAgICAgICAgICBjdXJzb3IuY29udGludWUoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwZW5kaW5nLnJlc29sdmUoKTtcbiAgICAgICAgfVxuICAgICAgfS5iaW5kKHRoaXMpO1xuXG4gICAgICByZXR1cm4gcGVuZGluZy5wcm9taXNlO1xuICAgIH0sXG5cbiAgICBjbG9zZURCOiBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLmRiLmNsb3NlKCk7XG4gICAgfVxuXG4gIH07XG5cbiAgSW5kZXhlZERCLm9wZW4gPSBmdW5jdGlvbiAobmFtZSwgY2FsbGJhY2spIHtcbiAgICB2YXIgdGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgIGNhbGxiYWNrKFwidGltZW91dCB0cnlpbmcgdG8gb3BlbiBkYlwiKTtcbiAgICB9LCAxMDAwMCk7XG5cbiAgICB0cnkge1xuICAgICAgdmFyIHJlcSA9IGluZGV4ZWREQi5vcGVuKG5hbWUsIERCX1ZFUlNJT04pO1xuXG4gICAgICByZXEub25lcnJvciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgbG9nKCdbSW5kZXhlZERCXSBPcGVuaW5nIERCIGZhaWxlZCcsIHJlcSk7XG5cbiAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVyKTtcbiAgICAgICAgY2FsbGJhY2socmVxLmVycm9yKTtcbiAgICAgIH07XG5cbiAgICAgIHJlcS5vbnVwZ3JhZGVuZWVkZWQgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgdmFyIGRiID0gcmVxLnJlc3VsdDtcblxuICAgICAgICBsb2coXCJbSW5kZXhlZERCXSBVcGdyYWRlOiBmcm9tIFwiLCBldmVudC5vbGRWZXJzaW9uLCBcIiB0byBcIiwgZXZlbnQubmV3VmVyc2lvbik7XG5cbiAgICAgICAgaWYgKGV2ZW50Lm9sZFZlcnNpb24gIT09IDEpIHtcbiAgICAgICAgICBsb2coXCJbSW5kZXhlZERCXSBDcmVhdGluZyBvYmplY3Qgc3RvcmU6IG5vZGVzXCIpO1xuICAgICAgICAgIGRiLmNyZWF0ZU9iamVjdFN0b3JlKCdub2RlcycsIHsga2V5UGF0aDogJ3BhdGgnIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgbG9nKFwiW0luZGV4ZWREQl0gQ3JlYXRpbmcgb2JqZWN0IHN0b3JlOiBjaGFuZ2VzXCIpO1xuXG4gICAgICAgIGRiLmNyZWF0ZU9iamVjdFN0b3JlKCdjaGFuZ2VzJywgeyBrZXlQYXRoOiAncGF0aCcgfSk7XG4gICAgICB9O1xuXG4gICAgICByZXEub25zdWNjZXNzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBjbGVhclRpbWVvdXQodGltZXIpO1xuXG4gICAgICAgIC8vIGNoZWNrIGlmIGFsbCBvYmplY3Qgc3RvcmVzIGV4aXN0XG4gICAgICAgIHZhciBkYiA9IHJlcS5yZXN1bHQ7XG4gICAgICAgIGlmKCFkYi5vYmplY3RTdG9yZU5hbWVzLmNvbnRhaW5zKCdub2RlcycpIHx8ICFkYi5vYmplY3RTdG9yZU5hbWVzLmNvbnRhaW5zKCdjaGFuZ2VzJykpIHtcbiAgICAgICAgICBsb2coXCJbSW5kZXhlZERCXSBNaXNzaW5nIG9iamVjdCBzdG9yZS4gUmVzZXR0aW5nIHRoZSBkYXRhYmFzZS5cIik7XG4gICAgICAgICAgSW5kZXhlZERCLmNsZWFuKG5hbWUsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgSW5kZXhlZERCLm9wZW4obmFtZSwgY2FsbGJhY2spO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNhbGxiYWNrKG51bGwsIHJlcS5yZXN1bHQpO1xuICAgICAgfTtcbiAgICB9IGNhdGNoKGVycm9yKSB7XG4gICAgICBsb2coXCJbSW5kZXhlZERCXSBGYWlsZWQgdG8gb3BlbiBkYXRhYmFzZTogXCIgKyBlcnJvcik7XG4gICAgICBsb2coXCJbSW5kZXhlZERCXSBSZXNldHRpbmcgZGF0YWJhc2UgYW5kIHRyeWluZyBhZ2Fpbi5cIik7XG5cbiAgICAgIGNsZWFyVGltZW91dCh0aW1lcik7XG5cbiAgICAgIEluZGV4ZWREQi5jbGVhbihuYW1lLCBmdW5jdGlvbigpIHtcbiAgICAgICAgSW5kZXhlZERCLm9wZW4obmFtZSwgY2FsbGJhY2spO1xuICAgICAgfSk7XG4gICAgfTtcbiAgfTtcblxuICBJbmRleGVkREIuY2xlYW4gPSBmdW5jdGlvbiAoZGF0YWJhc2VOYW1lLCBjYWxsYmFjaykge1xuICAgIHZhciByZXEgPSBpbmRleGVkREIuZGVsZXRlRGF0YWJhc2UoZGF0YWJhc2VOYW1lKTtcblxuICAgIHJlcS5vbnN1Y2Nlc3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBsb2coJ1tJbmRleGVkREJdIERvbmUgcmVtb3ZpbmcgREInKTtcbiAgICAgIGNhbGxiYWNrKCk7XG4gICAgfTtcblxuICAgIHJlcS5vbmVycm9yID0gcmVxLm9uYWJvcnQgPSBmdW5jdGlvbiAoZXZ0KSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdGYWlsZWQgdG8gcmVtb3ZlIGRhdGFiYXNlIFwiJyArIGRhdGFiYXNlTmFtZSArICdcIicsIGV2dCk7XG4gICAgfTtcbiAgfTtcblxuICBJbmRleGVkREIuX3JzX2luaXQgPSBmdW5jdGlvbiAocmVtb3RlU3RvcmFnZSkge1xuICAgIHZhciBwZW5kaW5nID0gUHJvbWlzZS5kZWZlcigpO1xuXG4gICAgSW5kZXhlZERCLm9wZW4oREVGQVVMVF9EQl9OQU1FLCBmdW5jdGlvbiAoZXJyLCBkYikge1xuICAgICAgaWYgKGVycikge1xuICAgICAgICBwZW5kaW5nLnJlamVjdChlcnIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgREVGQVVMVF9EQiA9IGRiO1xuICAgICAgICBkYi5vbmVycm9yID0gZnVuY3Rpb24gKCkgeyByZW1vdGVTdG9yYWdlLl9lbWl0KCdlcnJvcicsIGVycik7IH07XG4gICAgICAgIHBlbmRpbmcucmVzb2x2ZSgpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIHBlbmRpbmcucHJvbWlzZTtcbiAgfTtcblxuICBJbmRleGVkREIuX3JzX3N1cHBvcnRlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcGVuZGluZyA9IFByb21pc2UuZGVmZXIoKTtcbiAgICB2YXIgY29udGV4dCA9IHV0aWwuZ2V0R2xvYmFsQ29udGV4dCgpO1xuXG4gICAgLy8gY29udGV4dC5pbmRleGVkREIgPSBjb250ZXh0LmluZGV4ZWREQiAgICB8fCBjb250ZXh0LndlYmtpdEluZGV4ZWREQiB8fFxuICAgIC8vICAgICAgICAgICAgICAgICAgICBjb250ZXh0Lm1vekluZGV4ZWREQiB8fCBjb250ZXh0Lm9JbmRleGVkREIgICAgICB8fFxuICAgIC8vICAgICAgICAgICAgICAgICAgICBjb250ZXh0Lm1zSW5kZXhlZERCO1xuXG4gICAgLy8gRGV0ZWN0IGJyb3dzZXJzIHdpdGgga25vd24gSW5kZXhlZERiIGlzc3VlcyAoZS5nLiBBbmRyb2lkIHByZS00LjQpXG4gICAgdmFyIHBvb3JJbmRleGVkRGJTdXBwb3J0ID0gZmFsc2U7XG4gICAgaWYgKHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICAgIG5hdmlnYXRvci51c2VyQWdlbnQubWF0Y2goL0FuZHJvaWQgKDJ8M3w0XFwuWzAtM10pLykpIHtcbiAgICAgIC8vIENocm9tZSBhbmQgRmlyZWZveCBzdXBwb3J0IEluZGV4ZWREQlxuICAgICAgaWYgKCFuYXZpZ2F0b3IudXNlckFnZW50Lm1hdGNoKC9DaHJvbWV8RmlyZWZveC8pKSB7XG4gICAgICAgIHBvb3JJbmRleGVkRGJTdXBwb3J0ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoJ2luZGV4ZWREQicgaW4gY29udGV4dCAmJiAhcG9vckluZGV4ZWREYlN1cHBvcnQpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHZhciBjaGVjayA9IGluZGV4ZWREQi5vcGVuKFwicnMtY2hlY2tcIik7XG4gICAgICAgIGNoZWNrLm9uZXJyb3IgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICBwZW5kaW5nLnJlamVjdCgpO1xuICAgICAgICB9O1xuICAgICAgICBjaGVjay5vbnN1Y2Nlc3MgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICBjaGVjay5yZXN1bHQuY2xvc2UoKTtcbiAgICAgICAgICBpbmRleGVkREIuZGVsZXRlRGF0YWJhc2UoXCJycy1jaGVja1wiKTtcbiAgICAgICAgICBwZW5kaW5nLnJlc29sdmUoKTtcbiAgICAgICAgfTtcbiAgICAgIH0gY2F0Y2goZSkge1xuICAgICAgICBwZW5kaW5nLnJlamVjdCgpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBwZW5kaW5nLnJlamVjdCgpO1xuICAgIH1cblxuICAgIHJldHVybiBwZW5kaW5nLnByb21pc2U7XG4gIH07XG5cbiAgSW5kZXhlZERCLl9yc19jbGVhbnVwID0gZnVuY3Rpb24gKHJlbW90ZVN0b3JhZ2UpIHtcbiAgICB2YXIgcGVuZGluZyA9IFByb21pc2UuZGVmZXIoKTtcblxuICAgIGlmIChyZW1vdGVTdG9yYWdlLmxvY2FsKSB7XG4gICAgICByZW1vdGVTdG9yYWdlLmxvY2FsLmNsb3NlREIoKTtcbiAgICB9XG5cbiAgICBJbmRleGVkREIuY2xlYW4oREVGQVVMVF9EQl9OQU1FLCBmdW5jdGlvbiAoKSB7XG4gICAgICBwZW5kaW5nLnJlc29sdmUoKTtcbiAgICB9KTtcblxuICAgIHJldHVybiBwZW5kaW5nLnByb21pc2U7XG4gIH07XG5cblxuICBtb2R1bGUuZXhwb3J0cyA9IEluZGV4ZWREQjtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvaW5kZXhlZGRiLmpzIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ },
/* 29 */
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar util = __webpack_require__(2);\nvar config = __webpack_require__(5);\n\n/**\n * Interface: cachinglayer\n *\n * This module defines functions that are mixed into remoteStorage.local when\n * it is instantiated (currently one of indexeddb.js, localstorage.js, or\n * inmemorystorage.js).\n *\n * All remoteStorage.local implementations should therefore implement\n * this.getNodes, this.setNodes, and this.forAllNodes. The rest is blended in\n * here to create a GPD (get/put/delete) interface which the BaseClient can\n * talk to.\n */\n\nvar isFolder = util.isFolder;\nvar isDocument = util.isDocument;\nvar deepClone = util.deepClone;\nvar equal = util.equal;\n\nfunction getLatest(node) {\n  if ((typeof node === 'undefined' ? 'undefined' : _typeof(node)) !== 'object' || typeof node.path !== 'string') {\n    return;\n  }\n  if (isFolder(node.path)) {\n    if (node.local && node.local.itemsMap) {\n      return node.local;\n    }\n    if (node.common && node.common.itemsMap) {\n      return node.common;\n    }\n  } else {\n    if (node.local && node.local.body && node.local.contentType) {\n      return node.local;\n    }\n    if (node.common && node.common.body && node.common.contentType) {\n      return node.common;\n    }\n    // Migration code! Once all apps use at least this version of the lib, we\n    // can publish clean-up code that migrates over any old-format data, and\n    // stop supporting it. For now, new apps will support data in both\n    // formats, thanks to this:\n    if (node.body && node.contentType) {\n      return {\n        body: node.body,\n        contentType: node.contentType\n      };\n    }\n  }\n}\n\nfunction isOutdated(nodes, maxAge) {\n  var path;\n  for (path in nodes) {\n    if (nodes[path] && nodes[path].remote) {\n      return true;\n    }\n    var nodeVersion = getLatest(nodes[path]);\n    if (nodeVersion && nodeVersion.timestamp && new Date().getTime() - nodeVersion.timestamp <= maxAge) {\n      return false;\n    } else if (!nodeVersion) {\n      return true;\n    }\n  }\n  return true;\n}\n\nvar pathsFromRoot = util.pathsFromRoot;\n\nfunction makeNode(path) {\n  var node = { path: path, common: {} };\n\n  if (isFolder(path)) {\n    node.common.itemsMap = {};\n  }\n  return node;\n}\n\nfunction updateFolderNodeWithItemName(node, itemName) {\n  if (!node.common) {\n    node.common = {\n      itemsMap: {}\n    };\n  }\n  if (!node.common.itemsMap) {\n    node.common.itemsMap = {};\n  }\n  if (!node.local) {\n    node.local = deepClone(node.common);\n  }\n  if (!node.local.itemsMap) {\n    node.local.itemsMap = node.common.itemsMap;\n  }\n  node.local.itemsMap[itemName] = true;\n\n  return node;\n}\n\nvar methods = {\n\n  // TODO: improve our code structure so that this function\n  // could call sync.queueGetRequest directly instead of needing\n  // this hacky third parameter as a callback\n  get: function get(path, maxAge, queueGetRequest) {\n    var self = this;\n    if (typeof maxAge === 'number') {\n      return self.getNodes(pathsFromRoot(path)).then(function (objs) {\n        var node = getLatest(objs[path]);\n        if (isOutdated(objs, maxAge)) {\n          return queueGetRequest(path);\n        } else if (node) {\n          return { statusCode: 200, body: node.body || node.itemsMap, contentType: node.contentType };\n        } else {\n          return { statusCode: 404 };\n        }\n      });\n    } else {\n      return self.getNodes([path]).then(function (objs) {\n        var node = getLatest(objs[path]);\n        if (node) {\n          if (isFolder(path)) {\n            for (var i in node.itemsMap) {\n              // the hasOwnProperty check here is only because our jshint settings require it:\n              if (node.itemsMap.hasOwnProperty(i) && node.itemsMap[i] === false) {\n                delete node.itemsMap[i];\n              }\n            }\n          }\n          return { statusCode: 200, body: node.body || node.itemsMap, contentType: node.contentType };\n        } else {\n          return { statusCode: 404 };\n        }\n      });\n    }\n  },\n\n  put: function put(path, body, contentType) {\n    var paths = pathsFromRoot(path);\n\n    function _processNodes(paths, nodes) {\n      try {\n        for (var i = 0, len = paths.length; i < len; i++) {\n          var path = paths[i];\n          var node = nodes[path];\n          var previous;\n\n          if (!node) {\n            nodes[path] = node = makeNode(path);\n          }\n\n          // Document\n          if (i === 0) {\n            previous = getLatest(node);\n            node.local = {\n              body: body,\n              contentType: contentType,\n              previousBody: previous ? previous.body : undefined,\n              previousContentType: previous ? previous.contentType : undefined\n            };\n          }\n          // Folder\n          else {\n              var itemName = paths[i - 1].substring(path.length);\n              node = updateFolderNodeWithItemName(node, itemName);\n            }\n        }\n        return nodes;\n      } catch (e) {\n        log('[Cachinglayer] Error during PUT', nodes, i, e);\n        throw e;\n      }\n    }\n    return this._updateNodes(paths, _processNodes);\n  },\n\n  delete: function _delete(path) {\n    var paths = pathsFromRoot(path);\n\n    return this._updateNodes(paths, function (paths, nodes) {\n      for (var i = 0, len = paths.length; i < len; i++) {\n        var path = paths[i];\n        var node = nodes[path];\n        if (!node) {\n          throw new Error('Cannot delete non-existing node ' + path);\n        }\n\n        if (i === 0) {\n          // Document\n          previous = getLatest(node);\n          node.local = {\n            body: false,\n            previousBody: previous ? previous.body : undefined,\n            previousContentType: previous ? previous.contentType : undefined\n          };\n        } else {\n          // Folder\n          if (!node.local) {\n            node.local = deepClone(node.common);\n          }\n          var itemName = paths[i - 1].substring(path.length);\n          delete node.local.itemsMap[itemName];\n\n          if (Object.getOwnPropertyNames(node.local.itemsMap).length > 0) {\n            // This folder still contains other items, don't remove any further ancestors\n            break;\n          }\n        }\n      }\n      return nodes;\n    });\n  },\n  flush: function flush(path) {\n    var self = this;\n    return self._getAllDescendentPaths(path).then(function (paths) {\n      return self.getNodes(paths);\n    }).then(function (nodes) {\n      for (var path in nodes) {\n        var node = nodes[path];\n\n        if (node && node.common && node.local) {\n          self._emitChange({\n            path: node.path,\n            origin: 'local',\n            oldValue: node.local.body === false ? undefined : node.local.body,\n            newValue: node.common.body === false ? undefined : node.common.body\n          });\n        }\n        nodes[path] = undefined;\n      }\n      return self.setNodes(nodes);\n    });\n  },\n\n  _emitChange: function _emitChange(obj) {\n    if (config.changeEvents[obj.origin]) {\n      this._emit('change', obj);\n    }\n  },\n\n  fireInitial: function fireInitial() {\n    if (!config.changeEvents.local) {\n      return;\n    }\n    var self = this;\n    self.forAllNodes(function (node) {\n      var latest;\n      if (isDocument(node.path)) {\n        latest = getLatest(node);\n        if (latest) {\n          self._emitChange({\n            path: node.path,\n            origin: 'local',\n            oldValue: undefined,\n            oldContentType: undefined,\n            newValue: latest.body,\n            newContentType: latest.contentType\n          });\n        }\n      }\n    }).then(function () {\n      self._emit('local-events-done');\n    });\n  },\n\n  onDiff: function onDiff(diffHandler) {\n    this.diffHandler = diffHandler;\n  },\n\n  migrate: function migrate(node) {\n    if ((typeof node === 'undefined' ? 'undefined' : _typeof(node)) === 'object' && !node.common) {\n      node.common = {};\n      if (typeof node.path === 'string') {\n        if (node.path.substr(-1) === '/' && _typeof(node.body) === 'object') {\n          node.common.itemsMap = node.body;\n        }\n      } else {\n        //save legacy content of document node as local version\n        if (!node.local) {\n          node.local = {};\n        }\n        node.local.body = node.body;\n        node.local.contentType = node.contentType;\n      }\n    }\n    return node;\n  },\n\n  // FIXME\n  // this process of updating nodes needs to be heavily documented first, then\n  // refactored. Right now it's almost impossible to refactor as there's no\n  // explanation of why things are implemented certain ways or what the goal(s)\n  // of the behavior are. -slvrbckt\n  _updateNodesRunning: false,\n  _updateNodesQueued: [],\n  _updateNodes: function _updateNodes(paths, _processNodes) {\n    var pending = Promise.defer();\n    this._doUpdateNodes(paths, _processNodes, pending);\n    return pending.promise;\n  },\n  _doUpdateNodes: function _doUpdateNodes(paths, _processNodes, promise) {\n    var self = this;\n\n    if (self._updateNodesRunning) {\n      self._updateNodesQueued.push({\n        paths: paths,\n        cb: _processNodes,\n        promise: promise\n      });\n      return;\n    } else {\n      self._updateNodesRunning = true;\n    }\n\n    self.getNodes(paths).then(function (nodes) {\n      var existingNodes = deepClone(nodes);\n      var changeEvents = [];\n      var node;\n      var equal = util.equal;\n\n      nodes = _processNodes(paths, nodes);\n\n      for (var path in nodes) {\n        node = nodes[path];\n        if (equal(node, existingNodes[path])) {\n          delete nodes[path];\n        } else if (isDocument(path)) {\n          if (!equal(node.local.body, node.local.previousBody) || node.local.contentType !== node.local.previousContentType) {\n            changeEvents.push({\n              path: path,\n              origin: 'window',\n              oldValue: node.local.previousBody,\n              newValue: node.local.body === false ? undefined : node.local.body,\n              oldContentType: node.local.previousContentType,\n              newContentType: node.local.contentType\n            });\n          }\n          delete node.local.previousBody;\n          delete node.local.previousContentType;\n        }\n      }\n\n      self.setNodes(nodes).then(function () {\n        self._emitChangeEvents(changeEvents);\n        promise.resolve({ statusCode: 200 });\n      });\n    }).then(function () {\n      return Promise.resolve();\n    }, function (err) {\n      promise.reject(err);\n    }).then(function () {\n      self._updateNodesRunning = false;\n      var nextJob = self._updateNodesQueued.shift();\n      if (nextJob) {\n        self._doUpdateNodes(nextJob.paths, nextJob.cb, nextJob.promise);\n      }\n    });\n  },\n\n  _emitChangeEvents: function _emitChangeEvents(events) {\n    for (var i = 0, len = events.length; i < len; i++) {\n      this._emitChange(events[i]);\n      if (this.diffHandler) {\n        this.diffHandler(events[i].path);\n      }\n    }\n  },\n\n  _getAllDescendentPaths: function _getAllDescendentPaths(path) {\n    var self = this;\n    if (isFolder(path)) {\n      return self.getNodes([path]).then(function (nodes) {\n        var allPaths = [path];\n        var latest = getLatest(nodes[path]);\n\n        var itemNames = Object.keys(latest.itemsMap);\n        var calls = itemNames.map(function (itemName) {\n          return self._getAllDescendentPaths(path + itemName).then(function (paths) {\n            for (var i = 0, len = paths.length; i < len; i++) {\n              allPaths.push(paths[i]);\n            }\n          });\n        });\n        return Promise.all(calls).then(function () {\n          return allPaths;\n        });\n      });\n    } else {\n      return Promise.resolve([path]);\n    }\n  },\n\n  _getInternals: function _getInternals() {\n    return {\n      getLatest: getLatest,\n      makeNode: makeNode,\n      isOutdated: isOutdated\n    };\n  }\n};\n\n/**\n * Function: cachingLayer\n *\n * Mixes common caching layer functionality into an object.\n *\n * The first parameter is always the object to be extended.\n *\n * Example:\n *   (start code)\n *   var MyConstructor = function () {\n *     cachingLayer(this);\n *   };\n *   (end code)\n */\nvar cachingLayer = function cachingLayer(object) {\n  for (var key in methods) {\n    object[key] = methods[key];\n  }\n};\n\nmodule.exports = cachingLayer;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvY2FjaGluZ2xheWVyLmpzPzc5MjgiXSwibmFtZXMiOlsidXRpbCIsInJlcXVpcmUiLCJjb25maWciLCJpc0ZvbGRlciIsImlzRG9jdW1lbnQiLCJkZWVwQ2xvbmUiLCJlcXVhbCIsImdldExhdGVzdCIsIm5vZGUiLCJwYXRoIiwibG9jYWwiLCJpdGVtc01hcCIsImNvbW1vbiIsImJvZHkiLCJjb250ZW50VHlwZSIsImlzT3V0ZGF0ZWQiLCJub2RlcyIsIm1heEFnZSIsInJlbW90ZSIsIm5vZGVWZXJzaW9uIiwidGltZXN0YW1wIiwiRGF0ZSIsImdldFRpbWUiLCJwYXRoc0Zyb21Sb290IiwibWFrZU5vZGUiLCJ1cGRhdGVGb2xkZXJOb2RlV2l0aEl0ZW1OYW1lIiwiaXRlbU5hbWUiLCJtZXRob2RzIiwiZ2V0IiwicXVldWVHZXRSZXF1ZXN0Iiwic2VsZiIsImdldE5vZGVzIiwidGhlbiIsIm9ianMiLCJzdGF0dXNDb2RlIiwiaSIsImhhc093blByb3BlcnR5IiwicHV0IiwicGF0aHMiLCJfcHJvY2Vzc05vZGVzIiwibGVuIiwibGVuZ3RoIiwicHJldmlvdXMiLCJwcmV2aW91c0JvZHkiLCJ1bmRlZmluZWQiLCJwcmV2aW91c0NvbnRlbnRUeXBlIiwic3Vic3RyaW5nIiwiZSIsImxvZyIsIl91cGRhdGVOb2RlcyIsImRlbGV0ZSIsIkVycm9yIiwiT2JqZWN0IiwiZ2V0T3duUHJvcGVydHlOYW1lcyIsImZsdXNoIiwiX2dldEFsbERlc2NlbmRlbnRQYXRocyIsIl9lbWl0Q2hhbmdlIiwib3JpZ2luIiwib2xkVmFsdWUiLCJuZXdWYWx1ZSIsInNldE5vZGVzIiwib2JqIiwiY2hhbmdlRXZlbnRzIiwiX2VtaXQiLCJmaXJlSW5pdGlhbCIsImZvckFsbE5vZGVzIiwibGF0ZXN0Iiwib2xkQ29udGVudFR5cGUiLCJuZXdDb250ZW50VHlwZSIsIm9uRGlmZiIsImRpZmZIYW5kbGVyIiwibWlncmF0ZSIsInN1YnN0ciIsIl91cGRhdGVOb2Rlc1J1bm5pbmciLCJfdXBkYXRlTm9kZXNRdWV1ZWQiLCJwZW5kaW5nIiwiUHJvbWlzZSIsImRlZmVyIiwiX2RvVXBkYXRlTm9kZXMiLCJwcm9taXNlIiwicHVzaCIsImNiIiwiZXhpc3RpbmdOb2RlcyIsIl9lbWl0Q2hhbmdlRXZlbnRzIiwicmVzb2x2ZSIsImVyciIsInJlamVjdCIsIm5leHRKb2IiLCJzaGlmdCIsImV2ZW50cyIsImFsbFBhdGhzIiwiaXRlbU5hbWVzIiwia2V5cyIsImNhbGxzIiwibWFwIiwiYWxsIiwiX2dldEludGVybmFscyIsImNhY2hpbmdMYXllciIsIm9iamVjdCIsImtleSIsIm1vZHVsZSIsImV4cG9ydHMiXSwibWFwcGluZ3MiOiI7Ozs7QUFBRSxJQUFJQSxPQUFPLG1CQUFBQyxDQUFRLENBQVIsQ0FBWDtBQUNBLElBQUlDLFNBQVMsbUJBQUFELENBQVEsQ0FBUixDQUFiOztBQUVBOzs7Ozs7Ozs7Ozs7O0FBYUEsSUFBSUUsV0FBV0gsS0FBS0csUUFBcEI7QUFDQSxJQUFJQyxhQUFhSixLQUFLSSxVQUF0QjtBQUNBLElBQUlDLFlBQVlMLEtBQUtLLFNBQXJCO0FBQ0EsSUFBSUMsUUFBUU4sS0FBS00sS0FBakI7O0FBRUEsU0FBU0MsU0FBVCxDQUFtQkMsSUFBbkIsRUFBeUI7QUFDdkIsTUFBSSxRQUFPQSxJQUFQLHlDQUFPQSxJQUFQLE9BQWlCLFFBQWpCLElBQTZCLE9BQU9BLEtBQUtDLElBQVosS0FBc0IsUUFBdkQsRUFBaUU7QUFDL0Q7QUFDRDtBQUNELE1BQUlOLFNBQVNLLEtBQUtDLElBQWQsQ0FBSixFQUF5QjtBQUN2QixRQUFJRCxLQUFLRSxLQUFMLElBQWNGLEtBQUtFLEtBQUwsQ0FBV0MsUUFBN0IsRUFBdUM7QUFDckMsYUFBT0gsS0FBS0UsS0FBWjtBQUNEO0FBQ0QsUUFBSUYsS0FBS0ksTUFBTCxJQUFlSixLQUFLSSxNQUFMLENBQVlELFFBQS9CLEVBQXlDO0FBQ3ZDLGFBQU9ILEtBQUtJLE1BQVo7QUFDRDtBQUNGLEdBUEQsTUFPTztBQUNMLFFBQUlK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QVAsSUFBY3hFLFFBQVF3RSxHQUFSLENBQWQ7QUFDRDtBQUNGLENBSkQ7O0FBTUFDLE9BQU9DLE9BQVAsR0FBaUJKLFlBQWpCIiwiZmlsZSI6IjI5LmpzIiwic291cmNlc0NvbnRlbnQiOlsiICB2YXIgdXRpbCA9IHJlcXVpcmUoJy4vdXRpbCcpO1xuICB2YXIgY29uZmlnID0gcmVxdWlyZSgnLi9jb25maWcnKTtcblxuICAvKipcbiAgICogSW50ZXJmYWNlOiBjYWNoaW5nbGF5ZXJcbiAgICpcbiAgICogVGhpcyBtb2R1bGUgZGVmaW5lcyBmdW5jdGlvbnMgdGhhdCBhcmUgbWl4ZWQgaW50byByZW1vdGVTdG9yYWdlLmxvY2FsIHdoZW5cbiAgICogaXQgaXMgaW5zdGFudGlhdGVkIChjdXJyZW50bHkgb25lIG9mIGluZGV4ZWRkYi5qcywgbG9jYWxzdG9yYWdlLmpzLCBvclxuICAgKiBpbm1lbW9yeXN0b3JhZ2UuanMpLlxuICAgKlxuICAgKiBBbGwgcmVtb3RlU3RvcmFnZS5sb2NhbCBpbXBsZW1lbnRhdGlvbnMgc2hvdWxkIHRoZXJlZm9yZSBpbXBsZW1lbnRcbiAgICogdGhpcy5nZXROb2RlcywgdGhpcy5zZXROb2RlcywgYW5kIHRoaXMuZm9yQWxsTm9kZXMuIFRoZSByZXN0IGlzIGJsZW5kZWQgaW5cbiAgICogaGVyZSB0byBjcmVhdGUgYSBHUEQgKGdldC9wdXQvZGVsZXRlKSBpbnRlcmZhY2Ugd2hpY2ggdGhlIEJhc2VDbGllbnQgY2FuXG4gICAqIHRhbGsgdG8uXG4gICAqL1xuXG4gIHZhciBpc0ZvbGRlciA9IHV0aWwuaXNGb2xkZXI7XG4gIHZhciBpc0RvY3VtZW50ID0gdXRpbC5pc0RvY3VtZW50O1xuICB2YXIgZGVlcENsb25lID0gdXRpbC5kZWVwQ2xvbmU7XG4gIHZhciBlcXVhbCA9IHV0aWwuZXF1YWw7XG5cbiAgZnVuY3Rpb24gZ2V0TGF0ZXN0KG5vZGUpIHtcbiAgICBpZiAodHlwZW9mKG5vZGUpICE9PSAnb2JqZWN0JyB8fCB0eXBlb2Yobm9kZS5wYXRoKSAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGlzRm9sZGVyKG5vZGUucGF0aCkpIHtcbiAgICAgIGlmIChub2RlLmxvY2FsICYmIG5vZGUubG9jYWwuaXRlbXNNYXApIHtcbiAgICAgICAgcmV0dXJuIG5vZGUubG9jYWw7XG4gICAgICB9XG4gICAgICBpZiAobm9kZS5jb21tb24gJiYgbm9kZS5jb21tb24uaXRlbXNNYXApIHtcbiAgICAgICAgcmV0dXJuIG5vZGUuY29tbW9uO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAobm9kZS5sb2NhbCAmJiBub2RlLmxvY2FsLmJvZHkgJiYgbm9kZS5sb2NhbC5jb250ZW50VHlwZSkge1xuICAgICAgICByZXR1cm4gbm9kZS5sb2NhbDtcbiAgICAgIH1cbiAgICAgIGlmIChub2RlLmNvbW1vbiAmJiBub2RlLmNvbW1vbi5ib2R5ICYmIG5vZGUuY29tbW9uLmNvbnRlbnRUeXBlKSB7XG4gICAgICAgIHJldHVybiBub2RlLmNvbW1vbjtcbiAgICAgIH1cbiAgICAgIC8vIE1pZ3JhdGlvbiBjb2RlISBPbmNlIGFsbCBhcHBzIHVzZSBhdCBsZWFzdCB0aGlzIHZlcnNpb24gb2YgdGhlIGxpYiwgd2VcbiAgICAgIC8vIGNhbiBwdWJsaXNoIGNsZWFuLXVwIGNvZGUgdGhhdCBtaWdyYXRlcyBvdmVyIGFueSBvbGQtZm9ybWF0IGRhdGEsIGFuZFxuICAgICAgLy8gc3RvcCBzdXBwb3J0aW5nIGl0LiBGb3Igbm93LCBuZXcgYXBwcyB3aWxsIHN1cHBvcnQgZGF0YSBpbiBib3RoXG4gICAgICAvLyBmb3JtYXRzLCB0aGFua3MgdG8gdGhpczpcbiAgICAgIGlmIChub2RlLmJvZHkgJiYgbm9kZS5jb250ZW50VHlwZSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGJvZHk6IG5vZGUuYm9keSxcbiAgICAgICAgICBjb250ZW50VHlwZTogbm9kZS5jb250ZW50VHlwZVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGlzT3V0ZGF0ZWQobm9kZXMsIG1heEFnZSkge1xuICAgIHZhciBwYXRoO1xuICAgIGZvciAocGF0aCBpbiBub2Rlcykge1xuICAgICAgaWYgKG5vZGVzW3BhdGhdICYmIG5vZGVzW3BhdGhdLnJlbW90ZSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHZhciBub2RlVmVyc2lvbiA9IGdldExhdGVzdChub2Rlc1twYXRoXSk7XG4gICAgICBpZiAobm9kZVZlcnNpb24gJiYgbm9kZVZlcnNpb24udGltZXN0YW1wICYmIChuZXcgRGF0ZSgpLmdldFRpbWUoKSkgLSBub2RlVmVyc2lvbi50aW1lc3RhbXAgPD0gbWF4QWdlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH0gZWxzZSBpZiAoIW5vZGVWZXJzaW9uKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHZhciBwYXRoc0Zyb21Sb290ID0gdXRpbC5wYXRoc0Zyb21Sb290O1xuXG4gIGZ1bmN0aW9uIG1ha2VOb2RlKHBhdGgpIHtcbiAgICB2YXIgbm9kZSA9IHsgcGF0aDogcGF0aCwgY29tbW9uOiB7IH0gfTtcblxuICAgIGlmIChpc0ZvbGRlcihwYXRoKSkge1xuICAgICAgbm9kZS5jb21tb24uaXRlbXNNYXAgPSB7fTtcbiAgICB9XG4gICAgcmV0dXJuIG5vZGU7XG4gIH1cblxuICBmdW5jdGlvbiB1cGRhdGVGb2xkZXJOb2RlV2l0aEl0ZW1OYW1lKG5vZGUsIGl0ZW1OYW1lKSB7XG4gICAgaWYgKCFub2RlLmNvbW1vbikge1xuICAgICAgbm9kZS5jb21tb24gPSB7XG4gICAgICAgIGl0ZW1zTWFwOiB7fVxuICAgICAgfTtcbiAgICB9XG4gICAgaWYgKCFub2RlLmNvbW1vbi5pdGVtc01hcCkge1xuICAgICAgbm9kZS5jb21tb24uaXRlbXNNYXAgPSB7fTtcbiAgICB9XG4gICAgaWYgKCFub2RlLmxvY2FsKSB7XG4gICAgICBub2RlLmxvY2FsID0gZGVlcENsb25lKG5vZGUuY29tbW9uKTtcbiAgICB9XG4gICAgaWYgKCFub2RlLmxvY2FsLml0ZW1zTWFwKSB7XG4gICAgICBub2RlLmxvY2FsLml0ZW1zTWFwID0gbm9kZS5jb21tb24uaXRlbXNNYXA7XG4gICAgfVxuICAgIG5vZGUubG9jYWwuaXRlbXNNYXBbaXRlbU5hbWVdID0gdHJ1ZTtcblxuICAgIHJldHVybiBub2RlO1xuICB9XG5cbiAgdmFyIG1ldGhvZHMgPSB7XG5cbiAgICAvLyBUT0RPOiBpbXByb3ZlIG91ciBjb2RlIHN0cnVjdHVyZSBzbyB0aGF0IHRoaXMgZnVuY3Rpb25cbiAgICAvLyBjb3VsZCBjYWxsIHN5bmMucXVldWVHZXRSZXF1ZXN0IGRpcmVjdGx5IGluc3RlYWQgb2YgbmVlZGluZ1xuICAgIC8vIHRoaXMgaGFja3kgdGhpcmQgcGFyYW1ldGVyIGFzIGEgY2FsbGJhY2tcbiAgICBnZXQ6IGZ1bmN0aW9uIChwYXRoLCBtYXhBZ2UsIHF1ZXVlR2V0UmVxdWVzdCkge1xuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgaWYgKHR5cGVvZihtYXhBZ2UpID09PSAnbnVtYmVyJykge1xuICAgICAgICByZXR1cm4gc2VsZi5nZXROb2RlcyhwYXRoc0Zyb21Sb290KHBhdGgpKVxuICAgICAgICAudGhlbihmdW5jdGlvbiAob2Jqcykge1xuICAgICAgICAgIHZhciBub2RlID0gZ2V0TGF0ZXN0KG9ianNbcGF0aF0pO1xuICAgICAgICAgIGlmIChpc091dGRhdGVkKG9ianMsIG1heEFnZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBxdWV1ZUdldFJlcXVlc3QocGF0aCk7XG4gICAgICAgICAgfSBlbHNlIGlmIChub2RlKSB7XG4gICAgICAgICAgICByZXR1cm4ge3N0YXR1c0NvZGU6IDIwMCwgYm9keTogbm9kZS5ib2R5IHx8IG5vZGUuaXRlbXNNYXAsIGNvbnRlbnRUeXBlOiBub2RlLmNvbnRlbnRUeXBlfTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHtzdGF0dXNDb2RlOiA0MDR9O1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gc2VsZi5nZXROb2RlcyhbcGF0aF0pXG4gICAgICAgIC50aGVuKGZ1bmN0aW9uIChvYmpzKSB7XG4gICAgICAgICAgdmFyIG5vZGUgPSBnZXRMYXRlc3Qob2Jqc1twYXRoXSk7XG4gICAgICAgICAgaWYgKG5vZGUpIHtcbiAgICAgICAgICAgIGlmIChpc0ZvbGRlcihwYXRoKSkge1xuICAgICAgICAgICAgICBmb3IgKHZhciBpIGluIG5vZGUuaXRlbXNNYXApIHtcbiAgICAgICAgICAgICAgICAvLyB0aGUgaGFzT3duUHJvcGVydHkgY2hlY2sgaGVyZSBpcyBvbmx5IGJlY2F1c2Ugb3VyIGpzaGludCBzZXR0aW5ncyByZXF1aXJlIGl0OlxuICAgICAgICAgICAgICAgIGlmIChub2RlLml0ZW1zTWFwLmhhc093blByb3BlcnR5KGkpICYmIG5vZGUuaXRlbXNNYXBbaV0gPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICBkZWxldGUgbm9kZS5pdGVtc01hcFtpXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7c3RhdHVzQ29kZTogMjAwLCBib2R5OiBub2RlLmJvZHkgfHwgbm9kZS5pdGVtc01hcCwgY29udGVudFR5cGU6IG5vZGUuY29udGVudFR5cGV9O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4ge3N0YXR1c0NvZGU6IDQwNH07XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgcHV0OiBmdW5jdGlvbiAocGF0aCwgYm9keSwgY29udGVudFR5cGUpIHtcbiAgICAgIHZhciBwYXRocyA9IHBhdGhzRnJvbVJvb3QocGF0aCk7XG5cbiAgICAgIGZ1bmN0aW9uIF9wcm9jZXNzTm9kZXMocGF0aHMsIG5vZGVzKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHBhdGhzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgcGF0aCA9IHBhdGhzW2ldO1xuICAgICAgICAgICAgdmFyIG5vZGUgPSBub2Rlc1twYXRoXTtcbiAgICAgICAgICAgIHZhciBwcmV2aW91cztcblxuICAgICAgICAgICAgaWYgKCFub2RlKSB7XG4gICAgICAgICAgICAgIG5vZGVzW3BhdGhdID0gbm9kZSA9IG1ha2VOb2RlKHBhdGgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBEb2N1bWVudFxuICAgICAgICAgICAgaWYgKGkgPT09IDApIHtcbiAgICAgICAgICAgICAgcHJldmlvdXMgPSBnZXRMYXRlc3Qobm9kZSk7XG4gICAgICAgICAgICAgIG5vZGUubG9jYWwgPSB7XG4gICAgICAgICAgICAgICAgYm9keTogICAgICAgICAgICAgICAgYm9keSxcbiAgICAgICAgICAgICAgICBjb250ZW50VHlwZTogICAgICAgICBjb250ZW50VHlwZSxcbiAgICAgICAgICAgICAgICBwcmV2aW91c0JvZHk6ICAgICAgICAocHJldmlvdXMgPyBwcmV2aW91cy5ib2R5IDogdW5kZWZpbmVkKSxcbiAgICAgICAgICAgICAgICBwcmV2aW91c0NvbnRlbnRUeXBlOiAocHJldmlvdXMgPyBwcmV2aW91cy5jb250ZW50VHlwZSA6IHVuZGVmaW5lZCksXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBGb2xkZXJcbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICB2YXIgaXRlbU5hbWUgPSBwYXRoc1tpLTFdLnN1YnN0cmluZyhwYXRoLmxlbmd0aCk7XG4gICAgICAgICAgICAgIG5vZGUgPSB1cGRhdGVGb2xkZXJOb2RlV2l0aEl0ZW1OYW1lKG5vZGUsIGl0ZW1OYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG5vZGVzO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgbG9nKCdbQ2FjaGluZ2xheWVyXSBFcnJvciBkdXJpbmcgUFVUJywgbm9kZXMsIGksIGUpO1xuICAgICAgICAgIHRocm93IGU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLl91cGRhdGVOb2RlcyhwYXRocywgX3Byb2Nlc3NOb2Rlcyk7XG4gICAgfSxcblxuICAgIGRlbGV0ZTogZnVuY3Rpb24gKHBhdGgpIHtcbiAgICAgIHZhciBwYXRocyA9IHBhdGhzRnJvbVJvb3QocGF0aCk7XG5cbiAgICAgIHJldHVybiB0aGlzLl91cGRhdGVOb2RlcyhwYXRocywgZnVuY3Rpb24gKHBhdGhzLCBub2Rlcykge1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gcGF0aHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICB2YXIgcGF0aCA9IHBhdGhzW2ldO1xuICAgICAgICAgIHZhciBub2RlID0gbm9kZXNbcGF0aF07XG4gICAgICAgICAgaWYgKCFub2RlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBkZWxldGUgbm9uLWV4aXN0aW5nIG5vZGUgJytwYXRoKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoaSA9PT0gMCkge1xuICAgICAgICAgIC8vIERvY3VtZW50XG4gICAgICAgICAgICBwcmV2aW91cyA9IGdldExhdGVzdChub2RlKTtcbiAgICAgICAgICAgIG5vZGUubG9jYWwgPSB7XG4gICAgICAgICAgICAgIGJvZHk6ICAgICAgICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgICAgICBwcmV2aW91c0JvZHk6ICAgICAgICAocHJldmlvdXMgPyBwcmV2aW91cy5ib2R5IDogdW5kZWZpbmVkKSxcbiAgICAgICAgICAgICAgcHJldmlvdXNDb250ZW50VHlwZTogKHByZXZpb3VzID8gcHJldmlvdXMuY29udGVudFR5cGUgOiB1bmRlZmluZWQpLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIEZvbGRlclxuICAgICAgICAgICAgaWYgKCFub2RlLmxvY2FsKSB7XG4gICAgICAgICAgICAgIG5vZGUubG9jYWwgPSBkZWVwQ2xvbmUobm9kZS5jb21tb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGl0ZW1OYW1lID0gcGF0aHNbaS0xXS5zdWJzdHJpbmcocGF0aC5sZW5ndGgpO1xuICAgICAgICAgICAgZGVsZXRlIG5vZGUubG9jYWwuaXRlbXNNYXBbaXRlbU5hbWVdO1xuXG4gICAgICAgICAgICBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMobm9kZS5sb2NhbC5pdGVtc01hcCkubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAvLyBUaGlzIGZvbGRlciBzdGlsbCBjb250YWlucyBvdGhlciBpdGVtcywgZG9uJ3QgcmVtb3ZlIGFueSBmdXJ0aGVyIGFuY2VzdG9yc1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5vZGVzO1xuICAgICAgfSk7XG4gICAgfSxcbiAgICBmbHVzaDogZnVuY3Rpb24gKHBhdGgpIHtcbiAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgIHJldHVybiBzZWxmLl9nZXRBbGxEZXNjZW5kZW50UGF0aHMocGF0aCkudGhlbihmdW5jdGlvbiAocGF0aHMpIHtcbiAgICAgICAgcmV0dXJuIHNlbGYuZ2V0Tm9kZXMocGF0aHMpO1xuICAgICAgfSkudGhlbihmdW5jdGlvbiAobm9kZXMpIHtcbiAgICAgICAgZm9yICh2YXIgcGF0aCBpbiBub2Rlcykge1xuICAgICAgICAgIHZhciBub2RlID0gbm9kZXNbcGF0aF07XG5cbiAgICAgICAgICBpZiAobm9kZSAmJiBub2RlLmNvbW1vbiAmJiBub2RlLmxvY2FsKSB7XG4gICAgICAgICAgICBzZWxmLl9lbWl0Q2hhbmdlKHtcbiAgICAgICAgICAgICAgcGF0aDogICAgIG5vZGUucGF0aCxcbiAgICAgICAgICAgICAgb3JpZ2luOiAgICdsb2NhbCcsXG4gICAgICAgICAgICAgIG9sZFZhbHVlOiAobm9kZS5sb2NhbC5ib2R5ID09PSBmYWxzZSA/IHVuZGVmaW5lZCA6IG5vZGUubG9jYWwuYm9keSksXG4gICAgICAgICAgICAgIG5ld1ZhbHVlOiAobm9kZS5jb21tb24uYm9keSA9PT0gZmFsc2UgPyB1bmRlZmluZWQgOiBub2RlLmNvbW1vbi5ib2R5KVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIG5vZGVzW3BhdGhdID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzZWxmLnNldE5vZGVzKG5vZGVzKTtcbiAgICAgIH0pO1xuICAgIH0sXG5cbiAgICBfZW1pdENoYW5nZTogZnVuY3Rpb24gKG9iaikge1xuICAgICAgaWYgKGNvbmZpZy5jaGFuZ2VFdmVudHNbb2JqLm9yaWdpbl0pIHtcbiAgICAgICAgdGhpcy5fZW1pdCgnY2hhbmdlJywgb2JqKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgZmlyZUluaXRpYWw6IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICghY29uZmlnLmNoYW5nZUV2ZW50cy5sb2NhbCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICBzZWxmLmZvckFsbE5vZGVzKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgIHZhciBsYXRlc3Q7XG4gICAgICAgIGlmIChpc0RvY3VtZW50KG5vZGUucGF0aCkpIHtcbiAgICAgICAgICBsYXRlc3QgPSBnZXRMYXRlc3Qobm9kZSk7XG4gICAgICAgICAgaWYgKGxhdGVzdCkge1xuICAgICAgICAgICAgc2VsZi5fZW1pdENoYW5nZSh7XG4gICAgICAgICAgICAgIHBhdGg6ICAgICAgICAgICBub2RlLnBhdGgsXG4gICAgICAgICAgICAgIG9yaWdpbjogICAgICAgICAnbG9jYWwnLFxuICAgICAgICAgICAgICBvbGRWYWx1ZTogICAgICAgdW5kZWZpbmVkLFxuICAgICAgICAgICAgICBvbGRDb250ZW50VHlwZTogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICBuZXdWYWx1ZTogICAgICAgbGF0ZXN0LmJvZHksXG4gICAgICAgICAgICAgIG5ld0NvbnRlbnRUeXBlOiBsYXRlc3QuY29udGVudFR5cGVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgIHNlbGYuX2VtaXQoJ2xvY2FsLWV2ZW50cy1kb25lJyk7XG4gICAgICB9KTtcbiAgICB9LFxuXG4gICAgb25EaWZmOiBmdW5jdGlvbiAoZGlmZkhhbmRsZXIpIHtcbiAgICAgIHRoaXMuZGlmZkhhbmRsZXIgPSBkaWZmSGFuZGxlcjtcbiAgICB9LFxuXG4gICAgbWlncmF0ZTogZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgIGlmICh0eXBlb2Yobm9kZSkgPT09ICdvYmplY3QnICYmICFub2RlLmNvbW1vbikge1xuICAgICAgICBub2RlLmNvbW1vbiA9IHt9O1xuICAgICAgICBpZiAodHlwZW9mKG5vZGUucGF0aCkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgaWYgKG5vZGUucGF0aC5zdWJzdHIoLTEpID09PSAnLycgJiYgdHlwZW9mKG5vZGUuYm9keSkgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICBub2RlLmNvbW1vbi5pdGVtc01hcCA9IG5vZGUuYm9keTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy9zYXZlIGxlZ2FjeSBjb250ZW50IG9mIGRvY3VtZW50IG5vZGUgYXMgbG9jYWwgdmVyc2lvblxuICAgICAgICAgIGlmICghbm9kZS5sb2NhbCkge1xuICAgICAgICAgICAgbm9kZS5sb2NhbCA9IHt9O1xuICAgICAgICAgIH1cbiAgICAgICAgICBub2RlLmxvY2FsLmJvZHkgPSBub2RlLmJvZHk7XG4gICAgICAgICAgbm9kZS5sb2NhbC5jb250ZW50VHlwZSA9IG5vZGUuY29udGVudFR5cGU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBub2RlO1xuICAgIH0sXG5cbiAgICAvLyBGSVhNRVxuICAgIC8vIHRoaXMgcHJvY2VzcyBvZiB1cGRhdGluZyBub2RlcyBuZWVkcyB0byBiZSBoZWF2aWx5IGRvY3VtZW50ZWQgZmlyc3QsIHRoZW5cbiAgICAvLyByZWZhY3RvcmVkLiBSaWdodCBub3cgaXQncyBhbG1vc3QgaW1wb3NzaWJsZSB0byByZWZhY3RvciBhcyB0aGVyZSdzIG5vXG4gICAgLy8gZXhwbGFuYXRpb24gb2Ygd2h5IHRoaW5ncyBhcmUgaW1wbGVtZW50ZWQgY2VydGFpbiB3YXlzIG9yIHdoYXQgdGhlIGdvYWwocylcbiAgICAvLyBvZiB0aGUgYmVoYXZpb3IgYXJlLiAtc2x2cmJja3RcbiAgICBfdXBkYXRlTm9kZXNSdW5uaW5nOiBmYWxzZSxcbiAgICBfdXBkYXRlTm9kZXNRdWV1ZWQ6IFtdLFxuICAgIF91cGRhdGVOb2RlczogZnVuY3Rpb24gKHBhdGhzLCBfcHJvY2Vzc05vZGVzKSB7XG4gICAgICB2YXIgcGVuZGluZyA9IFByb21pc2UuZGVmZXIoKTtcbiAgICAgIHRoaXMuX2RvVXBkYXRlTm9kZXMocGF0aHMsIF9wcm9jZXNzTm9kZXMsIHBlbmRpbmcpO1xuICAgICAgcmV0dXJuIHBlbmRpbmcucHJvbWlzZTtcbiAgICB9LFxuICAgIF9kb1VwZGF0ZU5vZGVzOiBmdW5jdGlvbiAocGF0aHMsIF9wcm9jZXNzTm9kZXMsIHByb21pc2UpIHtcbiAgICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgICAgaWYgKHNlbGYuX3VwZGF0ZU5vZGVzUnVubmluZykge1xuICAgICAgICBzZWxmLl91cGRhdGVOb2Rlc1F1ZXVlZC5wdXNoKHtcbiAgICAgICAgICBwYXRoczogcGF0aHMsXG4gICAgICAgICAgY2I6IF9wcm9jZXNzTm9kZXMsXG4gICAgICAgICAgcHJvbWlzZTogcHJvbWlzZVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2VsZi5fdXBkYXRlTm9kZXNSdW5uaW5nID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgc2VsZi5nZXROb2RlcyhwYXRocykudGhlbihmdW5jdGlvbiAobm9kZXMpIHtcbiAgICAgICAgdmFyIGV4aXN0aW5nTm9kZXMgPSBkZWVwQ2xvbmUobm9kZXMpO1xuICAgICAgICB2YXIgY2hhbmdlRXZlbnRzID0gW107XG4gICAgICAgIHZhciBub2RlO1xuICAgICAgICB2YXIgZXF1YWwgPSB1dGlsLmVxdWFsO1xuXG4gICAgICAgIG5vZGVzID0gX3Byb2Nlc3NOb2RlcyhwYXRocywgbm9kZXMpO1xuXG4gICAgICAgIGZvciAodmFyIHBhdGggaW4gbm9kZXMpIHtcbiAgICAgICAgICBub2RlID0gbm9kZXNbcGF0aF07XG4gICAgICAgICAgaWYgKGVxdWFsKG5vZGUsIGV4aXN0aW5nTm9kZXNbcGF0aF0pKSB7XG4gICAgICAgICAgICBkZWxldGUgbm9kZXNbcGF0aF07XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2UgaWYgKGlzRG9jdW1lbnQocGF0aCkpIHtcbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgIWVxdWFsKG5vZGUubG9jYWwuYm9keSwgbm9kZS5sb2NhbC5wcmV2aW91c0JvZHkpIHx8XG4gICAgICAgICAgICAgIG5vZGUubG9jYWwuY29udGVudFR5cGUgIT09IG5vZGUubG9jYWwucHJldmlvdXNDb250ZW50VHlwZVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgIGNoYW5nZUV2ZW50cy5wdXNoKHtcbiAgICAgICAgICAgICAgICBwYXRoOiAgICAgICAgICAgcGF0aCxcbiAgICAgICAgICAgICAgICBvcmlnaW46ICAgICAgICAgJ3dpbmRvdycsXG4gICAgICAgICAgICAgICAgb2xkVmFsdWU6ICAgICAgIG5vZGUubG9jYWwucHJldmlvdXNCb2R5LFxuICAgICAgICAgICAgICAgIG5ld1ZhbHVlOiAgICAgICBub2RlLmxvY2FsLmJvZHkgPT09IGZhbHNlID8gdW5kZWZpbmVkIDogbm9kZS5sb2NhbC5ib2R5LFxuICAgICAgICAgICAgICAgIG9sZENvbnRlbnRUeXBlOiBub2RlLmxvY2FsLnByZXZpb3VzQ29udGVudFR5cGUsXG4gICAgICAgICAgICAgICAgbmV3Q29udGVudFR5cGU6IG5vZGUubG9jYWwuY29udGVudFR5cGVcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkZWxldGUgbm9kZS5sb2NhbC5wcmV2aW91c0JvZHk7XG4gICAgICAgICAgICBkZWxldGUgbm9kZS5sb2NhbC5wcmV2aW91c0NvbnRlbnRUeXBlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHNlbGYuc2V0Tm9kZXMobm9kZXMpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHNlbGYuX2VtaXRDaGFuZ2VFdmVudHMoY2hhbmdlRXZlbnRzKTtcbiAgICAgICAgICBwcm9taXNlLnJlc29sdmUoe3N0YXR1c0NvZGU6IDIwMH0pO1xuICAgICAgICB9KTtcbiAgICAgIH0pLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgICB9LCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgIHByb21pc2UucmVqZWN0KGVycik7XG4gICAgICB9KS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgc2VsZi5fdXBkYXRlTm9kZXNSdW5uaW5nID0gZmFsc2U7XG4gICAgICAgIHZhciBuZXh0Sm9iID0gc2VsZi5fdXBkYXRlTm9kZXNRdWV1ZWQuc2hpZnQoKTtcbiAgICAgICAgaWYgKG5leHRKb2IpIHtcbiAgICAgICAgICBzZWxmLl9kb1VwZGF0ZU5vZGVzKG5leHRKb2IucGF0aHMsIG5leHRKb2IuY2IsIG5leHRKb2IucHJvbWlzZSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0sXG5cbiAgICBfZW1pdENoYW5nZUV2ZW50czogZnVuY3Rpb24gKGV2ZW50cykge1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGV2ZW50cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICB0aGlzLl9lbWl0Q2hhbmdlKGV2ZW50c1tpXSk7XG4gICAgICAgIGlmICh0aGlzLmRpZmZIYW5kbGVyKSB7XG4gICAgICAgICAgdGhpcy5kaWZmSGFuZGxlcihldmVudHNbaV0ucGF0aCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgX2dldEFsbERlc2NlbmRlbnRQYXRoczogZnVuY3Rpb24gKHBhdGgpIHtcbiAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgIGlmIChpc0ZvbGRlcihwYXRoKSkge1xuICAgICAgICByZXR1cm4gc2VsZi5nZXROb2RlcyhbcGF0aF0pLnRoZW4oZnVuY3Rpb24gKG5vZGVzKSB7XG4gICAgICAgICAgdmFyIGFsbFBhdGhzID0gW3BhdGhdO1xuICAgICAgICAgIHZhciBsYXRlc3QgPSBnZXRMYXRlc3Qobm9kZXNbcGF0aF0pO1xuXG4gICAgICAgICAgdmFyIGl0ZW1OYW1lcyA9IE9iamVjdC5rZXlzKGxhdGVzdC5pdGVtc01hcCk7XG4gICAgICAgICAgdmFyIGNhbGxzID0gaXRlbU5hbWVzLm1hcChmdW5jdGlvbiAoaXRlbU5hbWUpIHtcbiAgICAgICAgICAgIHJldHVybiBzZWxmLl9nZXRBbGxEZXNjZW5kZW50UGF0aHMocGF0aCtpdGVtTmFtZSkudGhlbihmdW5jdGlvbiAocGF0aHMpIHtcbiAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHBhdGhzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgYWxsUGF0aHMucHVzaChwYXRoc1tpXSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJldHVybiBQcm9taXNlLmFsbChjYWxscykudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gYWxsUGF0aHM7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShbcGF0aF0pO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBfZ2V0SW50ZXJuYWxzOiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBnZXRMYXRlc3Q6IGdldExhdGVzdCxcbiAgICAgICAgbWFrZU5vZGU6IG1ha2VOb2RlLFxuICAgICAgICBpc091dGRhdGVkOiBpc091dGRhdGVkXG4gICAgICB9O1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogRnVuY3Rpb246IGNhY2hpbmdMYXllclxuICAgKlxuICAgKiBNaXhlcyBjb21tb24gY2FjaGluZyBsYXllciBmdW5jdGlvbmFsaXR5IGludG8gYW4gb2JqZWN0LlxuICAgKlxuICAgKiBUaGUgZmlyc3QgcGFyYW1ldGVyIGlzIGFsd2F5cyB0aGUgb2JqZWN0IHRvIGJlIGV4dGVuZGVkLlxuICAgKlxuICAgKiBFeGFtcGxlOlxuICAgKiAgIChzdGFydCBjb2RlKVxuICAgKiAgIHZhciBNeUNvbnN0cnVjdG9yID0gZnVuY3Rpb24gKCkge1xuICAgKiAgICAgY2FjaGluZ0xheWVyKHRoaXMpO1xuICAgKiAgIH07XG4gICAqICAgKGVuZCBjb2RlKVxuICAgKi9cbiAgdmFyIGNhY2hpbmdMYXllciA9IGZ1bmN0aW9uIChvYmplY3QpIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gbWV0aG9kcykge1xuICAgICAgb2JqZWN0W2tleV0gPSBtZXRob2RzW2tleV07XG4gICAgfVxuICB9O1xuXG4gIG1vZHVsZS5leHBvcnRzID0gY2FjaGluZ0xheWVyO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2NhY2hpbmdsYXllci5qcyJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ },
/* 30 */
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';\n\nvar cachingLayer = __webpack_require__(29);\nvar log = __webpack_require__(4);\nvar eventHandling = __webpack_require__(3);\nvar util = __webpack_require__(2);\n\n/**\n * Class: RemoteStorage.LocalStorage\n *\n * localStorage caching adapter. Used when no IndexedDB available.\n **/\n\nvar NODES_PREFIX = \"remotestorage:cache:nodes:\";\nvar CHANGES_PREFIX = \"remotestorage:cache:changes:\";\n\nvar LocalStorage = function LocalStorage() {\n  cachingLayer(this);\n  log('[LocalStorage] Registering events');\n  eventHandling(this, 'change', 'local-events-done');\n};\n\nfunction isRemoteStorageKey(key) {\n  return key.substr(0, NODES_PREFIX.length) === NODES_PREFIX || key.substr(0, CHANGES_PREFIX.length) === CHANGES_PREFIX;\n}\n\nfunction isNodeKey(key) {\n  return key.substr(0, NODES_PREFIX.length) === NODES_PREFIX;\n}\n\nLocalStorage.prototype = {\n\n  getNodes: function getNodes(paths) {\n    var nodes = {};\n\n    for (var i = 0, len = paths.length; i < len; i++) {\n      try {\n        nodes[paths[i]] = JSON.parse(localStorage[NODES_PREFIX + paths[i]]);\n      } catch (e) {\n        nodes[paths[i]] = undefined;\n      }\n    }\n\n    return Promise.resolve(nodes);\n  },\n\n  setNodes: function setNodes(nodes) {\n    for (var path in nodes) {\n      // TODO shouldn't we use getItem/setItem?\n      localStorage[NODES_PREFIX + path] = JSON.stringify(nodes[path]);\n    }\n\n    return Promise.resolve();\n  },\n\n  forAllNodes: function forAllNodes(cb) {\n    var node;\n\n    for (var i = 0, len = localStorage.length; i < len; i++) {\n      if (isNodeKey(localStorage.key(i))) {\n        try {\n          node = this.migrate(JSON.parse(localStorage[localStorage.key(i)]));\n        } catch (e) {\n          node = undefined;\n        }\n        if (node) {\n          cb(node);\n        }\n      }\n    }\n    return Promise.resolve();\n  }\n\n};\n\nLocalStorage._rs_init = function () {};\n\nLocalStorage._rs_supported = function () {\n  return util.localStorageAvailable();\n};\n\n// TODO tests missing!\nLocalStorage._rs_cleanup = function () {\n  var keys = [];\n\n  for (var i = 0, len = localStorage.length; i < len; i++) {\n    var key = localStorage.key(i);\n    if (isRemoteStorageKey(key)) {\n      keys.push(key);\n    }\n  }\n\n  keys.forEach(function (key) {\n    log('[LocalStorage] Removing', key);\n    delete localStorage[key];\n  });\n};\n\nmodule.exports = LocalStorage;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvbG9jYWxzdG9yYWdlLmpzPzlhYjYiXSwibmFtZXMiOlsiY2FjaGluZ0xheWVyIiwicmVxdWlyZSIsImxvZyIsImV2ZW50SGFuZGxpbmciLCJ1dGlsIiwiTk9ERVNfUFJFRklYIiwiQ0hBTkdFU19QUkVGSVgiLCJMb2NhbFN0b3JhZ2UiLCJpc1JlbW90ZVN0b3JhZ2VLZXkiLCJrZXkiLCJzdWJzdHIiLCJsZW5ndGgiLCJpc05vZGVLZXkiLCJwcm90b3R5cGUiLCJnZXROb2RlcyIsInBhdGhzIiwibm9kZXMiLCJpIiwibGVuIiwiSlNPTiIsInBhcnNlIiwibG9jYWxTdG9yYWdlIiwiZSIsInVuZGVmaW5lZCIsIlByb21pc2UiLCJyZXNvbHZlIiwic2V0Tm9kZXMiLCJwYXRoIiwic3RyaW5naWZ5IiwiZm9yQWxsTm9kZXMiLCJjYiIsIm5vZGUiLCJtaWdyYXRlIiwiX3JzX2luaXQiLCJfcnNfc3VwcG9ydGVkIiwibG9jYWxTdG9yYWdlQXZhaWxhYmxlIiwiX3JzX2NsZWFudXAiLCJrZXlzIiwicHVzaCIsImZvckVhY2giLCJtb2R1bGUiLCJleHBvcnRzIl0sIm1hcHBpbmdzIjoiOztBQUFFLElBQUlBLGVBQWUsbUJBQUFDLENBQVEsRUFBUixDQUFuQjtBQUNBLElBQUlDLE1BQU0sbUJBQUFELENBQVEsQ0FBUixDQUFWO0FBQ0EsSUFBSUUsZ0JBQWdCLG1CQUFBRixDQUFRLENBQVIsQ0FBcEI7QUFDQSxJQUFJRyxPQUFPLG1CQUFBSCxDQUFRLENBQVIsQ0FBWDs7QUFFQTs7Ozs7O0FBTUEsSUFBSUksZUFBZSw0QkFBbkI7QUFDQSxJQUFJQyxpQkFBaUIsOEJBQXJCOztBQUVBLElBQUlDLGVBQWUsU0FBZkEsWUFBZSxHQUFZO0FBQzdCUCxlQUFhLElBQWI7QUFDQUUsTUFBSSxtQ0FBSjtBQUNBQyxnQkFBYyxJQUFkLEVBQW9CLFFBQXBCLEVBQThCLG1CQUE5QjtBQUNELENBSkQ7O0FBTUEsU0FBU0ssa0JBQVQsQ0FBNEJDLEdBQTVC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OztBQWdCQStCLE9BQU9DLE9BQVAsR0FBaUJsQyxZQUFqQiIsImZpbGUiOiIzMC5qcyIsInNvdXJjZXNDb250ZW50IjpbIiAgdmFyIGNhY2hpbmdMYXllciA9IHJlcXVpcmUoJy4vY2FjaGluZ2xheWVyJylcbiAgdmFyIGxvZyA9IHJlcXVpcmUoJy4vbG9nJyk7XG4gIHZhciBldmVudEhhbmRsaW5nID0gcmVxdWlyZSgnLi9ldmVudGhhbmRsaW5nJyk7XG4gIHZhciB1dGlsID0gcmVxdWlyZSgnLi91dGlsJyk7XG5cbiAgLyoqXG4gICAqIENsYXNzOiBSZW1vdGVTdG9yYWdlLkxvY2FsU3RvcmFnZVxuICAgKlxuICAgKiBsb2NhbFN0b3JhZ2UgY2FjaGluZyBhZGFwdGVyLiBVc2VkIHdoZW4gbm8gSW5kZXhlZERCIGF2YWlsYWJsZS5cbiAgICoqL1xuXG4gIHZhciBOT0RFU19QUkVGSVggPSBcInJlbW90ZXN0b3JhZ2U6Y2FjaGU6bm9kZXM6XCI7XG4gIHZhciBDSEFOR0VTX1BSRUZJWCA9IFwicmVtb3Rlc3RvcmFnZTpjYWNoZTpjaGFuZ2VzOlwiO1xuXG4gIHZhciBMb2NhbFN0b3JhZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgY2FjaGluZ0xheWVyKHRoaXMpO1xuICAgIGxvZygnW0xvY2FsU3RvcmFnZV0gUmVnaXN0ZXJpbmcgZXZlbnRzJyk7XG4gICAgZXZlbnRIYW5kbGluZyh0aGlzLCAnY2hhbmdlJywgJ2xvY2FsLWV2ZW50cy1kb25lJyk7XG4gIH07XG5cbiAgZnVuY3Rpb24gaXNSZW1vdGVTdG9yYWdlS2V5KGtleSkge1xuICAgIHJldHVybiBrZXkuc3Vic3RyKDAsIE5PREVTX1BSRUZJWC5sZW5ndGgpID09PSBOT0RFU19QUkVGSVggfHxcbiAgICAgICAgICAga2V5LnN1YnN0cigwLCBDSEFOR0VTX1BSRUZJWC5sZW5ndGgpID09PSBDSEFOR0VTX1BSRUZJWDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzTm9kZUtleShrZXkpIHtcbiAgICByZXR1cm4ga2V5LnN1YnN0cigwLCBOT0RFU19QUkVGSVgubGVuZ3RoKSA9PT0gTk9ERVNfUFJFRklYO1xuICB9XG5cbiAgTG9jYWxTdG9yYWdlLnByb3RvdHlwZSA9IHtcblxuICAgIGdldE5vZGVzOiBmdW5jdGlvbiAocGF0aHMpIHtcbiAgICAgIHZhciBub2RlcyA9IHt9O1xuXG4gICAgICBmb3IodmFyIGkgPSAwLCBsZW4gPSBwYXRocy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIG5vZGVzW3BhdGhzW2ldXSA9IEpTT04ucGFyc2UobG9jYWxTdG9yYWdlW05PREVTX1BSRUZJWCtwYXRoc1tpXV0pO1xuICAgICAgICB9IGNhdGNoKGUpIHtcbiAgICAgICAgICBub2Rlc1twYXRoc1tpXV0gPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShub2Rlcyk7XG4gICAgfSxcblxuICAgIHNldE5vZGVzOiBmdW5jdGlvbiAobm9kZXMpIHtcbiAgICAgIGZvciAodmFyIHBhdGggaW4gbm9kZXMpIHtcbiAgICAgICAgLy8gVE9ETyBzaG91bGRuJ3Qgd2UgdXNlIGdldEl0ZW0vc2V0SXRlbT9cbiAgICAgICAgbG9jYWxTdG9yYWdlW05PREVTX1BSRUZJWCtwYXRoXSA9IEpTT04uc3RyaW5naWZ5KG5vZGVzW3BhdGhdKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgIH0sXG5cbiAgICBmb3JBbGxOb2RlczogZnVuY3Rpb24gKGNiKSB7XG4gICAgICB2YXIgbm9kZTtcblxuICAgICAgZm9yKHZhciBpID0gMCwgbGVuID0gbG9jYWxTdG9yYWdlLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGlmIChpc05vZGVLZXkobG9jYWxTdG9yYWdlLmtleShpKSkpIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgbm9kZSA9IHRoaXMubWlncmF0ZShKU09OLnBhcnNlKGxvY2FsU3RvcmFnZVtsb2NhbFN0b3JhZ2Uua2V5KGkpXSkpO1xuICAgICAgICAgIH0gY2F0Y2goZSkge1xuICAgICAgICAgICAgbm9kZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG5vZGUpIHtcbiAgICAgICAgICAgIGNiKG5vZGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgIH1cblxuICB9O1xuXG4gIExvY2FsU3RvcmFnZS5fcnNfaW5pdCA9IGZ1bmN0aW9uICgpIHt9O1xuXG4gIExvY2FsU3RvcmFnZS5fcnNfc3VwcG9ydGVkID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB1dGlsLmxvY2FsU3RvcmFnZUF2YWlsYWJsZSgpO1xuICB9O1xuXG4gIC8vIFRPRE8gdGVzdHMgbWlzc2luZyFcbiAgTG9jYWxTdG9yYWdlLl9yc19jbGVhbnVwID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBrZXlzID0gW107XG5cbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gbG9jYWxTdG9yYWdlLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICB2YXIga2V5ID0gbG9jYWxTdG9yYWdlLmtleShpKTtcbiAgICAgIGlmIChpc1JlbW90ZVN0b3JhZ2VLZXkoa2V5KSkge1xuICAgICAgICBrZXlzLnB1c2goa2V5KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBrZXlzLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgbG9nKCdbTG9jYWxTdG9yYWdlXSBSZW1vdmluZycsIGtleSk7XG4gICAgICBkZWxldGUgbG9jYWxTdG9yYWdlW2tleV07XG4gICAgfSk7XG4gIH07XG5cbiAgbW9kdWxlLmV4cG9ydHMgPSBMb2NhbFN0b3JhZ2U7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvbG9jYWxzdG9yYWdlLmpzIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ },
/* 31 */
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';\n\nvar eventHandling = __webpack_require__(3);\nvar log = __webpack_require__(4);\nvar cachingLayer = __webpack_require__(29);\n/**\n * Class: RemoteStorage.InMemoryStorage\n *\n * In-memory caching adapter. Used when no IndexedDB or localStorage\n * available.\n **/\n\nvar InMemoryStorage = function InMemoryStorage() {\n  cachingLayer(this);\n  log('[InMemoryStorage] Registering events');\n  eventHandling(this, 'change', 'local-events-done');\n\n  this._storage = {};\n};\n\nInMemoryStorage.prototype = {\n\n  getNodes: function getNodes(paths) {\n    var nodes = {};\n\n    for (var i = 0, len = paths.length; i < len; i++) {\n      nodes[paths[i]] = this._storage[paths[i]];\n    }\n\n    return Promise.resolve(nodes);\n  },\n\n  setNodes: function setNodes(nodes) {\n    for (var path in nodes) {\n      if (nodes[path] === undefined) {\n        delete this._storage[path];\n      } else {\n        this._storage[path] = nodes[path];\n      }\n    }\n\n    return Promise.resolve();\n  },\n\n  forAllNodes: function forAllNodes(cb) {\n    for (var path in this._storage) {\n      cb(this.migrate(this._storage[path]));\n    }\n    return Promise.resolve();\n  }\n\n};\n\nInMemoryStorage._rs_init = function () {};\n\nInMemoryStorage._rs_supported = function () {\n  // In-memory storage is always supported\n  return true;\n};\n\nInMemoryStorage._rs_cleanup = function () {};\n\nmodule.exports = InMemoryStorage;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvaW5tZW1vcnlzdG9yYWdlLmpzPzY1NDMiXSwibmFtZXMiOlsiZXZlbnRIYW5kbGluZyIsInJlcXVpcmUiLCJsb2ciLCJjYWNoaW5nTGF5ZXIiLCJJbk1lbW9yeVN0b3JhZ2UiLCJfc3RvcmFnZSIsInByb3RvdHlwZSIsImdldE5vZGVzIiwicGF0aHMiLCJub2RlcyIsImkiLCJsZW4iLCJsZW5ndGgiLCJQcm9taXNlIiwicmVzb2x2ZSIsInNldE5vZGVzIiwicGF0aCIsInVuZGVmaW5lZCIsImZvckFsbE5vZGVzIiwiY2IiLCJtaWdyYXRlIiwiX3JzX2luaXQiLCJfcnNfc3VwcG9ydGVkIiwiX3JzX2NsZWFudXAiLCJtb2R1bGUiLCJleHBvcnRzIl0sIm1hcHBpbmdzIjoiOztBQUFFLElBQUlBLGdCQUFnQixtQkFBQUMsQ0FBUSxDQUFSLENBQXBCO0FBQ0EsSUFBSUMsTUFBTSxtQkFBQUQsQ0FBUSxDQUFSLENBQVY7QUFDQSxJQUFJRSxlQUFlLG1CQUFBRixDQUFRLEVBQVIsQ0FBbkI7QUFDQTs7Ozs7OztBQU9BLElBQUlHLGtCQUFrQixTQUFsQkEsZUFBa0IsR0FBWTtBQUNoQ0QsZUFBYSxJQUFiO0FBQ0FELE1BQUksc0NBQUo7QUFDQUYsZ0JBQWMsSUFBZCxFQUFvQixRQUFwQixFQUE4QixtQkFBOUI7O0FBRUEsT0FBS0ssUUFBTCxHQUFnQixFQUFoQjtBQUNELENBTkQ7O0FBUUFELGdCQUFnQkUsU0FBaEIsR0FBNEI7O0FBRTFCQyxZQUFVLGtCQUFVQyxLQUFWLEVBQWlCO0FBQ3pCLFFBQUlDLFFBQVEsRUFBWjs7QUFFQSxTQUFJLElBQUlDLElBQUksQ0FBUixFQUFXQyxNQUFNSCxNQUFNSSxNQUEzQixFQUFtQ0YsSUFBSUMsR0FBdkMsRUFBNENELEdBQTVDLEVBQWlEO0FBQy9DRCxZQUFNRCxNQUFNRSxDQUFOLENBQU4sSUFBa0IsS0FBS0wsUUFBTCxDQUFjRyxNQUFNRSxDQUFOLENBQWQsQ0FBbEI7QUFDRDs7QUFFRCxXQUFPRyxRQUFRQyxPQUFSLENBQWdCTCxLQUFoQixDQUFQO0FBQ0QsR0FWeUI7O0FBWTFCTSxZQUFVLGtCQUFVTixLQUFWLEVBQWlCO0FBQ3pCLFNBQUssSUFBSU8sSUFBVCxJQUFpQlAsS0FBakIsRUFBd0I7QUFDdEIsVUFBSUEsTUFBTU8sSUFBTixNQUFnQkMsU0FBcEIsRUFBK0I7QUFDN0IsZUFBTyxLQUFLWixRQUFMLENBQWNXLElBQWQsQ0FBUDtBQUNELE9BRkQsTUFFTztBQUNMLGFBQUtYLFFBQUwsQ0FBY1csSUFBZCxJQUFzQlAsTUFBTU8sSUFBTixDQUF0QjtBQUNEO0FBQ0Y7O0FBRUQsV0FBT0gsUUFBUUMsT0FBUixFQUFQO0FBQ0QsR0F0QnlCOztBQXdCMUJJLGVBQWEscUJBQVVDLEVBQVYsRUFBYztBQUN6QixTQUFLLElBQUlILElBQVQsSUFBaUIsS0FBS1gsUUFBdEIsRUFBZ0M7QUFDOUJjLFNBQUcsS0FBS0MsT0FBTCxDQUFhLEtBQUtmLFFBQUwsQ0FBY1csSUFBZCxDQUFiLENBQUg7QUFDRDtBQUNELFdBQU9ILFFBQVFDLE9BQVIsRUFBUDtBQUNEOztBQTdCeUIsQ0FBNUI7O0FBaUNBVixnQkFBZ0JpQixRQUFoQixHQUEyQixZQUFZLENBQUUsQ0FBekM7O0FBRUFqQixnQkFBZ0JrQixhQUFoQixHQUFnQyxZQUFZO0FBQzFDO0FBQ0EsU0FBTyxJQUFQO0FBQ0QsQ0FIRDs7QUFLQWxCLGdCQUFnQm1CLFdBQWhCLEdBQThCLFlBQVksQ0FBRSxDQUE1Qzs7QUFFQUMsT0FBT0MsT0FBUCxHQUFpQnJCLGVBQWpCIiwiZmlsZSI6IjMxLmpzIiwic291cmNlc0NvbnRlbnQiOlsiICB2YXIgZXZlbnRIYW5kbGluZyA9IHJlcXVpcmUoJy4vZXZlbnRoYW5kbGluZycpO1xuICB2YXIgbG9nID0gcmVxdWlyZSgnLi9sb2cnKTtcbiAgdmFyIGNhY2hpbmdMYXllciA9IHJlcXVpcmUoJy4vY2FjaGluZ2xheWVyJyk7XG4gIC8qKlxuICAgKiBDbGFzczogUmVtb3RlU3RvcmFnZS5Jbk1lbW9yeVN0b3JhZ2VcbiAgICpcbiAgICogSW4tbWVtb3J5IGNhY2hpbmcgYWRhcHRlci4gVXNlZCB3aGVuIG5vIEluZGV4ZWREQiBvciBsb2NhbFN0b3JhZ2VcbiAgICogYXZhaWxhYmxlLlxuICAgKiovXG5cbiAgdmFyIEluTWVtb3J5U3RvcmFnZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBjYWNoaW5nTGF5ZXIodGhpcyk7XG4gICAgbG9nKCdbSW5NZW1vcnlTdG9yYWdlXSBSZWdpc3RlcmluZyBldmVudHMnKTtcbiAgICBldmVudEhhbmRsaW5nKHRoaXMsICdjaGFuZ2UnLCAnbG9jYWwtZXZlbnRzLWRvbmUnKTtcblxuICAgIHRoaXMuX3N0b3JhZ2UgPSB7fTtcbiAgfTtcblxuICBJbk1lbW9yeVN0b3JhZ2UucHJvdG90eXBlID0ge1xuXG4gICAgZ2V0Tm9kZXM6IGZ1bmN0aW9uIChwYXRocykge1xuICAgICAgdmFyIG5vZGVzID0ge307XG5cbiAgICAgIGZvcih2YXIgaSA9IDAsIGxlbiA9IHBhdGhzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIG5vZGVzW3BhdGhzW2ldXSA9IHRoaXMuX3N0b3JhZ2VbcGF0aHNbaV1dO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKG5vZGVzKTtcbiAgICB9LFxuXG4gICAgc2V0Tm9kZXM6IGZ1bmN0aW9uIChub2Rlcykge1xuICAgICAgZm9yICh2YXIgcGF0aCBpbiBub2Rlcykge1xuICAgICAgICBpZiAobm9kZXNbcGF0aF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGRlbGV0ZSB0aGlzLl9zdG9yYWdlW3BhdGhdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuX3N0b3JhZ2VbcGF0aF0gPSBub2Rlc1twYXRoXTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgfSxcblxuICAgIGZvckFsbE5vZGVzOiBmdW5jdGlvbiAoY2IpIHtcbiAgICAgIGZvciAodmFyIHBhdGggaW4gdGhpcy5fc3RvcmFnZSkge1xuICAgICAgICBjYih0aGlzLm1pZ3JhdGUodGhpcy5fc3RvcmFnZVtwYXRoXSkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgIH1cblxuICB9O1xuXG4gIEluTWVtb3J5U3RvcmFnZS5fcnNfaW5pdCA9IGZ1bmN0aW9uICgpIHt9O1xuXG4gIEluTWVtb3J5U3RvcmFnZS5fcnNfc3VwcG9ydGVkID0gZnVuY3Rpb24gKCkge1xuICAgIC8vIEluLW1lbW9yeSBzdG9yYWdlIGlzIGFsd2F5cyBzdXBwb3J0ZWRcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcblxuICBJbk1lbW9yeVN0b3JhZ2UuX3JzX2NsZWFudXAgPSBmdW5jdGlvbiAoKSB7fTtcblxuICBtb2R1bGUuZXhwb3J0cyA9IEluTWVtb3J5U3RvcmFnZTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvaW5tZW1vcnlzdG9yYWdlLmpzIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ },
/* 32 */
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';\n\nvar BaseClient = __webpack_require__(8);\nvar RemoteStorage = __webpack_require__(1);\n\nRemoteStorage.MODULES = {};\n\n/*\n * Method: RemoteStorage.defineModule\n *\n * Method for defining a new remoteStorage data module\n *\n * Parameters:\n *   moduleName - Name of the module\n *   builder    - Builder function defining the module\n *\n * The module builder function should return an object containing another\n * object called exports, which will be exported to any <RemoteStorage>\n * instance under the module's name. So when defining a locations module,\n * like in the example below, it would be accessible via\n * `remoteStorage.locations`, which would in turn have a `features` and a\n * `collections` property.\n *\n * The function receives a private and a public client, which are both\n * instances of <RemoteStorage.BaseClient>. In the following example, the\n * scope of privateClient is `/locations` and the scope of publicClient is\n * `/public/locations`.\n *\n * Example:\n *   (start code)\n *   RemoteStorage.defineModule('locations', function (privateClient, publicClient) {\n *     return {\n *       exports: {\n *         features: privateClient.scope('features/').defaultType('feature'),\n *         collections: privateClient.scope('collections/').defaultType('feature-collection')\n *       }\n *     };\n *   });\n * (end code)\n*/\n\nRemoteStorage.defineModule = function (moduleName, builder) {\n  RemoteStorage.MODULES[moduleName] = builder;\n\n  Object.defineProperty(RemoteStorage.prototype, moduleName, {\n    configurable: true,\n    get: function get() {\n      var instance = this._loadModule(moduleName);\n      Object.defineProperty(this, moduleName, {\n        value: instance\n      });\n      return instance;\n    }\n  });\n\n  if (moduleName.indexOf('-') !== -1) {\n    var camelizedName = moduleName.replace(/\\-[a-z]/g, function (s) {\n      return s[1].toUpperCase();\n    });\n    Object.defineProperty(RemoteStorage.prototype, camelizedName, {\n      get: function get() {\n        return this[moduleName];\n      }\n    });\n  }\n};\n\nRemoteStorage.prototype._loadModule = function (moduleName) {\n  var builder = RemoteStorage.MODULES[moduleName];\n  if (builder) {\n    var module = builder(new BaseClient(this, '/' + moduleName + '/'), new BaseClient(this, '/public/' + moduleName + '/'));\n    return module.exports;\n  } else {\n    throw \"Unknown module: \" + moduleName;\n  }\n};\n\nRemoteStorage.prototype.defineModule = function (moduleName) {\n  console.log(\"remoteStorage.defineModule is deprecated, use RemoteStorage.defineModule instead!\");\n  RemoteStorage.defineModule.apply(RemoteStorage, arguments);\n};\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvbW9kdWxlcy5qcz9jNzMyIl0sIm5hbWVzIjpbIkJhc2VDbGllbnQiLCJyZXF1aXJlIiwiUmVtb3RlU3RvcmFnZSIsIk1PRFVMRVMiLCJkZWZpbmVNb2R1bGUiLCJtb2R1bGVOYW1lIiwiYnVpbGRlciIsIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwicHJvdG90eXBlIiwiY29uZmlndXJhYmxlIiwiZ2V0IiwiaW5zdGFuY2UiLCJfbG9hZE1vZHVsZSIsInZhbHVlIiwiaW5kZXhPZiIsImNhbWVsaXplZE5hbWUiLCJyZXBsYWNlIiwicyIsInRvVXBwZXJDYXNlIiwibW9kdWxlIiwiZXhwb3J0cyIsImNvbnNvbGUiLCJsb2ciLCJhcHBseSIsImFyZ3VtZW50cyJdLCJtYXBwaW5ncyI6Ijs7QUFBRSxJQUFJQSxhQUFhLG1CQUFBQyxDQUFRLENBQVIsQ0FBakI7QUFDQSxJQUFJQyxnQkFBZ0IsbUJBQUFELENBQVEsQ0FBUixDQUFwQjs7QUFFQUMsY0FBY0MsT0FBZCxHQUF3QixFQUF4Qjs7QUFFQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQWtDQUQsY0FBY0UsWUFBZCxHQUE2QixVQUFVQyxVQUFWLEVBQXNCQyxPQUF0QixFQUErQjtBQUMxREosZ0JBQWNDLE9BQWQsQ0FBc0JFLFVBQXRCLElBQW9DQyxPQUFwQzs7QUFFQUMsU0FBT0MsY0FBUCxDQUFzQk4sY0FBY08sU0FBcEMsRUFBK0NKLFVBQS9DLEVBQTJEO0FBQ3pESyxrQkFBYyxJQUQyQztBQUV6REMsU0FBSyxlQUFZO0FBQ2YsVUFBSUMsV0FBVyxLQUFLQyxXQUFMLENBQWlCUixVQUFqQixDQUFmO0FBQ0FFLGFBQU9DLGNBQVAsQ0FBc0IsSUFBdEIsRUFBNEJILFVBQTVCLEVBQXdDO0FBQ3RDUyxlQUFPRjtBQUQrQixPQUF4QztBQUdBLGFBQU9BLFFBQVA7QUFDRDtBQVJ3RCxHQUEzRDs7QUFXQSxNQUFJUCxXQUFXVSxPQUFYLENBQW1CLEdBQW5CLE1BQTRCLENBQUMsQ0FBakMsRUFBb0M7QUFDbEMsUUFBSUMsZ0JBQWdCWCxXQUFXWSxPQUFYLENBQW1CLFVBQW5CLEVBQStCLFVBQVVDLENBQVYsRUFBYTtBQUM5RCxhQUFPQSxFQUFFLENBQUYsRUFBS0MsV0FBTCxFQUFQO0FBQ0QsS0FGbUIsQ0FBcEI7QUFHQVosV0FBT0MsY0FBUCxDQUFzQk4sY0FBY08sU0FBcEMsRUFBK0NPLGFBQS9DLEVBQThEO0FBQzVETCxXQUFLLGVBQVk7QUFDZixlQUFPLEtBQUtOLFVBQUwsQ0FBUDtBQUNEO0FBSDJELEtBQTlEO0FBS0Q7QUFDRixDQXhCRDs7QUEwQkFILGNBQWNPLFNBQWQsQ0FBd0JJLFdBQXhCLEdBQXNDLFVBQVVSLFVBQVYsRUFBc0I7QUFDMUQsTUFBSUMsVUFBVUosY0FBY0MsT0FBZCxDQUFzQkUsVUFBdEIsQ0FBZDtBQUNBLE1BQUlDLE9BQUosRUFBYTtBQUNYLFFBQUljLFNBQVNkLFFBQVEsSUFBSU4sVUFBSixDQUFlLElBQWYsRUFBcUIsTUFBTUssVUFBTixHQUFtQixHQUF4QyxDQUFSLEVBQ1EsSUFBSUwsVUFBSixDQUFlLElBQWYsRUFBcUIsYUFBYUssVUFBYixHQUEwQixHQUEvQyxDQURSLENBQWI7QUFFQSxXQUFPZSxPQUFPQyxPQUFkO0FBQ0QsR0FKRCxNQUlPO0FBQ0wsVUFBTSxxQkFBcUJoQixVQUEzQjtBQUNEO0FBQ0YsQ0FURDs7QUFXQUgsY0FBY08sU0FBZCxDQUF3QkwsWUFBeEIsR0FBdUMsVUFBVUMsVUFBVixFQUFzQjtBQUMzRGlCLFVBQVFDLEdBQVIsQ0FBWSxtRkFBWjtBQUNBckIsZ0JBQWNFLFlBQWQsQ0FBMkJvQixLQUEzQixDQUFpQ3RCLGFBQWpDLEVBQWdEdUIsU0FBaEQ7QUFDRCxDQUhEIiwiZmlsZSI6IjMyLmpzIiwic291cmNlc0NvbnRlbnQiOlsiICB2YXIgQmFzZUNsaWVudCA9IHJlcXVpcmUoJy4vYmFzZWNsaWVudCcpO1xuICB2YXIgUmVtb3RlU3RvcmFnZSA9IHJlcXVpcmUoJy4vcmVtb3Rlc3RvcmFnZScpO1xuICBcbiAgUmVtb3RlU3RvcmFnZS5NT0RVTEVTID0ge307XG5cbiAgLypcbiAgICogTWV0aG9kOiBSZW1vdGVTdG9yYWdlLmRlZmluZU1vZHVsZVxuICAgKlxuICAgKiBNZXRob2QgZm9yIGRlZmluaW5nIGEgbmV3IHJlbW90ZVN0b3JhZ2UgZGF0YSBtb2R1bGVcbiAgICpcbiAgICogUGFyYW1ldGVyczpcbiAgICogICBtb2R1bGVOYW1lIC0gTmFtZSBvZiB0aGUgbW9kdWxlXG4gICAqICAgYnVpbGRlciAgICAtIEJ1aWxkZXIgZnVuY3Rpb24gZGVmaW5pbmcgdGhlIG1vZHVsZVxuICAgKlxuICAgKiBUaGUgbW9kdWxlIGJ1aWxkZXIgZnVuY3Rpb24gc2hvdWxkIHJldHVybiBhbiBvYmplY3QgY29udGFpbmluZyBhbm90aGVyXG4gICAqIG9iamVjdCBjYWxsZWQgZXhwb3J0cywgd2hpY2ggd2lsbCBiZSBleHBvcnRlZCB0byBhbnkgPFJlbW90ZVN0b3JhZ2U+XG4gICAqIGluc3RhbmNlIHVuZGVyIHRoZSBtb2R1bGUncyBuYW1lLiBTbyB3aGVuIGRlZmluaW5nIGEgbG9jYXRpb25zIG1vZHVsZSxcbiAgICogbGlrZSBpbiB0aGUgZXhhbXBsZSBiZWxvdywgaXQgd291bGQgYmUgYWNjZXNzaWJsZSB2aWFcbiAgICogYHJlbW90ZVN0b3JhZ2UubG9jYXRpb25zYCwgd2hpY2ggd291bGQgaW4gdHVybiBoYXZlIGEgYGZlYXR1cmVzYCBhbmQgYVxuICAgKiBgY29sbGVjdGlvbnNgIHByb3BlcnR5LlxuICAgKlxuICAgKiBUaGUgZnVuY3Rpb24gcmVjZWl2ZXMgYSBwcml2YXRlIGFuZCBhIHB1YmxpYyBjbGllbnQsIHdoaWNoIGFyZSBib3RoXG4gICAqIGluc3RhbmNlcyBvZiA8UmVtb3RlU3RvcmFnZS5CYXNlQ2xpZW50Pi4gSW4gdGhlIGZvbGxvd2luZyBleGFtcGxlLCB0aGVcbiAgICogc2NvcGUgb2YgcHJpdmF0ZUNsaWVudCBpcyBgL2xvY2F0aW9uc2AgYW5kIHRoZSBzY29wZSBvZiBwdWJsaWNDbGllbnQgaXNcbiAgICogYC9wdWJsaWMvbG9jYXRpb25zYC5cbiAgICpcbiAgICogRXhhbXBsZTpcbiAgICogICAoc3RhcnQgY29kZSlcbiAgICogICBSZW1vdGVTdG9yYWdlLmRlZmluZU1vZHVsZSgnbG9jYXRpb25zJywgZnVuY3Rpb24gKHByaXZhdGVDbGllbnQsIHB1YmxpY0NsaWVudCkge1xuICAgKiAgICAgcmV0dXJuIHtcbiAgICogICAgICAgZXhwb3J0czoge1xuICAgKiAgICAgICAgIGZlYXR1cmVzOiBwcml2YXRlQ2xpZW50LnNjb3BlKCdmZWF0dXJlcy8nKS5kZWZhdWx0VHlwZSgnZmVhdHVyZScpLFxuICAgKiAgICAgICAgIGNvbGxlY3Rpb25zOiBwcml2YXRlQ2xpZW50LnNjb3BlKCdjb2xsZWN0aW9ucy8nKS5kZWZhdWx0VHlwZSgnZmVhdHVyZS1jb2xsZWN0aW9uJylcbiAgICogICAgICAgfVxuICAgKiAgICAgfTtcbiAgICogICB9KTtcbiAgICogKGVuZCBjb2RlKVxuICAqL1xuXG4gIFJlbW90ZVN0b3JhZ2UuZGVmaW5lTW9kdWxlID0gZnVuY3Rpb24gKG1vZHVsZU5hbWUsIGJ1aWxkZXIpIHtcbiAgICBSZW1vdGVTdG9yYWdlLk1PRFVMRVNbbW9kdWxlTmFtZV0gPSBidWlsZGVyO1xuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFJlbW90ZVN0b3JhZ2UucHJvdG90eXBlLCBtb2R1bGVOYW1lLCB7XG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGluc3RhbmNlID0gdGhpcy5fbG9hZE1vZHVsZShtb2R1bGVOYW1lKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIG1vZHVsZU5hbWUsIHtcbiAgICAgICAgICB2YWx1ZTogaW5zdGFuY2VcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBpbnN0YW5jZTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGlmIChtb2R1bGVOYW1lLmluZGV4T2YoJy0nKSAhPT0gLTEpIHtcbiAgICAgIHZhciBjYW1lbGl6ZWROYW1lID0gbW9kdWxlTmFtZS5yZXBsYWNlKC9cXC1bYS16XS9nLCBmdW5jdGlvbiAocykge1xuICAgICAgICByZXR1cm4gc1sxXS50b1VwcGVyQ2FzZSgpO1xuICAgICAgfSk7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUmVtb3RlU3RvcmFnZS5wcm90b3R5cGUsIGNhbWVsaXplZE5hbWUsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXNbbW9kdWxlTmFtZV07XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcblxuICBSZW1vdGVTdG9yYWdlLnByb3RvdHlwZS5fbG9hZE1vZHVsZSA9IGZ1bmN0aW9uIChtb2R1bGVOYW1lKSB7XG4gICAgdmFyIGJ1aWxkZXIgPSBSZW1vdGVTdG9yYWdlLk1PRFVMRVNbbW9kdWxlTmFtZV07XG4gICAgaWYgKGJ1aWxkZXIpIHtcbiAgICAgIHZhciBtb2R1bGUgPSBidWlsZGVyKG5ldyBCYXNlQ2xpZW50KHRoaXMsICcvJyArIG1vZHVsZU5hbWUgKyAnLycpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3IEJhc2VDbGllbnQodGhpcywgJy9wdWJsaWMvJyArIG1vZHVsZU5hbWUgKyAnLycpKTtcbiAgICAgIHJldHVybiBtb2R1bGUuZXhwb3J0cztcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgXCJVbmtub3duIG1vZHVsZTogXCIgKyBtb2R1bGVOYW1lO1xuICAgIH1cbiAgfTtcblxuICBSZW1vdGVTdG9yYWdlLnByb3RvdHlwZS5kZWZpbmVNb2R1bGUgPSBmdW5jdGlvbiAobW9kdWxlTmFtZSkge1xuICAgIGNvbnNvbGUubG9nKFwicmVtb3RlU3RvcmFnZS5kZWZpbmVNb2R1bGUgaXMgZGVwcmVjYXRlZCwgdXNlIFJlbW90ZVN0b3JhZ2UuZGVmaW5lTW9kdWxlIGluc3RlYWQhXCIpO1xuICAgIFJlbW90ZVN0b3JhZ2UuZGVmaW5lTW9kdWxlLmFwcGx5KFJlbW90ZVN0b3JhZ2UsIGFyZ3VtZW50cyk7XG4gIH07XG5cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9tb2R1bGVzLmpzIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ }
/******/ ])
});
;